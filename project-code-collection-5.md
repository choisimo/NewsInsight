# Project Code Snapshot

Generated at 2025-12-22T11:56:45.087Z

---

## frontend/src/components/ui/table.tsx

```tsx
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(
  ({ className, ...props }, ref) => (
    <div className="relative w-full overflow-auto">
      <table ref={ref} className={cn("w-full caption-bottom text-sm", className)} {...props} />
    </div>
  ),
);
Table.displayName = "Table";

const TableHeader = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />,
);
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tbody ref={ref} className={cn("[&_tr:last-child]:border-0", className)} {...props} />
  ),
);
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tfoot ref={ref} className={cn("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className)} {...props} />
  ),
);
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>(
  ({ className, ...props }, ref) => (
    <tr
      ref={ref}
      className={cn("border-b transition-colors data-[state=selected]:bg-muted hover:bg-muted/50", className)}
      {...props}
    />
  ),
);
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<HTMLTableCellElement, React.ThHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <th
      ref={ref}
      className={cn(
        "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
        className,
      )}
      {...props}
    />
  ),
);
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<HTMLTableCellElement, React.TdHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <td ref={ref} className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)} {...props} />
  ),
);
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<HTMLTableCaptionElement, React.HTMLAttributes<HTMLTableCaptionElement>>(
  ({ className, ...props }, ref) => (
    <caption ref={ref} className={cn("mt-4 text-sm text-muted-foreground", className)} {...props} />
  ),
);
TableCaption.displayName = "TableCaption";

export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption };

```

---

## frontend/src/components/ui/tabs.tsx

```tsx
import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

```

---

## frontend/src/components/ui/textarea.tsx

```tsx
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = "Textarea";

export { Textarea };

```

---

## frontend/src/components/ui/toast.tsx

```tsx
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return <ToastPrimitives.Root ref={ref} className={cn(toastVariants({ variant }), className)} {...props} />;
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50",
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title ref={ref} className={cn("text-sm font-semibold", className)} {...props} />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description ref={ref} className={cn("text-sm opacity-90", className)} {...props} />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

```

---

## frontend/src/components/ui/toaster.tsx

```tsx
import { useToast } from "@/hooks/use-toast";
import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from "@/components/ui/toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && <ToastDescription>{description}</ToastDescription>}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}

```

---

## frontend/src/components/ui/toggle-group.tsx

```tsx
import * as React from "react";
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group";
import { type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";
import { toggleVariants } from "@/components/ui/toggle";

const ToggleGroupContext = React.createContext<VariantProps<typeof toggleVariants>>({
  size: "default",
  variant: "default",
});

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> & VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root ref={ref} className={cn("flex items-center justify-center gap-1", className)} {...props}>
    <ToggleGroupContext.Provider value={{ variant, size }}>{children}</ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
));

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName;

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> & VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className,
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
});

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName;

export { ToggleGroup, ToggleGroupItem };

```

---

## frontend/src/components/ui/toggle.tsx

```tsx
import * as React from "react";
import * as TogglePrimitive from "@radix-ui/react-toggle";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> & VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root ref={ref} className={cn(toggleVariants({ variant, size, className }))} {...props} />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };

```

---

## frontend/src/components/ui/tooltip.tsx

```tsx
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

```

---

## frontend/src/components/ui/use-toast.ts

```ts
import { useToast, toast } from "@/hooks/use-toast";

export { useToast, toast };

```

---

## frontend/src/components/visualizer/StepProgress.tsx

```tsx
import { cn } from '@/lib/utils';
import {
  CheckCircle2,
  Circle,
  Loader2,
  AlertCircle,
  ChevronRight,
} from 'lucide-react';

export interface Step {
  id: string;
  name: string;
  description?: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  error?: string;
  provider?: string;
}

interface StepProgressProps {
  steps: Step[];
  /** 현재 활성 단계 인덱스 */
  currentStepIndex?: number;
  /** 방향 */
  orientation?: 'horizontal' | 'vertical';
  /** 클래스명 */
  className?: string;
}

const statusConfig: Record<Step['status'], {
  icon: React.ReactNode;
  color: string;
  bgColor: string;
  borderColor: string;
}> = {
  pending: {
    icon: <Circle className="h-5 w-5" />,
    color: 'text-gray-400',
    bgColor: 'bg-gray-100 dark:bg-gray-800',
    borderColor: 'border-gray-300 dark:border-gray-600',
  },
  running: {
    icon: <Loader2 className="h-5 w-5 animate-spin" />,
    color: 'text-blue-600',
    bgColor: 'bg-blue-50 dark:bg-blue-950',
    borderColor: 'border-blue-400',
  },
  completed: {
    icon: <CheckCircle2 className="h-5 w-5" />,
    color: 'text-green-600',
    bgColor: 'bg-green-50 dark:bg-green-950',
    borderColor: 'border-green-400',
  },
  failed: {
    icon: <AlertCircle className="h-5 w-5" />,
    color: 'text-red-600',
    bgColor: 'bg-red-50 dark:bg-red-950',
    borderColor: 'border-red-400',
  },
};

function StepItem({
  step,
  isLast,
  orientation,
}: {
  step: Step;
  isLast: boolean;
  orientation: 'horizontal' | 'vertical';
}) {
  const config = statusConfig[step.status];
  const isHorizontal = orientation === 'horizontal';

  return (
    <div
      className={cn(
        'flex',
        isHorizontal ? 'flex-col items-center' : 'items-start gap-4'
      )}
    >
      {/* Icon & Connector */}
      <div
        className={cn(
          'flex',
          isHorizontal ? 'flex-row items-center' : 'flex-col items-center'
        )}
      >
        {/* Step Icon */}
        <div
          className={cn(
            'flex items-center justify-center w-10 h-10 rounded-full border-2 transition-all',
            config.color,
            config.bgColor,
            config.borderColor,
            step.status === 'running' && 'ring-4 ring-blue-200 dark:ring-blue-800'
          )}
        >
          {config.icon}
        </div>

        {/* Connector Line */}
        {!isLast && (
          <div
            className={cn(
              isHorizontal
                ? 'w-12 h-0.5 mx-2'
                : 'w-0.5 h-8 my-2',
              step.status === 'completed'
                ? 'bg-green-400'
                : 'bg-gray-200 dark:bg-gray-700'
            )}
          />
        )}
      </div>

      {/* Content */}
      <div
        className={cn(
          isHorizontal ? 'text-center mt-2 max-w-[120px]' : 'flex-1 pb-4'
        )}
      >
        <h4
          className={cn(
            'text-sm font-medium',
            step.status === 'running' && 'text-blue-600',
            step.status === 'completed' && 'text-green-600',
            step.status === 'failed' && 'text-red-600'
          )}
        >
          {step.name}
        </h4>
        {step.description && (
          <p className="text-xs text-muted-foreground mt-0.5 line-clamp-2">
            {step.description}
          </p>
        )}
        {step.provider && (
          <span className="text-xs text-muted-foreground">
            via {step.provider}
          </span>
        )}
        {step.error && (
          <p className="text-xs text-red-600 mt-1 line-clamp-2">{step.error}</p>
        )}
      </div>
    </div>
  );
}

/**
 * AI 분석 진행 단계 시각화 컴포넌트
 */
export function StepProgress({
  steps,
  currentStepIndex,
  orientation = 'vertical',
  className,
}: StepProgressProps) {
  // 진행률 계산
  const completedCount = steps.filter((s) => s.status === 'completed').length;
  const progress = steps.length > 0 ? Math.round((completedCount / steps.length) * 100) : 0;

  return (
    <div className={cn('space-y-4', className)}>
      {/* Progress Summary */}
      <div className="flex items-center justify-between">
        <span className="text-sm text-muted-foreground">
          진행률: {completedCount}/{steps.length}
        </span>
        <span className="text-sm font-medium">{progress}%</span>
      </div>

      {/* Progress Bar */}
      <div className="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
        <div
          className="h-full bg-gradient-to-r from-blue-500 to-green-500 transition-all duration-500 ease-out"
          style={{ width: `${progress}%` }}
        />
      </div>

      {/* Steps */}
      <div
        className={cn(
          'pt-4',
          orientation === 'horizontal'
            ? 'flex items-start justify-between'
            : 'space-y-0'
        )}
      >
        {steps.map((step, index) => (
          <StepItem
            key={step.id}
            step={step}
            isLast={index === steps.length - 1}
            orientation={orientation}
          />
        ))}
      </div>
    </div>
  );
}

export default StepProgress;

```

---

## frontend/src/contexts/AuthContext.tsx

```tsx
import { createContext, useContext, useState, useEffect, useCallback, type ReactNode } from 'react';
import type { Token, User, SetupStatus } from '@/types/admin';
import { authApi } from '@/lib/adminApi';
import { resetApiClient } from '@/lib/api';

// Storage keys
const ACCESS_TOKEN_KEY = 'access_token';
// Note: Refresh token is now stored in HTTP-Only cookie, not localStorage
const TOKEN_TYPE_KEY = 'token_type';
const USER_KEY = 'admin_user';

interface AuthContextType {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  passwordChangeRequired: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  refreshUser: () => Promise<void>;
  checkSetupStatus: () => Promise<SetupStatus | null>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const clearAuthStorage = useCallback(() => {
    localStorage.removeItem(ACCESS_TOKEN_KEY);
    localStorage.removeItem(TOKEN_TYPE_KEY);
    localStorage.removeItem(USER_KEY);
    // Clear access token cookie
    document.cookie = 'access_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT';
    // Note: HTTP-Only refresh token cookie is cleared by the logout endpoint
    // Reset API client to clear any cached state
    resetApiClient();
  }, []);

  // Listen for token refresh events from API interceptor
  useEffect(() => {
    const handleTokenRefreshed = (event: CustomEvent<{ accessToken: string }>) => {
      const { accessToken } = event.detail;
      
      // Update state with new access token
      // Note: Refresh token is handled via HTTP-Only cookie
      setToken(accessToken);
      localStorage.setItem(ACCESS_TOKEN_KEY, accessToken);
      document.cookie = `access_token=${accessToken}; path=/; SameSite=Lax`;
      
      console.log('Token refreshed successfully via interceptor');
    };

    const handleUnauthorized = () => {
      console.warn('Received unauthorized event, clearing auth state');
      clearAuthStorage();
      setToken(null);
      setUser(null);
    };

    window.addEventListener('auth:tokenRefreshed', handleTokenRefreshed as EventListener);
    window.addEventListener('auth:unauthorized', handleUnauthorized);

    return () => {
      window.removeEventListener('auth:tokenRefreshed', handleTokenRefreshed as EventListener);
      window.removeEventListener('auth:unauthorized', handleUnauthorized);
    };
  }, [clearAuthStorage]);

  // Initialize auth state from storage
  useEffect(() => {
    const initAuth = async () => {
      try {
        const storedToken = localStorage.getItem(ACCESS_TOKEN_KEY);
        const storedUser = localStorage.getItem(USER_KEY);

        if (storedToken) {
          setToken(storedToken);
          
          // Also set as cookie for SSE/EventSource requests
          document.cookie = `access_token=${storedToken}; path=/; SameSite=Lax`;

          if (storedUser) {
            try {
              setUser(JSON.parse(storedUser));
            } catch {
              // Invalid stored user, will refresh
            }
          }

          // Verify token is still valid by fetching current user
          // The API interceptor will automatically refresh if needed
          // (using HTTP-Only cookie for refresh token)
          try {
            const currentUser = await authApi.me();
            setUser(currentUser);
            localStorage.setItem(USER_KEY, JSON.stringify(currentUser));
          } catch (error) {
            // Token refresh also failed (handled by interceptor)
            // Check if we still have a valid token after potential refresh
            const currentToken = localStorage.getItem(ACCESS_TOKEN_KEY);
            if (!currentToken) {
              console.warn('Token validation and refresh failed, clearing auth state:', error);
              clearAuthStorage();
              setToken(null);
              setUser(null);
            } else {
              // Token was refreshed, update state
              setToken(currentToken);
              try {
                const currentUser = await authApi.me();
                setUser(currentUser);
                localStorage.setItem(USER_KEY, JSON.stringify(currentUser));
              } catch {
                // Still failing after refresh, clear everything
                clearAuthStorage();
                setToken(null);
                setUser(null);
              }
            }
          }
        } else {
          // No access token - try to refresh using HTTP-Only cookie
          // The cookie is sent automatically by the browser
          try {
            const tokenResponse = await authApi.refresh();
            
            // Store new access token (refresh token is in HTTP-Only cookie)
            localStorage.setItem(ACCESS_TOKEN_KEY, tokenResponse.access_token);
            localStorage.setItem(TOKEN_TYPE_KEY, tokenResponse.token_type);
            setToken(tokenResponse.access_token);
            document.cookie = `access_token=${tokenResponse.access_token}; path=/; SameSite=Lax`;

            // Fetch user info
            const currentUser = await authApi.me();
            setUser(currentUser);
            localStorage.setItem(USER_KEY, JSON.stringify(currentUser));
          } catch {
            // No valid refresh token cookie, user needs to login
            // This is expected for new sessions
          }
        }
      } catch (error) {
        console.error('Failed to initialize auth:', error);
      } finally {
        setIsLoading(false);
      }
    };

    initAuth();
  }, [clearAuthStorage]);

  const login = useCallback(async (username: string, password: string) => {
    setIsLoading(true);
    try {
      const tokenResponse: Token = await authApi.login(username, password);
      
      // Store access token (refresh token is set as HTTP-Only cookie by server)
      localStorage.setItem(ACCESS_TOKEN_KEY, tokenResponse.access_token);
      localStorage.setItem(TOKEN_TYPE_KEY, tokenResponse.token_type);
      setToken(tokenResponse.access_token);

      // Also set as cookie for SSE/EventSource requests
      document.cookie = `access_token=${tokenResponse.access_token}; path=/; SameSite=Lax`;

      // Fetch user info
      const currentUser = await authApi.me();
      setUser(currentUser);
      localStorage.setItem(USER_KEY, JSON.stringify(currentUser));
    } finally {
      setIsLoading(false);
    }
  }, []);

  const logout = useCallback(async () => {
    setIsLoading(true);
    try {
      if (token) {
        try {
          await authApi.logout();
        } catch (error) {
          // Ignore logout errors (token might already be invalid)
          console.warn('Logout API call failed:', error);
        }
      }
    } finally {
      clearAuthStorage();
      setToken(null);
      setUser(null);
      setIsLoading(false);
    }
  }, [token, clearAuthStorage]);

  const refreshUser = useCallback(async () => {
    if (!token) return;
    
    try {
      const currentUser = await authApi.me();
      setUser(currentUser);
      localStorage.setItem(USER_KEY, JSON.stringify(currentUser));
    } catch (error) {
      console.error('Failed to refresh user:', error);
      // The API interceptor will handle token refresh
      // If we get here, token refresh also failed
      const currentToken = localStorage.getItem(ACCESS_TOKEN_KEY);
      if (!currentToken) {
        clearAuthStorage();
        setToken(null);
        setUser(null);
      }
    }
  }, [token, clearAuthStorage]);

  const checkSetupStatus = useCallback(async (): Promise<SetupStatus | null> => {
    try {
      return await authApi.getSetupStatus();
    } catch (error) {
      console.error('Failed to check setup status:', error);
      return null;
    }
  }, []);

  // Compute password change required status
  const passwordChangeRequired = user?.password_change_required ?? false;

  const value: AuthContextType = {
    user,
    token,
    isAuthenticated: !!token && !!user,
    isLoading,
    passwordChangeRequired,
    login,
    logout,
    refreshUser,
    checkSetupStatus,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Export storage keys for use in API client
export { ACCESS_TOKEN_KEY };

```

---

## frontend/src/contexts/BackgroundTaskContext.tsx

```tsx
import React, { createContext, useContext, useReducer, useEffect, useCallback, useRef } from 'react';
import { toast } from '@/hooks/use-toast';

// ============================================
// Types
// ============================================

export type TaskType = 'deep-search' | 'browser-agent' | 'fact-check' | 'ml-analysis';
export type TaskStatus = 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';

export interface BackgroundTask {
  id: string;
  type: TaskType;
  title: string;
  status: TaskStatus;
  progress?: number;
  progressMessage?: string;
  createdAt: string;
  completedAt?: string;
  result?: unknown;
  error?: string;
  // Deep Search specific
  evidenceCount?: number;
  // For navigation
  resultUrl?: string;
  // ML Analysis specific
  articleId?: number;
  batchId?: string;
  addonCategory?: string;
}

interface BackgroundTaskState {
  tasks: BackgroundTask[];
  isLoaded: boolean;
}

type BackgroundTaskAction =
  | { type: 'LOAD_TASKS'; tasks: BackgroundTask[] }
  | { type: 'ADD_TASK'; task: BackgroundTask }
  | { type: 'UPDATE_TASK'; id: string; updates: Partial<BackgroundTask> }
  | { type: 'REMOVE_TASK'; id: string }
  | { type: 'CLEAR_COMPLETED' };

// ============================================
// Constants
// ============================================

const STORAGE_KEY = 'newsinsight_background_tasks';
const TASK_EXPIRY_MS = 24 * 60 * 60 * 1000; // 24 hours

// ============================================
// Reducer
// ============================================

function taskReducer(state: BackgroundTaskState, action: BackgroundTaskAction): BackgroundTaskState {
  switch (action.type) {
    case 'LOAD_TASKS':
      return { ...state, tasks: action.tasks, isLoaded: true };

    case 'ADD_TASK': {
      // Prevent duplicates
      if (state.tasks.some(t => t.id === action.task.id)) {
        return state;
      }
      return { ...state, tasks: [action.task, ...state.tasks] };
    }

    case 'UPDATE_TASK':
      return {
        ...state,
        tasks: state.tasks.map(t =>
          t.id === action.id ? { ...t, ...action.updates } : t
        ),
      };

    case 'REMOVE_TASK':
      return {
        ...state,
        tasks: state.tasks.filter(t => t.id !== action.id),
      };

    case 'CLEAR_COMPLETED':
      return {
        ...state,
        tasks: state.tasks.filter(t => t.status !== 'completed' && t.status !== 'failed' && t.status !== 'cancelled'),
      };

    default:
      return state;
  }
}

// ============================================
// Context
// ============================================

interface BackgroundTaskContextValue {
  tasks: BackgroundTask[];
  activeTasks: BackgroundTask[];
  completedTasks: BackgroundTask[];
  isLoaded: boolean;
  addTask: (task: Omit<BackgroundTask, 'createdAt'>) => void;
  updateTask: (id: string, updates: Partial<BackgroundTask>) => void;
  removeTask: (id: string) => void;
  getTask: (id: string) => BackgroundTask | undefined;
  clearCompletedTasks: () => void;
  hasActiveTasks: boolean;
  activeTaskCount: number;
}

const BackgroundTaskContext = createContext<BackgroundTaskContextValue | null>(null);

// ============================================
// Provider Component
// ============================================

export function BackgroundTaskProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(taskReducer, { tasks: [], isLoaded: false });
  const initialized = useRef(false);

  // Load tasks from localStorage on mount
  useEffect(() => {
    if (initialized.current) return;
    initialized.current = true;

    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored) as BackgroundTask[];
        const now = Date.now();
        
        // Filter out expired tasks (older than 24 hours and completed/failed)
        const validTasks = parsed.filter(task => {
          const createdAt = new Date(task.createdAt).getTime();
          const isExpired = now - createdAt > TASK_EXPIRY_MS;
          const isTerminal = ['completed', 'failed', 'cancelled'].includes(task.status);
          return !(isExpired && isTerminal);
        });

        dispatch({ type: 'LOAD_TASKS', tasks: validTasks });
      } else {
        dispatch({ type: 'LOAD_TASKS', tasks: [] });
      }
    } catch (e) {
      console.error('Failed to load background tasks:', e);
      dispatch({ type: 'LOAD_TASKS', tasks: [] });
    }
  }, []);

  // Persist tasks to localStorage whenever they change
  useEffect(() => {
    if (!state.isLoaded) return;
    
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state.tasks));
    } catch (e) {
      console.error('Failed to save background tasks:', e);
    }
  }, [state.tasks, state.isLoaded]);

  // Derived state
  const activeTasks = state.tasks.filter(
    t => t.status === 'pending' || t.status === 'running'
  );

  const completedTasks = state.tasks.filter(
    t => t.status === 'completed' || t.status === 'failed' || t.status === 'cancelled'
  );

  // Actions
  const addTask = useCallback((task: Omit<BackgroundTask, 'createdAt'>) => {
    dispatch({
      type: 'ADD_TASK',
      task: {
        ...task,
        createdAt: new Date().toISOString(),
      },
    });
  }, []);

  const updateTask = useCallback((id: string, updates: Partial<BackgroundTask>) => {
    // Get current task to check if status changed to a terminal state
    const currentTask = state.tasks.find(t => t.id === id);
    
    // Check if we're transitioning to a terminal status (completed/failed)
    const isNewlyCompleted = 
      updates.status && 
      (updates.status === 'completed' || updates.status === 'failed' || updates.status === 'cancelled') &&
      currentTask && 
      currentTask.status !== 'completed' && 
      currentTask.status !== 'failed' && 
      currentTask.status !== 'cancelled';

    dispatch({ type: 'UPDATE_TASK', id, updates });

    // Show toast notification for completed/failed tasks
    // This allows users to know when a background task finishes even if they're on a different page
    if (isNewlyCompleted && currentTask) {
      const taskTitle = currentTask.title || 'Background Task';
      const taskType = currentTask.type === 'deep-search' ? 'Deep Search' 
        : currentTask.type === 'browser-agent' ? 'Browser Agent'
        : currentTask.type === 'fact-check' ? 'Fact Check'
        : currentTask.type === 'ml-analysis' ? 'ML 분석'
        : currentTask.type;

      if (updates.status === 'completed') {
        toast({
          title: `✅ ${taskType} 완료`,
          description: `"${taskTitle}" 작업이 완료되었습니다. 결과를 확인하세요.`,
          duration: 8000,
        });
      } else if (updates.status === 'failed') {
        toast({
          title: `❌ ${taskType} 실패`,
          description: updates.error || `"${taskTitle}" 작업 중 오류가 발생했습니다.`,
          variant: 'destructive',
          duration: 10000,
        });
      } else if (updates.status === 'cancelled') {
        toast({
          title: `⚠️ ${taskType} 취소됨`,
          description: `"${taskTitle}" 작업이 취소되었습니다.`,
          duration: 5000,
        });
      }
    }
  }, [state.tasks]);

  const removeTask = useCallback((id: string) => {
    dispatch({ type: 'REMOVE_TASK', id });
  }, []);

  const getTask = useCallback(
    (id: string) => state.tasks.find(t => t.id === id),
    [state.tasks]
  );

  const clearCompletedTasks = useCallback(() => {
    dispatch({ type: 'CLEAR_COMPLETED' });
  }, []);

  const value: BackgroundTaskContextValue = {
    tasks: state.tasks,
    activeTasks,
    completedTasks,
    isLoaded: state.isLoaded,
    addTask,
    updateTask,
    removeTask,
    getTask,
    clearCompletedTasks,
    hasActiveTasks: activeTasks.length > 0,
    activeTaskCount: activeTasks.length,
  };

  return (
    <BackgroundTaskContext.Provider value={value}>
      {children}
    </BackgroundTaskContext.Provider>
  );
}

// ============================================
// Hook
// ============================================

export function useBackgroundTasks(): BackgroundTaskContextValue {
  const context = useContext(BackgroundTaskContext);
  if (!context) {
    throw new Error('useBackgroundTasks must be used within a BackgroundTaskProvider');
  }
  return context;
}

export default BackgroundTaskContext;

```

---

## frontend/src/contexts/NotificationContext.tsx

```tsx
import { createContext, useContext, useState, useCallback, useRef, useEffect, ReactNode } from "react";
import { useNavigate } from "react-router-dom";
import { Bell, X, CheckCircle2, AlertCircle, Info, AlertTriangle, ArrowRight } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { ScrollArea } from "@/components/ui/scroll-area";
import { cn } from "@/lib/utils";

export type NotificationType = "info" | "success" | "warning" | "error";

export interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  message?: string;
  timestamp: Date;
  read: boolean;
  actionUrl?: string;
  actionLabel?: string;
  persistent?: boolean;
}

interface NotificationContextType {
  notifications: Notification[];
  unreadCount: number;
  addNotification: (notification: Omit<Notification, "id" | "timestamp" | "read">) => string;
  markAsRead: (id: string) => void;
  markAllAsRead: () => void;
  removeNotification: (id: string) => void;
  clearAll: () => void;
}

const NotificationContext = createContext<NotificationContextType | null>(null);

interface NotificationProviderProps {
  children: ReactNode;
  maxNotifications?: number;
  persistKey?: string;
}

/**
 * 실시간 알림 시스템 Provider
 * 
 * @example
 * ``\`tsx
 * <NotificationProvider>
 *   <App />
 * </NotificationProvider>
 * ``\`
 */
export function NotificationProvider({
  children,
  maxNotifications = 50,
  persistKey = "newsinsight-notifications",
}: NotificationProviderProps) {
  const [notifications, setNotifications] = useState<Notification[]>(() => {
    // 로컬 스토리지에서 복원
    try {
      const stored = localStorage.getItem(persistKey);
      if (stored) {
        const parsed = JSON.parse(stored);
        return parsed.map((n: any) => ({
          ...n,
          timestamp: new Date(n.timestamp),
        }));
      }
    } catch {
      // 무시
    }
    return [];
  });

  const idCounter = useRef(0);

  // 로컬 스토리지에 저장
  useEffect(() => {
    try {
      const toStore = notifications
        .filter((n) => n.persistent)
        .slice(0, maxNotifications);
      localStorage.setItem(persistKey, JSON.stringify(toStore));
    } catch {
      // 무시
    }
  }, [notifications, persistKey, maxNotifications]);

  const unreadCount = notifications.filter((n) => !n.read).length;

  const addNotification = useCallback(
    (notification: Omit<Notification, "id" | "timestamp" | "read">): string => {
      const id = `notification-${Date.now()}-${++idCounter.current}`;
      const newNotification: Notification = {
        ...notification,
        id,
        timestamp: new Date(),
        read: false,
      };

      setNotifications((prev) => {
        const updated = [newNotification, ...prev];
        return updated.slice(0, maxNotifications);
      });

      return id;
    },
    [maxNotifications]
  );

  const markAsRead = useCallback((id: string) => {
    setNotifications((prev) =>
      prev.map((n) => (n.id === id ? { ...n, read: true } : n))
    );
  }, []);

  const markAllAsRead = useCallback(() => {
    setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));
  }, []);

  const removeNotification = useCallback((id: string) => {
    setNotifications((prev) => prev.filter((n) => n.id !== id));
  }, []);

  const clearAll = useCallback(() => {
    setNotifications([]);
  }, []);

  return (
    <NotificationContext.Provider
      value={{
        notifications,
        unreadCount,
        addNotification,
        markAsRead,
        markAllAsRead,
        removeNotification,
        clearAll,
      }}
    >
      {children}
    </NotificationContext.Provider>
  );
}

/**
 * 알림 훅
 */
export function useNotifications() {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error("useNotifications must be used within NotificationProvider");
  }
  return context;
}

const typeConfig = {
  info: {
    icon: Info,
    color: "text-blue-600",
    bgColor: "bg-blue-100 dark:bg-blue-900/30",
    borderColor: "border-l-blue-500",
  },
  success: {
    icon: CheckCircle2,
    color: "text-green-600",
    bgColor: "bg-green-100 dark:bg-green-900/30",
    borderColor: "border-l-green-500",
  },
  warning: {
    icon: AlertTriangle,
    color: "text-yellow-600",
    bgColor: "bg-yellow-100 dark:bg-yellow-900/30",
    borderColor: "border-l-yellow-500",
  },
  error: {
    icon: AlertCircle,
    color: "text-red-600",
    bgColor: "bg-red-100 dark:bg-red-900/30",
    borderColor: "border-l-red-500",
  },
};

interface NotificationItemProps {
  notification: Notification;
  onMarkAsRead: (id: string) => void;
  onRemove: (id: string) => void;
  onNavigate?: (url: string) => void;
}

function NotificationItem({ notification, onMarkAsRead, onRemove, onNavigate }: NotificationItemProps) {
  const config = typeConfig[notification.type];
  const Icon = config.icon;

  const handleClick = useCallback(() => {
    if (!notification.read) {
      onMarkAsRead(notification.id);
    }
  }, [notification.id, notification.read, onMarkAsRead]);

  const handleActionClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (notification.actionUrl && onNavigate) {
      onMarkAsRead(notification.id);
      onNavigate(notification.actionUrl);
    }
  }, [notification.actionUrl, notification.id, onMarkAsRead, onNavigate]);

  return (
    <div
      className={cn(
        "relative p-3 border-l-4 rounded-r-lg transition-colors cursor-pointer",
        config.borderColor,
        notification.read ? "bg-muted/30" : config.bgColor,
        "hover:bg-muted/50"
      )}
      onClick={handleClick}
      role="button"
      aria-label={notification.read ? "읽은 알림" : "읽지 않은 알림"}
    >
      <div className="flex items-start gap-3">
        <Icon className={cn("h-5 w-5 mt-0.5 shrink-0", config.color)} />
        <div className="flex-1 min-w-0">
          <div className="flex items-start justify-between gap-2">
            <h4 className={cn("font-medium text-sm", !notification.read && "font-semibold")}>
              {notification.title}
            </h4>
            <button
              onClick={(e) => {
                e.stopPropagation();
                onRemove(notification.id);
              }}
              className="shrink-0 p-1 rounded hover:bg-muted transition-colors"
              aria-label="알림 삭제"
            >
              <X className="h-3 w-3" />
            </button>
          </div>
          {notification.message && (
            <p className="text-xs text-muted-foreground mt-0.5 line-clamp-2">
              {notification.message}
            </p>
          )}
          <div className="flex items-center justify-between mt-2">
            <span className="text-xs text-muted-foreground">
              {formatRelativeTime(notification.timestamp)}
            </span>
            {notification.actionUrl && onNavigate && (
              <button
                onClick={handleActionClick}
                className="text-xs text-primary hover:underline flex items-center gap-1"
              >
                {notification.actionLabel || "자세히"}
                <ArrowRight className="h-3 w-3" />
              </button>
            )}
          </div>
        </div>
        {!notification.read && (
          <div className="absolute top-3 right-8 w-2 h-2 rounded-full bg-primary" />
        )}
      </div>
    </div>
  );
}

/**
 * 알림 벨 버튼 컴포넌트
 */
export function NotificationBell() {
  const navigate = useNavigate();
  const [open, setOpen] = useState(false);
  const {
    notifications,
    unreadCount,
    markAsRead,
    markAllAsRead,
    removeNotification,
    clearAll,
  } = useNotifications();

  const handleNavigate = useCallback((url: string) => {
    setOpen(false);
    navigate(url);
  }, [navigate]);

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="ghost"
          size="icon"
          className="relative"
          aria-label={`알림 ${unreadCount > 0 ? `(${unreadCount}개 읽지 않음)` : ""}`}
        >
          <Bell className="h-5 w-5" />
          {unreadCount > 0 && (
            <Badge
              variant="destructive"
              className="absolute -top-1 -right-1 h-5 min-w-5 px-1 text-xs"
            >
              {unreadCount > 99 ? "99+" : unreadCount}
            </Badge>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-80 p-0" align="end">
        <div className="flex items-center justify-between px-4 py-3 border-b">
          <h3 className="font-semibold text-sm">알림</h3>
          <div className="flex items-center gap-2">
            {unreadCount > 0 && (
              <Button
                variant="ghost"
                size="sm"
                className="h-7 text-xs"
                onClick={markAllAsRead}
              >
                모두 읽음
              </Button>
            )}
            {notifications.length > 0 && (
              <Button
                variant="ghost"
                size="sm"
                className="h-7 text-xs text-destructive hover:text-destructive"
                onClick={clearAll}
              >
                모두 삭제
              </Button>
            )}
          </div>
        </div>
        <ScrollArea className="h-80">
          {notifications.length > 0 ? (
            <div className="p-2 space-y-2">
              {notifications.map((notification) => (
                <NotificationItem
                  key={notification.id}
                  notification={notification}
                  onMarkAsRead={markAsRead}
                  onRemove={removeNotification}
                  onNavigate={handleNavigate}
                />
              ))}
            </div>
          ) : (
            <div className="flex flex-col items-center justify-center h-40 text-muted-foreground">
              <Bell className="h-8 w-8 mb-2 opacity-50" />
              <p className="text-sm">알림이 없습니다</p>
            </div>
          )}
        </ScrollArea>
      </PopoverContent>
    </Popover>
  );
}

/**
 * 상대 시간 포맷
 */
function formatRelativeTime(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffSec = Math.floor(diffMs / 1000);
  const diffMin = Math.floor(diffSec / 60);
  const diffHour = Math.floor(diffMin / 60);
  const diffDay = Math.floor(diffHour / 24);

  if (diffSec < 60) return "방금 전";
  if (diffMin < 60) return `${diffMin}분 전`;
  if (diffHour < 24) return `${diffHour}시간 전`;
  if (diffDay < 7) return `${diffDay}일 전`;
  
  return date.toLocaleDateString("ko-KR");
}

export default NotificationProvider;

```

---

## frontend/src/contexts/QuickAccessContext.tsx

```tsx
import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';

interface QuickAccessContextType {
  isOpen: boolean;
  open: () => void;
  close: () => void;
  toggle: () => void;
}

const QuickAccessContext = createContext<QuickAccessContextType | undefined>(undefined);

export const useQuickAccess = () => {
  const context = useContext(QuickAccessContext);
  if (!context) {
    throw new Error('useQuickAccess must be used within QuickAccessProvider');
  }
  return context;
};

interface QuickAccessProviderProps {
  children: React.ReactNode;
}

export const QuickAccessProvider: React.FC<QuickAccessProviderProps> = ({ children }) => {
  const [isOpen, setIsOpen] = useState(false);

  const open = useCallback(() => setIsOpen(true), []);
  const close = useCallback(() => setIsOpen(false), []);
  const toggle = useCallback(() => setIsOpen(prev => !prev), []);

  // Keyboard shortcut: Ctrl/Cmd + Shift + K
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'K') {
        e.preventDefault();
        toggle();
      }
      // ESC to close
      if (e.key === 'Escape' && isOpen) {
        close();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [toggle, close, isOpen]);

  return (
    <QuickAccessContext.Provider value={{ isOpen, open, close, toggle }}>
      {children}
    </QuickAccessContext.Provider>
  );
};

```

---

## frontend/src/contexts/SearchJobContext.tsx

```tsx
import React, { createContext, useContext, useReducer, useEffect, useCallback, useRef } from 'react';
import { toast } from '@/hooks/use-toast';
import {
  startSearchJob,
  startSearchJobsBatch,
  getSearchJobStatus,
  getActiveSearchJobs,
  getAllSearchJobs,
  cancelSearchJob,
  openAllJobsStream,
  type SearchJob,
  type SearchJobEvent,
  type SearchJobType,
  type SearchJobStatus,
  type StartSearchJobRequest,
} from '@/lib/api';

// ============================================
// Types
// ============================================

interface SearchJobState {
  jobs: SearchJob[];
  isLoaded: boolean;
  isConnected: boolean;
  connectionError: string | null;
}

type SearchJobAction =
  | { type: 'LOAD_JOBS'; jobs: SearchJob[] }
  | { type: 'ADD_JOB'; job: SearchJob }
  | { type: 'UPDATE_JOB'; jobId: string; updates: Partial<SearchJob> }
  | { type: 'REMOVE_JOB'; jobId: string }
  | { type: 'SET_CONNECTED'; connected: boolean; error?: string }
  | { type: 'CLEAR_COMPLETED' };

// ============================================
// Constants
// ============================================

const MAX_JOBS_TO_KEEP = 50;
const RECONNECT_DELAY_MS = 3000;
const MAX_RECONNECT_ATTEMPTS = 5;

// Job type labels (Korean)
export const JOB_TYPE_LABELS: Record<SearchJobType, string> = {
  UNIFIED: '통합 검색',
  DEEP_SEARCH: '심층 분석',
  FACT_CHECK: '팩트체크',
  BROWSER_AGENT: 'AI 에이전트',
};

// Job status labels (Korean)
export const JOB_STATUS_LABELS: Record<SearchJobStatus, string> = {
  PENDING: '대기 중',
  RUNNING: '진행 중',
  COMPLETED: '완료',
  FAILED: '실패',
  CANCELLED: '취소됨',
};

// ============================================
// Reducer
// ============================================

function jobReducer(state: SearchJobState, action: SearchJobAction): SearchJobState {
  switch (action.type) {
    case 'LOAD_JOBS':
      return { ...state, jobs: action.jobs, isLoaded: true };

    case 'ADD_JOB': {
      // Prevent duplicates
      if (state.jobs.some(j => j.jobId === action.job.jobId)) {
        return state;
      }
      // Add new job at the beginning, limit total jobs
      const newJobs = [action.job, ...state.jobs].slice(0, MAX_JOBS_TO_KEEP);
      return { ...state, jobs: newJobs };
    }

    case 'UPDATE_JOB':
      return {
        ...state,
        jobs: state.jobs.map(j =>
          j.jobId === action.jobId ? { ...j, ...action.updates } : j
        ),
      };

    case 'REMOVE_JOB':
      return {
        ...state,
        jobs: state.jobs.filter(j => j.jobId !== action.jobId),
      };

    case 'SET_CONNECTED':
      return {
        ...state,
        isConnected: action.connected,
        connectionError: action.error || null,
      };

    case 'CLEAR_COMPLETED':
      return {
        ...state,
        jobs: state.jobs.filter(j => 
          j.status !== 'COMPLETED' && j.status !== 'FAILED' && j.status !== 'CANCELLED'
        ),
      };

    default:
      return state;
  }
}

// ============================================
// Context
// ============================================

interface SearchJobContextValue {
  // State
  jobs: SearchJob[];
  activeJobs: SearchJob[];
  completedJobs: SearchJob[];
  isLoaded: boolean;
  isConnected: boolean;
  connectionError: string | null;
  
  // Computed
  hasActiveJobs: boolean;
  activeJobCount: number;
  
  // Actions
  startJob: (request: StartSearchJobRequest) => Promise<string | null>;
  startJobsBatch: (requests: StartSearchJobRequest[]) => Promise<string[]>;
  cancelJob: (jobId: string) => Promise<boolean>;
  refreshJobs: () => Promise<void>;
  getJob: (jobId: string) => SearchJob | undefined;
  clearCompletedJobs: () => void;
}

const SearchJobContext = createContext<SearchJobContextValue | null>(null);

// ============================================
// Provider Component
// ============================================

interface SearchJobProviderProps {
  children: React.ReactNode;
  userId?: string;
  autoConnect?: boolean;
}

export function SearchJobProvider({ 
  children, 
  userId = 'anonymous',
  autoConnect = true,
}: SearchJobProviderProps) {
  const [state, dispatch] = useReducer(jobReducer, {
    jobs: [],
    isLoaded: false,
    isConnected: false,
    connectionError: null,
  });

  const eventSourceRef = useRef<EventSource | null>(null);
  const reconnectAttempts = useRef(0);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const userIdRef = useRef(userId);

  // Keep userId ref updated
  useEffect(() => {
    userIdRef.current = userId;
  }, [userId]);

  // Handle SSE events
  const handleJobEvent = useCallback((event: SearchJobEvent) => {
    const { jobId, eventType, status, progress, currentPhase, message } = event;

    switch (eventType) {
      case 'started':
        // Job started - may already be in state from startJob call
        dispatch({
          type: 'UPDATE_JOB',
          jobId,
          updates: { status, progress, currentPhase },
        });
        break;

      case 'progress':
        dispatch({
          type: 'UPDATE_JOB',
          jobId,
          updates: { status, progress, currentPhase },
        });
        break;

      case 'completed': {
        dispatch({
          type: 'UPDATE_JOB',
          jobId,
          updates: {
            status: 'COMPLETED',
            progress: 100,
            completedAt: new Date().toISOString(),
          },
        });
        // Note: Toast notification will be shown by the status change detector
        break;
      }

      case 'failed': {
        dispatch({
          type: 'UPDATE_JOB',
          jobId,
          updates: {
            status: 'FAILED',
            errorMessage: message,
            completedAt: new Date().toISOString(),
          },
        });
        // Note: Toast notification will be shown by the status change detector
        break;
      }

      case 'cancelled': {
        dispatch({
          type: 'UPDATE_JOB',
          jobId,
          updates: {
            status: 'CANCELLED',
            completedAt: new Date().toISOString(),
          },
        });
        // Note: Toast notification will be shown by the status change detector
        break;
      }

      case 'heartbeat':
        // Just keep connection alive
        break;
    }
  }, [state.jobs]);

  // Connect to SSE stream
  const connect = useCallback(async () => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
    }

    try {
      const eventSource = await openAllJobsStream(userIdRef.current);
      eventSourceRef.current = eventSource;

      eventSource.onopen = () => {
        console.log('[SearchJob SSE] Connected');
        dispatch({ type: 'SET_CONNECTED', connected: true });
        reconnectAttempts.current = 0;
      };

      // Listen for job events
      eventSource.addEventListener('job_started', (e) => {
        try {
          const data = JSON.parse(e.data) as SearchJobEvent;
          handleJobEvent(data);
        } catch (err) {
          console.error('[SearchJob SSE] Failed to parse job_started:', err);
        }
      });

      eventSource.addEventListener('job_progress', (e) => {
        try {
          const data = JSON.parse(e.data) as SearchJobEvent;
          handleJobEvent(data);
        } catch (err) {
          console.error('[SearchJob SSE] Failed to parse job_progress:', err);
        }
      });

      eventSource.addEventListener('job_completed', (e) => {
        try {
          const data = JSON.parse(e.data) as SearchJobEvent;
          handleJobEvent({ ...data, eventType: 'completed' });
        } catch (err) {
          console.error('[SearchJob SSE] Failed to parse job_completed:', err);
        }
      });

      eventSource.addEventListener('job_failed', (e) => {
        try {
          const data = JSON.parse(e.data) as SearchJobEvent;
          handleJobEvent({ ...data, eventType: 'failed' });
        } catch (err) {
          console.error('[SearchJob SSE] Failed to parse job_failed:', err);
        }
      });

      eventSource.addEventListener('job_cancelled', (e) => {
        try {
          const data = JSON.parse(e.data) as SearchJobEvent;
          handleJobEvent({ ...data, eventType: 'cancelled' });
        } catch (err) {
          console.error('[SearchJob SSE] Failed to parse job_cancelled:', err);
        }
      });

      eventSource.addEventListener('heartbeat', () => {
        // Connection alive
      });

      eventSource.onerror = (err) => {
        console.error('[SearchJob SSE] Error:', err);
        
        // Close the failed connection
        if (eventSourceRef.current) {
          eventSourceRef.current.close();
          eventSourceRef.current = null;
        }
        
        dispatch({ type: 'SET_CONNECTED', connected: false });

        // Attempt reconnection with exponential backoff
        if (reconnectAttempts.current < MAX_RECONNECT_ATTEMPTS) {
          const delay = Math.min(
            RECONNECT_DELAY_MS * Math.pow(2, reconnectAttempts.current),
            30000
          );
          console.log(`[SearchJob SSE] Reconnecting in ${delay}ms (attempt ${reconnectAttempts.current + 1})`);

          reconnectTimeoutRef.current = setTimeout(() => {
            reconnectAttempts.current++;
            connect();
          }, delay);
        } else {
          console.error('[SearchJob SSE] Max reconnection attempts reached. Stopping reconnection.');
          dispatch({
            type: 'SET_CONNECTED',
            connected: false,
            error: '실시간 연결에 실패했습니다. 새로고침해 주세요.',
          });
        }
      };
    } catch (err) {
      console.error('[SearchJob SSE] Failed to connect:', err);
      dispatch({
        type: 'SET_CONNECTED',
        connected: false,
        error: err instanceof Error ? err.message : '연결 실패',
      });
    }
  }, [handleJobEvent]);

  // Disconnect from SSE stream
  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }

    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }

    dispatch({ type: 'SET_CONNECTED', connected: false });
  }, []);

  // Load initial jobs
  const loadJobs = useCallback(async () => {
    try {
      const jobs = await getAllSearchJobs(userIdRef.current, MAX_JOBS_TO_KEEP);
      dispatch({ type: 'LOAD_JOBS', jobs });
      return jobs;
    } catch (err) {
      console.error('[SearchJob] Failed to load jobs:', err);
      dispatch({ type: 'LOAD_JOBS', jobs: [] });
      return [];
    }
  }, []);

  // Track previous job states to detect completions when returning to page
  const prevJobStatesRef = useRef<Map<string, SearchJobStatus>>(new Map());

  // Detect newly completed jobs (for background completion notifications)
  useEffect(() => {
    const currentStates = new Map(state.jobs.map(j => [j.jobId, j.status]));
    
    state.jobs.forEach(job => {
      const prevStatus = prevJobStatesRef.current.get(job.jobId);
      const isNewlyCompleted = prevStatus && 
        (prevStatus === 'PENDING' || prevStatus === 'RUNNING') &&
        (job.status === 'COMPLETED' || job.status === 'FAILED' || job.status === 'CANCELLED');
      
      if (isNewlyCompleted) {
        console.log(`[SearchJob] Detected background completion: ${job.jobId} (${prevStatus} -> ${job.status})`);
        
        // Show notification for background completion
        if (job.status === 'COMPLETED') {
          toast({
            title: `✅ ${JOB_TYPE_LABELS[job.type]} 완료`,
            description: `"${job.query}" 작업이 완료되었습니다. 결과를 확인하세요.`,
            duration: 8000,
          });
        } else if (job.status === 'FAILED') {
          toast({
            title: `❌ ${JOB_TYPE_LABELS[job.type]} 실패`,
            description: job.errorMessage || `"${job.query}" 작업 중 오류가 발생했습니다.`,
            variant: 'destructive',
            duration: 10000,
          });
        } else if (job.status === 'CANCELLED') {
          toast({
            title: `⚠️ ${JOB_TYPE_LABELS[job.type]} 취소됨`,
            description: `"${job.query}" 작업이 취소되었습니다.`,
            duration: 5000,
          });
        }
      }
    });
    
    prevJobStatesRef.current = currentStates;
  }, [state.jobs]);

  // Initialize on mount
  useEffect(() => {
    const initializeJobs = async () => {
      const jobs = await loadJobs();
      
      // Store initial job states (don't show notifications for already completed jobs on mount)
      prevJobStatesRef.current = new Map(jobs.map(j => [j.jobId, j.status]));
    };
    
    initializeJobs();

    if (autoConnect) {
      connect();
    }

    return () => {
      disconnect();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [autoConnect]); // Only run on mount and when autoConnect changes

  // Refresh jobs when page becomes visible (user returns to tab)
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        console.log('[SearchJob] Page visible, refreshing jobs...');
        loadJobs();
        
        // Reconnect SSE if disconnected
        if (autoConnect && !state.isConnected) {
          console.log('[SearchJob] Reconnecting SSE...');
          connect();
        }
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [autoConnect, state.isConnected]);

  // Derived state
  const activeJobs = state.jobs.filter(
    j => j.status === 'PENDING' || j.status === 'RUNNING'
  );

  const completedJobs = state.jobs.filter(
    j => j.status === 'COMPLETED' || j.status === 'FAILED' || j.status === 'CANCELLED'
  );

  // Actions
  const startJob = useCallback(async (request: StartSearchJobRequest): Promise<string | null> => {
    try {
      const response = await startSearchJob({
        ...request,
        userId: userIdRef.current,
      });

      // Optimistically add job to state
      const newJob: SearchJob = {
        jobId: response.jobId,
        type: request.type,
        query: request.query,
        timeWindow: request.timeWindow,
        userId: userIdRef.current,
        sessionId: request.sessionId,
        projectId: request.projectId,
        status: 'PENDING',
        progress: 0,
        startedAt: new Date().toISOString(),
      };

      dispatch({ type: 'ADD_JOB', job: newJob });

      toast({
        title: `${JOB_TYPE_LABELS[request.type]} 시작`,
        description: `"${request.query}" 작업을 시작했습니다.`,
        duration: 3000,
      });

      return response.jobId;
    } catch (err) {
      console.error('[SearchJob] Failed to start job:', err);
      toast({
        title: '작업 시작 실패',
        description: err instanceof Error ? err.message : '작업을 시작할 수 없습니다.',
        variant: 'destructive',
      });
      return null;
    }
  }, []);

  const startJobsBatch = useCallback(async (requests: StartSearchJobRequest[]): Promise<string[]> => {
    try {
      const enrichedRequests = requests.map(req => ({
        ...req,
        userId: userIdRef.current,
      }));

      const response = await startSearchJobsBatch(enrichedRequests);

      // Optimistically add jobs to state
      response.jobs.forEach((job, index) => {
        const request = requests[index];
        const newJob: SearchJob = {
          jobId: job.jobId,
          type: request.type,
          query: request.query,
          timeWindow: request.timeWindow,
          userId: userIdRef.current,
          sessionId: request.sessionId,
          projectId: request.projectId,
          status: 'PENDING',
          progress: 0,
          startedAt: new Date().toISOString(),
        };

        dispatch({ type: 'ADD_JOB', job: newJob });
      });

      toast({
        title: '일괄 작업 시작',
        description: `${response.count}개의 작업을 시작했습니다.`,
        duration: 3000,
      });

      return response.jobs.map(j => j.jobId);
    } catch (err) {
      console.error('[SearchJob] Failed to start batch jobs:', err);
      toast({
        title: '일괄 작업 시작 실패',
        description: err instanceof Error ? err.message : '작업을 시작할 수 없습니다.',
        variant: 'destructive',
      });
      return [];
    }
  }, []);

  const cancelJobAction = useCallback(async (jobId: string): Promise<boolean> => {
    try {
      await cancelSearchJob(jobId);

      dispatch({
        type: 'UPDATE_JOB',
        jobId,
        updates: {
          status: 'CANCELLED',
          completedAt: new Date().toISOString(),
        },
      });

      return true;
    } catch (err) {
      console.error('[SearchJob] Failed to cancel job:', err);
      toast({
        title: '작업 취소 실패',
        description: err instanceof Error ? err.message : '작업을 취소할 수 없습니다.',
        variant: 'destructive',
      });
      return false;
    }
  }, []);

  const refreshJobs = useCallback(async () => {
    await loadJobs();
  }, [loadJobs]);

  const getJob = useCallback(
    (jobId: string) => state.jobs.find(j => j.jobId === jobId),
    [state.jobs]
  );

  const clearCompletedJobs = useCallback(() => {
    dispatch({ type: 'CLEAR_COMPLETED' });
  }, []);

  const value: SearchJobContextValue = {
    jobs: state.jobs,
    activeJobs,
    completedJobs,
    isLoaded: state.isLoaded,
    isConnected: state.isConnected,
    connectionError: state.connectionError,
    hasActiveJobs: activeJobs.length > 0,
    activeJobCount: activeJobs.length,
    startJob,
    startJobsBatch,
    cancelJob: cancelJobAction,
    refreshJobs,
    getJob,
    clearCompletedJobs,
  };

  return (
    <SearchJobContext.Provider value={value}>
      {children}
    </SearchJobContext.Provider>
  );
}

// ============================================
// Hook
// ============================================

export function useSearchJobs(): SearchJobContextValue {
  const context = useContext(SearchJobContext);
  if (!context) {
    throw new Error('useSearchJobs must be used within a SearchJobProvider');
  }
  return context;
}

export default SearchJobContext;

```

---

## frontend/src/contexts/ThemeContext.tsx

```tsx
import { createContext, useContext, useEffect, useState, useCallback } from "react";

type Theme = "light" | "dark" | "system";

interface ThemeContextType {
  theme: Theme;
  resolvedTheme: "light" | "dark";
  setTheme: (theme: Theme) => void;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

const THEME_STORAGE_KEY = "newsinsight-theme";

function getSystemTheme(): "light" | "dark" {
  if (typeof window === "undefined") return "light";
  return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setThemeState] = useState<Theme>(() => {
    if (typeof window === "undefined") return "system";
    const stored = localStorage.getItem(THEME_STORAGE_KEY) as Theme | null;
    return stored || "system";
  });

  const [resolvedTheme, setResolvedTheme] = useState<"light" | "dark">(() => {
    if (typeof window === "undefined") return "light";
    const stored = localStorage.getItem(THEME_STORAGE_KEY) as Theme | null;
    if (stored && stored !== "system") return stored;
    return getSystemTheme();
  });

  // 시스템 테마 변경 감지
  useEffect(() => {
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");

    const handleChange = () => {
      if (theme === "system") {
        const newResolved = getSystemTheme();
        setResolvedTheme(newResolved);
        updateDocumentTheme(newResolved);
      }
    };

    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, [theme]);

  // DOM 클래스 업데이트
  const updateDocumentTheme = useCallback((resolvedTheme: "light" | "dark") => {
    const root = document.documentElement;
    root.classList.remove("light", "dark");
    root.classList.add(resolvedTheme);
  }, []);

  // 테마 변경 시 처리
  useEffect(() => {
    const newResolved = theme === "system" ? getSystemTheme() : theme;
    setResolvedTheme(newResolved);
    updateDocumentTheme(newResolved);
    localStorage.setItem(THEME_STORAGE_KEY, theme);
  }, [theme, updateDocumentTheme]);

  const setTheme = useCallback((newTheme: Theme) => {
    setThemeState(newTheme);
  }, []);

  const toggleTheme = useCallback(() => {
    setThemeState((current) => {
      // light -> dark -> system -> light
      if (current === "light") return "dark";
      if (current === "dark") return "system";
      return "light";
    });
  }, []);

  return (
    <ThemeContext.Provider value={{ theme, resolvedTheme, setTheme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
}

```

---

## frontend/src/hooks/use-mobile.tsx

```tsx
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined);

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}

```

---

## frontend/src/hooks/use-toast.ts

```ts
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };

```

---

## frontend/src/hooks/useAccessibility.tsx

```tsx
import React, { useRef, useCallback, useEffect } from "react";

/**
 * 포커스 가능한 요소 셀렉터
 */
const FOCUSABLE_SELECTOR = [
  'button:not([disabled])',
  'a[href]',
  'input:not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])',
  '[tabindex]:not([tabindex="-1"])',
  '[contenteditable="true"]',
].join(', ');

/**
 * 포커스 트랩 훅 - 모달/다이얼로그 내에서 포커스를 가둠
 * 
 * @example
 * ``\`tsx
 * const { containerRef, trapFocus, releaseFocus } = useFocusTrap();
 * 
 * <div ref={containerRef} onKeyDown={trapFocus}>
 *   <button>First</button>
 *   <button>Second</button>
 * </div>
 * ``\`
 */
export function useFocusTrap<T extends HTMLElement = HTMLElement>() {
  const containerRef = useRef<T>(null);
  const previousActiveElement = useRef<HTMLElement | null>(null);

  // 포커스 가능한 요소들 가져오기
  const getFocusableElements = useCallback(() => {
    if (!containerRef.current) return [];
    return Array.from(
      containerRef.current.querySelectorAll<HTMLElement>(FOCUSABLE_SELECTOR)
    ).filter((el) => el.offsetParent !== null); // 보이는 요소만
  }, []);

  // 포커스 트랩 활성화
  const trapFocus = useCallback((event: React.KeyboardEvent | KeyboardEvent) => {
    if (event.key !== 'Tab') return;

    const focusableElements = getFocusableElements();
    if (focusableElements.length === 0) return;

    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    const activeElement = document.activeElement as HTMLElement;

    if (event.shiftKey) {
      // Shift + Tab: 역순 이동
      if (activeElement === firstElement || !focusableElements.includes(activeElement)) {
        event.preventDefault();
        lastElement.focus();
      }
    } else {
      // Tab: 정순 이동
      if (activeElement === lastElement || !focusableElements.includes(activeElement)) {
        event.preventDefault();
        firstElement.focus();
      }
    }
  }, [getFocusableElements]);

  // 포커스 트랩 시작 (이전 포커스 저장)
  const enableTrap = useCallback(() => {
    previousActiveElement.current = document.activeElement as HTMLElement;
    const focusableElements = getFocusableElements();
    if (focusableElements.length > 0) {
      focusableElements[0].focus();
    }
  }, [getFocusableElements]);

  // 포커스 트랩 해제 (이전 포커스 복원)
  const releaseFocus = useCallback(() => {
    if (previousActiveElement.current) {
      previousActiveElement.current.focus();
      previousActiveElement.current = null;
    }
  }, []);

  return {
    containerRef,
    trapFocus,
    enableTrap,
    releaseFocus,
    getFocusableElements,
  };
}

/**
 * 스킵 링크 훅 - 키보드 사용자를 위한 콘텐츠 건너뛰기
 * 
 * @example
 * ``\`tsx
 * const { SkipLink } = useSkipLinks();
 * 
 * return (
 *   <>
 *     <SkipLink />
 *     <header>...</header>
 *     <main id="main-content">...</main>
 *   </>
 * );
 * ``\`
 */
export function useSkipLinks() {
  const SkipLink = useCallback(
    ({ targetId = 'main-content', text = '본문으로 건너뛰기' }: { targetId?: string; text?: string }) => (
      <a
        href={`#${targetId}`}
        className="sr-only focus:not-sr-only focus:absolute focus:z-[9999] focus:top-4 focus:left-4 focus:px-4 focus:py-2 focus:bg-primary focus:text-primary-foreground focus:rounded-md focus:shadow-lg"
      >
        {text}
      </a>
    ),
    []
  );

  return { SkipLink };
}

/**
 * 라이브 리전 훅 - 스크린 리더에 동적 콘텐츠 알림
 * 
 * @example
 * ``\`tsx
 * const { announce, LiveRegion } = useLiveRegion();
 * 
 * const handleSave = () => {
 *   // ... save logic
 *   announce('저장되었습니다', 'polite');
 * };
 * 
 * return (
 *   <>
 *     <LiveRegion />
 *     <button onClick={handleSave}>저장</button>
 *   </>
 * );
 * ``\`
 */
export function useLiveRegion() {
  const politeRef = useRef<HTMLDivElement>(null);
  const assertiveRef = useRef<HTMLDivElement>(null);

  const announce = useCallback((
    message: string,
    priority: 'polite' | 'assertive' = 'polite'
  ) => {
    const ref = priority === 'assertive' ? assertiveRef : politeRef;
    if (ref.current) {
      // 메시지 초기화 후 설정 (스크린 리더가 변경 감지)
      ref.current.textContent = '';
      requestAnimationFrame(() => {
        if (ref.current) {
          ref.current.textContent = message;
        }
      });
    }
  }, []);

  const LiveRegion = useCallback(() => (
    <>
      <div
        ref={politeRef}
        aria-live="polite"
        aria-atomic="true"
        className="sr-only"
      />
      <div
        ref={assertiveRef}
        aria-live="assertive"
        aria-atomic="true"
        className="sr-only"
      />
    </>
  ), []);

  return { announce, LiveRegion };
}

/**
 * 포커스 관리 훅 - 컴포넌트 마운트/언마운트 시 포커스 관리
 * 
 * @example
 * ``\`tsx
 * const buttonRef = useRef<HTMLButtonElement>(null);
 * useFocusOnMount(buttonRef);
 * 
 * return <button ref={buttonRef}>Focus me</button>;
 * ``\`
 */
export function useFocusOnMount<T extends HTMLElement>(
  ref: React.RefObject<T>,
  options: { enabled?: boolean; restoreOnUnmount?: boolean } = {}
) {
  const { enabled = true, restoreOnUnmount = true } = options;
  const previousActiveElement = useRef<HTMLElement | null>(null);

  useEffect(() => {
    if (!enabled) return;

    previousActiveElement.current = document.activeElement as HTMLElement;

    // 마운트 시 포커스
    if (ref.current) {
      ref.current.focus();
    }

    return () => {
      // 언마운트 시 이전 포커스 복원
      if (restoreOnUnmount && previousActiveElement.current) {
        previousActiveElement.current.focus();
      }
    };
  }, [ref, enabled, restoreOnUnmount]);
}

/**
 * 키보드 네비게이션 훅 - 화살표 키로 요소 간 이동
 * 
 * @example
 * ``\`tsx
 * const { activeIndex, handleKeyDown, setActiveIndex } = useArrowNavigation({
 *   itemCount: items.length,
 *   orientation: 'vertical',
 * });
 * 
 * return (
 *   <ul onKeyDown={handleKeyDown}>
 *     {items.map((item, index) => (
 *       <li key={item.id} tabIndex={index === activeIndex ? 0 : -1}>
 *         {item.label}
 *       </li>
 *     ))}
 *   </ul>
 * );
 * ``\`
 */
export function useArrowNavigation(options: {
  itemCount: number;
  orientation?: 'horizontal' | 'vertical' | 'both';
  loop?: boolean;
  onSelect?: (index: number) => void;
}) {
  const { itemCount, orientation = 'vertical', loop = true, onSelect } = options;
  const activeIndexRef = useRef(0);

  const setActiveIndex = useCallback((index: number) => {
    activeIndexRef.current = index;
  }, []);

  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    const { key } = event;
    let newIndex = activeIndexRef.current;

    const isVertical = orientation === 'vertical' || orientation === 'both';
    const isHorizontal = orientation === 'horizontal' || orientation === 'both';

    if ((key === 'ArrowDown' && isVertical) || (key === 'ArrowRight' && isHorizontal)) {
      event.preventDefault();
      newIndex = loop
        ? (activeIndexRef.current + 1) % itemCount
        : Math.min(activeIndexRef.current + 1, itemCount - 1);
    } else if ((key === 'ArrowUp' && isVertical) || (key === 'ArrowLeft' && isHorizontal)) {
      event.preventDefault();
      newIndex = loop
        ? (activeIndexRef.current - 1 + itemCount) % itemCount
        : Math.max(activeIndexRef.current - 1, 0);
    } else if (key === 'Home') {
      event.preventDefault();
      newIndex = 0;
    } else if (key === 'End') {
      event.preventDefault();
      newIndex = itemCount - 1;
    } else if (key === 'Enter' || key === ' ') {
      event.preventDefault();
      onSelect?.(activeIndexRef.current);
      return;
    }

    if (newIndex !== activeIndexRef.current) {
      activeIndexRef.current = newIndex;
      onSelect?.(newIndex);
    }
  }, [itemCount, orientation, loop, onSelect]);

  return {
    activeIndex: activeIndexRef.current,
    handleKeyDown,
    setActiveIndex,
  };
}

/**
 * 접근성 ID 생성 훅 - 고유한 ID 생성
 */
export function useAccessibleId(prefix: string = 'accessible') {
  const idRef = useRef<string | null>(null);
  
  if (!idRef.current) {
    idRef.current = `${prefix}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  return idRef.current;
}

export default {
  useFocusTrap,
  useSkipLinks,
  useLiveRegion,
  useFocusOnMount,
  useArrowNavigation,
  useAccessibleId,
};

```

---

## frontend/src/hooks/useAgentResultsStorage.ts

```ts
import { useState, useCallback, useEffect } from "react";
import {
  saveSearchHistorySync,
  listSearchHistory,
  deleteSearchHistory,
  updateSearchTags,
  updateSearchNotes,
  type SearchHistoryRecord,
} from "@/lib/api";

/**
 * Browser Agent 작업 결과 저장 데이터 구조
 */
export interface SavedAgentResult {
  id: string;
  dbId?: number; // 백엔드 DB ID
  savedAt: string;
  
  // 작업 정보
  task: string;
  startUrl?: string;
  jobId: string;
  
  // 실행 결과
  status: "completed" | "failed" | "cancelled";
  result?: string;
  error?: string;
  
  // 실행 통계
  executionStats: {
    totalSteps: number;
    maxSteps: number;
    durationMs?: number;
    startedAt?: string;
    completedAt?: string;
  };
  
  // 방문한 URL 목록
  visitedUrls: string[];
  
  // 마지막 스크린샷 (base64, 선택적)
  lastScreenshot?: string;
  
  // 태그 (사용자 분류용)
  tags?: string[];
  
  // 메모
  notes?: string;
}

/**
 * 결과 저장 시 필요한 입력 데이터
 */
export interface SaveAgentResultInput {
  task: string;
  startUrl?: string;
  jobId: string;
  status: "completed" | "failed" | "cancelled";
  result?: string;
  error?: string;
  executionStats: {
    totalSteps: number;
    maxSteps: number;
    durationMs?: number;
    startedAt?: string;
    completedAt?: string;
  };
  visitedUrls: string[];
  lastScreenshot?: string;
  tags?: string[];
  notes?: string;
}

const MAX_SCREENSHOT_SIZE = 500000; // 500KB limit for screenshots

/**
 * SearchHistoryRecord를 SavedAgentResult로 변환
 */
const recordToAgentResult = (record: SearchHistoryRecord): SavedAgentResult => {
  const metadata = record.metadata as {
    task?: string;
    startUrl?: string;
    status?: "completed" | "failed" | "cancelled";
    result?: string;
    error?: string;
    executionStats?: {
      totalSteps: number;
      maxSteps: number;
      durationMs?: number;
      startedAt?: string;
      completedAt?: string;
    };
    visitedUrls?: string[];
    lastScreenshot?: string;
  } | undefined;

  return {
    id: record.externalId || String(record.id),
    dbId: record.id,
    savedAt: record.createdAt,
    task: record.query,
    startUrl: metadata?.startUrl,
    jobId: record.externalId || String(record.id),
    status: metadata?.status || (record.success ? "completed" : "failed"),
    result: metadata?.result,
    error: record.errorMessage || metadata?.error,
    executionStats: metadata?.executionStats || {
      totalSteps: 0,
      maxSteps: 0,
      durationMs: record.durationMs,
    },
    visitedUrls: record.discoveredUrls || metadata?.visitedUrls || [],
    lastScreenshot: metadata?.lastScreenshot,
    tags: record.tags,
    notes: record.notes,
  };
};

/**
 * Browser Agent 결과 저장 및 관리를 위한 훅
 * 백엔드 API를 통해 데이터를 저장하고 조회합니다.
 */
export function useAgentResultsStorage() {
  const [savedResults, setSavedResults] = useState<SavedAgentResult[]>([]);
  const [isLoaded, setIsLoaded] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 백엔드에서 저장된 결과 로드
  const loadResults = useCallback(async () => {
    try {
      setError(null);
      const response = await listSearchHistory(0, 100, 'createdAt', 'DESC', 'BROWSER_AGENT');
      const results = response.content.map(recordToAgentResult);
      setSavedResults(results);
    } catch (err) {
      console.error("Failed to load saved agent results:", err);
      setError(err instanceof Error ? err.message : "결과를 불러오는데 실패했습니다.");
    } finally {
      setIsLoaded(true);
    }
  }, []);

  // 초기 로드
  useEffect(() => {
    loadResults();
  }, [loadResults]);

  // 결과 저장
  const saveResult = useCallback(async (input: SaveAgentResultInput): Promise<string> => {
    // 스크린샷 크기 제한
    let screenshot = input.lastScreenshot;
    if (screenshot && screenshot.length > MAX_SCREENSHOT_SIZE) {
      screenshot = undefined; // 너무 크면 저장하지 않음
    }

    const externalId = `agent_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

    try {
      setError(null);
      const savedRecord = await saveSearchHistorySync({
        externalId,
        searchType: 'BROWSER_AGENT',
        query: input.task,
        discoveredUrls: input.visitedUrls,
        durationMs: input.executionStats.durationMs,
        errorMessage: input.error,
        success: input.status === "completed",
        metadata: {
          task: input.task,
          startUrl: input.startUrl,
          status: input.status,
          result: input.result,
          error: input.error,
          executionStats: input.executionStats,
          visitedUrls: input.visitedUrls,
          lastScreenshot: screenshot,
        },
      });

      // 로컬 상태 업데이트
      const newResult = recordToAgentResult(savedRecord);
      setSavedResults((prev) => [newResult, ...prev].slice(0, 100));

      return newResult.id;
    } catch (err) {
      console.error("Failed to save agent result:", err);
      setError(err instanceof Error ? err.message : "저장에 실패했습니다.");
      throw err;
    }
  }, []);

  // 결과 삭제
  const deleteResult = useCallback(async (id: string) => {
    try {
      setError(null);
      const resultToDelete = savedResults.find((r) => r.id === id);
      if (resultToDelete?.dbId) {
        await deleteSearchHistory(resultToDelete.dbId);
      }
      setSavedResults((prev) => prev.filter((r) => r.id !== id));
    } catch (err) {
      console.error("Failed to delete agent result:", err);
      // 로컬에서는 삭제 (백엔드 실패해도 UI 반영)
      setSavedResults((prev) => prev.filter((r) => r.id !== id));
    }
  }, [savedResults]);

  // 여러 결과 삭제
  const deleteResults = useCallback(async (ids: string[]) => {
    try {
      setError(null);
      for (const id of ids) {
        const resultToDelete = savedResults.find((r) => r.id === id);
        if (resultToDelete?.dbId) {
          try {
            await deleteSearchHistory(resultToDelete.dbId);
          } catch {
            // 개별 삭제 실패는 무시
          }
        }
      }
      setSavedResults((prev) => prev.filter((r) => !ids.includes(r.id)));
    } catch (err) {
      console.error("Failed to delete agent results:", err);
      setSavedResults((prev) => prev.filter((r) => !ids.includes(r.id)));
    }
  }, [savedResults]);

  // 모든 결과 삭제
  const clearAllResults = useCallback(async () => {
    try {
      setError(null);
      for (const result of savedResults) {
        if (result.dbId) {
          try {
            await deleteSearchHistory(result.dbId);
          } catch {
            // 개별 삭제 실패는 무시
          }
        }
      }
      setSavedResults([]);
    } catch (err) {
      console.error("Failed to clear all results:", err);
      setError(err instanceof Error ? err.message : "삭제에 실패했습니다.");
    }
  }, [savedResults]);

  // 특정 결과 조회
  const getResult = useCallback(
    (id: string) => savedResults.find((r) => r.id === id),
    [savedResults]
  );

  // 결과 업데이트 (태그, 메모 등)
  const updateResult = useCallback(async (id: string, updates: Partial<Pick<SavedAgentResult, "tags" | "notes">>) => {
    try {
      setError(null);
      const resultToUpdate = savedResults.find((r) => r.id === id);
      if (resultToUpdate?.dbId) {
        // 태그와 메모를 개별 API로 업데이트
        if (updates.tags !== undefined) {
          await updateSearchTags(resultToUpdate.dbId, updates.tags);
        }
        if (updates.notes !== undefined) {
          await updateSearchNotes(resultToUpdate.dbId, updates.notes);
        }
      }
      setSavedResults((prev) => 
        prev.map((r) => r.id === id ? { ...r, ...updates } : r)
      );
    } catch (err) {
      console.error("Failed to update agent result:", err);
      // 로컬에서는 업데이트 (백엔드 실패해도 UI 반영)
      setSavedResults((prev) => 
        prev.map((r) => r.id === id ? { ...r, ...updates } : r)
      );
    }
  }, [savedResults]);

  // 결과 새로고침
  const refresh = useCallback(() => {
    setIsLoaded(false);
    return loadResults();
  }, [loadResults]);

  // 태그로 필터링
  const getResultsByTag = useCallback(
    (tag: string) => savedResults.filter((r) => r.tags?.includes(tag)),
    [savedResults]
  );

  // 상태로 필터링
  const getResultsByStatus = useCallback(
    (status: SavedAgentResult["status"]) => savedResults.filter((r) => r.status === status),
    [savedResults]
  );

  // 모든 태그 목록
  const getAllTags = useCallback(() => {
    const tags = new Set<string>();
    savedResults.forEach((r) => r.tags?.forEach((t) => tags.add(t)));
    return Array.from(tags).sort();
  }, [savedResults]);

  // JSON으로 내보내기 (로컬 기능 유지)
  const exportToJson = useCallback((id?: string) => {
    const dataToExport = id 
      ? savedResults.filter((r) => r.id === id)
      : savedResults;
    
    if (dataToExport.length === 0) return null;

    // 스크린샷 및 dbId 제외한 데이터로 내보내기
    const exportData = dataToExport.map(({ lastScreenshot, dbId, ...rest }) => rest);

    const blob = new Blob(
      [JSON.stringify(exportData, null, 2)],
      { type: "application/json" }
    );
    const url = URL.createObjectURL(blob);
    const filename = id 
      ? `agent_result_${id}.json`
      : `agent_results_${new Date().toISOString().split("T")[0]}.json`;

    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    return filename;
  }, [savedResults]);

  // Markdown으로 내보내기
  const exportToMarkdown = useCallback((id: string) => {
    const result = savedResults.find((r) => r.id === id);
    if (!result) return null;

    const statusEmoji = {
      completed: "✅",
      failed: "❌",
      cancelled: "⚪",
    }[result.status];

    const lines: string[] = [
      `# Browser Agent 작업 보고서`,
      ``,
      `**작업:** ${result.task}`,
      `**상태:** ${statusEmoji} ${result.status}`,
      `**실행 일시:** ${new Date(result.savedAt).toLocaleString("ko-KR")}`,
      ``,
    ];

    if (result.startUrl) {
      lines.push(`**시작 URL:** ${result.startUrl}`, ``);
    }

    lines.push(
      `---`,
      ``,
      `## 실행 통계`,
      ``,
      `- **총 단계:** ${result.executionStats.totalSteps} / ${result.executionStats.maxSteps}`,
    );

    if (result.executionStats.durationMs) {
      const seconds = Math.round(result.executionStats.durationMs / 1000);
      lines.push(`- **소요 시간:** ${seconds}초`);
    }

    if (result.executionStats.startedAt) {
      lines.push(`- **시작 시간:** ${new Date(result.executionStats.startedAt).toLocaleString("ko-KR")}`);
    }

    if (result.executionStats.completedAt) {
      lines.push(`- **완료 시간:** ${new Date(result.executionStats.completedAt).toLocaleString("ko-KR")}`);
    }

    lines.push(``, `---`, ``, `## 방문한 URL`, ``);

    if (result.visitedUrls.length > 0) {
      result.visitedUrls.forEach((url, i) => {
        lines.push(`${i + 1}. ${url}`);
      });
    } else {
      lines.push(`_방문한 URL이 없습니다._`);
    }

    if (result.result) {
      lines.push(
        ``,
        `---`,
        ``,
        `## 추출된 결과`,
        ``,
        "``\`",
        result.result,
        "``\`"
      );
    }

    if (result.error) {
      lines.push(
        ``,
        `---`,
        ``,
        `## 오류 정보`,
        ``,
        `> ${result.error}`
      );
    }

    if (result.tags && result.tags.length > 0) {
      lines.push(
        ``,
        `---`,
        ``,
        `## 태그`,
        ``,
        result.tags.map((t) => `\`${t}\``).join(", ")
      );
    }

    if (result.notes) {
      lines.push(
        ``,
        `---`,
        ``,
        `## 메모`,
        ``,
        result.notes
      );
    }

    lines.push(
      ``,
      `---`,
      ``,
      `*이 보고서는 NewsInsight Browser Agent에서 생성되었습니다.*`,
      ``,
      `Job ID: \`${result.jobId}\``
    );

    const markdown = lines.join("\n");
    const blob = new Blob([markdown], { type: "text/markdown" });
    const url = URL.createObjectURL(blob);
    const taskSlug = result.task.substring(0, 30).replace(/[^a-zA-Z0-9가-힣]/g, "_");
    const filename = `agent_${taskSlug}_${new Date(result.savedAt).toISOString().split("T")[0]}.md`;

    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    return filename;
  }, [savedResults]);

  // CSV로 내보내기 (요약 데이터)
  const exportToCsv = useCallback(() => {
    if (savedResults.length === 0) return null;

    const headers = ["ID", "작업", "상태", "시작URL", "방문URL수", "단계수", "실행일시"];
    const rows = savedResults.map((r) => [
      r.id,
      `"${r.task.replace(/"/g, '""')}"`,
      r.status,
      r.startUrl || "",
      r.visitedUrls.length.toString(),
      `${r.executionStats.totalSteps}/${r.executionStats.maxSteps}`,
      new Date(r.savedAt).toISOString(),
    ]);

    const csv = [headers.join(","), ...rows.map((r) => r.join(","))].join("\n");
    const blob = new Blob(["\uFEFF" + csv], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const filename = `agent_results_${new Date().toISOString().split("T")[0]}.csv`;

    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    return filename;
  }, [savedResults]);

  // 통계 정보
  const getStats = useCallback(() => {
    const completed = savedResults.filter((r) => r.status === "completed").length;
    const failed = savedResults.filter((r) => r.status === "failed").length;
    const cancelled = savedResults.filter((r) => r.status === "cancelled").length;
    const totalUrls = savedResults.reduce((sum, r) => sum + r.visitedUrls.length, 0);
    
    return {
      total: savedResults.length,
      completed,
      failed,
      cancelled,
      successRate: savedResults.length > 0 ? (completed / savedResults.length) * 100 : 0,
      totalUrlsVisited: totalUrls,
      averageSteps: savedResults.length > 0 
        ? savedResults.reduce((sum, r) => sum + r.executionStats.totalSteps, 0) / savedResults.length 
        : 0,
    };
  }, [savedResults]);

  return {
    savedResults,
    isLoaded,
    error,
    saveResult,
    deleteResult,
    deleteResults,
    clearAllResults,
    getResult,
    updateResult,
    refresh,
    getResultsByTag,
    getResultsByStatus,
    getAllTags,
    exportToJson,
    exportToMarkdown,
    exportToCsv,
    getStats,
  };
}

```

---

## frontend/src/hooks/useAiJobs.ts

```ts
/**
 * AI Orchestration 관련 React 훅
 * Backend: /api/v1/ai
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import {
  startAiJob,
  getAiJob,
  listAiJobs,
  cancelAiJob,
  retryAiJob,
  getAiProviders,
  checkAiHealth,
  pollAiJobCompletion,
  type AiJobDTO,
  type AiJobStatus,
  type AiProviderInfo,
  type DeepSearchRequest,
  type PageResponse,
} from '@/lib/api/ai';

// ============================================
// AI Jobs List Hook
// ============================================

export interface UseAiJobsOptions {
  /** 초기 페이지 */
  page?: number;
  /** 페이지 크기 */
  size?: number;
  /** 상태 필터 */
  status?: AiJobStatus;
  /** 자동 새로고침 활성화 */
  autoRefresh?: boolean;
  /** 새로고침 간격 (ms) */
  refreshInterval?: number;
}

export interface UseAiJobsReturn {
  /** 작업 목록 */
  jobs: AiJobDTO[];
  /** 총 개수 */
  total: number;
  /** 총 페이지 */
  totalPages: number;
  /** 현재 페이지 */
  currentPage: number;
  /** 로딩 상태 */
  loading: boolean;
  /** 에러 */
  error: Error | null;
  /** 새로고침 */
  refresh: () => Promise<void>;
  /** 페이지 변경 */
  setPage: (page: number) => void;
  /** 작업 취소 */
  cancel: (jobId: string) => Promise<void>;
  /** 작업 재시도 */
  retry: (jobId: string) => Promise<void>;
}

export function useAiJobs(options: UseAiJobsOptions = {}): UseAiJobsReturn {
  const {
    page: initialPage = 0,
    size = 20,
    status,
    autoRefresh = false,
    refreshInterval = 5000,
  } = options;

  const [jobs, setJobs] = useState<AiJobDTO[]>([]);
  const [total, setTotal] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [currentPage, setCurrentPage] = useState(initialPage);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await listAiJobs(currentPage, size, status);
      setJobs(data.content);
      setTotal(data.totalElements);
      setTotalPages(data.totalPages);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load jobs'));
    } finally {
      setLoading(false);
    }
  }, [currentPage, size, status]);

  const cancel = useCallback(
    async (jobId: string) => {
      try {
        await cancelAiJob(jobId);
        await refresh();
      } catch (e) {
        setError(e instanceof Error ? e : new Error('Failed to cancel job'));
        throw e;
      }
    },
    [refresh]
  );

  const retry = useCallback(
    async (jobId: string) => {
      try {
        await retryAiJob(jobId);
        await refresh();
      } catch (e) {
        setError(e instanceof Error ? e : new Error('Failed to retry job'));
        throw e;
      }
    },
    [refresh]
  );

  useEffect(() => {
    refresh();
  }, [refresh]);

  useEffect(() => {
    if (!autoRefresh) return;
    const interval = setInterval(refresh, refreshInterval);
    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval, refresh]);

  return {
    jobs,
    total,
    totalPages,
    currentPage,
    loading,
    error,
    refresh,
    setPage: setCurrentPage,
    cancel,
    retry,
  };
}

// ============================================
// Single AI Job Hook (with polling)
// ============================================

export interface UseAiJobOptions {
  /** 자동 폴링 활성화 (진행 중인 작업) */
  autoPolling?: boolean;
  /** 폴링 간격 (ms) */
  pollingInterval?: number;
  /** 상태 변경 콜백 */
  onStatusChange?: (status: AiJobStatus) => void;
  /** 완료 콜백 */
  onComplete?: (job: AiJobDTO) => void;
  /** 실패 콜백 */
  onFailed?: (job: AiJobDTO) => void;
}

export interface UseAiJobReturn {
  job: AiJobDTO | null;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
  cancel: () => Promise<void>;
  retry: () => Promise<void>;
  /** 진행률 (0-100) */
  progress: number;
  /** 진행 중 여부 */
  isRunning: boolean;
}

export function useAiJob(jobId: string | null, options: UseAiJobOptions = {}): UseAiJobReturn {
  const {
    autoPolling = true,
    pollingInterval = 2000,
    onStatusChange,
    onComplete,
    onFailed,
  } = options;

  const [job, setJob] = useState<AiJobDTO | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const previousStatusRef = useRef<AiJobStatus | null>(null);

  const refresh = useCallback(async () => {
    if (!jobId) return;
    try {
      setLoading(true);
      setError(null);
      const data = await getAiJob(jobId);
      setJob(data);

      // 상태 변경 감지
      if (previousStatusRef.current !== data.overallStatus) {
        if (previousStatusRef.current !== null) {
          onStatusChange?.(data.overallStatus);
        }
        previousStatusRef.current = data.overallStatus;

        if (data.overallStatus === 'COMPLETED') {
          onComplete?.(data);
        } else if (data.overallStatus === 'FAILED') {
          onFailed?.(data);
        }
      }
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load job'));
    } finally {
      setLoading(false);
    }
  }, [jobId, onStatusChange, onComplete, onFailed]);

  const cancel = useCallback(async () => {
    if (!jobId) return;
    try {
      await cancelAiJob(jobId);
      await refresh();
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to cancel job'));
      throw e;
    }
  }, [jobId, refresh]);

  const retry = useCallback(async () => {
    if (!jobId) return;
    try {
      await retryAiJob(jobId);
      await refresh();
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to retry job'));
      throw e;
    }
  }, [jobId, refresh]);

  useEffect(() => {
    refresh();
  }, [refresh]);

  // 자동 폴링 (진행 중인 작업만)
  useEffect(() => {
    if (!autoPolling || !jobId) return;
    if (!job || job.overallStatus === 'COMPLETED' || job.overallStatus === 'FAILED' || job.overallStatus === 'CANCELLED') {
      return;
    }

    const interval = setInterval(refresh, pollingInterval);
    return () => clearInterval(interval);
  }, [autoPolling, jobId, job?.overallStatus, pollingInterval, refresh]);

  const progress = job ? Math.round((job.completedTasks / job.totalTasks) * 100) || 0 : 0;
  const isRunning = job?.overallStatus === 'RUNNING' || job?.overallStatus === 'PENDING';

  return {
    job,
    loading,
    error,
    refresh,
    cancel,
    retry,
    progress,
    isRunning,
  };
}

// ============================================
// AI Providers Hook
// ============================================

export interface UseAiProvidersReturn {
  providers: AiProviderInfo[];
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
}

export function useAiProviders(): UseAiProvidersReturn {
  const [providers, setProviders] = useState<AiProviderInfo[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getAiProviders();
      setProviders(data);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load providers'));
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    refresh();
  }, [refresh]);

  return { providers, loading, error, refresh };
}

// ============================================
// AI Health Hook
// ============================================

export interface UseAiHealthReturn {
  health: {
    status: string;
    providers: Record<string, boolean>;
    timestamp: string;
  } | null;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
  isHealthy: boolean;
}

export function useAiHealth(): UseAiHealthReturn {
  const [health, setHealth] = useState<{
    status: string;
    providers: Record<string, boolean>;
    timestamp: string;
  } | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await checkAiHealth();
      setHealth(data);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to check health'));
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    refresh();
  }, [refresh]);

  const isHealthy = health?.status === 'UP' || health?.status === 'healthy';

  return { health, loading, error, refresh, isHealthy };
}

// ============================================
// AI Analysis Action Hook
// ============================================

export interface UseAiAnalysisReturn {
  /** 분석 시작 */
  startAnalysis: (
    request: DeepSearchRequest,
    providers?: string[]
  ) => Promise<AiJobDTO>;
  /** 분석 시작 및 완료 대기 */
  analyzeAndWait: (
    request: DeepSearchRequest,
    onProgress?: (job: AiJobDTO) => void
  ) => Promise<AiJobDTO>;
  /** 현재 작업 */
  currentJob: AiJobDTO | null;
  /** 시작 중 여부 */
  isStarting: boolean;
  /** 대기 중 여부 */
  isWaiting: boolean;
  /** 에러 */
  error: Error | null;
  /** 에러 초기화 */
  clearError: () => void;
}

export function useAiAnalysis(): UseAiAnalysisReturn {
  const [currentJob, setCurrentJob] = useState<AiJobDTO | null>(null);
  const [isStarting, setIsStarting] = useState(false);
  const [isWaiting, setIsWaiting] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const startAnalysis = useCallback(
    async (request: DeepSearchRequest, providers?: string[]) => {
      try {
        setIsStarting(true);
        setError(null);
        const job = await startAiJob(request, providers);
        setCurrentJob(job);
        return job;
      } catch (e) {
        const err = e instanceof Error ? e : new Error('Failed to start analysis');
        setError(err);
        throw err;
      } finally {
        setIsStarting(false);
      }
    },
    []
  );

  const analyzeAndWait = useCallback(
    async (request: DeepSearchRequest, onProgress?: (job: AiJobDTO) => void) => {
      try {
        setIsWaiting(true);
        setError(null);
        const job = await startAiJob(request);
        setCurrentJob(job);

        const result = await pollAiJobCompletion(job.jobId, 2000, 300000, (progressJob) => {
          setCurrentJob(progressJob);
          onProgress?.(progressJob);
        });

        setCurrentJob(result);
        return result;
      } catch (e) {
        const err = e instanceof Error ? e : new Error('Analysis failed');
        setError(err);
        throw err;
      } finally {
        setIsWaiting(false);
      }
    },
    []
  );

  const clearError = useCallback(() => setError(null), []);

  return {
    startAnalysis,
    analyzeAndWait,
    currentJob,
    isStarting,
    isWaiting,
    error,
    clearError,
  };
}

export default useAiJobs;

```

---

## frontend/src/hooks/useAnalysisSSE.ts

```ts
import { useState, useEffect, useCallback, useRef } from "react";

// Storage key for access token (matches AuthContext)
const ACCESS_TOKEN_KEY = 'access_token';

/**
 * Append authentication token to URL for SSE connections.
 * EventSource doesn't support custom headers, so we use query parameter.
 */
function appendTokenToUrl(url: string): string {
  const token = localStorage.getItem(ACCESS_TOKEN_KEY);
  if (!token) return url;
  
  const separator = url.includes('?') ? '&' : '?';
  return `${url}${separator}token=${encodeURIComponent(token)}`;
}

export interface AnalysisUpdate {
  articleId: number;
  eventType: "analysis_started" | "analysis_progress" | "analysis_partial" | "analysis_complete" | "discussion_complete" | "analysis_error";
  addonKey?: string;
  progress?: number;
  analysis?: {
    reliabilityScore?: number;
    reliabilityGrade?: string;
    reliabilityColor?: string;
    sentimentLabel?: string;
    sentimentScore?: number;
    biasLabel?: string;
    biasScore?: number;
    factcheckStatus?: string;
    misinfoRisk?: string;
    riskTags?: string[];
    topics?: string[];
    summary?: string;
    fullyAnalyzed?: boolean;
  };
  discussion?: {
    totalCommentCount?: number;
    overallSentiment?: string;
    sentimentDistribution?: Record<string, number>;
    discussionQualityScore?: number;
    stanceDistribution?: Record<string, number>;
    suspiciousPatternDetected?: boolean;
  };
  error?: string;
  timestamp?: number;
}

interface UseAnalysisSSEOptions {
  articleIds: number[];
  enabled?: boolean;
  onUpdate?: (update: AnalysisUpdate) => void;
  onError?: (error: string) => void;
}

interface UseAnalysisSSEReturn {
  isConnected: boolean;
  updates: Map<number, AnalysisUpdate>;
  reconnect: () => void;
  disconnect: () => void;
}

const getApiBaseUrl = (): string => {
  // 개발 환경: Vite proxy 사용 (상대 경로)
  if (import.meta.env.DEV) {
    return '';
  }

  if (import.meta.env.VITE_API_BASE_URL) {
    return import.meta.env.VITE_API_BASE_URL as string;
  }

  // 프로덕션: 현재 호스트 사용
  if (typeof window !== 'undefined') {
    return window.location.origin;
  }

  return '';
};

export function useAnalysisSSE({
  articleIds,
  enabled = true,
  onUpdate,
  onError,
}: UseAnalysisSSEOptions): UseAnalysisSSEReturn {
  const [isConnected, setIsConnected] = useState(false);
  const [updates, setUpdates] = useState<Map<number, AnalysisUpdate>>(new Map());
  const eventSourceRef = useRef<EventSource | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;

  const disconnect = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    setIsConnected(false);
  }, []);

  const connect = useCallback(() => {
    if (!enabled || articleIds.length === 0) {
      return;
    }

    // Close existing connection
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
    }

    const baseUrl = getApiBaseUrl();
    const url = new URL("/api/v1/search/analysis/stream", baseUrl);
    url.searchParams.set("articleIds", articleIds.join(","));

    // Append auth token to URL for SSE authentication
    const authenticatedUrl = appendTokenToUrl(url.toString());
    const es = new EventSource(authenticatedUrl);
    eventSourceRef.current = es;

    es.onopen = () => {
      setIsConnected(true);
      reconnectAttempts.current = 0;
    };

    es.onerror = () => {
      setIsConnected(false);
      es.close();
      eventSourceRef.current = null;

      // Attempt to reconnect with exponential backoff
      if (reconnectAttempts.current < maxReconnectAttempts) {
        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 30000);
        reconnectTimeoutRef.current = setTimeout(() => {
          reconnectAttempts.current += 1;
          connect();
        }, delay);
      } else {
        onError?.("Analysis stream connection failed after multiple attempts");
      }
    };

    // Handle different event types
    const handleEvent = (eventType: AnalysisUpdate["eventType"]) => (event: MessageEvent) => {
      try {
        const data = JSON.parse(event.data);
        const update: AnalysisUpdate = {
          articleId: data.articleId,
          eventType,
          ...data,
        };

        setUpdates((prev) => {
          const newMap = new Map(prev);
          const existing = newMap.get(update.articleId);
          // Merge with existing data
          newMap.set(update.articleId, { ...existing, ...update });
          return newMap;
        });

        onUpdate?.(update);
      } catch (e) {
        console.error("Failed to parse analysis event:", e);
      }
    };

    es.addEventListener("analysis_started", handleEvent("analysis_started"));
    es.addEventListener("analysis_progress", handleEvent("analysis_progress"));
    es.addEventListener("analysis_partial", handleEvent("analysis_partial"));
    es.addEventListener("analysis_complete", handleEvent("analysis_complete"));
    es.addEventListener("discussion_complete", handleEvent("discussion_complete"));
    es.addEventListener("analysis_error", handleEvent("analysis_error"));

    es.addEventListener("heartbeat", () => {
      // Just keep the connection alive
    });

    es.addEventListener("error", (event: MessageEvent) => {
      try {
        const data = JSON.parse(event.data);
        onError?.(data.error || "Unknown error");
      } catch {
        // Not a data error, handled by onerror
      }
    });
  }, [enabled, articleIds, onUpdate, onError]);

  const reconnect = useCallback(() => {
    reconnectAttempts.current = 0;
    disconnect();
    connect();
  }, [connect, disconnect]);

  // Connect when enabled and articleIds change
  useEffect(() => {
    if (enabled && articleIds.length > 0) {
      connect();
    }

    return () => {
      disconnect();
    };
  }, [enabled, articleIds.join(","), connect, disconnect]);

  return {
    isConnected,
    updates,
    reconnect,
    disconnect,
  };
}

export default useAnalysisSSE;

```

---

## frontend/src/hooks/useAutoExpandResults.ts

```ts
import { useState, useRef, useEffect, useCallback } from 'react';

interface UseAutoExpandResultsOptions<T> {
  /** Initial items to display */
  items: T[];
  /** Number of items to show initially */
  initialCount?: number;
  /** Number of items to load on each expansion */
  incrementCount?: number;
  /** Threshold for intersection observer (0-1) */
  threshold?: number;
  /** Root margin for intersection observer */
  rootMargin?: string;
  /** Whether auto-expand is enabled */
  enabled?: boolean;
}

interface UseAutoExpandResultsReturn<T> {
  /** Currently visible items */
  visibleItems: T[];
  /** Whether there are more items to show */
  hasMore: boolean;
  /** Manually load more items */
  loadMore: () => void;
  /** Reset to initial count */
  reset: () => void;
  /** Ref to attach to sentinel element */
  sentinelRef: React.RefObject<HTMLDivElement>;
  /** Total items count */
  totalCount: number;
  /** Currently visible count */
  visibleCount: number;
  /** Loading state (for animation) */
  isLoading: boolean;
  /** Expand all items */
  expandAll: () => void;
  /** Collapse to initial count */
  collapseAll: () => void;
}

/**
 * Hook for auto-expanding search results on scroll.
 * Uses IntersectionObserver to detect when the user scrolls near the bottom.
 */
export function useAutoExpandResults<T>(
  options: UseAutoExpandResultsOptions<T>
): UseAutoExpandResultsReturn<T> {
  const {
    items,
    initialCount = 10,
    incrementCount = 10,
    threshold = 0.1,
    rootMargin = '100px',
    enabled = true,
  } = options;

  const [visibleCount, setVisibleCount] = useState(initialCount);
  const [isLoading, setIsLoading] = useState(false);
  const sentinelRef = useRef<HTMLDivElement>(null);
  const observerRef = useRef<IntersectionObserver | null>(null);

  const totalCount = items.length;
  const hasMore = visibleCount < totalCount;
  const visibleItems = items.slice(0, visibleCount);

  // Load more items
  const loadMore = useCallback(() => {
    if (!hasMore || isLoading) return;
    
    setIsLoading(true);
    // Small delay for smooth animation
    requestAnimationFrame(() => {
      setVisibleCount(prev => Math.min(prev + incrementCount, totalCount));
      setIsLoading(false);
    });
  }, [hasMore, isLoading, incrementCount, totalCount]);

  // Reset to initial count
  const reset = useCallback(() => {
    setVisibleCount(initialCount);
  }, [initialCount]);

  // Expand all
  const expandAll = useCallback(() => {
    setVisibleCount(totalCount);
  }, [totalCount]);

  // Collapse all
  const collapseAll = useCallback(() => {
    setVisibleCount(initialCount);
  }, [initialCount]);

  // Setup IntersectionObserver
  useEffect(() => {
    if (!enabled) return;

    const sentinel = sentinelRef.current;
    if (!sentinel) return;

    // Cleanup previous observer
    if (observerRef.current) {
      observerRef.current.disconnect();
    }

    observerRef.current = new IntersectionObserver(
      (entries) => {
        const [entry] = entries;
        if (entry.isIntersecting && hasMore && !isLoading) {
          loadMore();
        }
      },
      {
        threshold,
        rootMargin,
      }
    );

    observerRef.current.observe(sentinel);

    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [enabled, hasMore, isLoading, loadMore, threshold, rootMargin]);

  // Reset visible count when items change significantly
  useEffect(() => {
    if (totalCount < visibleCount) {
      setVisibleCount(Math.min(initialCount, totalCount));
    }
  }, [totalCount, visibleCount, initialCount]);

  return {
    visibleItems,
    hasMore,
    loadMore,
    reset,
    sentinelRef,
    totalCount,
    visibleCount,
    isLoading,
    expandAll,
    collapseAll,
  };
}

/**
 * Hook for individual item auto-expansion on scroll into view.
 * Each item expands when it becomes visible.
 */
export function useAutoExpandOnView(options: {
  enabled?: boolean;
  threshold?: number;
  delay?: number;
} = {}) {
  const { enabled = true, threshold = 0.3, delay = 100 } = options;
  
  const [isExpanded, setIsExpanded] = useState(false);
  const ref = useRef<HTMLDivElement>(null);
  const hasTriggered = useRef(false);

  useEffect(() => {
    if (!enabled) return;

    const element = ref.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      (entries) => {
        const [entry] = entries;
        if (entry.isIntersecting && !hasTriggered.current) {
          hasTriggered.current = true;
          if (delay > 0) {
            setTimeout(() => setIsExpanded(true), delay);
          } else {
            setIsExpanded(true);
          }
          observer.disconnect();
        }
      },
      { threshold }
    );

    observer.observe(element);

    return () => {
      observer.disconnect();
    };
  }, [enabled, threshold, delay]);

  // Reset function
  const reset = useCallback(() => {
    setIsExpanded(false);
    hasTriggered.current = false;
  }, []);

  return { ref, isExpanded, reset };
}

export default useAutoExpandResults;

```

---

## frontend/src/hooks/useCollectedData.ts

```ts
/**
 * 수집된 데이터 관련 React 훅
 * Backend: /api/v1/data
 */

import { useState, useEffect, useCallback } from 'react';
import {
  listCollectedData,
  listUnprocessedData,
  getCollectedData,
  markDataAsProcessed,
  getDataStats,
  type CollectedDataDTO,
  type DataStatsResponse,
  type PageResponse,
} from '@/lib/api/data';

// ============================================
// Collected Data List Hook
// ============================================

export interface UseCollectedDataOptions {
  /** 초기 페이지 */
  page?: number;
  /** 페이지 크기 */
  size?: number;
  /** 소스 ID 필터 */
  sourceId?: number;
  /** 처리 상태 필터 */
  processed?: boolean;
  /** 검색어 */
  query?: string;
  /** 자동 새로고침 활성화 */
  autoRefresh?: boolean;
  /** 새로고침 간격 (ms) */
  refreshInterval?: number;
}

export interface UseCollectedDataReturn {
  /** 데이터 목록 */
  data: CollectedDataDTO[];
  /** 총 개수 */
  total: number;
  /** 총 페이지 */
  totalPages: number;
  /** 현재 페이지 */
  currentPage: number;
  /** 로딩 상태 */
  loading: boolean;
  /** 에러 */
  error: Error | null;
  /** 새로고침 */
  refresh: () => Promise<void>;
  /** 페이지 변경 */
  setPage: (page: number) => void;
  /** 처리됨 표시 */
  markAsProcessed: (id: number) => Promise<void>;
}

export function useCollectedData(options: UseCollectedDataOptions = {}): UseCollectedDataReturn {
  const {
    page: initialPage = 0,
    size = 20,
    sourceId,
    processed,
    query,
    autoRefresh = false,
    refreshInterval = 10000,
  } = options;

  const [data, setData] = useState<CollectedDataDTO[]>([]);
  const [total, setTotal] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [currentPage, setCurrentPage] = useState(initialPage);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await listCollectedData(currentPage, size, sourceId, processed, query);
      setData(result.content);
      setTotal(result.totalElements);
      setTotalPages(result.totalPages);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load data'));
    } finally {
      setLoading(false);
    }
  }, [currentPage, size, sourceId, processed, query]);

  const markAsProcessedAction = useCallback(
    async (id: number) => {
      try {
        await markDataAsProcessed(id);
        // 상태 업데이트
        setData((prev) =>
          prev.map((item) => (item.id === id ? { ...item, processed: true } : item))
        );
      } catch (e) {
        setError(e instanceof Error ? e : new Error('Failed to mark as processed'));
        throw e;
      }
    },
    []
  );

  useEffect(() => {
    refresh();
  }, [refresh]);

  useEffect(() => {
    if (!autoRefresh) return;
    const interval = setInterval(refresh, refreshInterval);
    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval, refresh]);

  return {
    data,
    total,
    totalPages,
    currentPage,
    loading,
    error,
    refresh,
    setPage: setCurrentPage,
    markAsProcessed: markAsProcessedAction,
  };
}

// ============================================
// Unprocessed Data Hook
// ============================================

export interface UseUnprocessedDataOptions {
  page?: number;
  size?: number;
  autoRefresh?: boolean;
  refreshInterval?: number;
}

export interface UseUnprocessedDataReturn {
  data: CollectedDataDTO[];
  total: number;
  totalPages: number;
  currentPage: number;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
  setPage: (page: number) => void;
  markAsProcessed: (id: number) => Promise<void>;
}

export function useUnprocessedData(
  options: UseUnprocessedDataOptions = {}
): UseUnprocessedDataReturn {
  const {
    page: initialPage = 0,
    size = 20,
    autoRefresh = false,
    refreshInterval = 10000,
  } = options;

  const [data, setData] = useState<CollectedDataDTO[]>([]);
  const [total, setTotal] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [currentPage, setCurrentPage] = useState(initialPage);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await listUnprocessedData(currentPage, size);
      setData(result.content);
      setTotal(result.totalElements);
      setTotalPages(result.totalPages);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load data'));
    } finally {
      setLoading(false);
    }
  }, [currentPage, size]);

  const markAsProcessedAction = useCallback(
    async (id: number) => {
      try {
        await markDataAsProcessed(id);
        // 처리된 항목 제거
        setData((prev) => prev.filter((item) => item.id !== id));
        setTotal((prev) => prev - 1);
      } catch (e) {
        setError(e instanceof Error ? e : new Error('Failed to mark as processed'));
        throw e;
      }
    },
    []
  );

  useEffect(() => {
    refresh();
  }, [refresh]);

  useEffect(() => {
    if (!autoRefresh) return;
    const interval = setInterval(refresh, refreshInterval);
    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval, refresh]);

  return {
    data,
    total,
    totalPages,
    currentPage,
    loading,
    error,
    refresh,
    setPage: setCurrentPage,
    markAsProcessed: markAsProcessedAction,
  };
}

// ============================================
// Single Data Item Hook
// ============================================

export interface UseCollectedDataItemReturn {
  data: CollectedDataDTO | null;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
  markAsProcessed: () => Promise<void>;
}

export function useCollectedDataItem(id: number | null): UseCollectedDataItemReturn {
  const [data, setData] = useState<CollectedDataDTO | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    if (!id) return;
    try {
      setLoading(true);
      setError(null);
      const result = await getCollectedData(id);
      setData(result);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load data'));
    } finally {
      setLoading(false);
    }
  }, [id]);

  const markAsProcessedAction = useCallback(async () => {
    if (!id) return;
    try {
      await markDataAsProcessed(id);
      setData((prev) => (prev ? { ...prev, processed: true } : null));
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to mark as processed'));
      throw e;
    }
  }, [id]);

  useEffect(() => {
    refresh();
  }, [refresh]);

  return {
    data,
    loading,
    error,
    refresh,
    markAsProcessed: markAsProcessedAction,
  };
}

// ============================================
// Data Stats Hook
// ============================================

export interface UseDataStatsReturn {
  stats: DataStatsResponse | null;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
}

export function useDataStats(): UseDataStatsReturn {
  const [stats, setStats] = useState<DataStatsResponse | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await getDataStats();
      setStats(result);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load stats'));
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    refresh();
  }, [refresh]);

  return { stats, loading, error, refresh };
}

export default useCollectedData;

```

---

## frontend/src/hooks/useCollections.ts

```ts
/**
 * Data Collection 관련 React 훅
 * Backend: /api/v1/collections
 */

import { useState, useEffect, useCallback } from 'react';
import {
  startCollection,
  startCollectionForSource,
  startCollectionForAllSources,
  listCollectionJobs,
  getCollectionJob,
  cancelCollectionJob,
  getCollectionStats,
  type CollectionJobDTO,
  type CollectionJobStatus,
  type CollectionResponse,
  type CollectionStatsDTO,
  type PageResponse,
} from '@/lib/api/collection';

// ============================================
// Collection Jobs Hook
// ============================================

export interface UseCollectionJobsOptions {
  /** 초기 페이지 */
  page?: number;
  /** 페이지 크기 */
  size?: number;
  /** 상태 필터 */
  status?: CollectionJobStatus;
  /** 자동 새로고침 활성화 */
  autoRefresh?: boolean;
  /** 새로고침 간격 (ms) */
  refreshInterval?: number;
}

export interface UseCollectionJobsReturn {
  /** 작업 목록 */
  jobs: CollectionJobDTO[];
  /** 총 개수 */
  total: number;
  /** 총 페이지 */
  totalPages: number;
  /** 현재 페이지 */
  currentPage: number;
  /** 로딩 상태 */
  loading: boolean;
  /** 에러 */
  error: Error | null;
  /** 새로고침 */
  refresh: () => Promise<void>;
  /** 페이지 변경 */
  setPage: (page: number) => void;
  /** 작업 취소 */
  cancel: (jobId: number) => Promise<void>;
}

export function useCollectionJobs(
  options: UseCollectionJobsOptions = {}
): UseCollectionJobsReturn {
  const {
    page: initialPage = 0,
    size = 20,
    status,
    autoRefresh = false,
    refreshInterval = 5000,
  } = options;

  const [jobs, setJobs] = useState<CollectionJobDTO[]>([]);
  const [total, setTotal] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [currentPage, setCurrentPage] = useState(initialPage);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await listCollectionJobs(currentPage, size, status);
      setJobs(data.content);
      setTotal(data.totalElements);
      setTotalPages(data.totalPages);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load jobs'));
    } finally {
      setLoading(false);
    }
  }, [currentPage, size, status]);

  const cancel = useCallback(
    async (jobId: number) => {
      try {
        await cancelCollectionJob(jobId);
        await refresh();
      } catch (e) {
        setError(e instanceof Error ? e : new Error('Failed to cancel job'));
        throw e;
      }
    },
    [refresh]
  );

  useEffect(() => {
    refresh();
  }, [refresh]);

  useEffect(() => {
    if (!autoRefresh) return;
    const interval = setInterval(refresh, refreshInterval);
    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval, refresh]);

  return {
    jobs,
    total,
    totalPages,
    currentPage,
    loading,
    error,
    refresh,
    setPage: setCurrentPage,
    cancel,
  };
}

// ============================================
// Single Collection Job Hook
// ============================================

export interface UseCollectionJobReturn {
  job: CollectionJobDTO | null;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
  cancel: () => Promise<void>;
}

export function useCollectionJob(jobId: number | null): UseCollectionJobReturn {
  const [job, setJob] = useState<CollectionJobDTO | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    if (!jobId) return;
    try {
      setLoading(true);
      setError(null);
      const data = await getCollectionJob(jobId);
      setJob(data);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load job'));
    } finally {
      setLoading(false);
    }
  }, [jobId]);

  const cancel = useCallback(async () => {
    if (!jobId) return;
    try {
      await cancelCollectionJob(jobId);
      await refresh();
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to cancel job'));
      throw e;
    }
  }, [jobId, refresh]);

  useEffect(() => {
    refresh();
  }, [refresh]);

  return { job, loading, error, refresh, cancel };
}

// ============================================
// Collection Stats Hook
// ============================================

export interface UseCollectionStatsReturn {
  stats: CollectionStatsDTO | null;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
}

export function useCollectionStats(): UseCollectionStatsReturn {
  const [stats, setStats] = useState<CollectionStatsDTO | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getCollectionStats();
      setStats(data);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load stats'));
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    refresh();
  }, [refresh]);

  return { stats, loading, error, refresh };
}

// ============================================
// Collection Actions Hook
// ============================================

export interface UseCollectionActionsReturn {
  /** 수집 시작 (특정 소스들) */
  startForSources: (sourceIds: number[]) => Promise<CollectionResponse>;
  /** 단일 소스 수집 시작 */
  startForSource: (sourceId: number) => Promise<CollectionResponse>;
  /** 모든 활성 소스 수집 시작 */
  startForAll: () => Promise<CollectionResponse>;
  /** 수집 진행 중 여부 */
  isStarting: boolean;
  /** 마지막 결과 */
  lastResult: CollectionResponse | null;
  /** 에러 */
  error: Error | null;
  /** 에러 초기화 */
  clearError: () => void;
}

export function useCollectionActions(): UseCollectionActionsReturn {
  const [isStarting, setIsStarting] = useState(false);
  const [lastResult, setLastResult] = useState<CollectionResponse | null>(null);
  const [error, setError] = useState<Error | null>(null);

  const startForSources = useCallback(async (sourceIds: number[]) => {
    try {
      setIsStarting(true);
      setError(null);
      const result = await startCollection({ sourceIds });
      setLastResult(result);
      return result;
    } catch (e) {
      const err = e instanceof Error ? e : new Error('Failed to start collection');
      setError(err);
      throw err;
    } finally {
      setIsStarting(false);
    }
  }, []);

  const startForSource = useCallback(async (sourceId: number) => {
    try {
      setIsStarting(true);
      setError(null);
      const result = await startCollectionForSource(sourceId);
      setLastResult(result);
      return result;
    } catch (e) {
      const err = e instanceof Error ? e : new Error('Failed to start collection');
      setError(err);
      throw err;
    } finally {
      setIsStarting(false);
    }
  }, []);

  const startForAll = useCallback(async () => {
    try {
      setIsStarting(true);
      setError(null);
      const result = await startCollectionForAllSources();
      setLastResult(result);
      return result;
    } catch (e) {
      const err = e instanceof Error ? e : new Error('Failed to start collection');
      setError(err);
      throw err;
    } finally {
      setIsStarting(false);
    }
  }, []);

  const clearError = useCallback(() => setError(null), []);

  return {
    startForSources,
    startForSource,
    startForAll,
    isStarting,
    lastResult,
    error,
    clearError,
  };
}

// ============================================
// Combined Collection Hook
// ============================================

export interface UseDataCollectionOptions {
  /** 작업 목록 자동 새로고침 */
  autoRefreshJobs?: boolean;
  /** 작업 목록 새로고침 간격 */
  jobsRefreshInterval?: number;
}

export interface UseDataCollectionReturn extends UseCollectionActionsReturn {
  /** 작업 목록 */
  jobs: CollectionJobDTO[];
  /** 작업 목록 로딩 */
  jobsLoading: boolean;
  /** 통계 */
  stats: CollectionStatsDTO | null;
  /** 통계 로딩 */
  statsLoading: boolean;
  /** 작업 목록 새로고침 */
  refreshJobs: () => Promise<void>;
  /** 통계 새로고침 */
  refreshStats: () => Promise<void>;
  /** 작업 취소 */
  cancelJob: (jobId: number) => Promise<void>;
}

export function useDataCollection(
  options: UseDataCollectionOptions = {}
): UseDataCollectionReturn {
  const { autoRefreshJobs = true, jobsRefreshInterval = 5000 } = options;

  const {
    jobs,
    loading: jobsLoading,
    refresh: refreshJobs,
    cancel: cancelJob,
  } = useCollectionJobs({
    autoRefresh: autoRefreshJobs,
    refreshInterval: jobsRefreshInterval,
    size: 10, // 최근 10개만
  });

  const { stats, loading: statsLoading, refresh: refreshStats } = useCollectionStats();

  const {
    startForSources,
    startForSource,
    startForAll,
    isStarting,
    lastResult,
    error,
    clearError,
  } = useCollectionActions();

  return {
    jobs,
    jobsLoading,
    stats,
    statsLoading,
    refreshJobs,
    refreshStats,
    cancelJob,
    startForSources,
    startForSource,
    startForAll,
    isStarting,
    lastResult,
    error,
    clearError,
  };
}

export default useDataCollection;

```

---

## frontend/src/hooks/useContinueWork.ts

```ts
/**
 * useContinueWork - 마지막 작업 상태를 추적하고 이어하기 기능 제공
 * 
 * 이제 백엔드 API를 사용하여 서버에서 관리되는 continue work 항목을 가져옵니다.
 * 
 * 추적 대상:
 * - 진행 중인 Deep Search 작업
 * - 미완료 팩트체크
 * - 실패한 검색 (재시도 가능)
 * - 미확인 완료 검색
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import {
  getContinueWorkItems,
  markSearchAsViewed,
  markSearchAsViewedByExternalId,
  updateSearchCompletionStatus,
  getFailedSearches,
  type ContinueWorkItem as APIContinueWorkItem,
  type CompletionStatus,
  type SearchHistoryType,
} from '@/lib/api';

export type WorkType = 'deep_search' | 'fact_check' | 'unified_search' | 'browser_agent' | 'url_analysis';
export type WorkStatus = 'in_progress' | 'paused' | 'waiting' | 'ready' | 'failed' | 'draft';

export interface ContinueWorkItem {
  id: string;
  type: WorkType;
  title: string;
  description?: string;
  progress?: number;
  status: WorkStatus;
  continueUrl: string;
  lastUpdated: string;
  viewed?: boolean;
  metadata?: {
    jobId?: string;
    query?: string;
    claimsCount?: number;
    evidenceCount?: number;
    errorMessage?: string;
    failurePhase?: string;
    dbId?: number; // Database ID for API calls
  };
}

interface ContinueWorkStats {
  total: number;
  inProgress: number;
  failed: number;
  draft: number;
  partial: number;
  unviewedCompleted: number;
}

interface UseContinueWorkReturn {
  lastWork: ContinueWorkItem | null;
  recentWorks: ContinueWorkItem[];
  stats: ContinueWorkStats;
  isLoading: boolean;
  error: string | null;
  refresh: () => Promise<void>;
  dismissWork: (id: string) => Promise<void>;
  markAsViewed: (id: string) => Promise<void>;
  retryWork: (id: string) => void;
  clearAllWorks: () => void;
}

const MAX_RECENT_WORKS = 10;

// 작업 타입별 라벨
const WORK_TYPE_LABELS: Record<WorkType, string> = {
  deep_search: '심층 분석',
  fact_check: '팩트체크',
  unified_search: '통합 검색',
  browser_agent: 'AI 에이전트',
  url_analysis: 'URL 분석',
};

// Search history type to work type mapping
const SEARCH_TYPE_TO_WORK_TYPE: Record<SearchHistoryType, WorkType> = {
  UNIFIED: 'unified_search',
  DEEP_SEARCH: 'deep_search',
  FACT_CHECK: 'fact_check',
  BROWSER_AGENT: 'browser_agent',
  NEWS_SEARCH: 'unified_search',
  URL_ANALYSIS: 'url_analysis',
};

// Completion status to work status mapping
const COMPLETION_TO_WORK_STATUS: Record<CompletionStatus, WorkStatus> = {
  DRAFT: 'draft',
  IN_PROGRESS: 'in_progress',
  PARTIAL: 'paused',
  COMPLETED: 'ready',
  FAILED: 'failed',
  CANCELLED: 'ready',
};

// Convert API item to internal format
function convertApiItemToWorkItem(item: APIContinueWorkItem): ContinueWorkItem {
  const searchType = item.searchType as SearchHistoryType;
  const type = SEARCH_TYPE_TO_WORK_TYPE[searchType] || 'unified_search';
  const completionStatus = item.completionStatus || 'COMPLETED';
  const status = COMPLETION_TO_WORK_STATUS[completionStatus] || 'ready';
  
  // Build continue URL based on search type
  const modeParam = 
    type === 'deep_search' ? 'deep' :
    type === 'fact_check' ? 'factcheck' :
    type === 'browser_agent' ? 'agent' :
    'unified';
  
  let continueUrl = `/search?mode=${modeParam}&q=${encodeURIComponent(item.query)}`;
  
  // Add job ID for in-progress deep search
  if (item.externalId && status === 'in_progress') {
    continueUrl += `&jobId=${item.externalId}`;
  }
  
  // For failed searches, add retry flag
  if (status === 'failed') {
    continueUrl += '&retry=true';
  }

  return {
    id: item.externalId || `db_${item.id}`,
    type,
    title: item.query,
    description: buildDescription(type, item, status),
    progress: item.progress,
    status,
    continueUrl,
    lastUpdated: item.updatedAt || item.createdAt,
    viewed: item.viewed,
    metadata: {
      jobId: item.externalId,
      query: item.query,
      evidenceCount: item.resultCount,
      errorMessage: item.errorMessage,
      failurePhase: item.failurePhase,
      dbId: item.id,
    },
  };
}

// Build description based on status and type
function buildDescription(type: WorkType, item: APIContinueWorkItem, status: WorkStatus): string {
  const typeLabel = WORK_TYPE_LABELS[type];
  
  if (status === 'in_progress') {
    const phase = item.currentPhase || '진행 중';
    const progress = item.progress ? ` (${item.progress}%)` : '';
    return `${typeLabel} ${phase}${progress}`;
  }
  
  if (status === 'failed') {
    return `${typeLabel} 실패 - ${item.failurePhase || item.errorMessage || '오류 발생'}`;
  }
  
  if (status === 'draft') {
    return `${typeLabel} 초안`;
  }
  
  if (status === 'paused') {
    return `${typeLabel} 일시 중단`;
  }
  
  const resultText = item.resultCount ? `${item.resultCount}개 결과` : '';
  return `${typeLabel}${resultText ? ` - ${resultText}` : ''}`;
}

/**
 * 마지막 작업 상태를 추적하고 이어하기 기능을 제공하는 Hook
 * 이제 백엔드 API를 통해 서버에서 관리되는 데이터를 사용합니다.
 */
export function useContinueWork(userId: string = 'anonymous'): UseContinueWorkReturn {
  const [lastWork, setLastWork] = useState<ContinueWorkItem | null>(null);
  const [recentWorks, setRecentWorks] = useState<ContinueWorkItem[]>([]);
  const [stats, setStats] = useState<ContinueWorkStats>({
    total: 0,
    inProgress: 0,
    failed: 0,
    draft: 0,
    partial: 0,
    unviewedCompleted: 0,
  });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const sessionIdRef = useRef<string | null>(null);

  // Get session ID from sessionStorage
  useEffect(() => {
    sessionIdRef.current = sessionStorage.getItem('search-session-id');
  }, []);

  // 데이터 새로고침
  const refresh = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const response = await getContinueWorkItems(
        userId,
        sessionIdRef.current || undefined,
        MAX_RECENT_WORKS
      );
      
      // Convert API items to internal format
      const works = response.items.map(convertApiItemToWorkItem);
      
      // Set stats
      setStats(response.stats);
      
      // Find the most important work item
      // Priority: in_progress > failed > draft > partial > ready (unviewed)
      const priorityOrder: WorkStatus[] = ['in_progress', 'failed', 'draft', 'paused', 'ready'];
      
      let primaryWork: ContinueWorkItem | null = null;
      for (const status of priorityOrder) {
        const workWithStatus = works.find(w => w.status === status);
        if (workWithStatus) {
          // For 'ready' status, prioritize unviewed items
          if (status === 'ready') {
            const unviewedWork = works.find(w => w.status === 'ready' && !w.viewed);
            primaryWork = unviewedWork || workWithStatus;
          } else {
            primaryWork = workWithStatus;
          }
          break;
        }
      }
      
      setLastWork(primaryWork);
      setRecentWorks(works);
      
    } catch (e) {
      const errorMessage = e instanceof Error ? e.message : '작업 목록을 불러오는데 실패했습니다.';
      setError(errorMessage);
      console.error('Failed to refresh continue work:', e);
      
      // Fallback: keep existing data
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  // Mark work as viewed (dismiss from primary position)
  const markAsViewedAction = useCallback(async (id: string) => {
    try {
      // Find the work item to get the database ID
      const work = recentWorks.find(w => w.id === id);
      
      if (work?.metadata?.dbId) {
        await markSearchAsViewed(work.metadata.dbId);
      } else if (id.startsWith('db_')) {
        const dbId = parseInt(id.replace('db_', ''), 10);
        if (!isNaN(dbId)) {
          await markSearchAsViewed(dbId);
        }
      } else {
        // Try using external ID
        await markSearchAsViewedByExternalId(id);
      }
      
      // Update local state
      setRecentWorks(prev => 
        prev.map(w => w.id === id ? { ...w, viewed: true } : w)
      );
      
      // If this was the last work, find next one
      if (lastWork?.id === id) {
        const nextWork = recentWorks.find(w => w.id !== id && (w.status === 'in_progress' || !w.viewed));
        setLastWork(nextWork || null);
      }
    } catch (e) {
      console.error('Failed to mark work as viewed:', e);
    }
  }, [recentWorks, lastWork]);

  // Dismiss work (mark as viewed and remove from list)
  const dismissWork = useCallback(async (id: string) => {
    await markAsViewedAction(id);
    
    // Remove from local list
    setRecentWorks(prev => prev.filter(w => w.id !== id));
    
    if (lastWork?.id === id) {
      setLastWork(recentWorks.find(w => w.id !== id) || null);
    }
  }, [markAsViewedAction, lastWork, recentWorks]);

  // Retry failed work
  const retryWork = useCallback((id: string) => {
    const work = recentWorks.find(w => w.id === id);
    if (work?.continueUrl) {
      window.location.href = work.continueUrl;
    }
  }, [recentWorks]);

  // Clear all works (mark all as viewed)
  const clearAllWorks = useCallback(async () => {
    try {
      // Mark all as viewed
      await Promise.all(
        recentWorks
          .filter(w => !w.viewed && w.metadata?.dbId)
          .map(w => markSearchAsViewed(w.metadata!.dbId!))
      );
    } catch (e) {
      console.error('Failed to clear all works:', e);
    }
    
    setRecentWorks([]);
    setLastWork(null);
    setStats({
      total: 0,
      inProgress: 0,
      failed: 0,
      draft: 0,
      partial: 0,
      unviewedCompleted: 0,
    });
  }, [recentWorks]);

  // 초기 로드
  useEffect(() => {
    refresh();
  }, [refresh]);

  // Periodic refresh for in-progress items
  useEffect(() => {
    if (stats.inProgress === 0) return;
    
    const intervalId = setInterval(() => {
      refresh();
    }, 10000); // Refresh every 10 seconds when there are in-progress items
    
    return () => clearInterval(intervalId);
  }, [stats.inProgress, refresh]);

  return {
    lastWork,
    recentWorks,
    stats,
    isLoading,
    error,
    refresh,
    dismissWork,
    markAsViewed: markAsViewedAction,
    retryWork,
    clearAllWorks,
  };
}

/**
 * 현재 작업을 저장하는 유틸리티 함수
 * 검색이나 분석 시작 시 호출
 * 
 * @deprecated 이제 백엔드에서 자동으로 관리됩니다. 검색 API가 자동으로 기록합니다.
 */
export function saveCurrentWork(work: Omit<ContinueWorkItem, 'lastUpdated'>) {
  console.warn('saveCurrentWork is deprecated. Search history is now managed by the backend automatically.');
  // No-op - backend handles this now
}

/**
 * Deep Search 작업 시작 시 호출
 * 
 * @deprecated 이제 백엔드에서 자동으로 관리됩니다.
 */
export function trackDeepSearchJob(jobId: string, topic: string) {
  console.warn('trackDeepSearchJob is deprecated. Use SearchJobContext instead.');
  // Keep session storage for backward compatibility
  sessionStorage.setItem('active_deep_search_job', jobId);
}

/**
 * Deep Search 완료 시 호출
 * 
 * @deprecated 이제 백엔드에서 자동으로 관리됩니다.
 */
export function completeDeepSearchJob(jobId: string) {
  console.warn('completeDeepSearchJob is deprecated. Use SearchJobContext instead.');
  sessionStorage.removeItem('active_deep_search_job');
}

export default useContinueWork;

```

---

## frontend/src/hooks/useCrawlerLogs.ts

```ts
import { useCallback, useState, useMemo } from 'react';
import { useEventSource } from './useEventSource';

// ============================================
// Crawler Log Types
// ============================================

export type CrawlerEventType =
  | 'connected'
  | 'agent_start'
  | 'agent_step'
  | 'agent_complete'
  | 'agent_error'
  | 'url_discovered'
  | 'health_update'
  | 'captcha_detected'
  | 'captcha_solved'
  | 'collection_start'
  | 'collection_progress'
  | 'collection_complete'
  | 'collection_error'
  | 'collection_log';

export type LogLevel = 'DEBUG' | 'INFO' | 'WARNING' | 'ERROR';

export interface CrawlerEvent {
  type: CrawlerEventType;
  id: string;
  timestamp: string;
  data: {
    source?: string;
    task_id?: string;
    url?: string;
    message: string;
    level?: LogLevel;
    progress?: number;
    total?: number;
    [key: string]: unknown;
  };
}

export interface CrawlerLogEntry {
  id: string;
  eventType: CrawlerEventType;
  source: string;
  message: string;
  level: LogLevel;
  timestamp: Date;
  data?: Record<string, unknown>;
}

// ============================================
// Crawler Logs Stream Hook
// ============================================

export interface UseCrawlerLogsOptions {
  /** 로그 최대 보관 개수 */
  maxLogs?: number;
  /** 연결 활성화 여부 */
  enabled?: boolean;
  /** 필터링할 소스 (비어있으면 전체) */
  filterSources?: string[];
  /** 필터링할 로그 레벨 (비어있으면 전체) */
  filterLevels?: LogLevel[];
  /** 이벤트 수신 콜백 */
  onEvent?: (event: CrawlerEvent) => void;
}

export interface UseCrawlerLogsReturn {
  /** 로그 목록 */
  logs: CrawlerLogEntry[];
  /** 연결 상태 */
  status: 'connecting' | 'connected' | 'disconnected' | 'error';
  /** 재연결 시도 횟수 */
  retryCount: number;
  /** 수동 재연결 */
  reconnect: () => void;
  /** 로그 초기화 */
  clearLogs: () => void;
  /** 활성 소스 목록 */
  activeSources: string[];
  /** 소스별 상태 */
  sourceStatus: Record<string, 'idle' | 'running' | 'complete' | 'error'>;
}

/**
 * 크롤러 SSE 스트림을 구독하는 훅
 * autonomous-crawler 서비스의 /events 엔드포인트에 연결
 */
export function useCrawlerLogs(
  options: UseCrawlerLogsOptions = {}
): UseCrawlerLogsReturn {
  const {
    maxLogs = 200,
    enabled = true,
    filterSources = [],
    filterLevels = [],
    onEvent,
  } = options;

  const [logs, setLogs] = useState<CrawlerLogEntry[]>([]);
  const [activeSources, setActiveSources] = useState<string[]>([]);
  const [sourceStatus, setSourceStatus] = useState<Record<string, 'idle' | 'running' | 'complete' | 'error'>>({});

  const handleMessage = useCallback((data: string) => {
    try {
      const event: CrawlerEvent = JSON.parse(data);
      
      // 연결 이벤트는 로그에 추가하지 않음
      if (event.type === 'connected') {
        onEvent?.(event);
        return;
      }

      const source = event.data?.source || event.data?.task_id || 'unknown';
      const level = (event.data?.level as LogLevel) || 'INFO';

      // 필터링 적용
      if (filterSources.length > 0 && !filterSources.includes(source)) {
        return;
      }
      if (filterLevels.length > 0 && !filterLevels.includes(level)) {
        return;
      }

      // 소스 상태 업데이트
      if (event.type === 'collection_start' || event.type === 'agent_start') {
        setActiveSources(prev => {
          if (!prev.includes(source)) return [...prev, source];
          return prev;
        });
        setSourceStatus(prev => ({ ...prev, [source]: 'running' }));
      } else if (event.type === 'collection_complete' || event.type === 'agent_complete') {
        setSourceStatus(prev => ({ ...prev, [source]: 'complete' }));
      } else if (event.type === 'collection_error' || event.type === 'agent_error') {
        setSourceStatus(prev => ({ ...prev, [source]: 'error' }));
      }

      const logEntry: CrawlerLogEntry = {
        id: event.id || `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        eventType: event.type,
        source,
        message: event.data?.message || '',
        level,
        timestamp: new Date(event.timestamp),
        data: event.data,
      };

      setLogs((prev) => {
        const newLogs = [logEntry, ...prev];
        return newLogs.slice(0, maxLogs);
      });

      onEvent?.(event);
    } catch (e) {
      console.error('Failed to parse crawler event:', e);
    }
  }, [maxLogs, filterSources, filterLevels, onEvent]);

  // autonomous-crawler 서비스의 SSE 엔드포인트
  // API Gateway를 통해 라우팅됨
  const { status, retryCount, reconnect } = useEventSource(
    enabled ? '/api/v1/crawler/events' : null,
    {
      onMessage: handleMessage,
      reconnectInterval: 5000,
      maxRetries: 10,
      enabled,
    }
  );

  const clearLogs = useCallback(() => {
    setLogs([]);
    setActiveSources([]);
    setSourceStatus({});
  }, []);

  return {
    logs,
    status,
    retryCount,
    reconnect,
    clearLogs,
    activeSources,
    sourceStatus,
  };
}

export default useCrawlerLogs;

```

---

## frontend/src/hooks/useDashboardEvents.ts

```ts
import { useCallback, useState, useMemo } from 'react';
import { useEventSource } from './useEventSource';

// ============================================
// Dashboard Event Types
// ============================================

export type DashboardEventType =
  | 'HEARTBEAT'
  | 'NEW_DATA'
  | 'SOURCE_UPDATED'
  | 'STATS_UPDATED'
  | 'COLLECTION_STARTED'
  | 'COLLECTION_COMPLETED'
  | 'ERROR';

export interface DashboardEvent {
  eventType: DashboardEventType;
  timestamp: string;
  message: string;
  data?: Record<string, unknown>;
}

export interface DashboardStats {
  total: number;
  unprocessed: number;
  processed: number;
  todayCount?: number;
  errorCount?: number;
}

export interface ActivityLogEntry {
  id: string;
  eventType: DashboardEventType;
  message: string;
  timestamp: Date;
  data?: Record<string, unknown>;
}

// ============================================
// Dashboard Events Stream Hook
// ============================================

export interface UseDashboardEventsOptions {
  /** 활동 로그 최대 보관 개수 */
  maxActivityLogs?: number;
  /** 연결 활성화 여부 */
  enabled?: boolean;
  /** 이벤트 수신 콜백 */
  onEvent?: (event: DashboardEvent) => void;
}

export interface UseDashboardEventsReturn {
  /** 최근 활동 로그 */
  activityLogs: ActivityLogEntry[];
  /** 연결 상태 */
  status: 'connecting' | 'connected' | 'disconnected' | 'error';
  /** 재연결 시도 횟수 */
  retryCount: number;
  /** 수동 재연결 */
  reconnect: () => void;
  /** 활동 로그 초기화 */
  clearLogs: () => void;
}

/**
 * 대시보드 이벤트 스트림을 구독하는 훅
 * GET /api/v1/events/stream
 */
export function useDashboardEvents(
  options: UseDashboardEventsOptions = {}
): UseDashboardEventsReturn {
  const {
    maxActivityLogs = 50,
    enabled = true,
    onEvent,
  } = options;

  const [activityLogs, setActivityLogs] = useState<ActivityLogEntry[]>([]);

  const handleMessage = useCallback((data: string) => {
    try {
      const event: DashboardEvent = JSON.parse(data);
      
      // HEARTBEAT는 로그에 추가하지 않음
      if (event.eventType !== 'HEARTBEAT') {
        const logEntry: ActivityLogEntry = {
          id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          eventType: event.eventType,
          message: event.message,
          timestamp: new Date(event.timestamp),
          data: event.data,
        };

        setActivityLogs((prev) => {
          const newLogs = [logEntry, ...prev];
          return newLogs.slice(0, maxActivityLogs);
        });
      }

      onEvent?.(event);
    } catch (e) {
      console.error('Failed to parse dashboard event:', e);
    }
  }, [maxActivityLogs, onEvent]);

  const { status, retryCount, reconnect } = useEventSource(
    enabled ? '/api/v1/events/stream' : null,
    {
      onMessage: handleMessage,
      reconnectInterval: 5000,
      maxRetries: 10,
      enabled,
    }
  );

  const clearLogs = useCallback(() => {
    setActivityLogs([]);
  }, []);

  return {
    activityLogs,
    status,
    retryCount,
    reconnect,
    clearLogs,
  };
}

// ============================================
// Dashboard Stats Stream Hook
// ============================================

export interface UseDashboardStatsOptions {
  /** 연결 활성화 여부 */
  enabled?: boolean;
  /** 통계 업데이트 콜백 */
  onStatsUpdate?: (stats: DashboardStats) => void;
}

export interface UseDashboardStatsReturn {
  /** 현재 통계 */
  stats: DashboardStats | null;
  /** 이전 통계 (변화량 계산용) */
  previousStats: DashboardStats | null;
  /** 연결 상태 */
  status: 'connecting' | 'connected' | 'disconnected' | 'error';
  /** 마지막 업데이트 시간 */
  lastUpdated: Date | null;
  /** 수동 재연결 */
  reconnect: () => void;
}

/**
 * 대시보드 통계 스트림을 구독하는 훅
 * GET /api/v1/events/stats/stream
 */
export function useDashboardStats(
  options: UseDashboardStatsOptions = {}
): UseDashboardStatsReturn {
  const { enabled = true, onStatsUpdate } = options;

  const [stats, setStats] = useState<DashboardStats | null>(null);
  const [previousStats, setPreviousStats] = useState<DashboardStats | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);

  const handleMessage = useCallback((data: string) => {
    try {
      const event: DashboardEvent = JSON.parse(data);
      
      if (event.eventType === 'STATS_UPDATED' && event.data) {
        const newStats: DashboardStats = {
          total: (event.data.total as number) ?? 0,
          unprocessed: (event.data.unprocessed as number) ?? 0,
          processed: (event.data.processed as number) ?? 0,
          todayCount: event.data.todayCount as number | undefined,
          errorCount: event.data.errorCount as number | undefined,
        };

        setPreviousStats(stats);
        setStats(newStats);
        setLastUpdated(new Date());
        onStatsUpdate?.(newStats);
      }
    } catch (e) {
      console.error('Failed to parse stats event:', e);
    }
  }, [stats, onStatsUpdate]);

  const { status, reconnect } = useEventSource(
    enabled ? '/api/v1/events/stats/stream' : null,
    {
      onMessage: handleMessage,
      reconnectInterval: 5000,
      maxRetries: 10,
      enabled,
    }
  );

  return {
    stats,
    previousStats,
    status,
    lastUpdated,
    reconnect,
  };
}

// ============================================
// Combined Dashboard Hook
// ============================================

export interface UseLiveDashboardOptions {
  /** 활동 로그 최대 보관 개수 */
  maxActivityLogs?: number;
  /** 연결 활성화 여부 */
  enabled?: boolean;
}

export interface UseLiveDashboardReturn {
  /** 현재 통계 */
  stats: DashboardStats | null;
  /** 이전 통계 */
  previousStats: DashboardStats | null;
  /** 최근 활동 로그 */
  activityLogs: ActivityLogEntry[];
  /** 이벤트 스트림 연결 상태 */
  eventsStatus: 'connecting' | 'connected' | 'disconnected' | 'error';
  /** 통계 스트림 연결 상태 */
  statsStatus: 'connecting' | 'connected' | 'disconnected' | 'error';
  /** 전체 연결 상태 (하나라도 연결되면 connected) */
  isConnected: boolean;
  /** 마지막 통계 업데이트 시간 */
  lastStatsUpdate: Date | null;
  /** 이벤트 스트림 재연결 */
  reconnectEvents: () => void;
  /** 통계 스트림 재연결 */
  reconnectStats: () => void;
  /** 활동 로그 초기화 */
  clearLogs: () => void;
}

/**
 * 대시보드 이벤트 + 통계 스트림을 모두 구독하는 통합 훅
 */
export function useLiveDashboard(
  options: UseLiveDashboardOptions = {}
): UseLiveDashboardReturn {
  const { maxActivityLogs = 50, enabled = true } = options;

  const {
    activityLogs,
    status: eventsStatus,
    reconnect: reconnectEvents,
    clearLogs,
  } = useDashboardEvents({ maxActivityLogs, enabled });

  const {
    stats,
    previousStats,
    status: statsStatus,
    lastUpdated: lastStatsUpdate,
    reconnect: reconnectStats,
  } = useDashboardStats({ enabled });

  const isConnected = useMemo(
    () => eventsStatus === 'connected' || statsStatus === 'connected',
    [eventsStatus, statsStatus]
  );

  return {
    stats,
    previousStats,
    activityLogs,
    eventsStatus,
    statsStatus,
    isConnected,
    lastStatsUpdate,
    reconnectEvents,
    reconnectStats,
    clearLogs,
  };
}

export default useLiveDashboard;

```

---

## frontend/src/hooks/useDeepSearchSSE.ts

```ts
import { useEffect, useRef, useCallback, useState } from 'react';
import { useBackgroundTasks } from '@/contexts/BackgroundTaskContext';
import type { DeepSearchJob, DeepSearchResult, Evidence } from '@/lib/api';

// Storage key for access token (matches AuthContext)
const ACCESS_TOKEN_KEY = 'access_token';

/**
 * Append authentication token to URL for SSE connections.
 * EventSource doesn't support custom headers, so we use query parameter.
 */
function appendTokenToUrl(url: string): string {
  const token = localStorage.getItem(ACCESS_TOKEN_KEY);
  if (!token) return url;
  
  const separator = url.includes('?') ? '&' : '?';
  return `${url}${separator}token=${encodeURIComponent(token)}`;
}

// ============================================
// Types
// ============================================

export interface DeepSearchSSEEvent {
  eventType: 'status' | 'progress' | 'evidence' | 'complete' | 'error' | 'heartbeat';
  jobId: string;
  status?: DeepSearchJob['status'];
  progress?: number;
  progressMessage?: string;
  evidence?: Evidence;
  evidenceCount?: number;
  result?: DeepSearchResult;
  error?: string;
}

export interface UseDeepSearchSSEOptions {
  jobId: string | null;
  topic?: string;
  onStatusUpdate?: (status: DeepSearchJob['status']) => void;
  onProgress?: (progress: number, message?: string) => void;
  onEvidence?: (evidence: Evidence, count: number) => void;
  onComplete?: (result: DeepSearchResult) => void;
  onError?: (error: string) => void;
  autoAddToBackground?: boolean;
  enabled?: boolean;
}

export interface UseDeepSearchSSEReturn {
  status: 'connecting' | 'connected' | 'disconnected' | 'error';
  currentStatus?: DeepSearchJob['status'];
  progress: number;
  progressMessage?: string;
  evidenceCount: number;
  result?: DeepSearchResult;
  error?: string;
  disconnect: () => void;
  reconnect: () => void;
}

// ============================================
// Constants
// ============================================

const RECONNECT_INTERVAL = 3000;
const MAX_RETRIES = 5;
const HEARTBEAT_TIMEOUT = 35000; // 35 seconds (server sends every 30s)

// ============================================
// Helper Functions
// ============================================

const resolveBaseUrl = (): string => {
  // 개발 환경: Vite proxy 사용 (상대 경로)
  if (import.meta.env.DEV) {
    return '';
  }

  if (import.meta.env.VITE_API_BASE_URL) {
    return import.meta.env.VITE_API_BASE_URL as string;
  }

  // 프로덕션: 현재 호스트 사용
  if (typeof window !== 'undefined') {
    return window.location.origin;
  }

  return '';
};

/**
 * Calculate stance distribution from evidence array
 */
const calculateStanceDistribution = (evidence: Evidence[]): DeepSearchResult['stanceDistribution'] => {
  const total = evidence.length;
  const pro = evidence.filter(e => e.stance === 'pro').length;
  const con = evidence.filter(e => e.stance === 'con').length;
  const neutral = evidence.filter(e => e.stance === 'neutral').length;
  
  return {
    pro,
    con,
    neutral,
    proRatio: total > 0 ? pro / total : 0,
    conRatio: total > 0 ? con / total : 0,
    neutralRatio: total > 0 ? neutral / total : 0,
  };
};

// ============================================
// Hook
// ============================================

export function useDeepSearchSSE(options: UseDeepSearchSSEOptions): UseDeepSearchSSEReturn {
  const {
    jobId,
    topic,
    onStatusUpdate,
    onProgress,
    onEvidence,
    onComplete,
    onError,
    autoAddToBackground = true,
    enabled = true,
  } = options;

  const { addTask, updateTask, getTask } = useBackgroundTasks();

  const [connectionStatus, setConnectionStatus] = useState<UseDeepSearchSSEReturn['status']>('disconnected');
  const [currentStatus, setCurrentStatus] = useState<DeepSearchJob['status']>();
  const [progress, setProgress] = useState(0);
  const [progressMessage, setProgressMessage] = useState<string>();
  const [evidenceCount, setEvidenceCount] = useState(0);
  const [result, setResult] = useState<DeepSearchResult>();
  const [error, setError] = useState<string>();

  const eventSourceRef = useRef<EventSource | null>(null);
  const retriesRef = useRef(0);
  const reconnectTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const heartbeatTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const mountedRef = useRef(true);
  
  // Ref to accumulate evidence items as they arrive
  const accumulatedEvidenceRef = useRef<Evidence[]>([]);

  // Refs for callbacks to avoid reconnection on callback changes
  const onStatusUpdateRef = useRef(onStatusUpdate);
  const onProgressRef = useRef(onProgress);
  const onEvidenceRef = useRef(onEvidence);
  const onCompleteRef = useRef(onComplete);
  const onErrorRef = useRef(onError);

  useEffect(() => {
    onStatusUpdateRef.current = onStatusUpdate;
    onProgressRef.current = onProgress;
    onEvidenceRef.current = onEvidence;
    onCompleteRef.current = onComplete;
    onErrorRef.current = onError;
  }, [onStatusUpdate, onProgress, onEvidence, onComplete, onError]);

  const clearTimeouts = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    if (heartbeatTimeoutRef.current) {
      clearTimeout(heartbeatTimeoutRef.current);
      heartbeatTimeoutRef.current = null;
    }
  }, []);

  const resetHeartbeatTimeout = useCallback(() => {
    if (heartbeatTimeoutRef.current) {
      clearTimeout(heartbeatTimeoutRef.current);
    }
    heartbeatTimeoutRef.current = setTimeout(() => {
      // Connection seems dead, try to reconnect
      if (eventSourceRef.current && mountedRef.current) {
        console.warn('[DeepSearchSSE] Heartbeat timeout, reconnecting...');
        eventSourceRef.current.close();
        eventSourceRef.current = null;
        setConnectionStatus('error');
        scheduleReconnect();
      }
    }, HEARTBEAT_TIMEOUT);
  }, []);

  const scheduleReconnect = useCallback(() => {
    if (retriesRef.current < MAX_RETRIES && mountedRef.current) {
      retriesRef.current++;
      reconnectTimeoutRef.current = setTimeout(() => {
        if (mountedRef.current) {
          connect();
        }
      }, RECONNECT_INTERVAL);
    }
  }, []);

  const disconnect = useCallback(() => {
    clearTimeouts();
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    if (mountedRef.current) {
      setConnectionStatus('disconnected');
    }
  }, [clearTimeouts]);

  const connect = useCallback(() => {
    if (!jobId || !enabled) {
      disconnect();
      return;
    }

    // Close existing connection
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
    }
    clearTimeouts();
    
    // Reset accumulated evidence for new connection
    accumulatedEvidenceRef.current = [];

    if (mountedRef.current) {
      setConnectionStatus('connecting');
    }

    // Add task to background if enabled
    if (autoAddToBackground && topic) {
      const existingTask = getTask(jobId);
      if (!existingTask) {
        addTask({
          id: jobId,
          type: 'deep-search',
          title: topic,
          status: 'pending',
          progress: 0,
          resultUrl: `/search?mode=deep&jobId=${jobId}`,
        });
      }
    }

    const baseUrl = resolveBaseUrl();
    const url = `${baseUrl}/api/v1/analysis/deep/${jobId}/stream`;
    
    // Append auth token to URL for SSE authentication
    const authenticatedUrl = appendTokenToUrl(url);
    console.log('[DeepSearchSSE] Connecting to:', authenticatedUrl.replace(/token=[^&]+/, 'token=***'));
    const eventSource = new EventSource(authenticatedUrl);
    eventSourceRef.current = eventSource;

    // Helper function to handle SSE event data
    const handleEventData = (eventType: string, data: Record<string, unknown>) => {
      if (!mountedRef.current) return;
      
      resetHeartbeatTimeout();
      console.log('[DeepSearchSSE] Event:', eventType, data);

      switch (eventType) {
        case 'heartbeat':
          // Just a keep-alive, no action needed
          break;

        case 'status':
          if (data.status) {
            const status = data.status as DeepSearchJob['status'];
            setCurrentStatus(status);
            onStatusUpdateRef.current?.(status);
            
            // Update background task
            const taskStatus = status === 'PENDING' ? 'pending' 
              : status === 'IN_PROGRESS' ? 'running'
              : status === 'COMPLETED' ? 'completed'
              : status === 'FAILED' || status === 'TIMEOUT' ? 'failed'
              : status === 'CANCELLED' ? 'cancelled'
              : 'pending';
            
            updateTask(jobId, { 
              status: taskStatus,
              ...(status === 'COMPLETED' && { completedAt: new Date().toISOString() }),
            });
          }
          break;

        case 'progress':
          if (data.progress !== undefined) {
            const progressValue = data.progress as number;
            const progressMsg = data.progressMessage as string | undefined;
            setProgress(progressValue);
            setProgressMessage(progressMsg);
            onProgressRef.current?.(progressValue, progressMsg);
            
            updateTask(jobId, { 
              progress: progressValue, 
              progressMessage: progressMsg,
              status: 'running',
            });
          }
          break;

        case 'evidence':
          if (data.evidence && data.evidenceCount !== undefined) {
            const evidence = data.evidence as Evidence;
            const count = data.evidenceCount as number;
            setEvidenceCount(count);
            onEvidenceRef.current?.(evidence, count);
            
            // Accumulate evidence and update result progressively
            // Check if evidence already exists to avoid duplicates
            const existingIndex = accumulatedEvidenceRef.current.findIndex(e => e.url === evidence.url);
            if (existingIndex === -1) {
              accumulatedEvidenceRef.current.push(evidence);
            } else {
              accumulatedEvidenceRef.current[existingIndex] = evidence;
            }
            
            // Update result with accumulated evidence for real-time display
            setResult(prev => ({
              ...prev,
              jobId: jobId,
              topic: topic || prev?.topic || '',
              status: 'IN_PROGRESS' as const,
              evidence: [...accumulatedEvidenceRef.current],
              evidenceCount: accumulatedEvidenceRef.current.length,
              stanceDistribution: calculateStanceDistribution(accumulatedEvidenceRef.current),
              createdAt: prev?.createdAt || new Date().toISOString(),
            }));
            
            updateTask(jobId, { evidenceCount: count });
          }
          break;

        case 'complete':
          if (data.result) {
            const result = data.result as DeepSearchResult;
            setResult(result);
            setCurrentStatus('COMPLETED');
            setProgress(100);
            onCompleteRef.current?.(result);
            
            updateTask(jobId, { 
              status: 'completed', 
              progress: 100,
              result: result,
              completedAt: new Date().toISOString(),
              evidenceCount: result.evidence?.length,
            });

            // Close connection after completion
            disconnect();
          }
          break;

        case 'error':
          if (data.error) {
            const errorMsg = data.error as string;
            setError(errorMsg);
            setCurrentStatus('FAILED');
            onErrorRef.current?.(errorMsg);
            
            updateTask(jobId, { 
              status: 'failed', 
              error: errorMsg,
              completedAt: new Date().toISOString(),
            });

            // Close connection after error
            disconnect();
          }
          break;
      }
    };

    eventSource.onopen = () => {
      if (mountedRef.current) {
        console.log('[DeepSearchSSE] Connected');
        setConnectionStatus('connected');
        retriesRef.current = 0;
        resetHeartbeatTimeout();
      }
    };

    // Register named event listeners for SSE event types
    // This handles SSE events where the event type is in the `event:` field
    const eventTypes = ['heartbeat', 'status', 'progress', 'evidence', 'complete', 'error'];
    eventTypes.forEach(eventType => {
      eventSource.addEventListener(eventType, (event: MessageEvent) => {
        if (!mountedRef.current) return;
        try {
          const data = JSON.parse(event.data) as Record<string, unknown>;
          handleEventData(eventType, data);
        } catch (e) {
          console.error('[DeepSearchSSE] Failed to parse event:', e, event.data);
        }
      });
    });

    // Fallback: handle generic message events (for backward compatibility)
    // This handles cases where eventType is in the data payload
    eventSource.onmessage = (event) => {
      if (!mountedRef.current) return;
      
      resetHeartbeatTimeout();

      try {
        const data = JSON.parse(event.data) as DeepSearchSSEEvent;
        // Only process if eventType is in data (fallback path)
        if (data.eventType) {
          handleEventData(data.eventType, data as unknown as Record<string, unknown>);
        }
      } catch (e) {
        console.error('[DeepSearchSSE] Failed to parse event:', e, event.data);
      }
    };

    eventSource.onerror = (e) => {
      console.error('[DeepSearchSSE] Connection error:', e);
      eventSource.close();
      eventSourceRef.current = null;

      if (mountedRef.current) {
        // Check if it's a terminal state - don't reconnect if job is done
        const terminalStatuses = ['COMPLETED', 'FAILED', 'CANCELLED', 'TIMEOUT'];
        if (currentStatus && terminalStatuses.includes(currentStatus)) {
          setConnectionStatus('disconnected');
          return;
        }

        setConnectionStatus('error');
        scheduleReconnect();
      }
    };
  }, [jobId, enabled, topic, autoAddToBackground, getTask, addTask, updateTask, disconnect, clearTimeouts, resetHeartbeatTimeout, scheduleReconnect, currentStatus]);

  const reconnect = useCallback(() => {
    retriesRef.current = 0;
    connect();
  }, [connect]);

  // Connect when jobId changes
  useEffect(() => {
    mountedRef.current = true;
    if (jobId && enabled) {
      connect();
    }

    return () => {
      mountedRef.current = false;
      disconnect();
    };
  }, [jobId, enabled]); // eslint-disable-line react-hooks/exhaustive-deps

  return {
    status: connectionStatus,
    currentStatus,
    progress,
    progressMessage,
    evidenceCount,
    result,
    error,
    disconnect,
    reconnect,
  };
}

export default useDeepSearchSSE;

```

---

## frontend/src/hooks/useEventSource.ts

```ts
import { useEffect, useRef, useCallback, useState } from 'react';

// Storage key for access token (matches AuthContext)
const ACCESS_TOKEN_KEY = 'access_token';

/**
 * Append authentication token to URL for SSE connections.
 * EventSource doesn't support custom headers, so we use query parameter.
 */
function appendTokenToUrl(url: string): string {
  const token = localStorage.getItem(ACCESS_TOKEN_KEY);
  if (!token) return url;
  
  const separator = url.includes('?') ? '&' : '?';
  return `${url}${separator}token=${encodeURIComponent(token)}`;
}

export interface UseEventSourceOptions {
  /** SSE 메시지 수신 시 콜백 */
  onMessage: (data: string, event?: MessageEvent) => void;
  /** 에러 발생 시 콜백 */
  onError?: (error: Event) => void;
  /** 연결 성공 시 콜백 */
  onOpen?: () => void;
  /** 재연결 간격 (ms), 기본값: 3000 */
  reconnectInterval?: number;
  /** 최대 재연결 시도 횟수, 기본값: 5 */
  maxRetries?: number;
  /** 연결 활성화 여부, 기본값: true */
  enabled?: boolean;
}

export interface UseEventSourceReturn {
  /** 현재 연결 상태 */
  status: 'connecting' | 'connected' | 'disconnected' | 'error';
  /** 재연결 시도 횟수 */
  retryCount: number;
  /** 수동 연결 해제 */
  disconnect: () => void;
  /** 수동 재연결 */
  reconnect: () => void;
}

/**
 * SSE(Server-Sent Events) 연결을 관리하는 커스텀 훅
 * 
 * @param url SSE 엔드포인트 URL (null이면 비활성화)
 * @param options 옵션
 * @returns 연결 상태 및 제어 함수
 * 
 * @example
 * ``\`tsx
 * const { status } = useEventSource('/api/v1/events/stream', {
 *   onMessage: (data) => {
 *     const event = JSON.parse(data);
 *     console.log('Received:', event);
 *   },
 *   onError: () => toast.error('연결 끊김'),
 * });
 * ``\`
 */
export function useEventSource(
  url: string | null,
  options: UseEventSourceOptions
): UseEventSourceReturn {
  const {
    onMessage,
    onError,
    onOpen,
    reconnectInterval = 3000,
    maxRetries = 5,
    enabled = true,
  } = options;

  const [status, setStatus] = useState<UseEventSourceReturn['status']>('disconnected');
  const [retryCount, setRetryCount] = useState(0);

  const sourceRef = useRef<EventSource | null>(null);
  const retriesRef = useRef(0);
  const reconnectTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const mountedRef = useRef(true);

  // 콜백 refs로 최신 값 유지
  const onMessageRef = useRef(onMessage);
  const onErrorRef = useRef(onError);
  const onOpenRef = useRef(onOpen);

  useEffect(() => {
    onMessageRef.current = onMessage;
    onErrorRef.current = onError;
    onOpenRef.current = onOpen;
  }, [onMessage, onError, onOpen]);

  const clearReconnectTimeout = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
  }, []);

  const disconnect = useCallback(() => {
    clearReconnectTimeout();
    if (sourceRef.current) {
      sourceRef.current.close();
      sourceRef.current = null;
    }
    if (mountedRef.current) {
      setStatus('disconnected');
    }
  }, [clearReconnectTimeout]);

  const connect = useCallback(() => {
    if (!url || !enabled) {
      disconnect();
      return;
    }

    // 기존 연결 정리
    if (sourceRef.current) {
      sourceRef.current.close();
    }
    clearReconnectTimeout();

    if (mountedRef.current) {
      setStatus('connecting');
    }

    // Append auth token to URL for SSE authentication
    const authenticatedUrl = appendTokenToUrl(url);
    const eventSource = new EventSource(authenticatedUrl);
    sourceRef.current = eventSource;

    eventSource.onopen = () => {
      if (mountedRef.current) {
        setStatus('connected');
        setRetryCount(0);
        retriesRef.current = 0;
      }
      onOpenRef.current?.();
    };

    eventSource.onmessage = (event) => {
      onMessageRef.current(event.data, event);
    };

    eventSource.onerror = (error) => {
      eventSource.close();
      sourceRef.current = null;

      if (mountedRef.current) {
        setStatus('error');
      }
      onErrorRef.current?.(error);

      // 자동 재연결
      if (retriesRef.current < maxRetries && mountedRef.current) {
        retriesRef.current++;
        if (mountedRef.current) {
          setRetryCount(retriesRef.current);
        }

        reconnectTimeoutRef.current = setTimeout(() => {
          if (mountedRef.current) {
            connect();
          }
        }, reconnectInterval);
      }
    };
  }, [url, enabled, maxRetries, reconnectInterval, disconnect, clearReconnectTimeout]);

  const reconnect = useCallback(() => {
    retriesRef.current = 0;
    setRetryCount(0);
    connect();
  }, [connect]);

  useEffect(() => {
    mountedRef.current = true;
    connect();

    return () => {
      mountedRef.current = false;
      disconnect();
    };
  }, [connect, disconnect]);

  return {
    status,
    retryCount,
    disconnect,
    reconnect,
  };
}

export default useEventSource;

```

---

## frontend/src/hooks/useExport.ts

```ts
import { useCallback } from "react";
import { useToast } from "@/hooks/use-toast";

/**
 * 내보내기 포맷
 */
export type ExportFormat = "json" | "csv" | "markdown" | "txt";

/**
 * 검색 결과 데이터 형식
 */
export interface ExportableSearchResult {
  id?: string;
  title?: string;
  snippet?: string;
  /** Full content text (not truncated) - used for export/analysis */
  content?: string;
  url?: string;
  source?: string;
  publishedAt?: string;
  stance?: string;
  reliabilityScore?: number;
  sentimentLabel?: string;
  [key: string]: unknown;
}

/**
 * Export section for structured content
 */
export interface ExportSection {
  /** Section title */
  title: string;
  /** Section content (text, can include newlines) */
  content: string;
}

/**
 * 내보내기 옵션
 */
export interface ExportOptions {
  /** 파일 이름 (확장자 제외) */
  filename?: string;
  /** 제목/헤더 */
  title?: string;
  /** 추가 메타데이터 */
  metadata?: Record<string, unknown>;
  /** Additional content sections (rendered after metadata, before data) */
  sections?: ExportSection[];
  /** CSV 구분자 */
  csvDelimiter?: string;
  /** BOM 추가 (한글 엑셀 호환) */
  addBom?: boolean;
}

/**
 * JSON 내보내기
 */
const exportToJson = (
  data: unknown,
  options: ExportOptions = {}
): string => {
  const { title, metadata, sections } = options;
  
  const exportData = {
    ...(title && { title }),
    exportedAt: new Date().toISOString(),
    ...metadata,
    ...(sections && sections.length > 0 && { sections }),
    data,
  };
  
  return JSON.stringify(exportData, null, 2);
};

/**
 * CSV 내보내기
 */
const exportToCsv = (
  data: ExportableSearchResult[],
  options: ExportOptions = {}
): string => {
  const { csvDelimiter = ",", addBom = true } = options;
  
  if (data.length === 0) return "";
  
  // 헤더 추출 (모든 객체의 키 합집합)
  const headers = new Set<string>();
  data.forEach((item) => {
    Object.keys(item).forEach((key) => headers.add(key));
  });
  const headerArray = Array.from(headers);
  
  // CSV 값 이스케이프
  const escapeValue = (value: unknown): string => {
    if (value === null || value === undefined) return "";
    const str = String(value);
    if (str.includes(csvDelimiter) || str.includes('"') || str.includes("\n")) {
      return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
  };
  
  // 헤더 행
  const headerRow = headerArray.map(escapeValue).join(csvDelimiter);
  
  // 데이터 행
  const dataRows = data.map((item) =>
    headerArray.map((header) => escapeValue(item[header])).join(csvDelimiter)
  );
  
  const csvContent = [headerRow, ...dataRows].join("\n");
  
  // BOM 추가 (한글 엑셀 호환)
  return addBom ? "\uFEFF" + csvContent : csvContent;
};

/**
 * Markdown 내보내기
 */
const exportToMarkdown = (
  data: ExportableSearchResult[],
  options: ExportOptions = {}
): string => {
  const { title, metadata, sections } = options;
  
  let md = "";
  
  // 제목
  if (title) {
    md += `# ${title}\n\n`;
  }
  
  // 메타데이터
  if (metadata) {
    md += `> 내보내기: ${new Date().toLocaleString("ko-KR")}\n`;
    Object.entries(metadata).forEach(([key, value]) => {
      md += `> ${key}: ${value}\n`;
    });
    md += "\n";
  }
  
  // 추가 섹션 (요약, 분석 결과 등)
  if (sections && sections.length > 0) {
    sections.forEach((section) => {
      md += `## ${section.title}\n\n`;
      md += `${section.content}\n\n`;
    });
  }
  
  // 결과 수
  md += `---\n\n## 상세 결과 (총 ${data.length}개)\n\n`;
  
  // 데이터
  data.forEach((item, index) => {
    md += `## ${index + 1}. ${item.title || "제목 없음"}\n\n`;
    
    if (item.source) md += `**출처:** ${item.source}\n\n`;
    if (item.publishedAt) md += `**날짜:** ${new Date(item.publishedAt).toLocaleDateString("ko-KR")}\n\n`;
    if (item.stance) md += `**입장:** ${item.stance}\n\n`;
    if (item.reliabilityScore !== undefined) md += `**신뢰도:** ${item.reliabilityScore}%\n\n`;
    if (item.sentimentLabel) md += `**감성:** ${item.sentimentLabel}\n\n`;
    
    // Use full content if available, otherwise fall back to snippet
    const displayContent = item.content || item.snippet;
    if (displayContent) {
      md += `### 내용\n\n${displayContent}\n\n`;
    }
    
    if (item.url) {
      md += `[원문 보기](${item.url})\n\n`;
    }
    
    md += "---\n\n";
  });
  
  return md;
};

/**
 * 텍스트 내보내기
 */
const exportToText = (
  data: ExportableSearchResult[],
  options: ExportOptions = {}
): string => {
  const { title, metadata, sections } = options;
  
  let txt = "";
  
  if (title) {
    txt += `${title}\n${"=".repeat(title.length)}\n\n`;
  }
  
  if (metadata) {
    txt += `내보내기: ${new Date().toLocaleString("ko-KR")}\n`;
    Object.entries(metadata).forEach(([key, value]) => {
      txt += `${key}: ${value}\n`;
    });
    txt += "\n" + "-".repeat(40) + "\n\n";
  }
  
  // 추가 섹션 (요약, 분석 결과 등)
  if (sections && sections.length > 0) {
    sections.forEach((section) => {
      txt += `[ ${section.title} ]\n`;
      txt += `${section.content}\n\n`;
    });
    txt += "-".repeat(40) + "\n\n";
  }
  
  txt += `상세 결과 (총 ${data.length}개)\n\n`;
  
  data.forEach((item, index) => {
    txt += `[${index + 1}] ${item.title || "제목 없음"}\n`;
    if (item.source) txt += `출처: ${item.source}\n`;
    if (item.publishedAt) txt += `날짜: ${new Date(item.publishedAt).toLocaleDateString("ko-KR")}\n`;
    // Use full content if available, otherwise fall back to snippet
    const displayContent = item.content || item.snippet;
    if (displayContent) txt += `\n${displayContent}\n`;
    if (item.url) txt += `\nURL: ${item.url}\n`;
    txt += "\n" + "-".repeat(40) + "\n\n";
  });
  
  return txt;
};

/**
 * 파일 다운로드 트리거
 */
const downloadFile = (content: string, filename: string, mimeType: string): void => {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
};

/**
 * MIME 타입 매핑
 */
const MIME_TYPES: Record<ExportFormat, string> = {
  json: "application/json;charset=utf-8",
  csv: "text/csv;charset=utf-8",
  markdown: "text/markdown;charset=utf-8",
  txt: "text/plain;charset=utf-8",
};

/**
 * 파일 확장자 매핑
 */
const FILE_EXTENSIONS: Record<ExportFormat, string> = {
  json: ".json",
  csv: ".csv",
  markdown: ".md",
  txt: ".txt",
};

/**
 * 내보내기 훅
 * 
 * @example
 * ``\`tsx
 * const { exportData, isExporting } = useExport();
 * 
 * // JSON 내보내기
 * exportData(results, "json", { filename: "search-results" });
 * 
 * // CSV 내보내기
 * exportData(results, "csv", { title: "검색 결과" });
 * ``\`
 */
export function useExport() {
  const { toast } = useToast();

  const exportData = useCallback(
    (
      data: ExportableSearchResult[],
      format: ExportFormat,
      options: ExportOptions = {}
    ): boolean => {
      try {
        if (!data || data.length === 0) {
          toast({
            title: "내보내기 실패",
            description: "내보낼 데이터가 없습니다.",
            variant: "destructive",
          });
          return false;
        }

        let content: string;
        
        switch (format) {
          case "json":
            content = exportToJson(data, options);
            break;
          case "csv":
            content = exportToCsv(data, options);
            break;
          case "markdown":
            content = exportToMarkdown(data, options);
            break;
          case "txt":
            content = exportToText(data, options);
            break;
          default:
            throw new Error(`지원하지 않는 형식: ${format}`);
        }

        const timestamp = new Date().toISOString().slice(0, 10);
        const filename = `${options.filename || "newsinsight-export"}-${timestamp}${FILE_EXTENSIONS[format]}`;
        
        downloadFile(content, filename, MIME_TYPES[format]);

        toast({
          title: "내보내기 완료",
          description: `${filename} 파일이 다운로드되었습니다.`,
        });

        return true;
      } catch (error) {
        console.error("Export error:", error);
        toast({
          title: "내보내기 실패",
          description: error instanceof Error ? error.message : "알 수 없는 오류가 발생했습니다.",
          variant: "destructive",
        });
        return false;
      }
    },
    [toast]
  );

  /**
   * 클립보드에 복사
   */
  const copyToClipboard = useCallback(
    async (data: ExportableSearchResult[], format: ExportFormat = "json"): Promise<boolean> => {
      try {
        let content: string;
        
        switch (format) {
          case "json":
            content = exportToJson(data);
            break;
          case "csv":
            content = exportToCsv(data, { addBom: false });
            break;
          case "markdown":
            content = exportToMarkdown(data);
            break;
          case "txt":
            content = exportToText(data);
            break;
          default:
            content = JSON.stringify(data, null, 2);
        }

        await navigator.clipboard.writeText(content);

        toast({
          title: "복사 완료",
          description: "클립보드에 복사되었습니다.",
        });

        return true;
      } catch (error) {
        console.error("Copy error:", error);
        toast({
          title: "복사 실패",
          description: "클립보드에 복사할 수 없습니다.",
          variant: "destructive",
        });
        return false;
      }
    },
    [toast]
  );

  return {
    exportData,
    copyToClipboard,
  };
}

export default useExport;

```

---

## frontend/src/hooks/useFactCheckAnalytics.ts

```ts
import { useState, useCallback, useMemo } from "react";
import type {
  FactCheckAnalytics,
  SourceCredibilityAnalysis,
  ClickbaitAnalysis,
  MisinformationAnalysis,
  ClaimAnalysis,
  ScoreBreakdown,
} from "@/components/FactCheckAnalyticsPanel";
import type {
  DetailedAnalytics,
  FactcheckResult,
  FactcheckAddonResponse,
} from "@/types/api";

// Trusted sources list (matches backend)
const TRUSTED_SOURCES = [
  "연합뉴스", "한국일보", "경향신문", "한겨레", "동아일보",
  "조선일보", "중앙일보", "매일경제", "한국경제", "KBS",
  "MBC", "SBS", "YTN", "JTBC", "채널A", "MBN", "TV조선"
];

// Clickbait patterns
const CLICKBAIT_PATTERNS = [
  { pattern: "충격", severity: "high" as const },
  { pattern: "경악", severity: "high" as const },
  { pattern: "대박", severity: "medium" as const },
  { pattern: "헉", severity: "low" as const },
  { pattern: "알고\\s*보니", severity: "medium" as const },
  { pattern: "결국", severity: "low" as const },
  { pattern: "드디어", severity: "low" as const },
  { pattern: "\\.\\.\\.+$", severity: "low" as const },
  { pattern: "\\?\\?\\?+", severity: "medium" as const },
  { pattern: "!!!+", severity: "medium" as const },
  { pattern: "속보", severity: "low" as const },
  { pattern: "단독", severity: "low" as const },
  { pattern: "긴급", severity: "medium" as const },
];

// Misinformation patterns
const MISINFO_PATTERNS = [
  { pattern: "정부가\\s*숨기", type: "misinformation" as const, severity: "high" as const },
  { pattern: "언론이\\s*보도하지\\s*않는", type: "misinformation" as const, severity: "high" as const },
  { pattern: "비밀리에", type: "misinformation" as const, severity: "medium" as const },
  { pattern: "충격\\s*진실", type: "misinformation" as const, severity: "high" as const },
  { pattern: "알려지지\\s*않은\\s*진실", type: "misinformation" as const, severity: "high" as const },
];

const UNVERIFIABLE_PATTERNS = [
  { pattern: "최초", type: "unverifiable" as const, severity: "low" as const },
  { pattern: "유일", type: "unverifiable" as const, severity: "low" as const },
  { pattern: "최고", type: "unverifiable" as const, severity: "low" as const },
  { pattern: "최대", type: "unverifiable" as const, severity: "low" as const },
  { pattern: "100%", type: "unverifiable" as const, severity: "medium" as const },
  { pattern: "모든\\s*사람", type: "unverifiable" as const, severity: "medium" as const },
  { pattern: "아무도", type: "unverifiable" as const, severity: "medium" as const },
  { pattern: "절대", type: "unverifiable" as const, severity: "medium" as const },
  { pattern: "반드시", type: "unverifiable" as const, severity: "low" as const },
];

// Claim indicators
const CLAIM_INDICATORS = [
  "라고 밝혔다", "라고 주장했다", "라고 전했다",
  "에 따르면", "것으로 알려졌다", "것으로 확인됐다",
  "것으로 보인다", "할 전망이다", "할 예정이다",
  "관계자는", "전문가는", "소식통에 따르면"
];

interface VerificationResult {
  claimId: string;
  originalClaim: string;
  status: string;
  confidenceScore: number;
  supportingEvidence: unknown[];
  contradictingEvidence: unknown[];
  verificationSummary: string;
  relatedConcepts: string[];
}

interface UseFactCheckAnalyticsOptions {
  topic?: string;
  sourceName?: string;
  content?: string;
  title?: string;
}

/**
 * Convert backend DetailedAnalytics to frontend FactCheckAnalytics format
 */
function convertBackendAnalytics(backend: DetailedAnalytics): FactCheckAnalytics {
  // Convert source analysis
  const sourceAnalysis: SourceCredibilityAnalysis = {
    sourceName: backend.source_analysis.source_name || "알 수 없음",
    isTrusted: backend.source_analysis.is_trusted,
    trustScore: backend.source_analysis.trust_score,
    trustLevel: backend.source_analysis.trust_level,
    reason: backend.source_analysis.reason,
    matchedTrustedSource: backend.source_analysis.matched_trusted_source,
  };

  // Convert clickbait analysis
  const clickbaitAnalysis: ClickbaitAnalysis = {
    isClickbait: backend.clickbait_analysis.is_clickbait,
    score: backend.clickbait_analysis.score,
    detectedPatterns: backend.clickbait_analysis.detected_patterns.map(p => ({
      pattern: p.pattern,
      matchedText: p.matched_text,
      severity: p.severity,
    })),
    totalPatternsChecked: backend.clickbait_analysis.total_patterns_checked,
  };

  // Convert misinfo analysis
  const misinfoAnalysis: MisinformationAnalysis = {
    riskScore: backend.misinfo_analysis.risk_score,
    riskLevel: backend.misinfo_analysis.risk_level,
    detectedPatterns: backend.misinfo_analysis.detected_patterns.map(p => ({
      type: p.type,
      pattern: p.pattern,
      matchedText: p.matched_text,
      severity: p.severity,
    })),
    unverifiableClaimCount: backend.misinfo_analysis.unverifiable_claim_count,
  };

  // Convert claim analyses
  const claimAnalyses: ClaimAnalysis[] = backend.claim_analyses.map(c => ({
    claimId: c.claim_id,
    claimText: c.claim_text,
    verdict: c.verdict as ClaimAnalysis["verdict"],
    confidence: c.confidence,
    claimIndicator: c.claim_indicator || "직접 주장",
    analysisMethod: c.analysis_method,
    supportingFactors: c.supporting_factors,
    contradictingFactors: c.contradicting_factors,
  }));

  // Convert score breakdown
  const scoreBreakdown: ScoreBreakdown = {
    sourceWeight: backend.score_breakdown.source_weight,
    clickbaitWeight: backend.score_breakdown.clickbait_weight,
    misinfoWeight: backend.score_breakdown.misinfo_weight,
    verificationWeight: backend.score_breakdown.verification_weight,
    sourceContribution: backend.score_breakdown.source_contribution,
    clickbaitContribution: backend.score_breakdown.clickbait_contribution,
    misinfoContribution: backend.score_breakdown.misinfo_contribution,
    verificationContribution: backend.score_breakdown.verification_contribution,
    totalScore: backend.score_breakdown.total_score,
    grade: backend.score_breakdown.grade as ScoreBreakdown["grade"],
  };

  return {
    sourceAnalysis,
    clickbaitAnalysis,
    misinfoAnalysis,
    claimAnalyses,
    scoreBreakdown,
    analysisVersion: `${backend.analysis_mode}-v2.0`,
    processingTimeMs: backend.processing_time_ms,
    analyzedAt: backend.analyzed_at,
    // Add ML metadata
    mlModelsUsed: backend.ml_models_used,
    externalApisUsed: backend.external_apis_used,
  };
}

/**
 * Hook to analyze content and generate detailed factcheck analytics
 */
export function useFactCheckAnalytics() {
  const [analytics, setAnalytics] = useState<FactCheckAnalytics | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  /**
   * Analyze source credibility (client-side fallback)
   */
  const analyzeSource = useCallback((sourceName?: string): SourceCredibilityAnalysis => {
    if (!sourceName) {
      return {
        sourceName: "알 수 없음",
        isTrusted: false,
        trustScore: 0.3,
        trustLevel: "untrusted",
        reason: "출처 정보가 제공되지 않았습니다. 신뢰도를 평가할 수 없습니다.",
      };
    }

    const matchedSource = TRUSTED_SOURCES.find(s => 
      sourceName.includes(s) || s.includes(sourceName)
    );

    if (matchedSource) {
      return {
        sourceName,
        isTrusted: true,
        trustScore: 0.9,
        trustLevel: "trusted",
        reason: `${matchedSource}은(는) 신뢰할 수 있는 주요 언론사로 분류됩니다.`,
        matchedTrustedSource: matchedSource,
      };
    }

    return {
      sourceName,
      isTrusted: false,
      trustScore: 0.5,
      trustLevel: "unknown",
      reason: "신뢰 매체 목록에 없는 출처입니다. 추가 확인이 필요합니다.",
    };
  }, []);

  /**
   * Detect clickbait patterns (client-side fallback)
   */
  const analyzeClickbait = useCallback((title?: string, content?: string): ClickbaitAnalysis => {
    const text = `${title || ""} ${content || ""}`;
    const detectedPatterns: ClickbaitAnalysis["detectedPatterns"] = [];

    for (const { pattern, severity } of CLICKBAIT_PATTERNS) {
      const regex = new RegExp(pattern, "gi");
      const matches = text.match(regex);
      if (matches) {
        detectedPatterns.push({
          pattern,
          matchedText: matches[0],
          severity,
        });
      }
    }

    const score = Math.min(detectedPatterns.length * 0.15, 1);
    const isClickbait = score > 0.3 || detectedPatterns.some(p => p.severity === "high");

    return {
      isClickbait,
      score,
      detectedPatterns,
      totalPatternsChecked: CLICKBAIT_PATTERNS.length,
    };
  }, []);

  /**
   * Analyze misinformation risk (client-side fallback)
   */
  const analyzeMisinformation = useCallback((title?: string, content?: string): MisinformationAnalysis => {
    const text = `${title || ""} ${content || ""}`;
    const detectedPatterns: MisinformationAnalysis["detectedPatterns"] = [];

    // Check misinformation patterns
    for (const { pattern, type, severity } of MISINFO_PATTERNS) {
      const regex = new RegExp(pattern, "gi");
      const matches = text.match(regex);
      if (matches) {
        detectedPatterns.push({
          type,
          pattern,
          matchedText: matches[0],
          severity,
        });
      }
    }

    // Check unverifiable patterns
    for (const { pattern, type, severity } of UNVERIFIABLE_PATTERNS) {
      const regex = new RegExp(pattern, "gi");
      const matches = text.match(regex);
      if (matches) {
        detectedPatterns.push({
          type,
          pattern,
          matchedText: matches[0],
          severity,
        });
      }
    }

    const misinfoCount = detectedPatterns.filter(p => p.type === "misinformation").length;
    const unverifiableCount = detectedPatterns.filter(p => p.type === "unverifiable").length;

    const riskScore = Math.min(
      (misinfoCount * 0.25) + (unverifiableCount * 0.1),
      1
    );

    const riskLevel: MisinformationAnalysis["riskLevel"] = 
      riskScore > 0.5 ? "high" : riskScore > 0.2 ? "medium" : "low";

    return {
      riskScore,
      riskLevel,
      detectedPatterns,
      unverifiableClaimCount: unverifiableCount,
    };
  }, []);

  /**
   * Analyze individual claims from verification results (client-side fallback)
   */
  const analyzeClaims = useCallback((
    verificationResults: VerificationResult[]
  ): ClaimAnalysis[] => {
    return verificationResults.map(result => {
      // Find which claim indicator was used
      const claimIndicator = CLAIM_INDICATORS.find(indicator =>
        result.originalClaim.includes(indicator)
      ) || "직접 주장";

      // Determine verdict from status
      type VerdictType = "verified" | "false" | "unverified" | "misleading" | "partially_true";
      const verdictMap: Record<string, VerdictType> = {
        VERIFIED: "verified",
        PARTIALLY_VERIFIED: "partially_true",
        UNVERIFIED: "unverified",
        DISPUTED: "misleading",
        FALSE: "false",
      };

      const verdict: VerdictType = verdictMap[result.status] || "unverified";

      // Generate analysis method description
      const analysisMethod = `${result.supportingEvidence.length}개 지지 근거, ` +
        `${result.contradictingEvidence.length}개 반박 근거를 기반으로 분석`;

      // Generate supporting/contradicting factors
      const supportingFactors = result.supportingEvidence.length > 0
        ? [`${result.supportingEvidence.length}개의 신뢰할 수 있는 출처에서 지지`]
        : [];

      const contradictingFactors = result.contradictingEvidence.length > 0
        ? [`${result.contradictingEvidence.length}개의 출처에서 반박`]
        : [];

      if (result.confidenceScore >= 0.8) {
        supportingFactors.push("높은 신뢰도 (80% 이상)");
      }

      if (result.relatedConcepts.length > 0) {
        supportingFactors.push(`관련 개념 ${result.relatedConcepts.length}개 확인됨`);
      }

      return {
        claimId: result.claimId,
        claimText: result.originalClaim,
        verdict,
        confidence: result.confidenceScore,
        claimIndicator,
        analysisMethod,
        supportingFactors,
        contradictingFactors,
      };
    });
  }, []);

  /**
   * Calculate score breakdown (client-side fallback)
   */
  const calculateScoreBreakdown = useCallback((
    sourceAnalysis: SourceCredibilityAnalysis,
    clickbaitAnalysis: ClickbaitAnalysis,
    misinfoAnalysis: MisinformationAnalysis,
    claimAnalyses: ClaimAnalysis[]
  ): ScoreBreakdown => {
    const sourceWeight = 30;
    const clickbaitWeight = 20;
    const misinfoWeight = 20;
    const verificationWeight = 30;

    // Calculate contributions
    const sourceContribution = sourceAnalysis.trustScore * sourceWeight;
    
    const clickbaitScore = clickbaitAnalysis.isClickbait ? 0.7 : 1;
    const clickbaitContribution = clickbaitScore * clickbaitWeight;
    
    const misinfoScore = 1 - misinfoAnalysis.riskScore;
    const misinfoContribution = misinfoScore * misinfoWeight;
    
    const verifiedCount = claimAnalyses.filter(c => c.verdict === "verified").length;
    const verificationRatio = claimAnalyses.length > 0 
      ? verifiedCount / claimAnalyses.length 
      : 0.5;
    const verificationContribution = verificationRatio * verificationWeight;

    const totalScore = Math.round(
      sourceContribution + clickbaitContribution + misinfoContribution + verificationContribution
    );

    type GradeType = "A" | "B" | "C" | "D" | "F";
    const grade: GradeType = 
      totalScore >= 80 ? "A" :
      totalScore >= 60 ? "B" :
      totalScore >= 40 ? "C" :
      totalScore >= 20 ? "D" : "F";

    return {
      sourceWeight,
      clickbaitWeight,
      misinfoWeight,
      verificationWeight,
      sourceContribution,
      clickbaitContribution,
      misinfoContribution,
      verificationContribution,
      totalScore,
      grade,
    };
  }, []);

  /**
   * Generate complete analytics from verification results (client-side fallback)
   */
  const generateAnalytics = useCallback((
    options: UseFactCheckAnalyticsOptions,
    verificationResults: VerificationResult[]
  ): FactCheckAnalytics => {
    const startTime = performance.now();

    const sourceAnalysis = analyzeSource(options.sourceName);
    const clickbaitAnalysis = analyzeClickbait(options.title, options.content);
    const misinfoAnalysis = analyzeMisinformation(options.title, options.content);
    const claimAnalyses = analyzeClaims(verificationResults);
    const scoreBreakdown = calculateScoreBreakdown(
      sourceAnalysis,
      clickbaitAnalysis,
      misinfoAnalysis,
      claimAnalyses
    );

    const processingTimeMs = Math.round(performance.now() - startTime);

    return {
      sourceAnalysis,
      clickbaitAnalysis,
      misinfoAnalysis,
      claimAnalyses,
      scoreBreakdown,
      analysisVersion: "factcheck-ko-heuristic-v1",
      processingTimeMs,
      analyzedAt: new Date().toISOString(),
    };
  }, [analyzeSource, analyzeClickbait, analyzeMisinformation, analyzeClaims, calculateScoreBreakdown]);

  /**
   * Process backend response and extract analytics
   * Use backend analytics if available, otherwise fall back to client-side generation
   */
  const processBackendResponse = useCallback((
    response: FactcheckAddonResponse | null,
    options: UseFactCheckAnalyticsOptions,
    verificationResults: VerificationResult[]
  ): FactCheckAnalytics => {
    // If backend provides detailed analytics, use them
    if (response?.results?.factcheck?.detailed_analytics) {
      return convertBackendAnalytics(response.results.factcheck.detailed_analytics);
    }

    // Fall back to client-side generation
    return generateAnalytics(options, verificationResults);
  }, [generateAnalytics]);

  /**
   * Analyze using backend response if available
   */
  const analyzeFromBackend = useCallback(async (
    backendResponse: FactcheckAddonResponse
  ) => {
    setIsAnalyzing(true);
    setError(null);

    try {
      if (backendResponse.results?.factcheck?.detailed_analytics) {
        const result = convertBackendAnalytics(backendResponse.results.factcheck.detailed_analytics);
        setAnalytics(result);
        return result;
      } else {
        setError("Backend response does not contain detailed analytics");
        return null;
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : "분석 처리 중 오류가 발생했습니다";
      setError(message);
      return null;
    } finally {
      setIsAnalyzing(false);
    }
  }, []);

  /**
   * Analyze and update state (client-side fallback)
   */
  const analyze = useCallback(async (
    options: UseFactCheckAnalyticsOptions,
    verificationResults: VerificationResult[],
    backendResponse?: FactcheckAddonResponse | null
  ) => {
    setIsAnalyzing(true);
    setError(null);

    try {
      // Simulate async processing
      await new Promise(resolve => setTimeout(resolve, 100));
      
      const result = processBackendResponse(backendResponse || null, options, verificationResults);
      setAnalytics(result);
      return result;
    } catch (err) {
      const message = err instanceof Error ? err.message : "분석 중 오류가 발생했습니다";
      setError(message);
      return null;
    } finally {
      setIsAnalyzing(false);
    }
  }, [processBackendResponse]);

  /**
   * Reset analytics state
   */
  const reset = useCallback(() => {
    setAnalytics(null);
    setError(null);
    setIsAnalyzing(false);
  }, []);

  return {
    analytics,
    isAnalyzing,
    error,
    analyze,
    analyzeFromBackend,
    reset,
    generateAnalytics,
    processBackendResponse,
    // Expose individual analyzers for granular use
    analyzeSource,
    analyzeClickbait,
    analyzeMisinformation,
    analyzeClaims,
  };
}

/**
 * Generate mock analytics for demo/testing purposes
 * WARNING: This function should only be used in development/testing environments.
 * In production, always use real backend data.
 */
export function generateMockAnalytics(overrides?: Partial<FactCheckAnalytics>): FactCheckAnalytics {
  // Log warning in production environment
  if (import.meta.env.PROD) {
    console.warn('[generateMockAnalytics] Using mock data in production environment. This should be avoided.');
  }
  
  return {
    sourceAnalysis: {
      sourceName: "연합뉴스",
      isTrusted: true,
      trustScore: 0.9,
      trustLevel: "trusted",
      reason: "연합뉴스은(는) 신뢰할 수 있는 주요 언론사로 분류됩니다.",
      matchedTrustedSource: "연합뉴스",
    },
    clickbaitAnalysis: {
      isClickbait: false,
      score: 0.1,
      detectedPatterns: [
        { pattern: "속보", matchedText: "속보", severity: "low" }
      ],
      totalPatternsChecked: 13,
    },
    misinfoAnalysis: {
      riskScore: 0.15,
      riskLevel: "low",
      detectedPatterns: [
        { type: "unverifiable", pattern: "최초", matchedText: "최초", severity: "low" }
      ],
      unverifiableClaimCount: 1,
    },
    claimAnalyses: [
      {
        claimId: "claim-1",
        claimText: "정부는 내년 예산을 10% 증액할 예정이라고 밝혔다",
        verdict: "verified",
        confidence: 0.85,
        claimIndicator: "라고 밝혔다",
        analysisMethod: "3개 지지 근거, 0개 반박 근거를 기반으로 분석",
        supportingFactors: ["3개의 신뢰할 수 있는 출처에서 지지", "높은 신뢰도 (80% 이상)"],
        contradictingFactors: [],
      },
      {
        claimId: "claim-2",
        claimText: "전문가는 경기 회복이 예상보다 빠를 것으로 전망했다",
        verdict: "partially_true",
        confidence: 0.65,
        claimIndicator: "전문가는",
        analysisMethod: "2개 지지 근거, 1개 반박 근거를 기반으로 분석",
        supportingFactors: ["2개의 신뢰할 수 있는 출처에서 지지"],
        contradictingFactors: ["1개의 출처에서 반박"],
      },
    ],
    scoreBreakdown: {
      sourceWeight: 30,
      clickbaitWeight: 20,
      misinfoWeight: 20,
      verificationWeight: 30,
      sourceContribution: 27,
      clickbaitContribution: 18,
      misinfoContribution: 17,
      verificationContribution: 22.5,
      totalScore: 85,
      grade: "A",
    },
    analysisVersion: "factcheck-ko-heuristic-v1",
    processingTimeMs: 42,
    analyzedAt: new Date().toISOString(),
    ...overrides,
  };
}

export default useFactCheckAnalytics;

```

---

## frontend/src/hooks/useFactCheckChat.ts

```ts
import { useState, useEffect, useRef, useCallback } from 'react';
import { getApiClient } from '@/lib/api';

interface ChatEvent {
  type: string;
  role: string;
  content: string;
  phase?: string;
  timestamp?: number;
  evidence?: any[];
  verificationResult?: any;
  credibility?: any;
}

interface UseFactCheckChatOptions {
  onMessage?: (event: ChatEvent) => void;
  onError?: (error: string) => void;
  onComplete?: () => void;
}

interface UseFactCheckChatReturn {
  sendMessage: (message: string, claims?: string[]) => Promise<void>;
  isConnected: boolean;
  isStreaming: boolean;
  sessionId: string | null;
  disconnect: () => void;
  reconnect: () => void;
}

/**
 * Resolve the base URL for API calls
 * In development, uses empty string (Vite proxy)
 * In production, uses environment variable or current origin
 */
const resolveBaseUrl = (): string => {
  if (import.meta.env.DEV) {
    return '';
  }
  if (import.meta.env.VITE_API_BASE_URL) {
    return import.meta.env.VITE_API_BASE_URL as string;
  }
  if (typeof window !== 'undefined') {
    return window.location.origin;
  }
  return '';
};

export const useFactCheckChat = (options: UseFactCheckChatOptions): UseFactCheckChatReturn => {
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isStreaming, setIsStreaming] = useState(false);
  const eventSourceRef = useRef<EventSource | null>(null);
  const optionsRef = useRef(options);
  const mountedRef = useRef(true);
  const sessionIdRef = useRef<string | null>(null);

  // 옵션 업데이트
  useEffect(() => {
    optionsRef.current = options;
  }, [options]);

  // 세션 생성 함수
  const createSession = useCallback(async () => {
    try {
      const client = await getApiClient();
      const response = await client.post('/api/v1/factcheck-chat/session', { message: 'init' });

      if (mountedRef.current) {
        const newSessionId = response.data.sessionId;
        setSessionId(newSessionId);
        sessionIdRef.current = newSessionId;
        setIsConnected(true);
        console.log('[FactCheckChat] Session created:', newSessionId);
      }
    } catch (error) {
      console.error('Failed to create fact-check chat session:', error);
      if (mountedRef.current) {
        optionsRef.current.onError?.('세션 생성에 실패했습니다. 잠시 후 다시 시도해주세요.');
      }
    }
  }, []);

  // 세션 재연결
  const reconnect = useCallback(() => {
    setIsConnected(false);
    setSessionId(null);
    sessionIdRef.current = null;
    createSession();
  }, [createSession]);

  // 초기 세션 생성
  useEffect(() => {
    mountedRef.current = true;
    createSession();

    // 컴포넌트 언마운트 시 세션 종료
    return () => {
      mountedRef.current = false;
      const currentSessionId = sessionIdRef.current;
      if (currentSessionId) {
        const baseUrl = resolveBaseUrl();
        fetch(`${baseUrl}/api/v1/factcheck-chat/session/${currentSessionId}`, {
          method: 'DELETE',
        }).catch(console.error);
      }
    };
  }, [createSession]);

  // SSE 연결 해제
  const disconnect = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    setIsStreaming(false);
  }, []);

  // 메시지 전송
  const sendMessage = useCallback(async (message: string, claims?: string[]) => {
    if (!sessionId) {
      optionsRef.current.onError?.('세션이 준비되지 않았습니다.');
      return;
    }

    if (isStreaming) {
      optionsRef.current.onError?.('이전 메시지를 처리 중입니다.');
      return;
    }

    setIsStreaming(true);

    try {
      // 기존 연결 종료
      disconnect();

      // SSE 연결 생성
      const baseUrl = resolveBaseUrl();
      const url = `${baseUrl}/api/v1/factcheck-chat/session/${sessionId}/message`;
      
      // POST 요청으로 메시지 전송 및 SSE 스트림 수신
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'text/event-stream',
        },
        body: JSON.stringify({
          message,
          claims: claims || [],
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      // SSE 스트림 읽기
      const reader = response.body?.getReader();
      const decoder = new TextDecoder();

      if (!reader) {
        throw new Error('Response body is null');
      }

      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        
        if (done) {
          setIsStreaming(false);
          optionsRef.current.onComplete?.();
          break;
        }

        buffer += decoder.decode(value, { stream: true });
        
        // SSE 이벤트 파싱
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        let currentEventType = '';
        
        for (const line of lines) {
          // SSE event type 라인 처리 (event: done 형식)
          if (line.startsWith('event:')) {
            currentEventType = line.startsWith('event: ') ? line.slice(7).trim() : line.slice(6).trim();
            continue;
          }
          
          // Handle both 'data: ' and 'data:' formats (with or without space)
          if (line.startsWith('data:')) {
            const data = line.startsWith('data: ') ? line.slice(6) : line.slice(5);
            
            if (data === '[DONE]') {
              setIsStreaming(false);
              optionsRef.current.onComplete?.();
              currentEventType = '';
              continue;
            }

            try {
              const event = JSON.parse(data);
              
              // SSE event type 또는 JSON data의 type 필드로 done 확인
              if (currentEventType === 'done' || event.type === 'done') {
                setIsStreaming(false);
                optionsRef.current.onComplete?.();
              } else if (currentEventType === 'error' || event.type === 'error') {
                optionsRef.current.onError?.(event.error || 'Unknown error');
                setIsStreaming(false);
              } else {
                // event type이 있으면 event 객체에 추가
                if (currentEventType && !event.type) {
                  event.type = currentEventType;
                }
                optionsRef.current.onMessage?.(event);
              }
            } catch (e) {
              console.error('Failed to parse SSE event:', e, 'data:', data);
            }
            
            // 이벤트 처리 후 타입 리셋
            currentEventType = '';
          }
        }
      }
    } catch (error) {
      console.error('Failed to send message:', error);
      optionsRef.current.onError?.('메시지 전송에 실패했습니다.');
      setIsStreaming(false);
    }
  }, [sessionId, isStreaming, disconnect]);

  return {
    sendMessage,
    isConnected,
    isStreaming,
    sessionId,
    disconnect,
    reconnect,
  };
};

```

---

## frontend/src/hooks/useFactCheckStorage.ts

```ts
import { useState, useCallback, useEffect } from "react";
import {
  saveSearchHistorySync,
  listSearchHistory,
  deleteSearchHistory,
  type SearchHistoryRecord,
} from "@/lib/api";

/**
 * 팩트체크 결과 저장 데이터 구조
 */
export interface SavedFactCheckResult {
  id: string;
  topic: string;
  claims: string[];
  priorityUrls: string[];
  savedAt: string;
  
  // 검증 결과
  verificationResults: Array<{
    claimId: string;
    originalClaim: string;
    status: string;
    confidenceScore: number;
    verificationSummary: string;
    supportingCount: number;
    contradictingCount: number;
  }>;
  
  // 수집된 근거 요약
  evidenceSummary: {
    total: number;
    bySource: Record<string, number>;
  };
  
  // 신뢰도 평가
  credibility?: {
    overallScore: number;
    verifiedCount: number;
    totalClaims: number;
    riskLevel: "low" | "medium" | "high";
    warnings: string[];
  };
  
  // AI 결론
  aiConclusion?: string;
}

/**
 * SearchHistoryRecord를 SavedFactCheckResult로 변환
 */
const recordToFactCheck = (record: SearchHistoryRecord): SavedFactCheckResult => {
  const factCheckResults = record.factCheckResults as Array<{
    claimId: string;
    originalClaim: string;
    status: string;
    confidenceScore: number;
    verificationSummary: string;
    supportingCount: number;
    contradictingCount: number;
  }> | undefined;
  
  const metadata = record.metadata as {
    claims?: string[];
    priorityUrls?: string[];
    evidenceSummary?: { total: number; bySource: Record<string, number> };
    credibility?: {
      overallScore: number;
      verifiedCount: number;
      totalClaims: number;
      riskLevel: "low" | "medium" | "high";
      warnings: string[];
    };
    aiConclusion?: string;
  } | undefined;

  return {
    id: record.externalId || String(record.id),
    topic: record.query,
    claims: metadata?.claims || [],
    priorityUrls: metadata?.priorityUrls || record.discoveredUrls || [],
    savedAt: record.createdAt,
    verificationResults: factCheckResults || [],
    evidenceSummary: metadata?.evidenceSummary || { total: 0, bySource: {} },
    credibility: metadata?.credibility,
    aiConclusion: metadata?.aiConclusion,
  };
};

/**
 * 팩트체크 결과 저장 및 관리를 위한 훅
 * 백엔드 API를 통해 데이터를 저장하고 조회합니다.
 */
export function useFactCheckStorage() {
  const [savedResults, setSavedResults] = useState<SavedFactCheckResult[]>([]);
  const [isLoaded, setIsLoaded] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 백엔드에서 저장된 결과 로드
  const loadResults = useCallback(async () => {
    try {
      setError(null);
      const response = await listSearchHistory(0, 50, 'createdAt', 'DESC', 'FACT_CHECK');
      const results = response.content.map(recordToFactCheck);
      setSavedResults(results);
    } catch (err) {
      console.error("Failed to load saved fact-check results:", err);
      setError(err instanceof Error ? err.message : "결과를 불러오는데 실패했습니다.");
    } finally {
      setIsLoaded(true);
    }
  }, []);

  // 초기 로드
  useEffect(() => {
    loadResults();
  }, [loadResults]);

  // 결과 저장
  const saveResult = useCallback(async (result: Omit<SavedFactCheckResult, "id" | "savedAt">) => {
    const externalId = `fc_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    
    try {
      setError(null);
      const savedRecord = await saveSearchHistorySync({
        externalId,
        searchType: 'FACT_CHECK',
        query: result.topic,
        resultCount: result.verificationResults.length,
        discoveredUrls: result.priorityUrls,
        factCheckResults: result.verificationResults as unknown as Array<Record<string, unknown>>,
        credibilityScore: result.credibility?.overallScore,
        metadata: {
          claims: result.claims,
          priorityUrls: result.priorityUrls,
          evidenceSummary: result.evidenceSummary,
          credibility: result.credibility,
          aiConclusion: result.aiConclusion,
        },
        success: true,
      });
      
      // 로컬 상태 업데이트
      const newResult = recordToFactCheck(savedRecord);
      setSavedResults((prev) => [newResult, ...prev].slice(0, 50));
      
      return newResult.id;
    } catch (err) {
      console.error("Failed to save fact-check result:", err);
      setError(err instanceof Error ? err.message : "저장에 실패했습니다.");
      throw err;
    }
  }, []);

  // 결과 삭제
  const deleteResult = useCallback(async (id: string) => {
    try {
      setError(null);
      // ID에서 숫자 ID 추출 (externalId가 아닌 실제 DB ID가 필요)
      const resultToDelete = savedResults.find((r) => r.id === id);
      if (resultToDelete) {
        // externalId로 삭제 시도
        await deleteSearchHistory(parseInt(id) || 0);
      }
      setSavedResults((prev) => prev.filter((r) => r.id !== id));
    } catch (err) {
      console.error("Failed to delete fact-check result:", err);
      // 로컬에서는 삭제 (백엔드 실패해도 UI 반영)
      setSavedResults((prev) => prev.filter((r) => r.id !== id));
    }
  }, [savedResults]);

  // 모든 결과 삭제 (주의: 실제로는 개별 삭제 필요)
  const clearAllResults = useCallback(async () => {
    try {
      setError(null);
      // 모든 결과를 개별적으로 삭제
      for (const result of savedResults) {
        try {
          await deleteSearchHistory(parseInt(result.id) || 0);
        } catch {
          // 개별 삭제 실패는 무시
        }
      }
      setSavedResults([]);
    } catch (err) {
      console.error("Failed to clear all results:", err);
      setError(err instanceof Error ? err.message : "삭제에 실패했습니다.");
    }
  }, [savedResults]);

  // 특정 결과 조회
  const getResult = useCallback(
    (id: string) => savedResults.find((r) => r.id === id),
    [savedResults]
  );

  // 결과 새로고침
  const refresh = useCallback(() => {
    setIsLoaded(false);
    return loadResults();
  }, [loadResults]);

  // JSON으로 내보내기 (로컬 기능 유지)
  const exportToJson = useCallback((id?: string) => {
    const dataToExport = id 
      ? savedResults.filter((r) => r.id === id)
      : savedResults;
    
    if (dataToExport.length === 0) return null;

    const blob = new Blob(
      [JSON.stringify(dataToExport, null, 2)],
      { type: "application/json" }
    );
    const url = URL.createObjectURL(blob);
    const filename = id 
      ? `factcheck_${id}.json`
      : `factcheck_all_${new Date().toISOString().split("T")[0]}.json`;

    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    return filename;
  }, [savedResults]);

  // Markdown으로 내보내기
  const exportToMarkdown = useCallback((id: string) => {
    const result = savedResults.find((r) => r.id === id);
    if (!result) return null;

    const lines: string[] = [
      `# 팩트체크 보고서`,
      ``,
      `**주제:** ${result.topic}`,
      `**분석 일시:** ${new Date(result.savedAt).toLocaleString("ko-KR")}`,
      ``,
      `---`,
      ``,
      `## 검증한 주장`,
      ``,
    ];

    result.claims.forEach((claim, i) => {
      lines.push(`${i + 1}. ${claim}`);
    });

    lines.push(``, `---`, ``, `## 검증 결과`);

    result.verificationResults.forEach((v, i) => {
      const statusEmoji = {
        VERIFIED: "✅",
        PARTIALLY_VERIFIED: "⚠️",
        UNVERIFIED: "❓",
        DISPUTED: "⚖️",
        FALSE: "❌",
      }[v.status] || "•";

      lines.push(
        ``,
        `### ${i + 1}. ${v.originalClaim}`,
        ``,
        `- **판정:** ${statusEmoji} ${v.status}`,
        `- **신뢰도:** ${Math.round(v.confidenceScore * 100)}%`,
        `- **지지 근거:** ${v.supportingCount}개`,
        `- **반박 근거:** ${v.contradictingCount}개`,
        ``,
        `> ${v.verificationSummary}`
      );
    });

    if (result.credibility) {
      lines.push(
        ``,
        `---`,
        ``,
        `## 전체 신뢰도 평가`,
        ``,
        `- **종합 점수:** ${Math.round(result.credibility.overallScore * 100)}%`,
        `- **검증된 주장:** ${result.credibility.verifiedCount}/${result.credibility.totalClaims}`,
        `- **위험 수준:** ${result.credibility.riskLevel}`
      );

      if (result.credibility.warnings.length > 0) {
        lines.push(``, `**주의사항:**`);
        result.credibility.warnings.forEach((w) => {
          lines.push(`- ${w}`);
        });
      }
    }

    lines.push(
      ``,
      `---`,
      ``,
      `## 수집된 근거`,
      ``,
      `**총 ${result.evidenceSummary.total}개의 근거 수집**`,
      ``
    );

    Object.entries(result.evidenceSummary.bySource).forEach(([source, count]) => {
      lines.push(`- ${source}: ${count}개`);
    });

    if (result.aiConclusion) {
      lines.push(
        ``,
        `---`,
        ``,
        `## AI 종합 분석`,
        ``,
        result.aiConclusion
      );
    }

    if (result.priorityUrls.length > 0) {
      lines.push(
        ``,
        `---`,
        ``,
        `## 참고 URL`,
        ``
      );
      result.priorityUrls.forEach((url) => {
        lines.push(`- ${url}`);
      });
    }

    lines.push(
      ``,
      `---`,
      ``,
      `*이 보고서는 NewsInsight 팩트체크 시스템에서 생성되었습니다.*`
    );

    const markdown = lines.join("\n");
    const blob = new Blob([markdown], { type: "text/markdown" });
    const url = URL.createObjectURL(blob);
    const filename = `factcheck_${result.topic.replace(/[^a-zA-Z0-9가-힣]/g, "_")}_${new Date(result.savedAt).toISOString().split("T")[0]}.md`;

    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    return filename;
  }, [savedResults]);

  // 텍스트로 내보내기
  const exportToText = useCallback((id: string) => {
    const result = savedResults.find((r) => r.id === id);
    if (!result) return null;

    const lines: string[] = [
      `팩트체크 보고서`,
      `${"=".repeat(40)}`,
      ``,
      `주제: ${result.topic}`,
      `분석 일시: ${new Date(result.savedAt).toLocaleString("ko-KR")}`,
      ``,
      `${"─".repeat(40)}`,
      ``,
      `[ 검증한 주장 ]`,
      ``,
    ];

    result.claims.forEach((claim, i) => {
      lines.push(`${i + 1}. ${claim}`);
    });

    lines.push(``, `${"─".repeat(40)}`, ``, `[ 검증 결과 ]`);

    result.verificationResults.forEach((v, i) => {
      const statusLabel = {
        VERIFIED: "[검증됨]",
        PARTIALLY_VERIFIED: "[부분 검증]",
        UNVERIFIED: "[검증 불가]",
        DISPUTED: "[논쟁 중]",
        FALSE: "[거짓]",
      }[v.status] || v.status;

      lines.push(
        ``,
        `${i + 1}. ${v.originalClaim}`,
        `   판정: ${statusLabel}`,
        `   신뢰도: ${Math.round(v.confidenceScore * 100)}%`,
        `   지지 근거: ${v.supportingCount}개 / 반박 근거: ${v.contradictingCount}개`,
        ``,
        `   요약: ${v.verificationSummary}`
      );
    });

    if (result.credibility) {
      const riskLabel = {
        low: "낮음",
        medium: "주의",
        high: "높음",
      }[result.credibility.riskLevel] || result.credibility.riskLevel;

      lines.push(
        ``,
        `${"─".repeat(40)}`,
        ``,
        `[ 전체 신뢰도 평가 ]`,
        ``,
        `종합 점수: ${Math.round(result.credibility.overallScore * 100)}%`,
        `검증된 주장: ${result.credibility.verifiedCount}/${result.credibility.totalClaims}`,
        `위험 수준: ${riskLabel}`
      );

      if (result.credibility.warnings.length > 0) {
        lines.push(``, `주의사항:`);
        result.credibility.warnings.forEach((w) => {
          lines.push(`  - ${w}`);
        });
      }
    }

    lines.push(
      ``,
      `${"─".repeat(40)}`,
      ``,
      `[ 수집된 근거 ]`,
      ``,
      `총 ${result.evidenceSummary.total}개의 근거 수집`,
      ``
    );

    Object.entries(result.evidenceSummary.bySource).forEach(([source, count]) => {
      lines.push(`  ${source}: ${count}개`);
    });

    if (result.aiConclusion) {
      lines.push(
        ``,
        `${"─".repeat(40)}`,
        ``,
        `[ AI 종합 분석 ]`,
        ``,
        result.aiConclusion
      );
    }

    if (result.priorityUrls.length > 0) {
      lines.push(
        ``,
        `${"─".repeat(40)}`,
        ``,
        `[ 참고 URL ]`,
        ``
      );
      result.priorityUrls.forEach((url) => {
        lines.push(`  ${url}`);
      });
    }

    lines.push(
      ``,
      `${"─".repeat(40)}`,
      ``,
      `이 보고서는 NewsInsight 팩트체크 시스템에서 생성되었습니다.`
    );

    const text = lines.join("\n");
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const filename = `factcheck_${result.topic.replace(/[^a-zA-Z0-9가-힣]/g, "_")}_${new Date(result.savedAt).toISOString().split("T")[0]}.txt`;

    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    return filename;
  }, [savedResults]);

  return {
    savedResults,
    isLoaded,
    error,
    saveResult,
    deleteResult,
    clearAllResults,
    getResult,
    refresh,
    exportToJson,
    exportToMarkdown,
    exportToText,
  };
}

```

---

## frontend/src/hooks/useKeyboardShortcuts.ts

```ts
import { useEffect, useCallback, useRef } from "react";

/**
 * 키보드 단축키 정의
 */
export interface KeyboardShortcut {
  /** 키 조합 (예: "ctrl+k", "escape", "ctrl+shift+s") */
  key: string;
  /** 실행할 콜백 */
  handler: (event: KeyboardEvent) => void;
  /** 설명 (도움말 표시용) */
  description?: string;
  /** input/textarea에서도 활성화할지 여부 */
  enableInInput?: boolean;
  /** 특정 조건에서만 활성화 */
  enabled?: boolean;
}

interface UseKeyboardShortcutsOptions {
  /** 전역 이벤트 리스너 사용 여부 */
  global?: boolean;
  /** 활성화 여부 */
  enabled?: boolean;
}

/**
 * 키 조합 파싱
 */
const parseKeyCombo = (combo: string): { key: string; ctrl: boolean; shift: boolean; alt: boolean; meta: boolean } => {
  const parts = combo.toLowerCase().split("+");
  return {
    key: parts.filter(p => !["ctrl", "shift", "alt", "meta", "cmd"].includes(p))[0] || "",
    ctrl: parts.includes("ctrl"),
    shift: parts.includes("shift"),
    alt: parts.includes("alt"),
    meta: parts.includes("meta") || parts.includes("cmd"),
  };
};

/**
 * 이벤트와 키 조합 매칭
 */
const matchesKeyCombo = (event: KeyboardEvent, combo: string): boolean => {
  const parsed = parseKeyCombo(combo);
  const key = event.key.toLowerCase();
  
  // 특수 키 매핑
  const keyMap: Record<string, string> = {
    escape: "escape",
    esc: "escape",
    enter: "enter",
    return: "enter",
    space: " ",
    arrowup: "arrowup",
    arrowdown: "arrowdown",
    arrowleft: "arrowleft",
    arrowright: "arrowright",
  };
  
  const normalizedKey = keyMap[parsed.key] || parsed.key;
  const normalizedEventKey = keyMap[key] || key;
  
  return (
    normalizedEventKey === normalizedKey &&
    event.ctrlKey === parsed.ctrl &&
    event.shiftKey === parsed.shift &&
    event.altKey === parsed.alt &&
    event.metaKey === parsed.meta
  );
};

/**
 * 키보드 단축키 훅
 * 
 * @example
 * ``\`tsx
 * useKeyboardShortcuts([
 *   { key: "ctrl+k", handler: () => setSearchOpen(true), description: "검색 열기" },
 *   { key: "escape", handler: () => setSearchOpen(false), description: "닫기" },
 * ]);
 * ``\`
 */
export function useKeyboardShortcuts(
  shortcuts: KeyboardShortcut[],
  options: UseKeyboardShortcutsOptions = {}
) {
  const { global = true, enabled = true } = options;
  const shortcutsRef = useRef(shortcuts);
  
  // 최신 shortcuts 참조 유지
  useEffect(() => {
    shortcutsRef.current = shortcuts;
  }, [shortcuts]);

  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    if (!enabled) return;

    // input/textarea에서 입력 중인지 확인
    const target = event.target as HTMLElement;
    const isInputFocused = 
      target.tagName === "INPUT" ||
      target.tagName === "TEXTAREA" ||
      target.isContentEditable;

    for (const shortcut of shortcutsRef.current) {
      // 단축키별 활성화 조건 확인
      if (shortcut.enabled === false) continue;
      
      // input에서 비활성화된 단축키 스킵
      if (isInputFocused && !shortcut.enableInInput) continue;

      if (matchesKeyCombo(event, shortcut.key)) {
        event.preventDefault();
        event.stopPropagation();
        shortcut.handler(event);
        return;
      }
    }
  }, [enabled]);

  useEffect(() => {
    if (!enabled) return;

    const target = global ? window : document;
    target.addEventListener("keydown", handleKeyDown as EventListener);
    
    return () => {
      target.removeEventListener("keydown", handleKeyDown as EventListener);
    };
  }, [global, enabled, handleKeyDown]);
}

/**
 * 전역 단축키 컨텍스트 (앱 전체에서 사용)
 */
export interface GlobalShortcuts {
  openSearch: () => void;
  closeAll: () => void;
  goToHome: () => void;
  goToDeepSearch: () => void;
  goToFactCheck: () => void;
  goToAgent: () => void;
  toggleTheme: () => void;
}

/**
 * 단축키 도움말 데이터
 */
export const SHORTCUT_HELP: Array<{ key: string; description: string; category: string }> = [
  // 네비게이션
  { key: "Ctrl+K", description: "검색 열기", category: "네비게이션" },
  { key: "Escape", description: "닫기 / 취소", category: "네비게이션" },
  { key: "Ctrl+H", description: "홈으로 이동", category: "네비게이션" },
  { key: "Ctrl+D", description: "Deep Search", category: "네비게이션" },
  { key: "Ctrl+F", description: "FactCheck", category: "네비게이션" },
  { key: "Ctrl+B", description: "Browser Agent", category: "네비게이션" },
  
  // 테마
  { key: "Ctrl+Shift+T", description: "테마 전환", category: "설정" },
  
  // 검색
  { key: "Enter", description: "검색 실행", category: "검색" },
  { key: "↑/↓", description: "제안 항목 이동", category: "검색" },
];

export default useKeyboardShortcuts;

```

---

## frontend/src/hooks/useMlAddons.ts

```ts
/**
 * ML Add-on 관련 React 훅
 * Backend: /api/v1/ml
 */

import { useState, useEffect, useCallback, useMemo } from 'react';
import type {
  MlAddon,
  MlAddonExecution,
  MlAddonResponse,
  AddonCategory,
  ExecutionStatus,
  PageResponse,
} from '@/types/api';
import {
  listMlAddons,
  getMlAddon,
  toggleMlAddon,
  getMlAddonStatus,
  listMlExecutions,
  getArticleExecutions,
  analyzeArticle,
  analyzeByCategory,
  runMlHealthCheck,
  type MlAddonStatusSummary,
} from '@/lib/api/ml';

// ============================================
// ML Add-ons List Hook
// ============================================

export interface UseMlAddonsOptions {
  /** 자동 새로고침 활성화 */
  autoRefresh?: boolean;
  /** 새로고침 간격 (ms) */
  refreshInterval?: number;
  /** 활성화된 것만 필터링 */
  enabledOnly?: boolean;
}

export interface UseMlAddonsReturn {
  /** Add-on 목록 */
  addons: MlAddon[];
  /** 로딩 상태 */
  loading: boolean;
  /** 에러 */
  error: Error | null;
  /** 새로고침 */
  refresh: () => Promise<void>;
  /** Add-on 토글 */
  toggle: (addonKey: string) => Promise<void>;
  /** 카테고리별 그룹 */
  groupedByCategory: Record<AddonCategory, MlAddon[]>;
}

export function useMlAddons(options: UseMlAddonsOptions = {}): UseMlAddonsReturn {
  const { autoRefresh = false, refreshInterval = 30000, enabledOnly = false } = options;

  const [addons, setAddons] = useState<MlAddon[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await listMlAddons();
      setAddons(enabledOnly ? data.filter((a) => a.enabled) : data);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load addons'));
    } finally {
      setLoading(false);
    }
  }, [enabledOnly]);

  const toggle = useCallback(async (addonKey: string) => {
    try {
      await toggleMlAddon(addonKey);
      // 상태 업데이트
      setAddons((prev) =>
        prev.map((addon) =>
          addon.addonKey === addonKey ? { ...addon, enabled: !addon.enabled } : addon
        )
      );
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to toggle addon'));
      throw e;
    }
  }, []);

  useEffect(() => {
    refresh();
  }, [refresh]);

  useEffect(() => {
    if (!autoRefresh) return;
    const interval = setInterval(refresh, refreshInterval);
    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval, refresh]);

  const groupedByCategory = useMemo(() => {
    return addons.reduce(
      (groups, addon) => {
        const category = addon.category;
        if (!groups[category]) {
          groups[category] = [];
        }
        groups[category].push(addon);
        return groups;
      },
      {} as Record<AddonCategory, MlAddon[]>
    );
  }, [addons]);

  return {
    addons,
    loading,
    error,
    refresh,
    toggle,
    groupedByCategory,
  };
}

// ============================================
// Single ML Add-on Hook
// ============================================

export interface UseMlAddonReturn {
  addon: MlAddon | null;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
}

export function useMlAddon(addonKey: string | null): UseMlAddonReturn {
  const [addon, setAddon] = useState<MlAddon | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    if (!addonKey) return;
    try {
      setLoading(true);
      setError(null);
      const data = await getMlAddon(addonKey);
      setAddon(data);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load addon'));
    } finally {
      setLoading(false);
    }
  }, [addonKey]);

  useEffect(() => {
    refresh();
  }, [refresh]);

  return { addon, loading, error, refresh };
}

// ============================================
// ML Add-on Status Hook
// ============================================

export interface UseMlAddonStatusReturn {
  status: MlAddonStatusSummary | null;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
  runHealthCheck: () => Promise<void>;
}

export function useMlAddonStatus(): UseMlAddonStatusReturn {
  const [status, setStatus] = useState<MlAddonStatusSummary | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getMlAddonStatus();
      setStatus(data);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load status'));
    } finally {
      setLoading(false);
    }
  }, []);

  const runHealthCheckAction = useCallback(async () => {
    try {
      await runMlHealthCheck();
      await refresh();
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Health check failed'));
    }
  }, [refresh]);

  useEffect(() => {
    refresh();
  }, [refresh]);

  return {
    status,
    loading,
    error,
    refresh,
    runHealthCheck: runHealthCheckAction,
  };
}

// ============================================
// ML Executions Hook
// ============================================

export interface UseMlExecutionsOptions {
  page?: number;
  size?: number;
  status?: ExecutionStatus;
  addonKey?: string;
  autoRefresh?: boolean;
  refreshInterval?: number;
}

export interface UseMlExecutionsReturn {
  executions: MlAddonExecution[];
  total: number;
  totalPages: number;
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
  setPage: (page: number) => void;
  currentPage: number;
}

export function useMlExecutions(options: UseMlExecutionsOptions = {}): UseMlExecutionsReturn {
  const {
    page: initialPage = 0,
    size = 20,
    status,
    addonKey,
    autoRefresh = false,
    refreshInterval = 10000,
  } = options;

  const [executions, setExecutions] = useState<MlAddonExecution[]>([]);
  const [total, setTotal] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [currentPage, setCurrentPage] = useState(initialPage);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await listMlExecutions(currentPage, size, status, addonKey);
      setExecutions(data.content);
      setTotal(data.totalElements);
      setTotalPages(data.totalPages);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load executions'));
    } finally {
      setLoading(false);
    }
  }, [currentPage, size, status, addonKey]);

  useEffect(() => {
    refresh();
  }, [refresh]);

  useEffect(() => {
    if (!autoRefresh) return;
    const interval = setInterval(refresh, refreshInterval);
    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval, refresh]);

  return {
    executions,
    total,
    totalPages,
    loading,
    error,
    refresh,
    setPage: setCurrentPage,
    currentPage,
  };
}

// ============================================
// Article Analysis Hook
// ============================================

export interface UseArticleAnalysisReturn {
  executions: MlAddonExecution[];
  loading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
  analyze: (importance?: 'realtime' | 'batch') => Promise<void>;
  analyzeCategory: (category: AddonCategory) => Promise<MlAddonResponse>;
  isAnalyzing: boolean;
}

export function useArticleAnalysis(articleId: number | null): UseArticleAnalysisReturn {
  const [executions, setExecutions] = useState<MlAddonExecution[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  const refresh = useCallback(async () => {
    if (!articleId) return;
    try {
      setLoading(true);
      setError(null);
      const data = await getArticleExecutions(articleId);
      setExecutions(data);
    } catch (e) {
      setError(e instanceof Error ? e : new Error('Failed to load executions'));
    } finally {
      setLoading(false);
    }
  }, [articleId]);

  const analyze = useCallback(
    async (importance: 'realtime' | 'batch' = 'batch') => {
      if (!articleId) return;
      try {
        setIsAnalyzing(true);
        setError(null);
        await analyzeArticle(articleId, importance);
        // 분석 시작 후 잠시 대기하고 새로고침
        setTimeout(refresh, 1000);
      } catch (e) {
        setError(e instanceof Error ? e : new Error('Failed to start analysis'));
        throw e;
      } finally {
        setIsAnalyzing(false);
      }
    },
    [articleId, refresh]
  );

  const analyzeCategoryAction = useCallback(
    async (category: AddonCategory): Promise<MlAddonResponse> => {
      if (!articleId) throw new Error('No article ID');
      try {
        setIsAnalyzing(true);
        setError(null);
        const result = await analyzeByCategory(articleId, category);
        refresh();
        return result;
      } catch (e) {
        setError(e instanceof Error ? e : new Error('Failed to analyze'));
        throw e;
      } finally {
        setIsAnalyzing(false);
      }
    },
    [articleId, refresh]
  );

  useEffect(() => {
    refresh();
  }, [refresh]);

  return {
    executions,
    loading,
    error,
    refresh,
    analyze,
    analyzeCategory: analyzeCategoryAction,
    isAnalyzing,
  };
}

export default useMlAddons;

```

---

## frontend/src/hooks/useMlAnalysis.ts

```ts
/**
 * useMlAnalysis - ML 분석 작업 관리 Hook
 * 
 * 기능:
 * - 분석 요청 및 상태 추적
 * - 백그라운드 작업 관리
 * - 알림 시스템 연동
 * - 분석 완료 시 결과 처리
 */

import { useCallback, useRef, useEffect } from 'react';
import { useBackgroundTasks } from '@/contexts/BackgroundTaskContext';
import { useNotifications } from '@/contexts/NotificationContext';
import { useToast } from '@/hooks/use-toast';
import {
  analyzeArticle,
  analyzeArticlesBatch,
  analyzeByCategory,
  listMlExecutions,
  getCategoryLabel,
} from '@/lib/api/ml';
import type { AddonCategory, ExecutionStatus } from '@/types/api';

interface AnalysisTask {
  taskId: string;
  batchId: string;
  executionIds: string[];
  articleId?: number;
  articleIds?: number[];
  category?: AddonCategory;
  startTime: number;
}

interface UseMlAnalysisReturn {
  startAnalysis: (articleId: number, importance?: 'realtime' | 'batch') => Promise<string | null>;
  startBatchAnalysis: (articleIds: number[], importance?: 'realtime' | 'batch') => Promise<string | null>;
  startCategoryAnalysis: (articleId: number, category: AddonCategory) => Promise<string | null>;
  isAnalyzing: (articleId: number) => boolean;
  getAnalysisStatus: (taskId: string) => 'pending' | 'running' | 'completed' | 'failed' | null;
}

const POLL_INTERVAL = 3000; // 3초
const MAX_POLL_DURATION = 5 * 60 * 1000; // 5분

export function useMlAnalysis(): UseMlAnalysisReturn {
  const { addTask, updateTask, getTask } = useBackgroundTasks();
  const { addNotification } = useNotifications();
  const { toast } = useToast();
  
  // 활성 분석 작업 추적
  const activeTasksRef = useRef<Map<string, AnalysisTask>>(new Map());
  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // 폴링으로 분석 상태 확인
  const pollAnalysisStatus = useCallback(async () => {
    const activeTasks = activeTasksRef.current;
    
    if (activeTasks.size === 0) {
      if (pollIntervalRef.current) {
        clearInterval(pollIntervalRef.current);
        pollIntervalRef.current = null;
      }
      return;
    }

    try {
      // 최근 실행 목록 조회
      const executions = await listMlExecutions(0, 100);
      
      for (const [taskId, task] of activeTasks.entries()) {
        const now = Date.now();
        
        // 최대 폴링 시간 초과
        if (now - task.startTime > MAX_POLL_DURATION) {
          updateTask(taskId, {
            status: 'failed',
            error: '분석 시간 초과',
            completedAt: new Date().toISOString(),
          });
          
          addNotification({
            type: 'error',
            title: 'ML 분석 시간 초과',
            message: '분석 작업이 너무 오래 걸려 중단되었습니다.',
            persistent: true,
          });
          
          activeTasks.delete(taskId);
          continue;
        }

        // 해당 배치의 실행 상태 확인
        const relevantExecutions = executions.content.filter(
          e => e.batchId === task.batchId || task.executionIds.includes(e.requestId)
        );

        if (relevantExecutions.length === 0) continue;

        const allCompleted = relevantExecutions.every(
          e => e.status === 'SUCCESS' || e.status === 'FAILED' || e.status === 'CANCELLED' || e.status === 'SKIPPED'
        );
        
        const anyRunning = relevantExecutions.some(e => e.status === 'RUNNING');
        const successCount = relevantExecutions.filter(e => e.status === 'SUCCESS').length;
        const failedCount = relevantExecutions.filter(e => e.status === 'FAILED').length;
        const totalCount = relevantExecutions.length;

        // 진행률 업데이트
        if (anyRunning || (successCount + failedCount) > 0) {
          const progress = Math.round(((successCount + failedCount) / totalCount) * 100);
          updateTask(taskId, {
            status: 'running',
            progress,
            progressMessage: `${successCount + failedCount}/${totalCount} 완료`,
          });
        }

        // 모두 완료되면 결과 처리
        if (allCompleted) {
          const allSuccess = failedCount === 0;
          
          updateTask(taskId, {
            status: allSuccess ? 'completed' : 'failed',
            progress: 100,
            completedAt: new Date().toISOString(),
            progressMessage: allSuccess 
              ? `${successCount}개 분석 완료` 
              : `${successCount}개 성공, ${failedCount}개 실패`,
            error: failedCount > 0 ? `${failedCount}개 분석 실패` : undefined,
          });

          // 알림 추가 - 기사 ID가 있으면 해당 기사 결과 페이지로, 없으면 전체 결과 페이지로
          const articleId = task.articleId;
          addNotification({
            type: allSuccess ? 'success' : 'warning',
            title: allSuccess ? 'ML 분석 완료' : 'ML 분석 일부 실패',
            message: allSuccess 
              ? `${successCount}개의 분석이 성공적으로 완료되었습니다.`
              : `${successCount}개 성공, ${failedCount}개 실패`,
            actionUrl: articleId ? `/ml-results?articleId=${articleId}` : '/ml-results',
            actionLabel: '결과 보기',
            persistent: true,
          });

          activeTasks.delete(taskId);
        }
      }
    } catch (error) {
      console.error('Failed to poll analysis status:', error);
    }
  }, [updateTask, addNotification]);

  // 폴링 시작/관리
  const startPolling = useCallback(() => {
    if (pollIntervalRef.current) return;
    
    pollIntervalRef.current = setInterval(pollAnalysisStatus, POLL_INTERVAL);
  }, [pollAnalysisStatus]);

  // 컴포넌트 언마운트 시 폴링 정리
  useEffect(() => {
    return () => {
      if (pollIntervalRef.current) {
        clearInterval(pollIntervalRef.current);
      }
    };
  }, []);

  // 단일 기사 분석
  const startAnalysis = useCallback(async (
    articleId: number,
    importance: 'realtime' | 'batch' = 'batch'
  ): Promise<string | null> => {
    const taskId = `ml-${articleId}-${Date.now()}`;
    
    try {
      // 백그라운드 작업 등록
      addTask({
        id: taskId,
        type: 'ml-analysis',
        title: `기사 #${articleId} ML 분석`,
        status: 'pending',
        progress: 0,
        progressMessage: '분석 준비 중...',
        articleId,
      });

      // Toast로 즉각 피드백
      toast({
        title: '🔬 ML 분석 시작',
        description: `기사 #${articleId}의 분석이 백그라운드에서 진행됩니다.`,
      });

      // 분석 요청
      const result = await analyzeArticle(articleId, importance);
      
      // executionIds가 없을 경우 안전 처리
      const executionIds = result.executionIds ?? [];
      const executionCount = executionIds.length || 1; // 최소 1개로 표시
      
      // 작업 상태 업데이트
      updateTask(taskId, {
        status: 'running',
        progress: 10,
        progressMessage: executionIds.length > 0 
          ? `${executionCount}개 애드온 분석 중...`
          : '분석 진행 중...',
        batchId: result.batchId,
      });

      // 알림 추가 (백그라운드 작업 알림)
      addNotification({
        type: 'info',
        title: 'ML 분석 진행 중',
        message: executionIds.length > 0
          ? `기사 #${articleId}의 ${executionCount}개 분석이 진행 중입니다.`
          : `기사 #${articleId}의 분석이 진행 중입니다.`,
        actionUrl: `/ml-results?articleId=${articleId}`,
        actionLabel: '결과 확인',
      });

      // 활성 작업에 추가
      activeTasksRef.current.set(taskId, {
        taskId,
        batchId: result.batchId,
        executionIds,
        articleId,
        startTime: Date.now(),
      });

      // 폴링 시작
      startPolling();

      return taskId;
    } catch (error) {
      console.error('Failed to start analysis:', error);
      
      updateTask(taskId, {
        status: 'failed',
        error: error instanceof Error ? error.message : '분석 시작 실패',
        completedAt: new Date().toISOString(),
      });

      toast({
        title: '분석 실패',
        description: error instanceof Error ? error.message : 'ML 분석을 시작할 수 없습니다.',
        variant: 'destructive',
      });

      addNotification({
        type: 'error',
        title: 'ML 분석 실패',
        message: error instanceof Error ? error.message : '분석을 시작할 수 없습니다.',
        persistent: true,
      });

      return null;
    }
  }, [addTask, updateTask, toast, addNotification, startPolling]);

  // 일괄 분석
  const startBatchAnalysis = useCallback(async (
    articleIds: number[],
    importance: 'realtime' | 'batch' = 'batch'
  ): Promise<string | null> => {
    if (articleIds.length === 0) {
      toast({
        title: '분석할 기사가 없습니다',
        variant: 'destructive',
      });
      return null;
    }

    const taskId = `ml-batch-${Date.now()}`;
    const limitedIds = articleIds.slice(0, 50); // 최대 50개
    
    try {
      addTask({
        id: taskId,
        type: 'ml-analysis',
        title: `${limitedIds.length}개 기사 일괄 분석`,
        status: 'pending',
        progress: 0,
        progressMessage: '일괄 분석 준비 중...',
      });

      toast({
        title: '🔬 일괄 분석 시작',
        description: `${limitedIds.length}개 기사의 분석이 백그라운드에서 진행됩니다.`,
      });

      const result = await analyzeArticlesBatch(limitedIds, importance);
      
      // executionIds가 없을 경우 안전 처리
      const executionIds = result.executionIds ?? [];
      
      updateTask(taskId, {
        status: 'running',
        progress: 5,
        progressMessage: `${result.articleCount}개 기사 분석 중...`,
        batchId: result.batchId,
      });

      addNotification({
        type: 'info',
        title: '일괄 분석 진행 중',
        message: `${result.articleCount}개 기사의 ML 분석이 진행 중입니다.`,
        actionUrl: '/ml-results',
        actionLabel: '결과 확인',
      });

      activeTasksRef.current.set(taskId, {
        taskId,
        batchId: result.batchId,
        executionIds,
        articleIds: limitedIds,
        startTime: Date.now(),
      });

      startPolling();

      return taskId;
    } catch (error) {
      console.error('Failed to start batch analysis:', error);
      
      updateTask(taskId, {
        status: 'failed',
        error: error instanceof Error ? error.message : '일괄 분석 시작 실패',
        completedAt: new Date().toISOString(),
      });

      toast({
        title: '일괄 분석 실패',
        description: error instanceof Error ? error.message : '일괄 분석을 시작할 수 없습니다.',
        variant: 'destructive',
      });

      addNotification({
        type: 'error',
        title: '일괄 분석 실패',
        message: error instanceof Error ? error.message : '분석을 시작할 수 없습니다.',
        persistent: true,
      });

      return null;
    }
  }, [addTask, updateTask, toast, addNotification, startPolling]);

  // 카테고리별 분석
  const startCategoryAnalysis = useCallback(async (
    articleId: number,
    category: AddonCategory
  ): Promise<string | null> => {
    const taskId = `ml-${articleId}-${category}-${Date.now()}`;
    const categoryLabel = getCategoryLabel(category);
    
    try {
      addTask({
        id: taskId,
        type: 'ml-analysis',
        title: `기사 #${articleId} ${categoryLabel}`,
        status: 'pending',
        progress: 0,
        progressMessage: `${categoryLabel} 준비 중...`,
        articleId,
        addonCategory: category,
      });

      toast({
        title: `🔬 ${categoryLabel} 시작`,
        description: `기사 #${articleId}의 ${categoryLabel}이 백그라운드에서 진행됩니다.`,
      });

      const result = await analyzeByCategory(articleId, category);
      
      // 카테고리 분석은 동기적으로 결과가 오므로 바로 완료 처리
      const isSuccess = result.status === 'success';
      
      updateTask(taskId, {
        status: isSuccess ? 'completed' : 'failed',
        progress: 100,
        completedAt: new Date().toISOString(),
        progressMessage: isSuccess ? '분석 완료' : '분석 실패',
        result: result.results,
        error: result.error?.message,
      });

      addNotification({
        type: isSuccess ? 'success' : 'error',
        title: isSuccess ? `${categoryLabel} 완료` : `${categoryLabel} 실패`,
        message: isSuccess 
          ? `기사 #${articleId}의 ${categoryLabel}이 완료되었습니다.`
          : result.error?.message || '분석 중 오류가 발생했습니다.',
        actionUrl: `/ml-results?articleId=${articleId}`,
        actionLabel: '결과 보기',
        persistent: true,
      });

      return taskId;
    } catch (error) {
      console.error('Failed to start category analysis:', error);
      
      updateTask(taskId, {
        status: 'failed',
        error: error instanceof Error ? error.message : '분석 시작 실패',
        completedAt: new Date().toISOString(),
      });

      toast({
        title: `${categoryLabel} 실패`,
        description: error instanceof Error ? error.message : '분석을 시작할 수 없습니다.',
        variant: 'destructive',
      });

      addNotification({
        type: 'error',
        title: `${categoryLabel} 실패`,
        message: error instanceof Error ? error.message : '분석을 시작할 수 없습니다.',
        persistent: true,
      });

      return null;
    }
  }, [addTask, updateTask, toast, addNotification]);

  // 특정 기사가 분석 중인지 확인
  const isAnalyzing = useCallback((articleId: number): boolean => {
    for (const task of activeTasksRef.current.values()) {
      if (task.articleId === articleId) return true;
      if (task.articleIds?.includes(articleId)) return true;
    }
    return false;
  }, []);

  // 작업 상태 조회
  const getAnalysisStatus = useCallback((taskId: string): 'pending' | 'running' | 'completed' | 'failed' | null => {
    const task = getTask(taskId);
    if (!task) return null;
    return task.status as 'pending' | 'running' | 'completed' | 'failed';
  }, [getTask]);

  return {
    startAnalysis,
    startBatchAnalysis,
    startCategoryAnalysis,
    isAnalyzing,
    getAnalysisStatus,
  };
}

export default useMlAnalysis;

```

---

## frontend/src/hooks/useNotificationBridge.ts

```ts
import { useEffect, useCallback, useRef } from 'react';
import { useNotifications, NotificationType } from '@/contexts/NotificationContext';
import { DashboardEvent, DashboardEventType } from './useDashboardEvents';

// Storage key for access token (matches AuthContext)
const ACCESS_TOKEN_KEY = 'access_token';

/**
 * Append authentication token to URL for SSE connections.
 * EventSource doesn't support custom headers, so we use query parameter.
 */
function appendTokenToUrl(url: string): string {
  const token = localStorage.getItem(ACCESS_TOKEN_KEY);
  if (!token) return url;
  
  const separator = url.includes('?') ? '&' : '?';
  return `${url}${separator}token=${encodeURIComponent(token)}`;
}

/**
 * SSE 이벤트 타입을 NotificationType으로 매핑
 */
const eventTypeToNotificationType: Record<DashboardEventType, NotificationType | null> = {
  HEARTBEAT: null, // 알림으로 표시하지 않음
  NEW_DATA: 'info',
  SOURCE_UPDATED: 'info',
  STATS_UPDATED: null, // 통계 업데이트는 알림으로 표시하지 않음
  COLLECTION_STARTED: 'info',
  COLLECTION_COMPLETED: 'success',
  ERROR: 'error',
};

/**
 * 이벤트 타입별 기본 제목 (한글)
 */
const eventTypeToTitle: Record<DashboardEventType, string> = {
  HEARTBEAT: '',
  NEW_DATA: '새 데이터',
  SOURCE_UPDATED: '소스 업데이트',
  STATS_UPDATED: '통계 업데이트',
  COLLECTION_STARTED: '수집 시작',
  COLLECTION_COMPLETED: '수집 완료',
  ERROR: '오류 발생',
};

export interface UseNotificationBridgeOptions {
  /** 알림을 생성할 이벤트 타입 목록 (비어있으면 모든 타입) */
  enabledEventTypes?: DashboardEventType[];
  /** 알림을 지속적으로 저장할지 여부 */
  persistent?: boolean;
  /** 중복 알림 방지 시간 (ms), 같은 타입의 알림이 이 시간 내에 오면 무시 */
  dedupeInterval?: number;
}

/**
 * SSE 대시보드 이벤트를 NotificationContext에 연결하는 훅
 * 
 * useDashboardEvents의 onEvent 콜백으로 사용할 수 있습니다.
 * 
 * @example
 * ``\`tsx
 * const { handleDashboardEvent } = useNotificationBridge();
 * 
 * useDashboardEvents({
 *   onEvent: handleDashboardEvent,
 * });
 * ``\`
 */
export function useNotificationBridge(options: UseNotificationBridgeOptions = {}) {
  const {
    enabledEventTypes,
    persistent = false,
    dedupeInterval = 5000, // 5초 내 동일 타입 알림 방지
  } = options;

  const { addNotification } = useNotifications();
  
  // 최근 알림 타입 및 시간 추적 (중복 방지용)
  const lastNotificationRef = useRef<Map<DashboardEventType, number>>(new Map());

  /**
   * 대시보드 이벤트를 알림으로 변환하여 추가
   */
  const handleDashboardEvent = useCallback((event: DashboardEvent) => {
    const notificationType = eventTypeToNotificationType[event.eventType];
    
    // 알림으로 표시하지 않는 이벤트 타입
    if (notificationType === null) {
      return;
    }

    // 활성화된 이벤트 타입 필터링
    if (enabledEventTypes && !enabledEventTypes.includes(event.eventType)) {
      return;
    }

    // 중복 알림 방지
    const now = Date.now();
    const lastTime = lastNotificationRef.current.get(event.eventType);
    if (lastTime && now - lastTime < dedupeInterval) {
      return;
    }
    lastNotificationRef.current.set(event.eventType, now);

    // 알림 제목 및 메시지 구성
    const title = eventTypeToTitle[event.eventType];
    const message = event.message || '';

    // actionUrl 구성 (이벤트 데이터에 따라)
    let actionUrl: string | undefined;
    let actionLabel: string | undefined;
    
    if (event.data) {
      // 수집 관련 이벤트면 수집 페이지로 링크
      if (event.eventType === 'COLLECTION_COMPLETED' || event.eventType === 'COLLECTION_STARTED') {
        if (event.data.jobId) {
          actionUrl = `/collections/${event.data.jobId}`;
          actionLabel = '상세 보기';
        }
      }
      // 새 데이터 이벤트면 기사 페이지로 링크
      if (event.eventType === 'NEW_DATA' && event.data.articleId) {
        actionUrl = `/articles/${event.data.articleId}`;
        actionLabel = '기사 보기';
      }
    }

    addNotification({
      type: notificationType,
      title,
      message,
      actionUrl,
      actionLabel,
      persistent,
    });
  }, [addNotification, enabledEventTypes, persistent, dedupeInterval]);

  return {
    handleDashboardEvent,
  };
}

/**
 * 대시보드 이벤트와 알림을 자동으로 연결하는 Provider 역할의 훅
 * 
 * App.tsx나 Layout에서 한 번만 호출하면 됩니다.
 * useDashboardEvents를 내부적으로 사용하며 자동으로 알림을 생성합니다.
 * 
 * @example
 * ``\`tsx
 * // App.tsx 또는 AppLayout.tsx에서
 * function App() {
 *   useAutoNotifications({ enabled: true });
 *   return <RouterProvider ... />;
 * }
 * ``\`
 */
export function useAutoNotifications(options: {
  enabled?: boolean;
  enabledEventTypes?: DashboardEventType[];
  persistent?: boolean;
  dedupeInterval?: number;
} = {}) {
  const { enabled = true, ...bridgeOptions } = options;
  const { handleDashboardEvent } = useNotificationBridge(bridgeOptions);

  // useDashboardEvents를 직접 import하지 않고 이벤트 리스너로 구현
  // (순환 의존성 방지)
  useEffect(() => {
    if (!enabled) return;

    // Append auth token to URL for SSE authentication
    const authenticatedUrl = appendTokenToUrl('/api/v1/events/stream');
    const eventSource = new EventSource(authenticatedUrl);
    
    const handleMessage = (event: MessageEvent) => {
      try {
        const dashboardEvent: DashboardEvent = JSON.parse(event.data);
        handleDashboardEvent(dashboardEvent);
      } catch (e) {
        console.error('Failed to parse notification event:', e);
      }
    };

    eventSource.addEventListener('message', handleMessage);

    return () => {
      eventSource.removeEventListener('message', handleMessage);
      eventSource.close();
    };
  }, [enabled, handleDashboardEvent]);
}

/**
 * 프로젝트 알림을 백엔드에서 가져와서 NotificationContext와 연동하는 훅
 * 
 * @example
 * ``\`tsx
 * // AppLayout.tsx에서
 * function AppLayout() {
 *   const { user } = useAuth();
 *   useProjectNotifications({ userId: user?.id, enabled: !!user });
 *   return <Outlet />;
 * }
 * ``\`
 */
export function useProjectNotifications(options: {
  userId?: string;
  enabled?: boolean;
  pollInterval?: number; // ms, default 60000 (1분)
} = {}) {
  const { userId, enabled = true, pollInterval = 60000 } = options;
  const { addNotification } = useNotifications();
  const loadedNotificationIds = useRef<Set<number>>(new Set());

  const loadProjectNotifications = useCallback(async () => {
    if (!userId) return;

    try {
      // 동적 import로 순환 의존성 방지
      const { getUnreadProjectNotifications, markProjectNotificationAsRead } = await import('@/lib/api');
      
      const unreadNotifications = await getUnreadProjectNotifications(userId);
      
      for (const notification of unreadNotifications) {
        // 이미 로드된 알림은 건너뛰기
        if (loadedNotificationIds.current.has(notification.id)) {
          continue;
        }
        
        loadedNotificationIds.current.add(notification.id);
        
        // NotificationContext에 추가
        addNotification({
          type: mapProjectNotificationType(notification.notificationType),
          title: notification.title,
          message: notification.message,
          actionUrl: notification.actionUrl,
          actionLabel: '상세 보기',
          persistent: true,
        });
        
        // 백엔드에서도 읽음 처리
        try {
          await markProjectNotificationAsRead(notification.id);
        } catch (e) {
          console.error('Failed to mark notification as read:', e);
        }
      }
    } catch (error) {
      console.error('Failed to load project notifications:', error);
    }
  }, [userId, addNotification]);

  useEffect(() => {
    if (!enabled || !userId) return;

    // 초기 로드
    loadProjectNotifications();

    // 주기적 폴링
    const interval = setInterval(loadProjectNotifications, pollInterval);
    
    return () => clearInterval(interval);
  }, [enabled, userId, loadProjectNotifications, pollInterval]);
}

/**
 * 프로젝트 알림 타입을 NotificationType으로 매핑
 */
function mapProjectNotificationType(notificationType: string): NotificationType {
  const typeMap: Record<string, NotificationType> = {
    'PROJECT_CREATED': 'success',
    'PROJECT_UPDATED': 'info',
    'PROJECT_DELETED': 'warning',
    'MEMBER_ADDED': 'info',
    'MEMBER_REMOVED': 'warning',
    'ITEM_ADDED': 'success',
    'ITEM_REMOVED': 'info',
    'SEARCH_COMPLETED': 'success',
    'REPORT_READY': 'success',
    'ANALYSIS_COMPLETED': 'success',
    'ERROR': 'error',
  };
  
  return typeMap[notificationType] || 'info';
}

export default useNotificationBridge;

```

---

## frontend/src/hooks/useProgressToast.tsx

```tsx
import { useState, useCallback, useRef, useEffect } from "react";
import { X, Loader2, CheckCircle2, AlertCircle, XCircle } from "lucide-react";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

export type ProgressToastStatus = "loading" | "success" | "error" | "cancelled";

interface ProgressToast {
  id: string;
  title: string;
  description?: string;
  progress: number;
  status: ProgressToastStatus;
  cancellable?: boolean;
  onCancel?: () => void;
  duration?: number;
}

interface ProgressToastItemProps {
  toast: ProgressToast;
  onDismiss: (id: string) => void;
}

const statusIcons = {
  loading: <Loader2 className="h-5 w-5 animate-spin text-primary" />,
  success: <CheckCircle2 className="h-5 w-5 text-green-600" />,
  error: <AlertCircle className="h-5 w-5 text-red-600" />,
  cancelled: <XCircle className="h-5 w-5 text-gray-500" />,
};

const statusColors = {
  loading: "border-l-primary",
  success: "border-l-green-500",
  error: "border-l-red-500",
  cancelled: "border-l-gray-400",
};

function ProgressToastItem({ toast, onDismiss }: ProgressToastItemProps) {
  const [isVisible, setIsVisible] = useState(true);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    // Auto-dismiss completed toasts
    if (toast.status !== "loading" && toast.duration) {
      timeoutRef.current = setTimeout(() => {
        setIsVisible(false);
        setTimeout(() => onDismiss(toast.id), 300);
      }, toast.duration);
    }

    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [toast.status, toast.duration, toast.id, onDismiss]);

  const handleCancel = useCallback(() => {
    if (toast.onCancel) {
      toast.onCancel();
    }
  }, [toast]);

  const handleDismiss = useCallback(() => {
    setIsVisible(false);
    setTimeout(() => onDismiss(toast.id), 300);
  }, [toast.id, onDismiss]);

  return (
    <div
      className={cn(
        "relative flex items-start gap-3 p-4 rounded-lg border border-l-4 bg-background shadow-lg transition-all duration-300",
        statusColors[toast.status],
        isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-2"
      )}
      role="alert"
      aria-live="polite"
    >
      <div className="shrink-0 mt-0.5">{statusIcons[toast.status]}</div>
      
      <div className="flex-1 min-w-0">
        <div className="flex items-start justify-between gap-2">
          <div>
            <h4 className="font-medium text-sm">{toast.title}</h4>
            {toast.description && (
              <p className="text-xs text-muted-foreground mt-0.5">{toast.description}</p>
            )}
          </div>
          
          <div className="flex items-center gap-1 shrink-0">
            {toast.status === "loading" && toast.cancellable && (
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 text-muted-foreground hover:text-destructive"
                onClick={handleCancel}
                aria-label="취소"
              >
                <X className="h-3 w-3" />
              </Button>
            )}
            {toast.status !== "loading" && (
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 text-muted-foreground hover:text-foreground"
                onClick={handleDismiss}
                aria-label="닫기"
              >
                <X className="h-3 w-3" />
              </Button>
            )}
          </div>
        </div>
        
        {toast.status === "loading" && (
          <div className="mt-2 space-y-1">
            <Progress value={toast.progress} className="h-1.5" />
            <div className="flex items-center justify-between text-xs text-muted-foreground">
              <span>{toast.progress}%</span>
              {toast.cancellable && (
                <button
                  onClick={handleCancel}
                  className="text-destructive hover:underline"
                >
                  취소
                </button>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

interface UseProgressToastOptions {
  maxToasts?: number;
  defaultDuration?: number;
}

/**
 * 진행 상태를 표시하는 토스트 훅
 * 
 * @example
 * ``\`tsx
 * const { toasts, addToast, updateToast, dismissToast, ToastContainer } = useProgressToast();
 * 
 * // 토스트 추가
 * const id = addToast({
 *   title: "파일 업로드 중...",
 *   progress: 0,
 *   cancellable: true,
 *   onCancel: () => abortController.abort(),
 * });
 * 
 * // 진행률 업데이트
 * updateToast(id, { progress: 50, description: "50% 완료" });
 * 
 * // 완료 처리
 * updateToast(id, { status: "success", title: "업로드 완료!" });
 * ``\`
 */
export function useProgressToast(options: UseProgressToastOptions = {}) {
  const { maxToasts = 5, defaultDuration = 3000 } = options;
  const [toasts, setToasts] = useState<ProgressToast[]>([]);
  const toastIdCounter = useRef(0);

  const addToast = useCallback((
    toast: Omit<ProgressToast, "id" | "status"> & { status?: ProgressToastStatus }
  ): string => {
    const id = `progress-toast-${++toastIdCounter.current}`;
    const newToast: ProgressToast = {
      id,
      status: "loading",
      duration: defaultDuration,
      ...toast,
    };

    setToasts((prev) => {
      const updated = [newToast, ...prev];
      return updated.slice(0, maxToasts);
    });

    return id;
  }, [maxToasts, defaultDuration]);

  const updateToast = useCallback((id: string, updates: Partial<ProgressToast>) => {
    setToasts((prev) =>
      prev.map((toast) =>
        toast.id === id ? { ...toast, ...updates } : toast
      )
    );
  }, []);

  const dismissToast = useCallback((id: string) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);

  const dismissAll = useCallback(() => {
    setToasts([]);
  }, []);

  const ToastContainer = useCallback(() => (
    <div
      className="fixed bottom-4 right-4 z-[100] flex flex-col gap-2 w-80 max-w-[calc(100vw-2rem)]"
      role="region"
      aria-label="알림"
    >
      {toasts.map((toast) => (
        <ProgressToastItem
          key={toast.id}
          toast={toast}
          onDismiss={dismissToast}
        />
      ))}
    </div>
  ), [toasts, dismissToast]);

  return {
    toasts,
    addToast,
    updateToast,
    dismissToast,
    dismissAll,
    ToastContainer,
  };
}

export default useProgressToast;

```

---

## frontend/src/hooks/useProjects.ts

```ts
/**
 * useProjects - Hook for managing projects
 * 
 * Provides CRUD operations, member management, and item management for projects.
 */

import { useState, useCallback, useEffect } from 'react';
import { useToast } from '@/hooks/use-toast';
import {
  createProject,
  getProject,
  updateProject,
  deleteProject,
  getProjectsByOwner,
  searchProjects,
  getDefaultProject,
  getProjectStats,
  getProjectMembers,
  inviteProjectMember,
  removeProjectMember,
  updateProjectMemberRole,
  addProjectItem,
  getProjectItems,
  searchProjectItems,
  markProjectItemAsRead,
  toggleProjectItemBookmark,
  deleteProjectItem,
  getProjectActivityLog,
  getRecentProjectActivity,
  type Project,
  type ProjectStatus,
  type ProjectCategory,
  type ProjectVisibility,
  type ProjectMember,
  type ProjectItem,
  type ProjectItemType,
  type ProjectActivityLog,
  type MemberRole,
  type CreateProjectRequest,
  type UpdateProjectRequest,
  type AddProjectItemRequest,
  type PageResponse,
} from '@/lib/api';

// Re-export types for convenience
export type {
  Project,
  ProjectStatus,
  ProjectCategory,
  ProjectVisibility,
  ProjectMember,
  ProjectItem,
  ProjectItemType,
  ProjectActivityLog,
  MemberRole,
  CreateProjectRequest,
  UpdateProjectRequest,
  AddProjectItemRequest,
};

// Korean labels
export const PROJECT_STATUS_LABELS: Record<ProjectStatus, string> = {
  ACTIVE: '활성',
  PAUSED: '일시중지',
  COMPLETED: '완료',
  ARCHIVED: '보관됨',
};

export const PROJECT_CATEGORY_LABELS: Record<ProjectCategory, string> = {
  RESEARCH: '연구',
  MONITORING: '모니터링',
  FACT_CHECK: '팩트체크',
  TREND_ANALYSIS: '트렌드 분석',
  CUSTOM: '사용자 정의',
};

export const PROJECT_VISIBILITY_LABELS: Record<ProjectVisibility, string> = {
  PRIVATE: '비공개',
  TEAM: '팀 공개',
  PUBLIC: '전체 공개',
};

export const ITEM_TYPE_LABELS: Record<ProjectItemType, string> = {
  ARTICLE: '기사',
  SEARCH_RESULT: '검색 결과',
  NOTE: '메모',
  DOCUMENT: '문서',
  URL: 'URL',
  EVIDENCE: '증거자료',
};

export const MEMBER_ROLE_LABELS: Record<MemberRole, string> = {
  OWNER: '소유자',
  ADMIN: '관리자',
  EDITOR: '편집자',
  VIEWER: '뷰어',
};

interface UseProjectsOptions {
  userId?: string;
  autoLoad?: boolean;
  pageSize?: number;
}

interface ProjectStats {
  itemCount: number;
  unreadCount: number;
  memberCount: number;
  categories: string[];
}

interface UseProjectsReturn {
  // State
  projects: Project[];
  currentProject: Project | null;
  loading: boolean;
  error: string | null;
  currentPage: number;
  totalPages: number;
  totalElements: number;

  // Project CRUD
  loadProjects: (page?: number, status?: ProjectStatus) => Promise<void>;
  searchProjectsAction: (query: string, page?: number) => Promise<void>;
  createProjectAction: (request: CreateProjectRequest) => Promise<Project | null>;
  updateProjectAction: (id: number, request: UpdateProjectRequest) => Promise<Project | null>;
  deleteProjectAction: (id: number) => Promise<boolean>;
  selectProject: (id: number) => Promise<void>;
  getDefaultProjectAction: () => Promise<Project | null>;
  getProjectStatsAction: (id: number) => Promise<ProjectStats | null>;

  // Members
  members: ProjectMember[];
  loadMembers: (projectId: number) => Promise<void>;
  inviteMember: (projectId: number, userId: string, role: MemberRole) => Promise<ProjectMember | null>;
  removeMember: (projectId: number, userId: string) => Promise<boolean>;
  updateMemberRole: (projectId: number, userId: string, role: MemberRole) => Promise<ProjectMember | null>;

  // Items
  items: ProjectItem[];
  itemsPage: number;
  itemsTotalPages: number;
  itemsLoading: boolean;
  loadItems: (projectId: number, type?: ProjectItemType, page?: number) => Promise<void>;
  searchItems: (projectId: number, query: string, page?: number) => Promise<void>;
  addItem: (projectId: number, request: AddProjectItemRequest) => Promise<ProjectItem | null>;
  markItemRead: (projectId: number, itemId: number) => Promise<void>;
  toggleItemBookmark: (projectId: number, itemId: number) => Promise<void>;
  deleteItem: (projectId: number, itemId: number) => Promise<boolean>;

  // Activities
  activities: ProjectActivityLog[];
  loadActivities: (projectId: number, page?: number) => Promise<void>;
  loadRecentActivities: (projectId: number) => Promise<void>;

  // Utilities
  refresh: () => Promise<void>;
}

export function useProjects(options: UseProjectsOptions = {}): UseProjectsReturn {
  const { userId = 'anonymous', autoLoad = true, pageSize = 20 } = options;
  const { toast } = useToast();

  // Projects state
  const [projects, setProjects] = useState<Project[]>([]);
  const [currentProject, setCurrentProject] = useState<Project | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentPage, setCurrentPage] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [totalElements, setTotalElements] = useState(0);

  // Members state
  const [members, setMembers] = useState<ProjectMember[]>([]);

  // Items state
  const [items, setItems] = useState<ProjectItem[]>([]);
  const [itemsPage, setItemsPage] = useState(0);
  const [itemsTotalPages, setItemsTotalPages] = useState(0);
  const [itemsLoading, setItemsLoading] = useState(false);

  // Activities state
  const [activities, setActivities] = useState<ProjectActivityLog[]>([]);

  // Load projects
  const loadProjects = useCallback(async (page: number = 0, status?: ProjectStatus) => {
    setLoading(true);
    setError(null);
    try {
      const response = await getProjectsByOwner(userId, status, page, pageSize);
      setProjects(response.content);
      setCurrentPage(response.page);
      setTotalPages(response.totalPages);
      setTotalElements(response.totalElements);
    } catch (err) {
      const message = err instanceof Error ? err.message : '프로젝트를 불러오는데 실패했습니다.';
      setError(message);
      console.error('Failed to load projects:', err);
    } finally {
      setLoading(false);
    }
  }, [userId, pageSize]);

  // Search projects
  const searchProjectsAction = useCallback(async (query: string, page: number = 0) => {
    setLoading(true);
    setError(null);
    try {
      const response = await searchProjects(query, page, pageSize);
      setProjects(response.content);
      setCurrentPage(response.page);
      setTotalPages(response.totalPages);
      setTotalElements(response.totalElements);
    } catch (err) {
      const message = err instanceof Error ? err.message : '프로젝트 검색에 실패했습니다.';
      setError(message);
      console.error('Failed to search projects:', err);
    } finally {
      setLoading(false);
    }
  }, [pageSize]);

  // Create project
  const createProjectAction = useCallback(async (request: CreateProjectRequest): Promise<Project | null> => {
    try {
      const project = await createProject({ ...request, ownerId: userId });
      setProjects(prev => [project, ...prev]);
      setTotalElements(prev => prev + 1);
      toast({
        title: '프로젝트 생성 완료',
        description: `"${project.name}" 프로젝트가 생성되었습니다.`,
      });
      return project;
    } catch (err) {
      const message = err instanceof Error ? err.message : '프로젝트 생성에 실패했습니다.';
      toast({
        title: '프로젝트 생성 실패',
        description: message,
        variant: 'destructive',
      });
      console.error('Failed to create project:', err);
      return null;
    }
  }, [userId, toast]);

  // Update project
  const updateProjectAction = useCallback(async (id: number, request: UpdateProjectRequest): Promise<Project | null> => {
    try {
      const updated = await updateProject(id, request, userId);
      setProjects(prev => prev.map(p => p.id === id ? updated : p));
      if (currentProject?.id === id) {
        setCurrentProject(updated);
      }
      toast({
        title: '프로젝트 업데이트 완료',
        description: `"${updated.name}" 프로젝트가 업데이트되었습니다.`,
      });
      return updated;
    } catch (err) {
      const message = err instanceof Error ? err.message : '프로젝트 업데이트에 실패했습니다.';
      toast({
        title: '프로젝트 업데이트 실패',
        description: message,
        variant: 'destructive',
      });
      console.error('Failed to update project:', err);
      return null;
    }
  }, [userId, currentProject, toast]);

  // Delete project
  const deleteProjectAction = useCallback(async (id: number): Promise<boolean> => {
    try {
      await deleteProject(id, userId);
      setProjects(prev => prev.filter(p => p.id !== id));
      setTotalElements(prev => prev - 1);
      if (currentProject?.id === id) {
        setCurrentProject(null);
      }
      toast({
        title: '프로젝트 삭제 완료',
        description: '프로젝트가 삭제되었습니다.',
      });
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : '프로젝트 삭제에 실패했습니다.';
      toast({
        title: '프로젝트 삭제 실패',
        description: message,
        variant: 'destructive',
      });
      console.error('Failed to delete project:', err);
      return false;
    }
  }, [userId, currentProject, toast]);

  // Select project
  const selectProject = useCallback(async (id: number) => {
    setLoading(true);
    try {
      const project = await getProject(id, userId);
      setCurrentProject(project);
    } catch (err) {
      const message = err instanceof Error ? err.message : '프로젝트를 불러오는데 실패했습니다.';
      setError(message);
      console.error('Failed to select project:', err);
    } finally {
      setLoading(false);
    }
  }, [userId]);

  // Get default project
  const getDefaultProjectAction = useCallback(async (): Promise<Project | null> => {
    try {
      const project = await getDefaultProject(userId);
      return project;
    } catch (err) {
      console.error('Failed to get default project:', err);
      return null;
    }
  }, [userId]);

  // Get project stats
  const getProjectStatsAction = useCallback(async (id: number): Promise<ProjectStats | null> => {
    try {
      return await getProjectStats(id);
    } catch (err) {
      console.error('Failed to get project stats:', err);
      return null;
    }
  }, []);

  // Load members
  const loadMembers = useCallback(async (projectId: number) => {
    try {
      const membersList = await getProjectMembers(projectId);
      setMembers(membersList);
    } catch (err) {
      console.error('Failed to load members:', err);
    }
  }, []);

  // Invite member
  const inviteMember = useCallback(async (
    projectId: number,
    memberUserId: string,
    role: MemberRole
  ): Promise<ProjectMember | null> => {
    try {
      const member = await inviteProjectMember(projectId, memberUserId, role, userId);
      setMembers(prev => [...prev, member]);
      toast({
        title: '멤버 초대 완료',
        description: '새 멤버가 초대되었습니다.',
      });
      return member;
    } catch (err) {
      const message = err instanceof Error ? err.message : '멤버 초대에 실패했습니다.';
      toast({
        title: '멤버 초대 실패',
        description: message,
        variant: 'destructive',
      });
      console.error('Failed to invite member:', err);
      return null;
    }
  }, [userId, toast]);

  // Remove member
  const removeMember = useCallback(async (projectId: number, memberUserId: string): Promise<boolean> => {
    try {
      await removeProjectMember(projectId, memberUserId, userId);
      setMembers(prev => prev.filter(m => m.userId !== memberUserId));
      toast({
        title: '멤버 제거 완료',
        description: '멤버가 프로젝트에서 제거되었습니다.',
      });
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : '멤버 제거에 실패했습니다.';
      toast({
        title: '멤버 제거 실패',
        description: message,
        variant: 'destructive',
      });
      console.error('Failed to remove member:', err);
      return false;
    }
  }, [userId, toast]);

  // Update member role
  const updateMemberRole = useCallback(async (
    projectId: number,
    memberUserId: string,
    role: MemberRole
  ): Promise<ProjectMember | null> => {
    try {
      const updated = await updateProjectMemberRole(projectId, memberUserId, role, userId);
      setMembers(prev => prev.map(m => m.userId === memberUserId ? updated : m));
      toast({
        title: '역할 변경 완료',
        description: '멤버 역할이 변경되었습니다.',
      });
      return updated;
    } catch (err) {
      const message = err instanceof Error ? err.message : '역할 변경에 실패했습니다.';
      toast({
        title: '역할 변경 실패',
        description: message,
        variant: 'destructive',
      });
      console.error('Failed to update member role:', err);
      return null;
    }
  }, [userId, toast]);

  // Load items
  const loadItems = useCallback(async (projectId: number, type?: ProjectItemType, page: number = 0) => {
    setItemsLoading(true);
    try {
      const response = await getProjectItems(projectId, type, page, pageSize);
      setItems(response.content);
      setItemsPage(response.page);
      setItemsTotalPages(response.totalPages);
    } catch (err) {
      console.error('Failed to load items:', err);
    } finally {
      setItemsLoading(false);
    }
  }, [pageSize]);

  // Search items
  const searchItems = useCallback(async (projectId: number, query: string, page: number = 0) => {
    setItemsLoading(true);
    try {
      const response = await searchProjectItems(projectId, query, page, pageSize);
      setItems(response.content);
      setItemsPage(response.page);
      setItemsTotalPages(response.totalPages);
    } catch (err) {
      console.error('Failed to search items:', err);
    } finally {
      setItemsLoading(false);
    }
  }, [pageSize]);

  // Add item
  const addItem = useCallback(async (
    projectId: number,
    request: AddProjectItemRequest
  ): Promise<ProjectItem | null> => {
    try {
      const item = await addProjectItem(projectId, request, userId);
      setItems(prev => [item, ...prev]);
      toast({
        title: '항목 추가 완료',
        description: '새 항목이 프로젝트에 추가되었습니다.',
      });
      return item;
    } catch (err) {
      const message = err instanceof Error ? err.message : '항목 추가에 실패했습니다.';
      toast({
        title: '항목 추가 실패',
        description: message,
        variant: 'destructive',
      });
      console.error('Failed to add item:', err);
      return null;
    }
  }, [userId, toast]);

  // Mark item read
  const markItemRead = useCallback(async (projectId: number, itemId: number) => {
    try {
      await markProjectItemAsRead(projectId, itemId, userId);
      setItems(prev => prev.map(item => 
        item.id === itemId ? { ...item, isRead: true, readAt: new Date().toISOString() } : item
      ));
    } catch (err) {
      console.error('Failed to mark item as read:', err);
    }
  }, [userId]);

  // Toggle item bookmark
  const toggleItemBookmark = useCallback(async (projectId: number, itemId: number) => {
    try {
      await toggleProjectItemBookmark(projectId, itemId, userId);
      setItems(prev => prev.map(item =>
        item.id === itemId ? { ...item, isBookmarked: !item.isBookmarked } : item
      ));
    } catch (err) {
      console.error('Failed to toggle bookmark:', err);
    }
  }, [userId]);

  // Delete item
  const deleteItem = useCallback(async (projectId: number, itemId: number): Promise<boolean> => {
    try {
      await deleteProjectItem(projectId, itemId, userId);
      setItems(prev => prev.filter(item => item.id !== itemId));
      toast({
        title: '항목 삭제 완료',
        description: '항목이 삭제되었습니다.',
      });
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : '항목 삭제에 실패했습니다.';
      toast({
        title: '항목 삭제 실패',
        description: message,
        variant: 'destructive',
      });
      console.error('Failed to delete item:', err);
      return false;
    }
  }, [userId, toast]);

  // Load activities
  const loadActivities = useCallback(async (projectId: number, page: number = 0) => {
    try {
      const response = await getProjectActivityLog(projectId, page, pageSize);
      setActivities(response.content);
    } catch (err) {
      console.error('Failed to load activities:', err);
    }
  }, [pageSize]);

  // Load recent activities
  const loadRecentActivities = useCallback(async (projectId: number) => {
    try {
      const recentActivities = await getRecentProjectActivity(projectId);
      setActivities(recentActivities);
    } catch (err) {
      console.error('Failed to load recent activities:', err);
    }
  }, []);

  // Refresh
  const refresh = useCallback(async () => {
    await loadProjects(currentPage);
  }, [loadProjects, currentPage]);

  // Auto-load on mount
  useEffect(() => {
    if (autoLoad) {
      loadProjects();
    }
  }, [autoLoad, loadProjects]);

  return {
    // State
    projects,
    currentProject,
    loading,
    error,
    currentPage,
    totalPages,
    totalElements,

    // Project CRUD
    loadProjects,
    searchProjectsAction,
    createProjectAction,
    updateProjectAction,
    deleteProjectAction,
    selectProject,
    getDefaultProjectAction,
    getProjectStatsAction,

    // Members
    members,
    loadMembers,
    inviteMember,
    removeMember,
    updateMemberRole,

    // Items
    items,
    itemsPage,
    itemsTotalPages,
    itemsLoading,
    loadItems,
    searchItems,
    addItem,
    markItemRead,
    toggleItemBookmark,
    deleteItem,

    // Activities
    activities,
    loadActivities,
    loadRecentActivities,

    // Utilities
    refresh,
  };
}

export default useProjects;

```

---

## frontend/src/hooks/useSearchHistory.ts

```ts
import { useState, useCallback, useEffect, useRef } from 'react';
import { useToast } from '@/hooks/use-toast';
import {
  saveSearchHistory,
  listSearchHistory,
  getSearchHistoryById,
  getDerivedSearches,
  toggleSearchBookmark,
  deleteSearchHistory,
  getBookmarkedSearches,
  searchHistoryByQuery,
  openSearchHistoryStream,
  type SearchHistoryRecord,
  type SaveSearchHistoryRequest,
  type SearchHistoryType,
  type PageResponse,
  type SearchHistorySSEEvent,
} from '@/lib/api';

// Generate session ID for grouping searches
const generateSessionId = (): string => {
  const stored = sessionStorage.getItem('search-session-id');
  if (stored) return stored;
  const newId = `session-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  sessionStorage.setItem('search-session-id', newId);
  return newId;
};

interface UseSearchHistoryOptions {
  autoSave?: boolean;
  pageSize?: number;
  userId?: string;
}

interface UseSearchHistoryReturn {
  // State
  history: SearchHistoryRecord[];
  loading: boolean;
  error: string | null;
  currentPage: number;
  totalPages: number;
  totalElements: number;
  
  // Actions
  saveSearch: (data: Omit<SaveSearchHistoryRequest, 'sessionId'>) => Promise<void>;
  loadHistory: (page?: number, type?: SearchHistoryType) => Promise<void>;
  loadBookmarked: (page?: number) => Promise<void>;
  searchHistory: (query: string, page?: number) => Promise<void>;
  toggleBookmark: (id: number) => Promise<void>;
  deleteSearch: (id: number) => Promise<void>;
  loadDerivedSearches: (parentId: number) => Promise<SearchHistoryRecord[]>;
  getSearchById: (id: number) => Promise<SearchHistoryRecord | null>;
  
  // Utilities
  sessionId: string;
  extractUrlsFromResults: (results: Array<Record<string, unknown>>) => string[];
}

/**
 * Hook for managing search history with database persistence.
 * Automatically saves search results to the backend via Kafka.
 */
export function useSearchHistory(options: UseSearchHistoryOptions = {}): UseSearchHistoryReturn {
  const { pageSize = 20, userId } = options;
  const { toast } = useToast();
  
  const [history, setHistory] = useState<SearchHistoryRecord[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentPage, setCurrentPage] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [totalElements, setTotalElements] = useState(0);
  
  const sessionId = useRef(generateSessionId()).current;

  /**
   * Extract URLs from search results for auto-collection
   */
  const extractUrlsFromResults = useCallback((results: Array<Record<string, unknown>>): string[] => {
    const urls: string[] = [];
    for (const result of results) {
      if (typeof result.url === 'string' && result.url) {
        urls.push(result.url);
      }
      // Also check for nested URLs (e.g., in evidence)
      if (Array.isArray(result.evidence)) {
        for (const evidence of result.evidence) {
          if (typeof evidence === 'object' && evidence && typeof (evidence as Record<string, unknown>).url === 'string') {
            urls.push((evidence as Record<string, unknown>).url as string);
          }
        }
      }
    }
    // Deduplicate
    return [...new Set(urls)];
  }, []);

  /**
   * Save a search to history
   */
  const saveSearch = useCallback(async (data: Omit<SaveSearchHistoryRequest, 'sessionId'>) => {
    try {
      // Auto-extract URLs if not provided
      let discoveredUrls = data.discoveredUrls;
      if (!discoveredUrls && data.results) {
        discoveredUrls = extractUrlsFromResults(data.results);
      }

      await saveSearchHistory({
        ...data,
        sessionId,
        userId,
        discoveredUrls,
      });
    } catch (err) {
      console.error('Failed to save search history:', err);
      // 사용자에게 저장 실패 알림
      toast({
        title: '검색 기록 저장 실패',
        description: err instanceof Error ? err.message : '잠시 후 다시 시도해주세요.',
        variant: 'destructive',
      });
    }
  }, [sessionId, userId, extractUrlsFromResults, toast]);

  /**
   * Load search history with pagination
   */
  const loadHistory = useCallback(async (page: number = 0, type?: SearchHistoryType) => {
    setLoading(true);
    setError(null);
    try {
      const response: PageResponse<SearchHistoryRecord> = await listSearchHistory(
        page,
        pageSize,
        'createdAt',
        'DESC',
        type,
        userId,
      );
      setHistory(response.content);
      setCurrentPage(response.page);
      setTotalPages(response.totalPages);
      setTotalElements(response.totalElements);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load search history');
      console.error('Failed to load search history:', err);
    } finally {
      setLoading(false);
    }
  }, [pageSize, userId]);

  /**
   * Load bookmarked searches
   */
  const loadBookmarked = useCallback(async (page: number = 0) => {
    setLoading(true);
    setError(null);
    try {
      const response = await getBookmarkedSearches(page, pageSize);
      setHistory(response.content);
      setCurrentPage(response.page);
      setTotalPages(response.totalPages);
      setTotalElements(response.totalElements);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load bookmarked searches');
      console.error('Failed to load bookmarked searches:', err);
    } finally {
      setLoading(false);
    }
  }, [pageSize]);

  /**
   * Search history by query text
   */
  const searchHistoryLocal = useCallback(async (query: string, page: number = 0) => {
    setLoading(true);
    setError(null);
    try {
      const response = await searchHistoryByQuery(query, page, pageSize);
      setHistory(response.content);
      setCurrentPage(response.page);
      setTotalPages(response.totalPages);
      setTotalElements(response.totalElements);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to search history');
      console.error('Failed to search history:', err);
    } finally {
      setLoading(false);
    }
  }, [pageSize]);

  /**
   * Toggle bookmark for a search
   */
  const toggleBookmarkLocal = useCallback(async (id: number) => {
    try {
      const updated = await toggleSearchBookmark(id);
      setHistory(prev => prev.map(item => 
        item.id === id ? updated : item
      ));
    } catch (err) {
      console.error('Failed to toggle bookmark:', err);
      throw err;
    }
  }, []);

  /**
   * Delete a search from history
   */
  const deleteSearchLocal = useCallback(async (id: number) => {
    try {
      await deleteSearchHistory(id);
      setHistory(prev => prev.filter(item => item.id !== id));
      setTotalElements(prev => prev - 1);
    } catch (err) {
      console.error('Failed to delete search:', err);
      throw err;
    }
  }, []);

  /**
   * Load derived (drill-down) searches
   */
  const loadDerivedSearches = useCallback(async (parentId: number): Promise<SearchHistoryRecord[]> => {
    try {
      return await getDerivedSearches(parentId);
    } catch (err) {
      console.error('Failed to load derived searches:', err);
      return [];
    }
  }, []);

  /**
   * Get a single search by ID
   */
  const getSearchById = useCallback(async (id: number): Promise<SearchHistoryRecord | null> => {
    try {
      return await getSearchHistoryById(id);
    } catch (err) {
      console.error('Failed to get search:', err);
      return null;
    }
  }, []);

  return {
    history,
    loading,
    error,
    currentPage,
    totalPages,
    totalElements,
    saveSearch,
    loadHistory,
    loadBookmarked,
    searchHistory: searchHistoryLocal,
    toggleBookmark: toggleBookmarkLocal,
    deleteSearch: deleteSearchLocal,
    loadDerivedSearches,
    getSearchById,
    sessionId,
    extractUrlsFromResults,
  };
}

/**
 * Hook for auto-saving search results.
 * Use this in search components to automatically save completed searches.
 */
export function useAutoSaveSearch() {
  const { saveSearch, sessionId, extractUrlsFromResults } = useSearchHistory();

  /**
   * Save unified search results
   */
  const saveUnifiedSearch = useCallback(async (
    query: string,
    results: Array<Record<string, unknown>>,
    aiSummary?: Record<string, unknown>,
    durationMs?: number,
    timeWindow?: string,
  ) => {
    await saveSearch({
      searchType: 'UNIFIED',
      query,
      timeWindow,
      results,
      aiSummary,
      resultCount: results.length,
      durationMs,
      success: true,
      discoveredUrls: extractUrlsFromResults(results),
    });
  }, [saveSearch, extractUrlsFromResults]);

  /**
   * Save deep search results
   */
  const saveDeepSearch = useCallback(async (
    jobId: string,
    topic: string,
    results: Array<Record<string, unknown>>,
    stanceDistribution?: Record<string, unknown>,
    durationMs?: number,
    parentSearchId?: number,
  ) => {
    await saveSearch({
      externalId: jobId,
      searchType: 'DEEP_SEARCH',
      query: topic,
      results,
      stanceDistribution,
      resultCount: results.length,
      durationMs,
      parentSearchId,
      success: true,
      discoveredUrls: extractUrlsFromResults(results),
    });
  }, [saveSearch, extractUrlsFromResults]);

  /**
   * Save fact check results
   */
  const saveFactCheck = useCallback(async (
    topic: string,
    factCheckResults: Array<Record<string, unknown>>,
    credibilityScore?: number,
    durationMs?: number,
    parentSearchId?: number,
  ) => {
    await saveSearch({
      searchType: 'FACT_CHECK',
      query: topic,
      factCheckResults,
      credibilityScore,
      resultCount: factCheckResults.length,
      durationMs,
      parentSearchId,
      success: true,
    });
  }, [saveSearch]);

  /**
   * Save browser agent results
   */
  const saveBrowserAgent = useCallback(async (
    task: string,
    results: Array<Record<string, unknown>>,
    urlsVisited: string[],
    durationMs?: number,
  ) => {
    await saveSearch({
      searchType: 'BROWSER_AGENT',
      query: task,
      results,
      discoveredUrls: urlsVisited,
      resultCount: results.length,
      durationMs,
      success: true,
    });
  }, [saveSearch]);

  /**
   * Save failed search
   */
  const saveFailedSearch = useCallback(async (
    searchType: SearchHistoryType,
    query: string,
    errorMessage: string,
    durationMs?: number,
  ) => {
    await saveSearch({
      searchType,
      query,
      errorMessage,
      durationMs,
      success: false,
    });
  }, [saveSearch]);

  return {
    saveUnifiedSearch,
    saveDeepSearch,
    saveFactCheck,
    saveBrowserAgent,
    saveFailedSearch,
    sessionId,
  };
}

/**
 * Hook for real-time search history updates via SSE.
 * Use this in components that need to display live updates.
 */
export function useSearchHistorySSE(options: {
  enabled?: boolean;
  onNewSearch?: (search: SearchHistoryRecord) => void;
  onUpdatedSearch?: (search: SearchHistoryRecord) => void;
  onDeletedSearch?: (id: number) => void;
} = {}) {
  const { enabled = true, onNewSearch, onUpdatedSearch, onDeletedSearch } = options;
  
  const [connected, setConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [lastEvent, setLastEvent] = useState<SearchHistorySSEEvent | null>(null);
  const eventSourceRef = useRef<EventSource | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;

  const connect = useCallback(async () => {
    if (!enabled) return;
    
    try {
      // Close existing connection
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
      
      const eventSource = await openSearchHistoryStream();
      eventSourceRef.current = eventSource;
      
      eventSource.onopen = () => {
        console.log('[SearchHistory SSE] Connected');
        setConnected(true);
        setError(null);
        reconnectAttempts.current = 0;
      };
      
      // Listen for specific event types
      eventSource.addEventListener('new_search', (event) => {
        try {
          const data = JSON.parse(event.data) as SearchHistorySSEEvent;
          console.log('[SearchHistory SSE] New search:', data);
          setLastEvent(data);
          if (onNewSearch && data.data && 'id' in data.data && 'searchType' in data.data) {
            onNewSearch(data.data as SearchHistoryRecord);
          }
        } catch (err) {
          console.error('[SearchHistory SSE] Failed to parse new_search event:', err);
        }
      });
      
      eventSource.addEventListener('updated_search', (event) => {
        try {
          const data = JSON.parse(event.data) as SearchHistorySSEEvent;
          console.log('[SearchHistory SSE] Updated search:', data);
          setLastEvent(data);
          if (onUpdatedSearch && data.data && 'id' in data.data && 'searchType' in data.data) {
            onUpdatedSearch(data.data as SearchHistoryRecord);
          }
        } catch (err) {
          console.error('[SearchHistory SSE] Failed to parse updated_search event:', err);
        }
      });
      
      eventSource.addEventListener('deleted_search', (event) => {
        try {
          const data = JSON.parse(event.data) as SearchHistorySSEEvent;
          console.log('[SearchHistory SSE] Deleted search:', data);
          setLastEvent(data);
          if (onDeletedSearch && data.data && 'id' in data.data) {
            onDeletedSearch((data.data as { id: number }).id);
          }
        } catch (err) {
          console.error('[SearchHistory SSE] Failed to parse deleted_search event:', err);
        }
      });
      
      eventSource.addEventListener('heartbeat', (event) => {
        try {
          const data = JSON.parse(event.data) as SearchHistorySSEEvent;
          console.debug('[SearchHistory SSE] Heartbeat:', data);
        } catch {
          // Heartbeat parsing errors are not critical
        }
      });
      
      eventSource.onerror = (err) => {
        console.error('[SearchHistory SSE] Error:', err);
        setConnected(false);
        
        // Attempt reconnection with exponential backoff
        if (reconnectAttempts.current < maxReconnectAttempts) {
          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 30000);
          console.log(`[SearchHistory SSE] Reconnecting in ${delay}ms (attempt ${reconnectAttempts.current + 1})`);
          
          reconnectTimeoutRef.current = setTimeout(() => {
            reconnectAttempts.current++;
            connect();
          }, delay);
        } else {
          setError('Failed to connect to search history stream after multiple attempts');
        }
      };
      
    } catch (err) {
      console.error('[SearchHistory SSE] Failed to connect:', err);
      setError(err instanceof Error ? err.message : 'Failed to connect');
      setConnected(false);
    }
  }, [enabled, onNewSearch, onUpdatedSearch, onDeletedSearch]);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    
    setConnected(false);
  }, []);

  // Connect on mount, disconnect on unmount
  useEffect(() => {
    if (enabled) {
      connect();
    }
    
    return () => {
      disconnect();
    };
  }, [enabled, connect, disconnect]);

  return {
    connected,
    error,
    lastEvent,
    reconnect: connect,
    disconnect,
  };
}

export default useSearchHistory;

```

---

## frontend/src/hooks/useSearchJobs.ts

```ts
/**
 * useSearchJobs - Hook for managing search jobs with the context
 * 
 * This hook provides additional functionality beyond the basic context:
 * - Job polling for specific jobs
 * - Job result retrieval
 * - Integration with search history
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import { useSearchJobs as useSearchJobsContext, JOB_TYPE_LABELS, JOB_STATUS_LABELS } from '@/contexts/SearchJobContext';
import {
  getSearchJobStatus,
  openSearchJobStream,
  type SearchJob,
  type SearchJobEvent,
  type SearchJobType,
  type SearchJobStatus,
  type StartSearchJobRequest,
} from '@/lib/api';

// Re-export labels for convenience
export { JOB_TYPE_LABELS, JOB_STATUS_LABELS };

interface UseSearchJobsOptions {
  /**
   * Auto-poll interval in ms for active jobs (0 to disable)
   */
  pollInterval?: number;
  /**
   * Callback when a job completes
   */
  onJobCompleted?: (job: SearchJob) => void;
  /**
   * Callback when a job fails
   */
  onJobFailed?: (job: SearchJob) => void;
}

interface UseSearchJobsReturn {
  // From context
  jobs: SearchJob[];
  activeJobs: SearchJob[];
  completedJobs: SearchJob[];
  isLoaded: boolean;
  isConnected: boolean;
  connectionError: string | null;
  hasActiveJobs: boolean;
  activeJobCount: number;
  
  // Context actions
  startJob: (request: StartSearchJobRequest) => Promise<string | null>;
  startJobsBatch: (requests: StartSearchJobRequest[]) => Promise<string[]>;
  cancelJob: (jobId: string) => Promise<boolean>;
  refreshJobs: () => Promise<void>;
  getJob: (jobId: string) => SearchJob | undefined;
  clearCompletedJobs: () => void;
  
  // Extended functionality
  watchJob: (jobId: string, onUpdate: (job: SearchJob) => void) => () => void;
  getJobsByType: (type: SearchJobType) => SearchJob[];
  getJobsByStatus: (status: SearchJobStatus) => SearchJob[];
  getLatestJobByType: (type: SearchJobType) => SearchJob | undefined;
  
  // Utilities
  formatJobType: (type: SearchJobType) => string;
  formatJobStatus: (status: SearchJobStatus) => string;
  getJobProgress: (job: SearchJob) => { percent: number; label: string };
}

/**
 * Extended hook for managing search jobs
 */
export function useSearchJobsExtended(options: UseSearchJobsOptions = {}): UseSearchJobsReturn {
  const { pollInterval = 0, onJobCompleted, onJobFailed } = options;
  const context = useSearchJobsContext();
  const prevActiveJobsRef = useRef<string[]>([]);

  // Track job completions/failures
  useEffect(() => {
    const currentActiveIds = context.activeJobs.map(j => j.jobId);
    const prevActiveIds = prevActiveJobsRef.current;

    // Find jobs that are no longer active
    const completedIds = prevActiveIds.filter(id => !currentActiveIds.includes(id));

    for (const jobId of completedIds) {
      const job = context.getJob(jobId);
      if (job) {
        if (job.status === 'COMPLETED' && onJobCompleted) {
          onJobCompleted(job);
        } else if (job.status === 'FAILED' && onJobFailed) {
          onJobFailed(job);
        }
      }
    }

    prevActiveJobsRef.current = currentActiveIds;
  }, [context.activeJobs, context.getJob, onJobCompleted, onJobFailed]);

  // Polling for active jobs (backup when SSE is not available)
  useEffect(() => {
    // Only poll if explicitly enabled, SSE is disconnected, and there are active jobs
    if (pollInterval <= 0 || context.isConnected || context.activeJobs.length === 0) {
      return;
    }

    console.log('[useSearchJobs] Starting polling fallback (SSE disconnected)');
    const intervalId = setInterval(() => {
      context.refreshJobs();
    }, pollInterval);

    return () => {
      console.log('[useSearchJobs] Stopping polling fallback');
      clearInterval(intervalId);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pollInterval, context.isConnected, context.activeJobs.length]);

  /**
   * Watch a specific job with SSE
   */
  const watchJob = useCallback((jobId: string, onUpdate: (job: SearchJob) => void): (() => void) => {
    let eventSource: EventSource | null = null;
    let pollIntervalId: ReturnType<typeof setInterval> | null = null;

    const startWatch = async () => {
      try {
        eventSource = await openSearchJobStream(jobId);

        const handleEvent = async (eventType: string) => {
          try {
            const job = await getSearchJobStatus(jobId);
            onUpdate(job);
          } catch (err) {
            console.error(`[watchJob] Failed to get job status after ${eventType}:`, err);
          }
        };

        eventSource.addEventListener('job_started', () => handleEvent('started'));
        eventSource.addEventListener('job_progress', () => handleEvent('progress'));
        eventSource.addEventListener('job_completed', () => handleEvent('completed'));
        eventSource.addEventListener('job_failed', () => handleEvent('failed'));
        eventSource.addEventListener('job_cancelled', () => handleEvent('cancelled'));

        eventSource.onerror = () => {
          console.warn('[watchJob] SSE error, falling back to polling');
          // Fall back to polling
          if (!pollIntervalId) {
            pollIntervalId = setInterval(async () => {
              try {
                const job = await getSearchJobStatus(jobId);
                onUpdate(job);
                // Stop polling if job is complete
                if (['COMPLETED', 'FAILED', 'CANCELLED'].includes(job.status)) {
                  if (pollIntervalId) {
                    clearInterval(pollIntervalId);
                    pollIntervalId = null;
                  }
                }
              } catch (err) {
                console.error('[watchJob] Polling error:', err);
              }
            }, 3000);
          }
        };
      } catch (err) {
        console.error('[watchJob] Failed to start SSE:', err);
        // Fall back to polling immediately
        pollIntervalId = setInterval(async () => {
          try {
            const job = await getSearchJobStatus(jobId);
            onUpdate(job);
            if (['COMPLETED', 'FAILED', 'CANCELLED'].includes(job.status)) {
              if (pollIntervalId) {
                clearInterval(pollIntervalId);
                pollIntervalId = null;
              }
            }
          } catch (pollErr) {
            console.error('[watchJob] Polling error:', pollErr);
          }
        }, 3000);
      }
    };

    startWatch();

    // Return cleanup function
    return () => {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
      if (pollIntervalId) {
        clearInterval(pollIntervalId);
        pollIntervalId = null;
      }
    };
  }, []);

  /**
   * Get jobs by type
   */
  const getJobsByType = useCallback((type: SearchJobType): SearchJob[] => {
    return context.jobs.filter(j => j.type === type);
  }, [context.jobs]);

  /**
   * Get jobs by status
   */
  const getJobsByStatus = useCallback((status: SearchJobStatus): SearchJob[] => {
    return context.jobs.filter(j => j.status === status);
  }, [context.jobs]);

  /**
   * Get latest job of a specific type
   */
  const getLatestJobByType = useCallback((type: SearchJobType): SearchJob | undefined => {
    const jobsOfType = context.jobs.filter(j => j.type === type);
    return jobsOfType.length > 0 ? jobsOfType[0] : undefined;
  }, [context.jobs]);

  /**
   * Format job type to Korean label
   */
  const formatJobType = useCallback((type: SearchJobType): string => {
    return JOB_TYPE_LABELS[type] || type;
  }, []);

  /**
   * Format job status to Korean label
   */
  const formatJobStatus = useCallback((status: SearchJobStatus): string => {
    return JOB_STATUS_LABELS[status] || status;
  }, []);

  /**
   * Get job progress info
   */
  const getJobProgress = useCallback((job: SearchJob): { percent: number; label: string } => {
    const percent = job.progress || 0;
    let label = `${percent}%`;

    if (job.currentPhase) {
      label = job.currentPhase;
    } else if (job.status === 'PENDING') {
      label = '대기 중...';
    } else if (job.status === 'RUNNING' && percent === 0) {
      label = '시작 중...';
    } else if (job.status === 'COMPLETED') {
      label = '완료';
    } else if (job.status === 'FAILED') {
      label = job.errorMessage || '실패';
    } else if (job.status === 'CANCELLED') {
      label = '취소됨';
    }

    return { percent, label };
  }, []);

  return {
    // From context
    ...context,
    
    // Extended functionality
    watchJob,
    getJobsByType,
    getJobsByStatus,
    getLatestJobByType,
    
    // Utilities
    formatJobType,
    formatJobStatus,
    getJobProgress,
  };
}

/**
 * Hook for watching a single job
 */
export function useWatchJob(jobId: string | null): {
  job: SearchJob | null;
  isLoading: boolean;
  error: string | null;
} {
  const [job, setJob] = useState<SearchJob | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!jobId) {
      setJob(null);
      return;
    }

    setIsLoading(true);
    setError(null);

    let eventSource: EventSource | null = null;
    let pollIntervalId: ReturnType<typeof setInterval> | null = null;
    let isActive = true;

    const fetchJob = async () => {
      try {
        const fetchedJob = await getSearchJobStatus(jobId);
        if (isActive) {
          setJob(fetchedJob);
          setIsLoading(false);
        }
        return fetchedJob;
      } catch (err) {
        if (isActive) {
          setError(err instanceof Error ? err.message : '작업을 불러올 수 없습니다.');
          setIsLoading(false);
        }
        return null;
      }
    };

    const startSSE = async () => {
      try {
        eventSource = await openSearchJobStream(jobId);

        eventSource.addEventListener('job_progress', () => fetchJob());
        eventSource.addEventListener('job_completed', () => fetchJob());
        eventSource.addEventListener('job_failed', () => fetchJob());
        eventSource.addEventListener('job_cancelled', () => fetchJob());

        eventSource.onerror = () => {
          // Fall back to polling
          if (!pollIntervalId) {
            pollIntervalId = setInterval(async () => {
              const updatedJob = await fetchJob();
              if (updatedJob && ['COMPLETED', 'FAILED', 'CANCELLED'].includes(updatedJob.status)) {
                if (pollIntervalId) {
                  clearInterval(pollIntervalId);
                  pollIntervalId = null;
                }
              }
            }, 3000);
          }
        };
      } catch {
        // Fall back to polling
        pollIntervalId = setInterval(async () => {
          const updatedJob = await fetchJob();
          if (updatedJob && ['COMPLETED', 'FAILED', 'CANCELLED'].includes(updatedJob.status)) {
            if (pollIntervalId) {
              clearInterval(pollIntervalId);
              pollIntervalId = null;
            }
          }
        }, 3000);
      }
    };

    // Initial fetch
    fetchJob().then((initialJob) => {
      if (initialJob && !['COMPLETED', 'FAILED', 'CANCELLED'].includes(initialJob.status)) {
        startSSE();
      }
    });

    return () => {
      isActive = false;
      if (eventSource) {
        eventSource.close();
      }
      if (pollIntervalId) {
        clearInterval(pollIntervalId);
      }
    };
  }, [jobId]);

  return { job, isLoading, error };
}

// Default export is the extended hook
export default useSearchJobsExtended;

```

---

## frontend/src/hooks/useSearchRecord.ts

```ts
import { useState, useCallback, useEffect, useMemo } from 'react';
import {
  getSearchHistoryById,
  getDerivedSearches,
  type SearchHistoryRecord,
  type SearchHistoryType,
} from '@/lib/api';

/**
 * Extracted URL data from search results
 */
export interface ExtractedUrl {
  url: string;
  title?: string;
  snippet?: string;
  source?: string;
  reliability?: 'high' | 'medium' | 'low';
}

/**
 * Priority URL format compatible with ParallelSearch/DeepSearch/FactCheck
 */
export interface PriorityUrl {
  id: string;
  url: string;
  name: string;
  description?: string;
  reliability?: 'high' | 'medium' | 'low';
}

interface UseSearchRecordOptions {
  /** Search history ID to load */
  searchId?: number;
  /** Auto-load on mount */
  autoLoad?: boolean;
}

interface UseSearchRecordReturn {
  // State
  record: SearchHistoryRecord | null;
  derivedSearches: SearchHistoryRecord[];
  loading: boolean;
  error: string | null;
  
  // Extracted data
  extractedUrls: ExtractedUrl[];
  priorityUrls: PriorityUrl[];
  aiSummary: string | null;
  query: string | null;
  searchType: SearchHistoryType | null;
  
  // Actions
  loadRecord: (id: number) => Promise<SearchHistoryRecord | null>;
  loadDerived: (parentId: number) => Promise<SearchHistoryRecord[]>;
  
  // Utilities for passing to other search components
  getNavigationState: () => {
    priorityUrls: PriorityUrl[];
    parentSearchId: number | undefined;
    deriveFrom: number | undefined;
    depthLevel: number;
    query: string;
  } | null;
}

/**
 * Extract URLs from search results array
 */
function extractUrlsFromResults(results: Array<Record<string, unknown>>): ExtractedUrl[] {
  const urls: ExtractedUrl[] = [];
  const seenUrls = new Set<string>();
  
  for (const result of results) {
    const url = result.url as string | undefined;
    if (url && !seenUrls.has(url)) {
      seenUrls.add(url);
      urls.push({
        url,
        title: result.title as string | undefined,
        snippet: result.snippet as string | undefined,
        source: result.source as string | undefined,
        reliability: parseReliability(result.reliabilityScore as number | undefined),
      });
    }
    
    // Also check for nested evidence URLs
    if (Array.isArray(result.evidence)) {
      for (const evidence of result.evidence) {
        const evUrl = (evidence as Record<string, unknown>)?.url as string | undefined;
        if (evUrl && !seenUrls.has(evUrl)) {
          seenUrls.add(evUrl);
          urls.push({
            url: evUrl,
            title: (evidence as Record<string, unknown>)?.title as string | undefined,
            snippet: (evidence as Record<string, unknown>)?.snippet as string | undefined,
            source: (evidence as Record<string, unknown>)?.source as string | undefined,
          });
        }
      }
    }
  }
  
  return urls;
}

/**
 * Convert reliability score to label
 */
function parseReliability(score: number | undefined): 'high' | 'medium' | 'low' | undefined {
  if (score === undefined || score === null) return undefined;
  if (score >= 70) return 'high';
  if (score >= 40) return 'medium';
  return 'low';
}

/**
 * Convert ExtractedUrl to PriorityUrl format
 */
function toPriorityUrl(extracted: ExtractedUrl, index: number): PriorityUrl {
  let hostname = extracted.url;
  try {
    hostname = new URL(extracted.url).hostname;
  } catch {
    // Keep original URL if parsing fails
  }
  
  return {
    id: `extracted-${index}-${Date.now()}`,
    url: extracted.url,
    name: extracted.title || hostname,
    description: extracted.snippet,
    reliability: extracted.reliability,
  };
}

/**
 * Extract AI summary text from aiSummary object
 */
function extractAiSummaryText(aiSummary: Record<string, unknown> | undefined): string | null {
  if (!aiSummary) return null;
  
  // Try common fields where AI content might be stored
  if (typeof aiSummary.content === 'string') return aiSummary.content;
  if (typeof aiSummary.summary === 'string') return aiSummary.summary;
  if (typeof aiSummary.text === 'string') return aiSummary.text;
  if (typeof aiSummary.analysis === 'string') return aiSummary.analysis;
  
  return null;
}

/**
 * Hook for loading and utilizing a search history record.
 * Useful for reusing search results in derived searches (e.g., passing URLs to FactCheck).
 * 
 * @example
 * ``\`tsx
 * // In a component that receives parentSearchId from navigation state
 * const { record, priorityUrls, getNavigationState } = useSearchRecord({
 *   searchId: parentSearchId,
 *   autoLoad: true,
 * });
 * 
 * // Navigate to FactCheck with extracted URLs
 * const navState = getNavigationState();
 * if (navState) {
 *   navigate('/fact-check', { state: navState });
 * }
 * ``\`
 */
export function useSearchRecord(options: UseSearchRecordOptions = {}): UseSearchRecordReturn {
  const { searchId, autoLoad = true } = options;
  
  const [record, setRecord] = useState<SearchHistoryRecord | null>(null);
  const [derivedSearches, setDerivedSearches] = useState<SearchHistoryRecord[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  /**
   * Load a search record by ID
   */
  const loadRecord = useCallback(async (id: number): Promise<SearchHistoryRecord | null> => {
    setLoading(true);
    setError(null);
    
    try {
      const data = await getSearchHistoryById(id);
      setRecord(data);
      return data;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load search record';
      setError(message);
      console.error('Failed to load search record:', err);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);
  
  /**
   * Load derived searches (children) for a parent search
   */
  const loadDerived = useCallback(async (parentId: number): Promise<SearchHistoryRecord[]> => {
    try {
      const data = await getDerivedSearches(parentId);
      setDerivedSearches(data);
      return data;
    } catch (err) {
      console.error('Failed to load derived searches:', err);
      return [];
    }
  }, []);
  
  // Auto-load on mount if searchId is provided
  useEffect(() => {
    if (autoLoad && searchId) {
      loadRecord(searchId);
    }
  }, [autoLoad, searchId, loadRecord]);
  
  /**
   * Extract URLs from loaded record
   */
  const extractedUrls = useMemo((): ExtractedUrl[] => {
    if (!record) return [];
    
    // Use discoveredUrls if available
    if (record.discoveredUrls && record.discoveredUrls.length > 0) {
      return record.discoveredUrls.map((url) => ({ url }));
    }
    
    // Otherwise extract from results
    if (record.results && Array.isArray(record.results)) {
      return extractUrlsFromResults(record.results);
    }
    
    return [];
  }, [record]);
  
  /**
   * Convert to PriorityUrl format for search components
   */
  const priorityUrls = useMemo((): PriorityUrl[] => {
    return extractedUrls.map((url, index) => toPriorityUrl(url, index));
  }, [extractedUrls]);
  
  /**
   * Extract AI summary text
   */
  const aiSummary = useMemo((): string | null => {
    if (!record?.aiSummary) return null;
    return extractAiSummaryText(record.aiSummary);
  }, [record]);
  
  /**
   * Get navigation state for passing to other search pages
   */
  const getNavigationState = useCallback(() => {
    if (!record) return null;
    
    return {
      priorityUrls,
      parentSearchId: record.id,
      deriveFrom: record.id,
      depthLevel: (record.depthLevel || 0) + 1,
      query: record.query,
    };
  }, [record, priorityUrls]);
  
  return {
    record,
    derivedSearches,
    loading,
    error,
    extractedUrls,
    priorityUrls,
    aiSummary,
    query: record?.query || null,
    searchType: record?.searchType || null,
    loadRecord,
    loadDerived,
    getNavigationState,
  };
}

/**
 * Hook for using search record data from navigation state.
 * Automatically loads the parent search if parentSearchId is in location state.
 * 
 * @example
 * ``\`tsx
 * // In FactCheck or DeepSearch page
 * const location = useLocation();
 * const { priorityUrls, parentQuery, isFromHistory } = useSearchRecordFromState(location.state);
 * ``\`
 */
export function useSearchRecordFromState(locationState: unknown) {
  const state = locationState as {
    parentSearchId?: number;
    deriveFrom?: number;
    priorityUrls?: PriorityUrl[];
    query?: string;
    depthLevel?: number;
  } | null;
  
  const searchId = state?.parentSearchId || state?.deriveFrom;
  const { record, loading, priorityUrls: loadedUrls, query } = useSearchRecord({
    searchId,
    autoLoad: !!searchId,
  });
  
  // Prefer URLs from state if provided (more up-to-date), fall back to loaded
  const priorityUrls = state?.priorityUrls?.length ? state.priorityUrls : loadedUrls;
  const parentQuery = state?.query || query;
  const depthLevel = state?.depthLevel || (record?.depthLevel ? record.depthLevel + 1 : 1);
  
  return {
    priorityUrls,
    parentQuery,
    parentSearchId: searchId,
    depthLevel,
    isFromHistory: !!searchId,
    loading,
    record,
  };
}

export default useSearchRecord;

```

---

## frontend/src/hooks/useSearchSuggestions.ts

```ts
import { useState, useEffect, useCallback, useMemo } from "react";

/**
 * 검색 제안 훅
 * - 최근 검색어 저장/불러오기
 * - 검색어 기반 제안 생성
 * - 로컬 스토리지 기반
 */

const STORAGE_KEY = "newsinsight-search-history";
const MAX_HISTORY = 20;
const MAX_SUGGESTIONS = 8;

export interface SearchSuggestion {
  type: "history" | "suggestion" | "trending";
  text: string;
  timestamp?: number;
  count?: number;
}

interface UseSearchSuggestionsOptions {
  /** 기본 제안 키워드 */
  defaultSuggestions?: string[];
  /** 트렌딩 키워드 (API에서 가져올 수 있음) */
  trendingKeywords?: string[];
  /** 최대 제안 수 */
  maxSuggestions?: number;
}

export function useSearchSuggestions(options: UseSearchSuggestionsOptions = {}) {
  const {
    defaultSuggestions = [],
    trendingKeywords = [],
    maxSuggestions = MAX_SUGGESTIONS,
  } = options;

  // 검색 히스토리 상태
  const [searchHistory, setSearchHistory] = useState<SearchSuggestion[]>([]);

  // 초기 로드
  useEffect(() => {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored) as SearchSuggestion[];
        setSearchHistory(parsed);
      }
    } catch (e) {
      console.error("Failed to load search history:", e);
    }
  }, []);

  // 히스토리 저장
  const saveHistory = useCallback((history: SearchSuggestion[]) => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
    } catch (e) {
      console.error("Failed to save search history:", e);
    }
  }, []);

  // 검색어 추가
  const addToHistory = useCallback((query: string) => {
    if (!query.trim()) return;

    const normalizedQuery = query.trim();

    setSearchHistory((prev) => {
      // 기존에 있으면 맨 앞으로 이동
      const filtered = prev.filter(
        (item) => item.text.toLowerCase() !== normalizedQuery.toLowerCase()
      );
      const newItem: SearchSuggestion = {
        type: "history",
        text: normalizedQuery,
        timestamp: Date.now(),
      };
      const updated = [newItem, ...filtered].slice(0, MAX_HISTORY);
      saveHistory(updated);
      return updated;
    });
  }, [saveHistory]);

  // 히스토리에서 제거
  const removeFromHistory = useCallback((query: string) => {
    setSearchHistory((prev) => {
      const updated = prev.filter(
        (item) => item.text.toLowerCase() !== query.toLowerCase()
      );
      saveHistory(updated);
      return updated;
    });
  }, [saveHistory]);

  // 히스토리 전체 삭제
  const clearHistory = useCallback(() => {
    setSearchHistory([]);
    localStorage.removeItem(STORAGE_KEY);
  }, []);

  // 쿼리 기반 제안 생성
  const getSuggestions = useCallback(
    (query: string): SearchSuggestion[] => {
      const normalizedQuery = query.trim().toLowerCase();

      if (!normalizedQuery) {
        // 빈 쿼리일 때는 최근 검색어 + 트렌딩 표시
        const historySuggestions = searchHistory.slice(0, 5);
        const trendingSuggestions: SearchSuggestion[] = trendingKeywords
          .slice(0, 3)
          .map((text) => ({ type: "trending", text }));
        return [...historySuggestions, ...trendingSuggestions].slice(0, maxSuggestions);
      }

      const suggestions: SearchSuggestion[] = [];

      // 히스토리에서 매칭되는 것
      const matchingHistory = searchHistory.filter((item) =>
        item.text.toLowerCase().includes(normalizedQuery)
      );
      suggestions.push(...matchingHistory.slice(0, 4));

      // 트렌딩에서 매칭되는 것
      const matchingTrending = trendingKeywords
        .filter((kw) => kw.toLowerCase().includes(normalizedQuery))
        .map((text): SearchSuggestion => ({ type: "trending", text }));
      suggestions.push(...matchingTrending.slice(0, 2));

      // 기본 제안에서 매칭되는 것
      const matchingDefault = defaultSuggestions
        .filter((kw) => kw.toLowerCase().includes(normalizedQuery))
        .filter((kw) => !suggestions.find((s) => s.text.toLowerCase() === kw.toLowerCase()))
        .map((text): SearchSuggestion => ({ type: "suggestion", text }));
      suggestions.push(...matchingDefault.slice(0, 2));

      // 중복 제거
      const seen = new Set<string>();
      return suggestions
        .filter((s) => {
          const key = s.text.toLowerCase();
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        })
        .slice(0, maxSuggestions);
    },
    [searchHistory, trendingKeywords, defaultSuggestions, maxSuggestions]
  );

  // 최근 검색어 목록
  const recentSearches = useMemo(
    () => searchHistory.slice(0, 5),
    [searchHistory]
  );

  return {
    searchHistory,
    recentSearches,
    addToHistory,
    removeFromHistory,
    clearHistory,
    getSuggestions,
  };
}

export default useSearchSuggestions;

```

---

## frontend/src/hooks/useTrendingTopics.ts

```ts
/**
 * useTrendingTopics - 트렌드 이슈 및 개인화 추천 주제 제공
 * 
 * 기능:
 * - 사용자 검색 기록 기반 개인화 토픽 추천
 * - 백엔드 트렌딩 API 연동 준비 (현재 미구현)
 * 
 * 참고: 트렌딩 토픽 API가 구현되면 fetchTrendingTopics() 함수를 활성화하세요
 */

import { useState, useEffect, useCallback } from 'react';
import { listSearchHistory, type SearchHistoryRecord } from '@/lib/api';

export interface TrendingTopic {
  id: string;
  title: string;
  description?: string;
  category?: string;
  
  // 입장 분포
  stanceDistribution?: {
    pro: number;
    con: number;
    neutral: number;
    proRatio: number;
    conRatio: number;
    neutralRatio: number;
  };
  
  // 메타데이터
  newsCount?: number;
  searchCount?: number;
  lastUpdated: string;
  
  // 트렌드 지표
  trendScore?: number;  // 0-100
  isHot?: boolean;
  isRising?: boolean;
  
  // 액션
  searchUrl: string;
}

interface UseTrendingTopicsReturn {
  topics: TrendingTopic[];
  personalizedTopics: TrendingTopic[];
  isLoading: boolean;
  error: string | null;
  hasTrendingApi: boolean; // 트렌딩 API 사용 가능 여부
  refresh: () => Promise<void>;
}

// 검색 히스토리에서 개인화 토픽 추출
const extractPersonalizedTopics = (history: SearchHistoryRecord[]): TrendingTopic[] => {
  const queryCount = new Map<string, { count: number; lastSearched: string; results: number }>();
  
  // 쿼리별 빈도 계산
  history.forEach(item => {
    const query = item.query.toLowerCase().trim();
    if (query.length < 2) return;
    
    const existing = queryCount.get(query);
    if (existing) {
      existing.count++;
      existing.results += item.resultCount || 0;
      if (new Date(item.createdAt) > new Date(existing.lastSearched)) {
        existing.lastSearched = item.createdAt;
      }
    } else {
      queryCount.set(query, {
        count: 1,
        lastSearched: item.createdAt,
        results: item.resultCount || 0,
      });
    }
  });
  
  // 빈도순 정렬 후 상위 5개 추출
  const sortedQueries = Array.from(queryCount.entries())
    .sort((a, b) => b[1].count - a[1].count)
    .slice(0, 5);
  
  return sortedQueries.map(([query, data], index) => ({
    id: `personal_${index}`,
    title: query.charAt(0).toUpperCase() + query.slice(1),
    description: `${data.count}회 검색, ${data.results}개 결과`,
    searchCount: data.count,
    lastUpdated: data.lastSearched,
    trendScore: Math.min(100, data.count * 20),
    searchUrl: `/search?q=${encodeURIComponent(query)}`,
  }));
};

/**
 * 트렌딩 토픽 및 개인화 추천 Hook
 * 
 * 현재 상태:
 * - 트렌딩 API가 아직 구현되지 않아 topics는 빈 배열 반환
 * - personalizedTopics는 사용자 검색 기록 기반으로 생성
 * 
 * 향후 개선:
 * - 백엔드에 트렌딩 API 구현 후 fetchTrendingTopics() 연동
 * - 예: GET /api/v1/trending/topics
 */
export function useTrendingTopics(): UseTrendingTopicsReturn {
  const [topics, setTopics] = useState<TrendingTopic[]>([]);
  const [personalizedTopics, setPersonalizedTopics] = useState<TrendingTopic[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasTrendingApi] = useState(false); // 트렌딩 API 구현 시 true로 변경

  // 데이터 새로고침
  const refresh = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      // 검색 히스토리에서 개인화 토픽 추출
      const historyResponse = await listSearchHistory(0, 50, 'createdAt', 'DESC');
      const personalTopics = extractPersonalizedTopics(historyResponse.content);
      setPersonalizedTopics(personalTopics);
      
      // TODO: 백엔드 트렌딩 API 구현 시 활성화
      // 예시:
      // try {
      //   const trendingResponse = await fetchTrendingTopics();
      //   setTopics(trendingResponse);
      //   setHasTrendingApi(true);
      // } catch {
      //   // 트렌딩 API 실패 시 빈 배열 유지
      //   setTopics([]);
      // }
      
      // 현재는 트렌딩 API가 없으므로 빈 배열
      setTopics([]);
      
    } catch (e) {
      setError(e instanceof Error ? e.message : '데이터를 불러오는데 실패했습니다.');
      console.error('Failed to load trending topics:', e);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // 초기 로드
  useEffect(() => {
    refresh();
  }, []);

  // 5분마다 자동 새로고침
  useEffect(() => {
    const interval = setInterval(refresh, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, [refresh]);

  return {
    topics,
    personalizedTopics,
    isLoading,
    error,
    hasTrendingApi,
    refresh,
  };
}

export default useTrendingTopics;

```

---

## frontend/src/hooks/useUrlCollection.ts

```ts
import { useState, useCallback, useEffect } from 'react';

// ============================================
// Types
// ============================================

export interface UrlItem {
  id: string;
  type: 'url';
  name: string;
  url: string;
  description?: string;
  tags?: string[];
  createdAt: string;
  lastAnalyzedAt?: string;
  // Citation metadata
  citationIndex?: number;       // [1], [2], etc. for reference
  sourceType?: 'browser_agent' | 'deep_search' | 'unified_search' | 'fact_check' | 'manual';
  sourceQuery?: string;         // Original search query that found this URL
  snippet?: string;             // Text snippet from the page
  accessedAt?: string;          // When the URL was accessed
  category?: UrlCategory;       // Auto-classified category
  reliability?: 'high' | 'medium' | 'low' | 'unknown';
}

export type UrlCategory = 
  | 'news'           // News articles
  | 'academic'       // Academic papers, research
  | 'government'     // Government sites
  | 'social'         // Social media
  | 'blog'           // Blogs, personal sites
  | 'corporate'      // Corporate/business sites
  | 'wiki'           // Wikipedia and wikis
  | 'forum'          // Forums, discussion boards
  | 'ecommerce'      // Shopping sites
  | 'other';         // Uncategorized

export interface FolderItem {
  id: string;
  type: 'folder';
  name: string;
  description?: string;
  children: (UrlItem | FolderItem)[];
  isExpanded?: boolean;
  createdAt: string;
}

export type TreeItem = UrlItem | FolderItem;

export interface UrlCollection {
  version: string;
  name: string;
  description?: string;
  root: FolderItem;
  createdAt: string;
  updatedAt: string;
}

export interface SelectedItems {
  folders: Set<string>;
  urls: Set<string>;
}

// ============================================
// Utility Functions
// ============================================

const generateId = (): string => {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

const createDefaultCollection = (): UrlCollection => ({
  version: '1.0',
  name: 'My URL Collection',
  description: 'URL collection for news analysis',
  root: {
    id: 'root',
    type: 'folder',
    name: 'Root',
    children: [
      // Korean News Sources folder
      {
        id: 'korean-news-sources',
        type: 'folder',
        name: '한국 뉴스 소스',
        description: '주요 한국 뉴스 사이트 모음',
        isExpanded: true,
        createdAt: new Date().toISOString(),
        children: [
          {
            id: 'yonhap-news',
            type: 'url',
            name: '연합뉴스',
            url: 'https://www.yna.co.kr',
            description: '대한민국 대표 통신사',
            tags: ['news', 'korean', 'official'],
            category: 'news',
            reliability: 'high',
            createdAt: new Date().toISOString(),
          },
          {
            id: 'kbs-news',
            type: 'url',
            name: 'KBS 뉴스',
            url: 'https://news.kbs.co.kr',
            description: '한국방송공사 뉴스',
            tags: ['news', 'korean', 'broadcast'],
            category: 'news',
            reliability: 'high',
            createdAt: new Date().toISOString(),
          },
          {
            id: 'chosun-news',
            type: 'url',
            name: '조선일보',
            url: 'https://www.chosun.com',
            description: '조선일보 메인',
            tags: ['news', 'korean', 'newspaper'],
            category: 'news',
            reliability: 'medium',
            createdAt: new Date().toISOString(),
          },
          {
            id: 'joongang-news',
            type: 'url',
            name: '중앙일보',
            url: 'https://www.joongang.co.kr',
            description: '중앙일보 메인',
            tags: ['news', 'korean', 'newspaper'],
            category: 'news',
            reliability: 'medium',
            createdAt: new Date().toISOString(),
          },
          {
            id: 'hankyoreh-news',
            type: 'url',
            name: '한겨레',
            url: 'https://www.hani.co.kr',
            description: '한겨레신문 메인',
            tags: ['news', 'korean', 'newspaper'],
            category: 'news',
            reliability: 'medium',
            createdAt: new Date().toISOString(),
          },
          {
            id: 'donga-news',
            type: 'url',
            name: '동아일보',
            url: 'https://www.donga.com',
            description: '동아일보 메인',
            tags: ['news', 'korean', 'newspaper'],
            category: 'news',
            reliability: 'medium',
            createdAt: new Date().toISOString(),
          },
        ] as UrlItem[],
      },
      // Korean Community/Forum folder
      {
        id: 'korean-communities',
        type: 'folder',
        name: '한국 커뮤니티',
        description: '주요 한국 커뮤니티 및 포럼',
        isExpanded: false,
        createdAt: new Date().toISOString(),
        children: [
          {
            id: 'dcinside',
            type: 'url',
            name: '디시인사이드',
            url: 'https://www.dcinside.com',
            description: '대표 익명 커뮤니티',
            tags: ['community', 'korean', 'forum'],
            category: 'forum',
            reliability: 'low',
            createdAt: new Date().toISOString(),
          },
          {
            id: 'fmkorea',
            type: 'url',
            name: '에펨코리아',
            url: 'https://www.fmkorea.com',
            description: '종합 커뮤니티',
            tags: ['community', 'korean', 'forum'],
            category: 'forum',
            reliability: 'low',
            createdAt: new Date().toISOString(),
          },
          {
            id: 'clien',
            type: 'url',
            name: '클리앙',
            url: 'https://www.clien.net',
            description: 'IT/생활 커뮤니티',
            tags: ['community', 'korean', 'tech'],
            category: 'forum',
            reliability: 'low',
            createdAt: new Date().toISOString(),
          },
          {
            id: 'ruliweb',
            type: 'url',
            name: '루리웹',
            url: 'https://www.ruliweb.com',
            description: '게임/문화 커뮤니티',
            tags: ['community', 'korean', 'gaming'],
            category: 'forum',
            reliability: 'low',
            createdAt: new Date().toISOString(),
          },
        ] as UrlItem[],
      },
      // Tech/IT News folder
      {
        id: 'tech-news-sources',
        type: 'folder',
        name: 'IT/테크 뉴스',
        description: 'IT 및 기술 관련 뉴스',
        isExpanded: false,
        createdAt: new Date().toISOString(),
        children: [
          {
            id: 'zdnet-korea',
            type: 'url',
            name: 'ZDNet Korea',
            url: 'https://zdnet.co.kr',
            description: 'IT 전문 미디어',
            tags: ['tech', 'korean', 'it'],
            category: 'news',
            reliability: 'medium',
            createdAt: new Date().toISOString(),
          },
          {
            id: 'etnews',
            type: 'url',
            name: '전자신문',
            url: 'https://www.etnews.com',
            description: 'IT/전자 전문 미디어',
            tags: ['tech', 'korean', 'it'],
            category: 'news',
            reliability: 'medium',
            createdAt: new Date().toISOString(),
          },
          {
            id: 'bloter',
            type: 'url',
            name: '블로터',
            url: 'https://www.bloter.net',
            description: 'IT 전문 온라인 미디어',
            tags: ['tech', 'korean', 'startup'],
            category: 'news',
            reliability: 'medium',
            createdAt: new Date().toISOString(),
          },
        ] as UrlItem[],
      },
    ] as (FolderItem | UrlItem)[],
    isExpanded: true,
    createdAt: new Date().toISOString(),
  },
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
});

const STORAGE_KEY = 'newsinsight-url-collection';

// Deep clone utility
const deepClone = <T>(obj: T): T => JSON.parse(JSON.stringify(obj));

// URL category classification patterns
const CATEGORY_PATTERNS: Array<{ pattern: RegExp; category: UrlCategory }> = [
  // Korean News sites (prioritized before general news pattern)
  { pattern: /\b(yna\.co\.kr|yonhapnews|kbs\.co\.kr|mbc\.co\.kr|sbs\.co\.kr|jtbc\.co\.kr)\b/i, category: 'news' },
  { pattern: /\b(chosun\.com|joongang\.co\.kr|donga\.com|hani\.co\.kr|khan\.co\.kr|mk\.co\.kr|hankyung\.com|mt\.co\.kr)\b/i, category: 'news' },
  { pattern: /\b(newsis|news1|newsen|edaily|zdnet\.co\.kr|etnews|bloter)\b/i, category: 'news' },
  // Korean Communities/Forums
  { pattern: /\b(dcinside|fmkorea|clien|ruliweb|ppomppu|todayhumor|bobaedream|mlbpark)\b/i, category: 'forum' },
  { pattern: /\b(inven\.co\.kr|theqoo|instiz|humoruniv)\b/i, category: 'forum' },
  // Korean Portals (blog/social)
  { pattern: /\b(naver\.com\/blog|blog\.naver|post\.naver|brunch\.co\.kr)\b/i, category: 'blog' },
  { pattern: /\b(tistory\.com|velog\.io)\b/i, category: 'blog' },
  // Korean Government
  { pattern: /\b(go\.kr|korea\.kr|mois\.go\.kr|mofa\.go\.kr)\b/i, category: 'government' },
  // General News sites
  { pattern: /\b(news|times|post|journal|herald|gazette|tribune|reporter|press|daily|bbc|cnn|reuters|ap|nytimes|washingtonpost|guardian)\b/i, category: 'news' },
  { pattern: /\.(news|media)$/i, category: 'news' },
  // Academic
  { pattern: /\b(arxiv|scholar|pubmed|ncbi|doi|jstor|researchgate|academia|edu|science|nature|ieee|acm)\b/i, category: 'academic' },
  { pattern: /\.edu$/i, category: 'academic' },
  // Government
  { pattern: /\b(gov|government|congress|senate|whitehouse|state\.gov|justice|fda|cdc|nih)\b/i, category: 'government' },
  { pattern: /\.gov$/i, category: 'government' },
  // Social media
  { pattern: /\b(twitter|x\.com|facebook|instagram|tiktok|linkedin|reddit|threads|mastodon|bluesky)\b/i, category: 'social' },
  // Wikipedia/Wiki
  { pattern: /\b(wikipedia|wiki|wikimedia|wiktionary|namu\.wiki|namuwiki)\b/i, category: 'wiki' },
  // Forums
  { pattern: /\b(forum|community|discuss|stackexchange|stackoverflow|quora|answers)\b/i, category: 'forum' },
  // Blogs
  { pattern: /\b(blog|medium|substack|wordpress|blogger|tumblr|ghost)\b/i, category: 'blog' },
  // Corporate
  { pattern: /\b(about|company|corporate|enterprise|business|inc|corp|ltd)\b/i, category: 'corporate' },
  // E-commerce
  { pattern: /\b(amazon|ebay|shop|store|buy|cart|checkout|alibaba|etsy|coupang|gmarket|11st)\b/i, category: 'ecommerce' },
];

// Reliability patterns
const HIGH_RELIABILITY_PATTERNS = [
  /\.gov$/i,
  /\.edu$/i,
  /\.go\.kr$/i, // Korean government
  /\b(reuters|ap|bbc|npr|pbs)\b/i,
  /\b(nature|science|pubmed|arxiv)\b/i,
  // Korean high-reliability sources (major wire services and public broadcasters)
  /\b(yna\.co\.kr|yonhapnews|kbs\.co\.kr|korea\.kr)\b/i,
];

const LOW_RELIABILITY_PATTERNS = [
  /\b(blog|tumblr|wordpress\.com|medium\.com)\b/i,
  /\b(reddit|twitter|facebook|tiktok)\b/i,
  /\b(forum|community)\b/i,
  // Korean community/forum sites (lower reliability for news)
  /\b(dcinside|fmkorea|clien|ruliweb|ppomppu|todayhumor|theqoo|instiz)\b/i,
];

/**
 * Auto-classify URL category based on domain and path
 */
const classifyUrl = (url: string): { category: UrlCategory; reliability: 'high' | 'medium' | 'low' | 'unknown' } => {
  try {
    const urlObj = new URL(url);
    const fullUrl = urlObj.hostname + urlObj.pathname;
    
    // Determine category
    let category: UrlCategory = 'other';
    for (const { pattern, category: cat } of CATEGORY_PATTERNS) {
      if (pattern.test(fullUrl)) {
        category = cat;
        break;
      }
    }
    
    // Determine reliability
    let reliability: 'high' | 'medium' | 'low' | 'unknown' = 'unknown';
    if (HIGH_RELIABILITY_PATTERNS.some(p => p.test(fullUrl))) {
      reliability = 'high';
    } else if (LOW_RELIABILITY_PATTERNS.some(p => p.test(fullUrl))) {
      reliability = 'low';
    } else if (category === 'news' || category === 'academic' || category === 'government') {
      reliability = 'medium';
    }
    
    return { category, reliability };
  } catch {
    return { category: 'other', reliability: 'unknown' };
  }
};

/**
 * Generate auto-tags based on URL
 */
const generateAutoTags = (url: string, category: UrlCategory): string[] => {
  const tags: string[] = [];
  
  // Add category tag
  tags.push(category);
  
  try {
    const urlObj = new URL(url);
    
    // Add domain as tag
    const domain = urlObj.hostname.replace('www.', '').split('.')[0];
    if (domain.length > 2) {
      tags.push(domain);
    }
    
    // Extract keywords from path
    const pathParts = urlObj.pathname.split('/').filter(p => p.length > 3);
    for (const part of pathParts.slice(0, 2)) {
      // Skip common path segments
      if (!['article', 'post', 'page', 'index', 'category'].includes(part.toLowerCase())) {
        tags.push(part.toLowerCase().replace(/[^a-z0-9]/g, '-'));
      }
    }
  } catch {
    // Ignore URL parse errors
  }
  
  return [...new Set(tags)].slice(0, 5); // Dedupe and limit to 5 tags
};

// Find item in tree
const findItemInTree = (
  items: TreeItem[],
  id: string
): { item: TreeItem; parent: FolderItem | null; index: number } | null => {
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (item.id === id) {
      return { item, parent: null, index: i };
    }
    if (item.type === 'folder') {
      const found = findItemInTree(item.children, id);
      if (found) {
        if (found.parent === null) {
          found.parent = item;
        }
        return found;
      }
    }
  }
  return null;
};

// Find folder by id
const findFolderById = (items: TreeItem[], id: string): FolderItem | null => {
  for (const item of items) {
    if (item.id === id && item.type === 'folder') {
      return item;
    }
    if (item.type === 'folder') {
      const found = findFolderById(item.children, id);
      if (found) return found;
    }
  }
  return null;
};

// Get all URLs from selected items (including nested)
const getAllUrlsFromItems = (items: TreeItem[], selectedFolders: Set<string>, selectedUrls: Set<string>): UrlItem[] => {
  const urls: UrlItem[] = [];
  
  const collectUrls = (item: TreeItem) => {
    if (item.type === 'url') {
      if (selectedUrls.has(item.id)) {
        urls.push(item);
      }
    } else {
      // If folder is selected, collect all URLs inside
      if (selectedFolders.has(item.id)) {
        const collectAllNested = (folder: FolderItem) => {
          for (const child of folder.children) {
            if (child.type === 'url') {
              urls.push(child);
            } else {
              collectAllNested(child);
            }
          }
        };
        collectAllNested(item);
      } else {
        // Check nested items
        for (const child of item.children) {
          collectUrls(child);
        }
      }
    }
  };

  for (const item of items) {
    collectUrls(item);
  }

  return urls;
};

// ============================================
// Hook
// ============================================

export function useUrlCollection() {
  const [collection, setCollection] = useState<UrlCollection>(() => {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        return JSON.parse(stored);
      }
    } catch (e) {
      console.error('Failed to load URL collection from storage:', e);
    }
    return createDefaultCollection();
  });

  const [selectedItems, setSelectedItems] = useState<SelectedItems>({
    folders: new Set(),
    urls: new Set(),
  });

  // Save to localStorage whenever collection changes
  useEffect(() => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(collection));
    } catch (e) {
      console.error('Failed to save URL collection:', e);
    }
  }, [collection]);

  // Update collection timestamp
  const updateCollection = useCallback((updater: (col: UrlCollection) => UrlCollection) => {
    setCollection(prev => {
      const updated = updater(deepClone(prev));
      updated.updatedAt = new Date().toISOString();
      return updated;
    });
  }, []);

  // Add folder
  const addFolder = useCallback((parentId: string, name: string, description?: string) => {
    const newFolder: FolderItem = {
      id: generateId(),
      type: 'folder',
      name,
      description,
      children: [],
      isExpanded: true,
      createdAt: new Date().toISOString(),
    };

    updateCollection(col => {
      if (parentId === 'root') {
        col.root.children.push(newFolder);
      } else {
        const parent = findFolderById([col.root], parentId);
        if (parent) {
          parent.children.push(newFolder);
        }
      }
      return col;
    });

    return newFolder.id;
  }, [updateCollection]);

  // Add URL
  const addUrl = useCallback((
    parentId: string,
    url: string,
    name?: string,
    description?: string,
    tags?: string[],
    sourceMetadata?: {
      sourceType?: UrlItem['sourceType'];
      sourceQuery?: string;
      snippet?: string;
      citationIndex?: number;
    }
  ) => {
    // Auto-classify URL
    const { category, reliability } = classifyUrl(url);
    const autoTags = generateAutoTags(url, category);
    
    // Safely extract hostname, fallback to url itself if invalid
    let hostname: string;
    try {
      hostname = new URL(url).hostname;
    } catch {
      hostname = url;
    }
    
    const newUrl: UrlItem = {
      id: generateId(),
      type: 'url',
      name: name || hostname,
      url,
      description,
      tags: tags ? [...new Set([...tags, ...autoTags])] : autoTags,
      createdAt: new Date().toISOString(),
      accessedAt: new Date().toISOString(),
      category,
      reliability,
      ...sourceMetadata,
    };

    updateCollection(col => {
      if (parentId === 'root') {
        col.root.children.push(newUrl);
      } else {
        const parent = findFolderById([col.root], parentId);
        if (parent) {
          parent.children.push(newUrl);
        }
      }
      return col;
    });

    return newUrl.id;
  }, [updateCollection]);

  // Add multiple URLs at once
  const addUrls = useCallback((
    parentId: string,
    urls: Array<{ 
      url: string; 
      name?: string; 
      description?: string; 
      tags?: string[];
      sourceType?: UrlItem['sourceType'];
      sourceQuery?: string;
      snippet?: string;
    }>
  ) => {
    updateCollection(col => {
      const parent = parentId === 'root' 
        ? col.root 
        : findFolderById([col.root], parentId);
      
      if (parent) {
        // Get current citation index for this session
        let citationIndex = parent.children.filter(c => c.type === 'url').length + 1;
        
        for (const urlData of urls) {
          // Auto-classify
          const { category, reliability } = classifyUrl(urlData.url);
          const autoTags = generateAutoTags(urlData.url, category);
          
          // Safely extract hostname, fallback to url itself if invalid
          let hostname: string;
          try {
            hostname = new URL(urlData.url).hostname;
          } catch {
            hostname = urlData.url;
          }
          
          const newUrl: UrlItem = {
            id: generateId(),
            type: 'url',
            name: urlData.name || hostname,
            url: urlData.url,
            description: urlData.description,
            tags: urlData.tags ? [...new Set([...urlData.tags, ...autoTags])] : autoTags,
            createdAt: new Date().toISOString(),
            accessedAt: new Date().toISOString(),
            category,
            reliability,
            sourceType: urlData.sourceType,
            sourceQuery: urlData.sourceQuery,
            snippet: urlData.snippet,
            citationIndex: citationIndex++,
          };
          parent.children.push(newUrl);
        }
      }
      return col;
    });
  }, [updateCollection]);

  // Add URL with full citation metadata (for search results)
  const addCitation = useCallback((
    parentId: string,
    citation: {
      url: string;
      title?: string;
      snippet?: string;
      sourceType: UrlItem['sourceType'];
      sourceQuery: string;
      reliability?: 'high' | 'medium' | 'low';
    }
  ) => {
    const { category, reliability: autoReliability } = classifyUrl(citation.url);
    const autoTags = generateAutoTags(citation.url, category);
    
    // Get next citation index
    const parent = parentId === 'root' 
      ? collection.root 
      : findFolderById([collection.root], parentId);
    const citationIndex = parent 
      ? parent.children.filter(c => c.type === 'url').length + 1 
      : 1;
    
    const newUrl: UrlItem = {
      id: generateId(),
      type: 'url',
      name: citation.title || new URL(citation.url).hostname,
      url: citation.url,
      description: citation.snippet,
      snippet: citation.snippet,
      tags: autoTags,
      createdAt: new Date().toISOString(),
      accessedAt: new Date().toISOString(),
      category,
      reliability: citation.reliability || autoReliability,
      sourceType: citation.sourceType,
      sourceQuery: citation.sourceQuery,
      citationIndex,
    };

    updateCollection(col => {
      const targetParent = parentId === 'root' 
        ? col.root 
        : findFolderById([col.root], parentId);
      if (targetParent) {
        targetParent.children.push(newUrl);
      }
      return col;
    });

    return { id: newUrl.id, citationIndex };
  }, [collection.root, updateCollection]);

  // Get citations for a specific search query
  const getCitationsForQuery = useCallback((sourceQuery: string): UrlItem[] => {
    const citations: UrlItem[] = [];
    const findCitations = (items: TreeItem[]) => {
      for (const item of items) {
        if (item.type === 'url' && item.sourceQuery === sourceQuery) {
          citations.push(item);
        } else if (item.type === 'folder') {
          findCitations(item.children);
        }
      }
    };
    findCitations([collection.root]);
    return citations.sort((a, b) => (a.citationIndex || 0) - (b.citationIndex || 0));
  }, [collection.root]);

  // Get URLs by category
  const getUrlsByCategory = useCallback((category: UrlCategory): UrlItem[] => {
    const urls: UrlItem[] = [];
    const findUrls = (items: TreeItem[]) => {
      for (const item of items) {
        if (item.type === 'url' && item.category === category) {
          urls.push(item);
        } else if (item.type === 'folder') {
          findUrls(item.children);
        }
      }
    };
    findUrls([collection.root]);
    return urls;
  }, [collection.root]);

  // Get URLs by reliability
  const getUrlsByReliability = useCallback((reliability: 'high' | 'medium' | 'low'): UrlItem[] => {
    const urls: UrlItem[] = [];
    const findUrls = (items: TreeItem[]) => {
      for (const item of items) {
        if (item.type === 'url' && item.reliability === reliability) {
          urls.push(item);
        } else if (item.type === 'folder') {
          findUrls(item.children);
        }
      }
    };
    findUrls([collection.root]);
    return urls;
  }, [collection.root]);

  // Update item
  const updateItem = useCallback((id: string, updates: Partial<UrlItem | FolderItem>) => {
    updateCollection(col => {
      const found = findItemInTree([col.root], id);
      if (found) {
        Object.assign(found.item, updates);
      }
      return col;
    });
  }, [updateCollection]);

  // Delete item
  const deleteItem = useCallback((id: string) => {
    updateCollection(col => {
      const removeFromChildren = (children: TreeItem[]): TreeItem[] => {
        return children.filter(child => {
          if (child.id === id) return false;
          if (child.type === 'folder') {
            child.children = removeFromChildren(child.children);
          }
          return true;
        });
      };
      col.root.children = removeFromChildren(col.root.children);
      return col;
    });

    // Remove from selection
    setSelectedItems(prev => {
      const newFolders = new Set(prev.folders);
      const newUrls = new Set(prev.urls);
      newFolders.delete(id);
      newUrls.delete(id);
      return { folders: newFolders, urls: newUrls };
    });
  }, [updateCollection]);

  // Move item to new parent
  const moveItem = useCallback((itemId: string, newParentId: string) => {
    updateCollection(col => {
      // Find and remove item from current location
      let itemToMove: TreeItem | null = null;
      
      const removeFromChildren = (children: TreeItem[]): TreeItem[] => {
        return children.filter(child => {
          if (child.id === itemId) {
            itemToMove = child;
            return false;
          }
          if (child.type === 'folder') {
            child.children = removeFromChildren(child.children);
          }
          return true;
        });
      };
      
      col.root.children = removeFromChildren(col.root.children);

      // Add to new parent
      if (itemToMove) {
        const newParent = newParentId === 'root' 
          ? col.root 
          : findFolderById([col.root], newParentId);
        if (newParent) {
          newParent.children.push(itemToMove);
        }
      }

      return col;
    });
  }, [updateCollection]);

  // Toggle folder expansion
  const toggleFolder = useCallback((id: string) => {
    updateCollection(col => {
      const folder = findFolderById([col.root], id);
      if (folder) {
        folder.isExpanded = !folder.isExpanded;
      }
      return col;
    });
  }, [updateCollection]);

  // Toggle item selection
  const toggleSelection = useCallback((id: string, type: 'folder' | 'url') => {
    setSelectedItems(prev => {
      const set = type === 'folder' ? new Set(prev.folders) : new Set(prev.urls);
      if (set.has(id)) {
        set.delete(id);
      } else {
        set.add(id);
      }
      return type === 'folder' 
        ? { ...prev, folders: set }
        : { ...prev, urls: set };
    });
  }, []);

  // Select all in folder
  const selectAllInFolder = useCallback((folderId: string) => {
    const folder = folderId === 'root' 
      ? collection.root 
      : findFolderById([collection.root], folderId);
    
    if (!folder) return;

    setSelectedItems(prev => {
      const newUrls = new Set(prev.urls);
      const newFolders = new Set(prev.folders);

      const selectRecursive = (f: FolderItem) => {
        for (const child of f.children) {
          if (child.type === 'url') {
            newUrls.add(child.id);
          } else {
            newFolders.add(child.id);
            selectRecursive(child);
          }
        }
      };

      // Include the target folder itself in the selection
      newFolders.add(folder.id);
      selectRecursive(folder);
      return { folders: newFolders, urls: newUrls };
    });
  }, [collection.root]);

  // Clear selection
  const clearSelection = useCallback(() => {
    setSelectedItems({ folders: new Set(), urls: new Set() });
  }, []);

  // Get selected URLs (flattened)
  const getSelectedUrls = useCallback((): UrlItem[] => {
    return getAllUrlsFromItems(
      [collection.root],
      selectedItems.folders,
      selectedItems.urls
    );
  }, [collection.root, selectedItems]);

  // Export to JSON
  const exportToJson = useCallback((): string => {
    return JSON.stringify(collection, null, 2);
  }, [collection]);

  // Export selected to JSON
  const exportSelectedToJson = useCallback((): string => {
    const selectedUrls = getSelectedUrls();
    const exportData = {
      version: '1.0',
      exportedAt: new Date().toISOString(),
      urls: selectedUrls.map(u => ({
        name: u.name,
        url: u.url,
        description: u.description,
        tags: u.tags,
      })),
    };
    return JSON.stringify(exportData, null, 2);
  }, [getSelectedUrls]);

  // Import from JSON
  const importFromJson = useCallback((jsonString: string, targetFolderId: string = 'root') => {
    try {
      const data = JSON.parse(jsonString);
      
      // Check if it's a full collection or just URLs
      if (data.version && data.root) {
        // Full collection import - replace everything
        setCollection({
          ...data,
          updatedAt: new Date().toISOString(),
        });
      } else if (data.urls && Array.isArray(data.urls)) {
        // URL list import - add to target folder
        addUrls(targetFolderId, data.urls);
      } else if (Array.isArray(data)) {
        // Simple URL array
        const urls = data.map((item: any) => ({
          url: typeof item === 'string' ? item : item.url,
          name: typeof item === 'string' ? undefined : item.name,
          description: typeof item === 'string' ? undefined : item.description,
          tags: typeof item === 'string' ? undefined : item.tags,
        }));
        addUrls(targetFolderId, urls);
      }
      return true;
    } catch (e) {
      console.error('Failed to import JSON:', e);
      return false;
    }
  }, [addUrls]);

  // Reset to default
  const resetCollection = useCallback(() => {
    setCollection(createDefaultCollection());
    clearSelection();
  }, [clearSelection]);

  // Mark URLs as analyzed
  const markAsAnalyzed = useCallback((urlIds: string[]) => {
    const now = new Date().toISOString();
    updateCollection(col => {
      const updateRecursive = (items: TreeItem[]) => {
        for (const item of items) {
          if (item.type === 'url' && urlIds.includes(item.id)) {
            item.lastAnalyzedAt = now;
          } else if (item.type === 'folder') {
            updateRecursive(item.children);
          }
        }
      };
      updateRecursive([col.root]);
      return col;
    });
  }, [updateCollection]);

  // Check if a URL already exists in the collection
  const urlExists = useCallback((url: string): boolean => {
    const checkRecursive = (items: TreeItem[]): boolean => {
      for (const item of items) {
        if (item.type === 'url' && item.url === url) {
          return true;
        } else if (item.type === 'folder') {
          if (checkRecursive(item.children)) {
            return true;
          }
        }
      }
      return false;
    };
    return checkRecursive([collection.root]);
  }, [collection.root]);

  // Get all URLs in the collection (flattened)
  const getAllUrls = useCallback((): UrlItem[] => {
    const urls: UrlItem[] = [];
    const collectRecursive = (items: TreeItem[]) => {
      for (const item of items) {
        if (item.type === 'url') {
          urls.push(item);
        } else if (item.type === 'folder') {
          collectRecursive(item.children);
        }
      }
    };
    collectRecursive([collection.root]);
    return urls;
  }, [collection.root]);

  return {
    collection,
    selectedItems,
    selectedCount: selectedItems.folders.size + selectedItems.urls.size,
    
    // CRUD operations
    addFolder,
    addUrl,
    addUrls,
    addCitation,
    updateItem,
    deleteItem,
    moveItem,
    
    // UI state
    toggleFolder,
    toggleSelection,
    selectAllInFolder,
    clearSelection,
    
    // Data access
    getSelectedUrls,
    urlExists,
    getAllUrls,
    getCitationsForQuery,
    getUrlsByCategory,
    getUrlsByReliability,
    
    // Import/Export
    exportToJson,
    exportSelectedToJson,
    importFromJson,
    
    // Misc
    resetCollection,
    markAsAnalyzed,
    
    // Utilities (expose for external use)
    classifyUrl: (url: string) => classifyUrl(url),
    generateAutoTags: (url: string, category: UrlCategory) => generateAutoTags(url, category),
  };
}

export default useUrlCollection;

```

---

## frontend/src/hooks/useUsageStreak.ts

```ts
/**
 * useUsageStreak - 연속 사용 일수 및 활동 통계 추적
 * 
 * 기능:
 * - 연속 사용 일수 (streak) 계산
 * - 주간/월간 검색 횟수
 * - 누적 분석 건수
 * - 사용 패턴 분석
 */

import { useState, useEffect, useCallback, useMemo } from 'react';
import { getSearchStatistics } from '@/lib/api';

export interface DayActivity {
  date: string;  // YYYY-MM-DD
  count: number;
  hasActivity: boolean;
}

export interface UsageStats {
  // 연속 사용
  currentStreak: number;
  longestStreak: number;
  lastActiveDate: string | null;
  
  // 주간 통계
  weeklySearchCount: number;
  weeklyFactCheckCount: number;
  weeklyDeepSearchCount: number;
  weeklyTotal: number;
  
  // 월간/전체 통계
  monthlyTotal: number;
  totalSearches: number;
  totalAnalyses: number;
  
  // 일별 활동 (최근 7일)
  weeklyActivity: DayActivity[];
  
  // 평균
  averageSearchesPerDay: number;
  averageResultsPerSearch: number;
}

interface UseUsageStreakReturn {
  stats: UsageStats;
  isLoading: boolean;
  error: string | null;
  refresh: () => Promise<void>;
  recordActivity: () => void;
  // 편의를 위한 개별 값들 (WorkspaceHub에서 사용)
  streak: number;
  weeklyStats: DayActivity[];
  totalSearches: number;
}

const STORAGE_KEY = 'newsinsight_usage_streak';
const ACTIVITY_STORAGE_KEY = 'newsinsight_daily_activity';

interface StoredStreakData {
  currentStreak: number;
  longestStreak: number;
  lastActiveDate: string | null;
  activityDates: string[];  // YYYY-MM-DD 형식 배열
}

// 날짜를 YYYY-MM-DD 형식으로 변환
const formatDate = (date: Date): string => {
  return date.toISOString().split('T')[0];
};

// 오늘 날짜 (로컬 시간 기준)
const getToday = (): string => {
  const now = new Date();
  return formatDate(new Date(now.getFullYear(), now.getMonth(), now.getDate()));
};

// 어제 날짜
const getYesterday = (): string => {
  const now = new Date();
  const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
  return formatDate(yesterday);
};

// 최근 N일 날짜 배열 생성
const getRecentDates = (days: number): string[] => {
  const dates: string[] = [];
  const now = new Date();
  
  for (let i = days - 1; i >= 0; i--) {
    const date = new Date(now.getFullYear(), now.getMonth(), now.getDate() - i);
    dates.push(formatDate(date));
  }
  
  return dates;
};

// 요일 이름 (한국어)
export const getDayName = (dateStr: string): string => {
  const days = ['일', '월', '화', '수', '목', '금', '토'];
  const date = new Date(dateStr);
  return days[date.getDay()];
};

/**
 * 연속 사용 및 활동 통계 Hook
 */
export function useUsageStreak(): UseUsageStreakReturn {
  const [stats, setStats] = useState<UsageStats>({
    currentStreak: 0,
    longestStreak: 0,
    lastActiveDate: null,
    weeklySearchCount: 0,
    weeklyFactCheckCount: 0,
    weeklyDeepSearchCount: 0,
    weeklyTotal: 0,
    monthlyTotal: 0,
    totalSearches: 0,
    totalAnalyses: 0,
    weeklyActivity: [],
    averageSearchesPerDay: 0,
    averageResultsPerSearch: 0,
  });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // 저장된 streak 데이터 불러오기
  const loadStoredData = useCallback((): StoredStreakData => {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        return JSON.parse(stored);
      }
    } catch (e) {
      console.error('Failed to load streak data:', e);
    }
    return {
      currentStreak: 0,
      longestStreak: 0,
      lastActiveDate: null,
      activityDates: [],
    };
  }, []);

  // streak 데이터 저장
  const saveStoredData = useCallback((data: StoredStreakData) => {
    try {
      // 최근 90일 활동만 유지
      const recentDates = data.activityDates.slice(-90);
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        ...data,
        activityDates: recentDates,
      }));
    } catch (e) {
      console.error('Failed to save streak data:', e);
    }
  }, []);

  // streak 계산
  const calculateStreak = useCallback((activityDates: string[], today: string): { current: number; longest: number } => {
    if (activityDates.length === 0) {
      return { current: 0, longest: 0 };
    }

    // 날짜 정렬 (오름차순)
    const sortedDates = [...new Set(activityDates)].sort();
    
    let currentStreak = 0;
    let longestStreak = 0;
    let tempStreak = 1;
    
    // 오늘 또는 어제 활동이 있어야 현재 streak 유지
    const yesterday = getYesterday();
    const hasRecentActivity = sortedDates.includes(today) || sortedDates.includes(yesterday);
    
    // 연속일 계산
    for (let i = 1; i < sortedDates.length; i++) {
      const prevDate = new Date(sortedDates[i - 1]);
      const currDate = new Date(sortedDates[i]);
      const diffDays = Math.floor((currDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24));
      
      if (diffDays === 1) {
        tempStreak++;
      } else {
        longestStreak = Math.max(longestStreak, tempStreak);
        tempStreak = 1;
      }
    }
    
    longestStreak = Math.max(longestStreak, tempStreak);
    
    // 현재 streak 계산 (가장 최근 연속 활동)
    if (hasRecentActivity) {
      currentStreak = 1;
      const startDate = sortedDates.includes(today) ? today : yesterday;
      let checkDate = new Date(startDate);
      
      for (let i = sortedDates.length - 1; i >= 0; i--) {
        const activityDate = sortedDates[i];
        if (activityDate === formatDate(checkDate)) {
          currentStreak++;
          checkDate.setDate(checkDate.getDate() - 1);
        } else if (activityDate < formatDate(checkDate)) {
          break;
        }
      }
      currentStreak--; // 시작점 중복 제거
    }
    
    return { current: Math.max(0, currentStreak), longest: longestStreak };
  }, []);

  // 서버에서 통계 가져오기 및 로컬 데이터 통합
  const refresh = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const today = getToday();
      const storedData = loadStoredData();
      
      // 서버 통계 가져오기
      let serverStats = null;
      try {
        serverStats = await getSearchStatistics(30);
      } catch (e) {
        console.warn('Failed to fetch server statistics:', e);
      }
      
      // streak 계산
      const { current, longest } = calculateStreak(storedData.activityDates, today);
      
      // 주간 활동 데이터 생성
      const recentDates = getRecentDates(7);
      const weeklyActivity: DayActivity[] = recentDates.map(date => ({
        date,
        count: storedData.activityDates.filter(d => d === date).length || 
               (serverStats ? 1 : 0),  // 서버 데이터 기반 추정
        hasActivity: storedData.activityDates.includes(date),
      }));
      
      // 통계 계산
      const weeklyTotal = serverStats?.totalSearches || storedData.activityDates.filter(d => 
        recentDates.includes(d)
      ).length;
      
      const byType = serverStats?.byType || [];
      const unifiedCount = byType.find(t => t.searchType === 'UNIFIED')?.count || 0;
      const deepCount = byType.find(t => t.searchType === 'DEEP_SEARCH')?.count || 0;
      const factCheckCount = byType.find(t => t.searchType === 'FACT_CHECK')?.count || 0;
      
      // 평균 계산
      const activeDays = storedData.activityDates.length;
      const avgPerDay = activeDays > 0 ? weeklyTotal / Math.min(activeDays, 7) : 0;
      const avgResults = byType.reduce((sum, t) => sum + (t.avgResults || 0), 0) / Math.max(byType.length, 1);
      
      setStats({
        currentStreak: current,
        longestStreak: Math.max(longest, storedData.longestStreak),
        lastActiveDate: storedData.lastActiveDate,
        weeklySearchCount: unifiedCount,
        weeklyFactCheckCount: factCheckCount,
        weeklyDeepSearchCount: deepCount,
        weeklyTotal,
        monthlyTotal: serverStats?.totalSearches || weeklyTotal * 4,
        totalSearches: serverStats?.totalSearches || 0,
        totalAnalyses: deepCount + factCheckCount,
        weeklyActivity,
        averageSearchesPerDay: Math.round(avgPerDay * 10) / 10,
        averageResultsPerSearch: Math.round(avgResults * 10) / 10,
      });
      
      // longest streak 업데이트
      if (longest > storedData.longestStreak) {
        saveStoredData({
          ...storedData,
          longestStreak: longest,
        });
      }
      
    } catch (e) {
      setError(e instanceof Error ? e.message : '통계를 불러오는데 실패했습니다.');
      console.error('Failed to load usage stats:', e);
    } finally {
      setIsLoading(false);
    }
  }, [loadStoredData, saveStoredData, calculateStreak]);

  // 오늘 활동 기록
  const recordActivity = useCallback(() => {
    const today = getToday();
    const storedData = loadStoredData();
    
    // 이미 오늘 기록이 있으면 스킵
    if (storedData.lastActiveDate === today) {
      return;
    }
    
    const newActivityDates = [...storedData.activityDates, today];
    const { current, longest } = calculateStreak(newActivityDates, today);
    
    const newData: StoredStreakData = {
      currentStreak: current,
      longestStreak: Math.max(longest, storedData.longestStreak),
      lastActiveDate: today,
      activityDates: newActivityDates,
    };
    
    saveStoredData(newData);
    
    // 상태 업데이트
    setStats(prev => ({
      ...prev,
      currentStreak: current,
      longestStreak: newData.longestStreak,
      lastActiveDate: today,
    }));
  }, [loadStoredData, saveStoredData, calculateStreak]);

  // 초기 로드
  useEffect(() => {
    refresh();
  }, []);

  // 페이지 방문 시 활동 기록
  useEffect(() => {
    recordActivity();
  }, [recordActivity]);

  return {
    stats,
    isLoading,
    error,
    refresh,
    recordActivity,
    // 편의를 위한 개별 값들 (WorkspaceHub에서 사용)
    streak: stats.currentStreak,
    weeklyStats: stats.weeklyActivity,
    totalSearches: stats.weeklyTotal,
  };
}

export default useUsageStreak;

```

---

## frontend/src/index.css

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Definition of the design system. All colors, gradients, fonts, etc should be defined here. 
All colors MUST be HSL.
*/

@layer base {
  :root {
    --background: 210 30% 98%;
    --foreground: 220 20% 15%;

    --card: 0 0% 100%;
    --card-foreground: 220 20% 15%;

    --popover: 0 0% 100%;
    --popover-foreground: 220 20% 15%;

    --primary: 217 91% 20%;
    --primary-foreground: 0 0% 100%;

    --secondary: 210 40% 96%;
    --secondary-foreground: 220 20% 15%;

    --muted: 210 40% 96%;
    --muted-foreground: 220 15% 45%;

    --accent: 217 91% 60%;
    --accent-foreground: 0 0% 100%;

    --destructive: 0 84% 60%;
    --destructive-foreground: 0 0% 100%;

    --success: 142 71% 45%;
    --success-foreground: 0 0% 100%;

    --warning: 38 92% 50%;
    --warning-foreground: 0 0% 100%;

    --border: 214 32% 91%;
    --input: 214 32% 91%;
    --ring: 217 91% 60%;

    --radius: 0.75rem;

    --gradient-primary: linear-gradient(135deg, hsl(217 91% 20%) 0%, hsl(217 91% 35%) 100%);
    --gradient-accent: linear-gradient(135deg, hsl(217 91% 60%) 0%, hsl(217 91% 75%) 100%);
    --gradient-bg: linear-gradient(180deg, hsl(210 30% 98%) 0%, hsl(210 40% 96%) 100%);
    
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
    --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);

    /* Neutral color palette for balanced viewpoints */
    --teal-50: 166 76% 97%;
    --teal-100: 167 85% 89%;
    --teal-200: 168 84% 78%;
    --teal-500: 172 66% 50%;
    --teal-600: 173 80% 40%;
    --teal-700: 175 77% 26%;
    --teal-900: 176 61% 19%;
    --teal-950: 176 74% 12%;

    --coral-50: 14 100% 97%;
    --coral-100: 14 93% 90%;
    --coral-200: 14 91% 82%;
    --coral-500: 14 89% 55%;
    --coral-600: 14 80% 50%;
    --coral-700: 14 83% 40%;
    --coral-900: 14 68% 25%;
    --coral-950: 14 75% 15%;

    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }

  .dark {
    --background: 220 25% 10%;
    --foreground: 210 40% 98%;

    --card: 220 20% 15%;
    --card-foreground: 210 40% 98%;

    --popover: 220 20% 15%;
    --popover-foreground: 210 40% 98%;

    --primary: 217 91% 60%;
    --primary-foreground: 220 20% 10%;

    --secondary: 220 20% 20%;
    --secondary-foreground: 210 40% 98%;

    --muted: 220 20% 20%;
    --muted-foreground: 220 15% 65%;

    --accent: 217 91% 60%;
    --accent-foreground: 220 20% 10%;

    --destructive: 0 62% 50%;
    --destructive-foreground: 0 0% 100%;

    --success: 142 71% 45%;
    --success-foreground: 0 0% 100%;

    --warning: 38 92% 50%;
    --warning-foreground: 0 0% 100%;

    --border: 220 20% 25%;
    --input: 220 20% 25%;
    --ring: 217 91% 60%;

    --gradient-primary: linear-gradient(135deg, hsl(217 91% 40%) 0%, hsl(217 91% 60%) 100%);
    --gradient-accent: linear-gradient(135deg, hsl(217 91% 60%) 0%, hsl(217 91% 75%) 100%);
    --gradient-bg: linear-gradient(180deg, hsl(220 25% 10%) 0%, hsl(220 20% 15%) 100%);

    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.3);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.4);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.4);
    --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.4);

    /* Dark mode neutral colors */
    --teal-50: 166 50% 15%;
    --teal-100: 167 45% 20%;
    --teal-200: 168 50% 25%;
    --teal-500: 172 66% 50%;
    --teal-600: 173 70% 55%;
    --teal-700: 175 65% 60%;
    --teal-900: 176 50% 25%;
    --teal-950: 176 55% 18%;

    --coral-50: 14 50% 15%;
    --coral-100: 14 45% 20%;
    --coral-200: 14 50% 25%;
    --coral-500: 14 89% 55%;
    --coral-600: 14 80% 60%;
    --coral-700: 14 75% 65%;
    --coral-900: 14 50% 25%;
    --coral-950: 14 55% 18%;

    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
    background: var(--gradient-bg);
    min-height: 100vh;
  }
}

@layer utilities {
  .gradient-primary {
    background: var(--gradient-primary);
  }
  
  .gradient-accent {
    background: var(--gradient-accent);
  }

  .shadow-elegant {
    box-shadow: var(--shadow-lg);
  }

  .card-hover {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .card-hover:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-xl);
  }

  /* Glassmorphism utility classes */
  .glass {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }

  .dark .glass {
    background: rgba(30, 41, 59, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .glass-subtle {
    background: rgba(255, 255, 255, 0.5);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  .dark .glass-subtle {
    background: rgba(30, 41, 59, 0.5);
  }

  /* Insight card specific styles */
  .insight-card {
    @apply rounded-2xl border shadow-lg p-6 md:p-8;
    @apply bg-card/80 backdrop-blur-md border-border/50;
    @apply transition-all duration-300;
  }

  .insight-card:hover {
    @apply shadow-xl;
  }

  /* Progress step animations */
  @keyframes step-pulse {
    0%, 100% {
      transform: scale(1);
      opacity: 1;
    }
    50% {
      transform: scale(1.1);
      opacity: 0.8;
    }
  }

  .step-active {
    animation: step-pulse 2s infinite;
  }

  /* Swipe hint animation */
  @keyframes swipe-hint {
    0%, 100% {
      transform: translateX(0);
      opacity: 1;
    }
    50% {
      transform: translateX(8px);
      opacity: 0.6;
    }
  }

  .swipe-hint {
    animation: swipe-hint 1.5s ease-in-out infinite;
  }

  /* Scroll snap for carousel */
  .snap-x {
    scroll-snap-type: x mandatory;
  }

  .snap-center {
    scroll-snap-align: center;
  }

  .snap-start {
    scroll-snap-align: start;
  }

  /* Hide scrollbar but allow scrolling */
  .scrollbar-hide {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }

  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }

  /* Text balance for headings */
  .text-balance {
    text-wrap: balance;
  }
}

```

---

## frontend/src/lib/adminApi.ts

```ts
import { getApiClient } from './api';
import type {
  Environment,
  EnvironmentStatus,
  Script,
  TaskExecution,
  Document,
  AuditLog,
  User,
  Token,
  SetupStatus,
} from '@/types/admin';

// Auth
export const authApi = {
  login: async (username: string, password: string): Promise<Token> => {
    const client = await getApiClient();
    const formData = new URLSearchParams();
    formData.append('username', username);
    formData.append('password', password);
    
    const response = await client.post('/api/v1/admin/auth/token', formData, {
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    });
    return response.data;
  },
  
  refresh: async (): Promise<Token> => {
    const client = await getApiClient();
    // Browser automatically sends HTTP-Only refresh_token cookie
    const response = await client.post<Token>('/api/v1/admin/auth/refresh', {}, {
      withCredentials: true, // Ensure cookies are sent
    });
    return response.data;
  },
  
  logout: async (): Promise<void> => {
    const client = await getApiClient();
    await client.post('/api/v1/admin/auth/logout');
  },
  
  me: async () => {
    const client = await getApiClient();
    const response = await client.get<User>('/api/v1/admin/auth/me');
    return response.data;
  },
  
  changePassword: async (oldPassword: string, newPassword: string) => {
    const client = await getApiClient();
    const response = await client.post('/api/v1/admin/auth/change-password', { old_password: oldPassword, new_password: newPassword });
    return response.data;
  },
  
  getSetupStatus: async (): Promise<SetupStatus> => {
    const client = await getApiClient();
    const response = await client.get<SetupStatus>('/api/v1/admin/auth/setup-status');
    return response.data;
  },
};

// Environments
export const environmentsApi = {
  list: async (activeOnly = false) => {
    const client = await getApiClient();
    const response = await client.get<Environment[]>(`/api/v1/admin/environments?active_only=${activeOnly}`);
    return response.data;
  },
  
  get: async (id: string) => {
    const client = await getApiClient();
    const response = await client.get<Environment>(`/api/v1/admin/environments/${id}`);
    return response.data;
  },
  
  getStatus: async (id: string) => {
    const client = await getApiClient();
    const response = await client.get<EnvironmentStatus>(`/api/v1/admin/environments/${id}/status`);
    return response.data;
  },
  
  create: async (data: Partial<Environment>) => {
    const client = await getApiClient();
    const response = await client.post<Environment>('/api/v1/admin/environments', data);
    return response.data;
  },
  
  update: async (id: string, data: Partial<Environment>) => {
    const client = await getApiClient();
    const response = await client.patch<Environment>(`/api/v1/admin/environments/${id}`, data);
    return response.data;
  },
  
  delete: async (id: string) => {
    const client = await getApiClient();
    await client.delete(`/api/v1/admin/environments/${id}`);
  },
  
  up: async (id: string, build = true) => {
    const client = await getApiClient();
    await client.post(`/api/v1/admin/environments/${id}/up?build=${build}`);
  },
  
  down: async (id: string, volumes = false) => {
    const client = await getApiClient();
    await client.post(`/api/v1/admin/environments/${id}/down?volumes=${volumes}`);
  },
  
  restart: async (id: string, service?: string) => {
    const client = await getApiClient();
    await client.post(`/api/v1/admin/environments/${id}/restart${service ? `?service=${service}` : ''}`);
  },
  
  logs: async (id: string, service: string, tail = 100) => {
    const client = await getApiClient();
    const response = await client.get<{ service: string; logs: string }>(
      `/api/v1/admin/environments/${id}/logs/${service}?tail=${tail}`
    );
    return response.data;
  },
};

// Scripts
export const scriptsApi = {
  list: async (environment?: string, tag?: string) => {
    const client = await getApiClient();
    const params = new URLSearchParams();
    if (environment) params.append('environment', environment);
    if (tag) params.append('tag', tag);
    const response = await client.get<Script[]>(`/api/v1/admin/scripts?${params}`);
    return response.data;
  },
  
  get: async (id: string) => {
    const client = await getApiClient();
    const response = await client.get<Script>(`/api/v1/admin/scripts/${id}`);
    return response.data;
  },
  
  create: async (data: Partial<Script>) => {
    const client = await getApiClient();
    const response = await client.post<Script>('/api/v1/admin/scripts', data);
    return response.data;
  },
  
  update: async (id: string, data: Partial<Script>) => {
    const client = await getApiClient();
    const response = await client.patch<Script>(`/api/v1/admin/scripts/${id}`, data);
    return response.data;
  },
  
  delete: async (id: string) => {
    const client = await getApiClient();
    await client.delete(`/api/v1/admin/scripts/${id}`);
  },
  
  execute: async (scriptId: string, environmentId: string, parameters: Record<string, unknown> = {}) => {
    const client = await getApiClient();
    const response = await client.post<TaskExecution>('/api/v1/admin/scripts/execute', {
      script_id: scriptId,
      environment_id: environmentId,
      parameters,
    });
    return response.data;
  },
  
  executeStream: async (
    scriptId: string,
    environmentId: string,
    parameters: Record<string, unknown>,
    _onData: (chunk: string) => void
  ) => {
     // Fallback to regular execute for now as axios doesn't support streaming easily
     console.warn("Stream execution falling back to regular execution");
     return scriptsApi.execute(scriptId, environmentId, parameters);
  },
  
  listExecutions: async (scriptId?: string, environmentId?: string, limit = 50) => {
    const client = await getApiClient();
    const params = new URLSearchParams();
    if (scriptId) params.append('script_id', scriptId);
    if (environmentId) params.append('environment_id', environmentId);
    params.append('limit', limit.toString());
    const response = await client.get<TaskExecution[]>(`/api/v1/admin/scripts/executions?${params}`);
    return response.data;
  },
  
  getExecution: async (id: string) => {
    const client = await getApiClient();
    const response = await client.get<TaskExecution>(`/api/v1/admin/scripts/executions/${id}`);
    return response.data;
  },
  
  cancelExecution: async (id: string) => {
    const client = await getApiClient();
    await client.post(`/api/v1/admin/scripts/executions/${id}/cancel`);
  },
};

// Documents
export const documentsApi = {
  list: async (category?: string, tag?: string, environment?: string, search?: string) => {
    const client = await getApiClient();
    const params = new URLSearchParams();
    if (category) params.append('category', category);
    if (tag) params.append('tag', tag);
    if (environment) params.append('environment', environment);
    if (search) params.append('search', search);
    const response = await client.get<Document[]>(`/api/v1/admin/documents?${params}`);
    return response.data;
  },
  
  get: async (id: string) => {
    const client = await getApiClient();
    const response = await client.get<Document>(`/api/v1/admin/documents/${id}`);
    return response.data;
  },
  
  getCategories: async () => {
    const client = await getApiClient();
    const response = await client.get<Record<string, number>>('/api/v1/admin/documents/categories');
    return response.data;
  },
  
  getTags: async () => {
    const client = await getApiClient();
    const response = await client.get<Record<string, number>>('/api/v1/admin/documents/tags');
    return response.data;
  },
  
  getRelated: async (environment?: string, scriptId?: string) => {
    const client = await getApiClient();
    const params = new URLSearchParams();
    if (environment) params.append('environment', environment);
    if (scriptId) params.append('script_id', scriptId);
    const response = await client.get<Document[]>(`/api/v1/admin/documents/related?${params}`);
    return response.data;
  },
  
  refresh: async () => {
    const client = await getApiClient();
    await client.post('/api/v1/admin/documents/refresh');
  },
};

// Audit
export const auditApi = {
  list: async (filters: {
    userId?: string;
    action?: string;
    resourceType?: string;
    environmentId?: string;
    startDate?: string;
    endDate?: string;
    success?: boolean;
    page?: number;
    pageSize?: number;
  } = {}) => {
    const client = await getApiClient();
    const params = new URLSearchParams();
    if (filters.userId) params.append('user_id', filters.userId);
    if (filters.action) params.append('action', filters.action);
    if (filters.resourceType) params.append('resource_type', filters.resourceType);
    if (filters.environmentId) params.append('environment_id', filters.environmentId);
    if (filters.startDate) params.append('start_date', filters.startDate);
    if (filters.endDate) params.append('end_date', filters.endDate);
    if (filters.success !== undefined) params.append('success', filters.success.toString());
    params.append('page', (filters.page || 1).toString());
    params.append('page_size', (filters.pageSize || 50).toString());
    
    const response = await client.get<AuditLog[]>(`/api/v1/admin/audit/logs?${params}`);
    return response.data;
  },
  
  get: async (id: string) => {
    const client = await getApiClient();
    const response = await client.get<AuditLog>(`/api/v1/admin/audit/logs/${id}`);
    return response.data;
  },
  
  statistics: async (startDate?: string, endDate?: string) => {
    const client = await getApiClient();
    const params = new URLSearchParams();
    if (startDate) params.append('start_date', startDate);
    if (endDate) params.append('end_date', endDate);
    const response = await client.get<Record<string, unknown>>(`/api/v1/admin/audit/statistics?${params}`);
    return response.data;
  },
};

// Users (Admin)
export const usersApi = {
  list: async (activeOnly = false) => {
    const client = await getApiClient();
    const response = await client.get<User[]>(`/api/v1/admin/auth/users?active_only=${activeOnly}`);
    return response.data;
  },
  
  get: async (id: string) => {
    const client = await getApiClient();
    const response = await client.get<User>(`/api/v1/admin/auth/users/${id}`);
    return response.data;
  },
  
  create: async (data: { username: string; password: string; email?: string; role: string }) => {
    const client = await getApiClient();
    const response = await client.post<User>('/api/v1/admin/auth/users', data);
    return response.data;
  },
  
  update: async (id: string, data: { email?: string; role?: string; is_active?: boolean }) => {
    const client = await getApiClient();
    const response = await client.patch<User>(`/api/v1/admin/auth/users/${id}`, data);
    return response.data;
  },
  
  resetPassword: async (id: string, newPassword: string) => {
    const client = await getApiClient();
    await client.post(`/api/v1/admin/auth/users/${id}/reset-password`, { new_password: newPassword });
  },
  
  delete: async (id: string) => {
    const client = await getApiClient();
    await client.delete(`/api/v1/admin/auth/users/${id}`);
  },
};

```

---

## frontend/src/lib/anonymous-session.ts

```ts
/**
 * Anonymous Session Management
 * 
 * Generates and manages unique session IDs for anonymous users to prevent
 * data leakage between different browser sessions.
 */

const SESSION_ID_KEY = 'anonymous_session_id';
const DEVICE_ID_KEY = 'anonymous_device_id';

/**
 * Generate a unique session ID
 * Format: sess-{timestamp}-{random}
 */
function generateSessionId(): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 15);
  return `sess-${timestamp}-${random}`;
}

/**
 * Generate a unique device ID (persistent across sessions)
 * Format: device-{uuid}
 */
function generateDeviceId(): string {
  const uuid = crypto.randomUUID();
  return `device-${uuid}`;
}

/**
 * Get or create session ID for the current browser session
 * Session ID is stored in sessionStorage (cleared when browser tab closes)
 */
export function getSessionId(): string {
  if (typeof window === 'undefined') {
    return generateSessionId();
  }

  let sessionId = sessionStorage.getItem(SESSION_ID_KEY);
  
  if (!sessionId) {
    sessionId = generateSessionId();
    sessionStorage.setItem(SESSION_ID_KEY, sessionId);
    console.log('[AnonymousSession] New session ID generated:', sessionId);
  }
  
  return sessionId;
}

/**
 * Get or create device ID for long-term tracking
 * Device ID is stored in localStorage (persistent across sessions)
 */
export function getDeviceId(): string {
  if (typeof window === 'undefined') {
    return generateDeviceId();
  }

  let deviceId = localStorage.getItem(DEVICE_ID_KEY);
  
  if (!deviceId) {
    deviceId = generateDeviceId();
    localStorage.setItem(DEVICE_ID_KEY, deviceId);
    console.log('[AnonymousSession] New device ID generated:', deviceId);
  }
  
  return deviceId;
}

/**
 * Clear session ID (useful for testing or manual session reset)
 */
export function clearSessionId(): void {
  if (typeof window !== 'undefined') {
    sessionStorage.removeItem(SESSION_ID_KEY);
    console.log('[AnonymousSession] Session ID cleared');
  }
}

/**
 * Clear device ID (useful for testing)
 */
export function clearDeviceId(): void {
  if (typeof window !== 'undefined') {
    localStorage.removeItem(DEVICE_ID_KEY);
    console.log('[AnonymousSession] Device ID cleared');
  }
}

/**
 * Get session info for debugging
 */
export function getSessionInfo(): {
  sessionId: string;
  deviceId: string;
  isNewSession: boolean;
} {
  const sessionId = getSessionId();
  const deviceId = getDeviceId();
  
  return {
    sessionId,
    deviceId,
    isNewSession: typeof window !== 'undefined' && !sessionStorage.getItem(SESSION_ID_KEY),
  };
}

```

---

## frontend/src/lib/api/ai.ts

```ts
/**
 * AI Orchestration Controller API
 * Backend: /api/v1/ai
 * 
 * AI 분석 작업 관리 API
 */

import { getApiClient } from '../api';

// ============================================
// Types
// ============================================

export type AiJobStatus = 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';
export type AiSubTaskStatus = 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED';

export interface AiSubTaskDTO {
  subTaskId: string;
  jobId: string;
  providerId: string;
  taskType: string;
  status: AiSubTaskStatus;
  resultJson: string | null;
  errorMessage: string | null;
  retryCount: number;
  createdAt: string;
  updatedAt: string;
  completedAt: string | null;
}

export interface AiJobDTO {
  jobId: string;
  topic: string;
  baseUrl: string | null;
  overallStatus: AiJobStatus;
  subTasks: AiSubTaskDTO[];
  totalTasks: number;
  completedTasks: number;
  failedTasks: number;
  errorMessage: string | null;
  createdAt: string;
  updatedAt: string;
  completedAt: string | null;
}

export interface DeepSearchRequest {
  topic: string;
  baseUrl?: string;
}

export interface AiProviderInfo {
  id: string;
  name: string;
  description?: string;
}

export interface PageResponse<T> {
  content: T[];
  page: number;
  size: number;
  totalElements: number;
  totalPages: number;
}

// ============================================
// API Functions
// ============================================

/**
 * AI 분석 작업 시작
 * POST /api/v1/ai/jobs
 */
export const startAiJob = async (
  request: DeepSearchRequest,
  providers?: string[]
): Promise<AiJobDTO> => {
  const client = await getApiClient();
  const params: Record<string, string> = {};
  if (providers && providers.length > 0) {
    params.providers = providers.join(',');
  }
  
  const response = await client.post<AiJobDTO>('/api/v1/ai/jobs', request, { params });
  return response.data;
};

/**
 * AI 작업 상태 조회
 * GET /api/v1/ai/jobs/{jobId}
 */
export const getAiJob = async (jobId: string): Promise<AiJobDTO> => {
  const client = await getApiClient();
  const response = await client.get<AiJobDTO>(`/api/v1/ai/jobs/${jobId}`);
  return response.data;
};

/**
 * AI 작업 목록 조회
 * GET /api/v1/ai/jobs
 */
export const listAiJobs = async (
  page: number = 0,
  size: number = 20,
  status?: AiJobStatus
): Promise<PageResponse<AiJobDTO>> => {
  const client = await getApiClient();
  const params: Record<string, string | number> = { page, size };
  if (status) params.status = status;
  
  const response = await client.get<PageResponse<AiJobDTO>>('/api/v1/ai/jobs', { params });
  return response.data;
};

/**
 * AI 작업 취소
 * POST /api/v1/ai/jobs/{jobId}/cancel
 */
export const cancelAiJob = async (jobId: string): Promise<AiJobDTO> => {
  const client = await getApiClient();
  const response = await client.post<AiJobDTO>(`/api/v1/ai/jobs/${jobId}/cancel`);
  return response.data;
};

/**
 * 실패한 서브태스크 재시도
 * POST /api/v1/ai/jobs/{jobId}/retry
 */
export const retryAiJob = async (jobId: string): Promise<AiJobDTO> => {
  const client = await getApiClient();
  const response = await client.post<AiJobDTO>(`/api/v1/ai/jobs/${jobId}/retry`);
  return response.data;
};

/**
 * 사용 가능한 AI 제공자 목록 조회
 * GET /api/v1/ai/providers
 */
export const getAiProviders = async (): Promise<AiProviderInfo[]> => {
  const client = await getApiClient();
  const response = await client.get<AiProviderInfo[]>('/api/v1/ai/providers');
  return response.data;
};

/**
 * AI 서비스 상태 확인
 * GET /api/v1/ai/health
 */
export const checkAiHealth = async (): Promise<{
  status: string;
  providers: Record<string, boolean>;
  timestamp: string;
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/ai/health');
  return response.data;
};

// ============================================
// Job Status Polling Hook Support
// ============================================

/**
 * AI 작업 완료 대기 (폴링)
 */
export const pollAiJobCompletion = async (
  jobId: string,
  pollIntervalMs: number = 2000,
  maxWaitMs: number = 300000,
  onProgress?: (job: AiJobDTO) => void
): Promise<AiJobDTO> => {
  const startTime = Date.now();
  
  while (Date.now() - startTime < maxWaitMs) {
    const job = await getAiJob(jobId);
    onProgress?.(job);
    
    if (job.overallStatus === 'COMPLETED') {
      return job;
    }
    
    if (job.overallStatus === 'FAILED' || job.overallStatus === 'CANCELLED') {
      throw new Error(`AI job ${job.overallStatus.toLowerCase()}: ${job.errorMessage || 'Unknown error'}`);
    }
    
    await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
  }
  
  throw new Error('AI job polling timed out');
};

// ============================================
// Utility Functions
// ============================================

/**
 * 작업 상태에 따른 색상 반환
 */
export const getAiJobStatusColor = (status: AiJobStatus): string => {
  const colors: Record<AiJobStatus, string> = {
    PENDING: 'yellow',
    RUNNING: 'blue',
    COMPLETED: 'green',
    FAILED: 'red',
    CANCELLED: 'gray',
  };
  return colors[status];
};

/**
 * 작업 상태 한글화
 */
export const getAiJobStatusLabel = (status: AiJobStatus): string => {
  const labels: Record<AiJobStatus, string> = {
    PENDING: '대기 중',
    RUNNING: '분석 중',
    COMPLETED: '완료',
    FAILED: '실패',
    CANCELLED: '취소됨',
  };
  return labels[status];
};

/**
 * 진행률 계산
 */
export const calculateAiJobProgress = (job: AiJobDTO): number => {
  if (job.totalTasks === 0) return 0;
  return Math.round((job.completedTasks / job.totalTasks) * 100);
};

/**
 * 진행 단계 추출
 */
export interface AiJobStep {
  id: string;
  name: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  provider: string;
  error?: string;
}

export const extractAiJobSteps = (job: AiJobDTO): AiJobStep[] => {
  return job.subTasks.map(task => ({
    id: task.subTaskId,
    name: task.taskType,
    status: task.status.toLowerCase() as AiJobStep['status'],
    provider: task.providerId,
    error: task.errorMessage || undefined,
  }));
};

```

---

## frontend/src/lib/api/collection.ts

```ts
/**
 * Collection Controller API
 * Backend: /api/v1/collections
 * 
 * 데이터 수집 작업 관리 API
 */

import { getApiClient } from '../api';

// ============================================
// Types
// ============================================

export type CollectionJobStatus = 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';

export interface CollectionRequest {
  /** 수집할 소스 ID 배열 (빈 배열이면 모든 활성 소스) */
  sourceIds: number[];
  /** 강제 재수집 여부 */
  force?: boolean;
}

export interface CollectionJobDTO {
  id: number;
  sourceId: number;
  status: CollectionJobStatus;
  startedAt: string | null;
  completedAt: string | null;
  itemsCollected: number;
  errorMessage: string | null;
  createdAt: string;
}

export interface CollectionResponse {
  message: string;
  jobs: CollectionJobDTO[];
  totalJobsStarted: number;
  timestamp: string;
}

export interface CollectionStatsDTO {
  totalSources: number;
  activeSources: number;
  totalItemsCollected: number;
  itemsCollectedToday: number;
  lastCollection: string | null;
}

export interface PageResponse<T> {
  content: T[];
  page: number;
  size: number;
  totalElements: number;
  totalPages: number;
  first: boolean;
  last: boolean;
  hasNext: boolean;
  hasPrevious: boolean;
}

// ============================================
// API Functions
// ============================================

/**
 * 데이터 수집 시작
 * POST /api/v1/collections/start
 */
export const startCollection = async (
  request: CollectionRequest = { sourceIds: [] }
): Promise<CollectionResponse> => {
  const client = await getApiClient();
  const response = await client.post<CollectionResponse>('/api/v1/collections/start', request);
  return response.data;
};

/**
 * 특정 소스에서 수집 시작
 */
export const startCollectionForSource = async (sourceId: number): Promise<CollectionResponse> => {
  return startCollection({ sourceIds: [sourceId] });
};

/**
 * 모든 활성 소스에서 수집 시작
 */
export const startCollectionForAllSources = async (): Promise<CollectionResponse> => {
  return startCollection({ sourceIds: [], force: false });
};

/**
 * 수집 작업 목록 조회
 * GET /api/v1/collections/jobs
 */
export const listCollectionJobs = async (
  page: number = 0,
  size: number = 20,
  status?: CollectionJobStatus
): Promise<PageResponse<CollectionJobDTO>> => {
  const client = await getApiClient();
  const params: Record<string, string | number> = { page, size };
  if (status) params.status = status;
  
  const response = await client.get<PageResponse<CollectionJobDTO>>('/api/v1/collections/jobs', { params });
  return response.data;
};

/**
 * 특정 수집 작업 조회
 * GET /api/v1/collections/jobs/{id}
 */
export const getCollectionJob = async (id: number): Promise<CollectionJobDTO> => {
  const client = await getApiClient();
  const response = await client.get<CollectionJobDTO>(`/api/v1/collections/jobs/${id}`);
  return response.data;
};

/**
 * 수집 작업 취소
 * POST /api/v1/collections/jobs/{id}/cancel
 */
export const cancelCollectionJob = async (id: number): Promise<void> => {
  const client = await getApiClient();
  await client.post(`/api/v1/collections/jobs/${id}/cancel`);
};

/**
 * 수집 통계 조회
 * GET /api/v1/collections/stats
 */
export const getCollectionStats = async (): Promise<CollectionStatsDTO> => {
  const client = await getApiClient();
  const response = await client.get<CollectionStatsDTO>('/api/v1/collections/stats');
  return response.data;
};

/**
 * 오래된 작업 정리
 * DELETE /api/v1/collections/jobs/cleanup
 */
export const cleanupOldJobs = async (daysOld: number = 30): Promise<string> => {
  const client = await getApiClient();
  const response = await client.delete<string>('/api/v1/collections/jobs/cleanup', {
    params: { daysOld },
  });
  return response.data;
};

// ============================================
// Utility Functions
// ============================================

/**
 * 작업 상태에 따른 색상 반환
 */
export const getJobStatusColor = (status: CollectionJobStatus): string => {
  const colors: Record<CollectionJobStatus, string> = {
    PENDING: 'yellow',
    RUNNING: 'blue',
    COMPLETED: 'green',
    FAILED: 'red',
    CANCELLED: 'gray',
  };
  return colors[status];
};

/**
 * 작업 상태 한글화
 */
export const getJobStatusLabel = (status: CollectionJobStatus): string => {
  const labels: Record<CollectionJobStatus, string> = {
    PENDING: '대기 중',
    RUNNING: '수집 중',
    COMPLETED: '완료',
    FAILED: '실패',
    CANCELLED: '취소됨',
  };
  return labels[status];
};

/**
 * 실행 중인 작업 개수 조회
 */
export const getRunningJobsCount = async (): Promise<number> => {
  const jobs = await listCollectionJobs(0, 100, 'RUNNING');
  return jobs.totalElements;
};

```

---

## frontend/src/lib/api/data.ts

```ts
/**
 * Data Controller API
 * Backend: /api/v1/data
 * 
 * 수집된 데이터 관리 API
 */

import { getApiClient } from '../api';

// ============================================
// Types
// ============================================

export interface CollectedDataDTO {
  id: number;
  sourceId: number;
  title: string;
  content: string;
  url: string;
  publishedDate: string | null;
  collectedAt: string;
  contentHash: string;
  metadata: Record<string, unknown>;
  processed: boolean;
}

export interface DataStatsResponse {
  total: number;
  unprocessed: number;
  processed: number;
}

export interface PageResponse<T> {
  content: T[];
  page: number;
  size: number;
  totalElements: number;
  totalPages: number;
  first: boolean;
  last: boolean;
}

// ============================================
// API Functions
// ============================================

/**
 * 수집된 데이터 목록 조회
 * GET /api/v1/data
 */
export const listCollectedData = async (
  page: number = 0,
  size: number = 20,
  sourceId?: number,
  processed?: boolean,
  query?: string
): Promise<PageResponse<CollectedDataDTO>> => {
  const client = await getApiClient();
  const params: Record<string, string | number | boolean> = { page, size };
  if (sourceId !== undefined) params.sourceId = sourceId;
  if (processed !== undefined) params.processed = processed;
  if (query !== undefined && query.trim() !== '') params.query = query.trim();
  
  const response = await client.get<PageResponse<CollectedDataDTO>>('/api/v1/data', { params });
  return response.data;
};

/**
 * 미처리 데이터 목록 조회
 * GET /api/v1/data/unprocessed
 */
export const listUnprocessedData = async (
  page: number = 0,
  size: number = 20
): Promise<PageResponse<CollectedDataDTO>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<CollectedDataDTO>>('/api/v1/data/unprocessed', {
    params: { page, size },
  });
  return response.data;
};

/**
 * 특정 데이터 조회
 * GET /api/v1/data/{id}
 */
export const getCollectedData = async (id: number): Promise<CollectedDataDTO> => {
  const client = await getApiClient();
  const response = await client.get<CollectedDataDTO>(`/api/v1/data/${id}`);
  return response.data;
};

/**
 * 데이터를 처리됨으로 표시
 * POST /api/v1/data/{id}/processed
 */
export const markDataAsProcessed = async (id: number): Promise<void> => {
  const client = await getApiClient();
  await client.post(`/api/v1/data/${id}/processed`);
};

/**
 * 데이터 통계 조회
 * GET /api/v1/data/stats
 */
export const getDataStats = async (): Promise<DataStatsResponse> => {
  const client = await getApiClient();
  const response = await client.get<DataStatsResponse>('/api/v1/data/stats');
  return response.data;
};

// ============================================
// Utility Functions
// ============================================

/**
 * 데이터 소스 타입에 따른 아이콘 반환
 */
export const getSourceIcon = (sourceId: number): string => {
  // 실제 구현에서는 소스 정보를 조회하여 적절한 아이콘 반환
  return 'newspaper';
};

/**
 * 데이터 요약 생성
 */
export const summarizeData = (data: CollectedDataDTO, maxLength: number = 100): string => {
  if (!data.content) return '';
  return data.content.length > maxLength
    ? `${data.content.substring(0, maxLength)}...`
    : data.content;
};

```

---

## frontend/src/lib/api/events.ts

```ts
/**
 * Dashboard Events Controller API
 * Backend: /api/v1/events
 *
 * 대시보드 실시간 이벤트 스트리밍 API
 */

import type { DashboardEvent, DashboardStats } from '@/types/api';
import { appendTokenToUrl } from '@/lib/api';

// ============================================
// SSE Stream URLs
// ============================================

/**
 * 대시보드 이벤트 스트림 URL 생성
 */
export const getDashboardEventsStreamUrl = (): string => {
  const baseUrl =
    typeof window !== 'undefined' ? window.location.origin : '';
  return `${baseUrl}/api/v1/events/stream`;
};

/**
 * 대시보드 통계 스트림 URL 생성
 */
export const getDashboardStatsStreamUrl = (): string => {
  const baseUrl =
    typeof window !== 'undefined' ? window.location.origin : '';
  return `${baseUrl}/api/v1/events/stats/stream`;
};

// ============================================
// SSE Event Source Functions
// ============================================

/**
 * 대시보드 이벤트 SSE 스트림 열기
 *
 * 이벤트 타입:
 * - HEARTBEAT: 연결 유지용 (30초마다)
 * - NEW_DATA: 새로운 데이터 수집됨
 * - SOURCE_UPDATED: 소스 상태 변경
 * - STATS_UPDATED: 통계 갱신
 * - COLLECTION_STARTED: 수집 시작
 * - COLLECTION_COMPLETED: 수집 완료
 * - ERROR: 에러 발생
 */
export const openDashboardEventsStream = (): EventSource => {
  const url = getDashboardEventsStreamUrl();
  // Append auth token for SSE authentication
  return new EventSource(appendTokenToUrl(url));
};

/**
 * 대시보드 통계 SSE 스트림 열기
 * 5초마다 최신 통계를 전송
 */
export const openDashboardStatsStream = (): EventSource => {
  const url = getDashboardStatsStreamUrl();
  // Append auth token for SSE authentication
  return new EventSource(appendTokenToUrl(url));
};

// ============================================
// Event Parsing Utilities
// ============================================

/**
 * SSE 이벤트 데이터를 DashboardEvent로 파싱
 */
export const parseDashboardEvent = (data: string): DashboardEvent | null => {
  try {
    return JSON.parse(data) as DashboardEvent;
  } catch {
    console.error('Failed to parse dashboard event:', data);
    return null;
  }
};

/**
 * SSE 이벤트에서 통계 데이터 추출
 */
export const parseStatsFromEvent = (event: DashboardEvent): DashboardStats | null => {
  if (event.eventType !== 'STATS_UPDATED' || !event.data) {
    return null;
  }

  return {
    totalCollected: (event.data.totalCollected as number) || 0,
    todayCollected: (event.data.todayCollected as number) || 0,
    activeSourceCount: (event.data.activeSourceCount as number) || 0,
    timestamp: (event.data.timestamp as number) || Date.now(),
  };
};

// ============================================
// Event Type Guards
// ============================================

export const isHeartbeat = (event: DashboardEvent): boolean => {
  return event.eventType === 'HEARTBEAT';
};

export const isNewData = (event: DashboardEvent): boolean => {
  return event.eventType === 'NEW_DATA';
};

export const isSourceUpdated = (event: DashboardEvent): boolean => {
  return event.eventType === 'SOURCE_UPDATED';
};

export const isStatsUpdated = (event: DashboardEvent): boolean => {
  return event.eventType === 'STATS_UPDATED';
};

export const isCollectionStarted = (event: DashboardEvent): boolean => {
  return event.eventType === 'COLLECTION_STARTED';
};

export const isCollectionCompleted = (event: DashboardEvent): boolean => {
  return event.eventType === 'COLLECTION_COMPLETED';
};

export const isError = (event: DashboardEvent): boolean => {
  return event.eventType === 'ERROR';
};

// ============================================
// Event Type Labels
// ============================================

export const getEventTypeLabel = (eventType: DashboardEvent['eventType']): string => {
  const labels: Record<DashboardEvent['eventType'], string> = {
    HEARTBEAT: '연결 유지',
    NEW_DATA: '새 데이터 수집',
    SOURCE_UPDATED: '소스 상태 변경',
    STATS_UPDATED: '통계 갱신',
    COLLECTION_STARTED: '수집 시작',
    COLLECTION_COMPLETED: '수집 완료',
    ERROR: '오류',
  };
  return labels[eventType];
};

export const getEventTypeColor = (eventType: DashboardEvent['eventType']): string => {
  const colors: Record<DashboardEvent['eventType'], string> = {
    HEARTBEAT: 'gray',
    NEW_DATA: 'green',
    SOURCE_UPDATED: 'blue',
    STATS_UPDATED: 'cyan',
    COLLECTION_STARTED: 'yellow',
    COLLECTION_COMPLETED: 'green',
    ERROR: 'red',
  };
  return colors[eventType];
};

```

---

## frontend/src/lib/api/index.ts

```ts
/**
 * API 모듈 통합 내보내기
 */

// Collection API
export * from './collection';

// AI Orchestration API
export * from './ai';

// Data API
export * from './data';

// ML Add-on API
export * from './ml';

// MCP Server API (Bias, Factcheck, Topic, Sentiment, NLP)
export * from './mcp';

// Dashboard Events API
export * from './events';

```

---

## frontend/src/lib/api/mcp.ts

```ts
/**
 * MCP (Model Context Protocol) API Client
 * Backend: autonomous-crawler-service /mcp/*
 *
 * MCP 서버들의 분석 기능을 프론트엔드에서 사용하기 위한 API
 * - 편향도 분석 (Bias)
 * - 팩트체크 (Factcheck)
 * - 토픽 분석 (Topic)
 * - 감성 분석 (Sentiment)
 * - NLP 기능 (요약, 개체명 추출)
 */

import { getApiClient } from '../api';

// ============================================
// Types
// ============================================

export interface MCPAddonInfo {
  name: string;
  description: string;
  available: boolean;
  tools: string[];
  port: number;
}

export interface MCPAddonResponse {
  success: boolean;
  addon_name: string;
  data: Record<string, unknown>;
  report?: string;
  error?: string;
  duration_ms: number;
}

export interface MCPHealthResponse {
  status: 'healthy' | 'degraded' | 'unhealthy';
  healthy: number;
  total: number;
  servers: Record<
    string,
    {
      status: string;
      latency_ms?: number;
      error?: string;
    }
  >;
}

export interface KeywordAnalysisRequest {
  keyword: string;
  days?: number;
  include_report?: boolean;
}

export interface TextAnalysisRequest {
  text: string;
  max_length?: number;
  min_length?: number;
}

export interface TrendingTopic {
  topic: string;
  count: number;
  trend: 'up' | 'down' | 'stable';
  category?: string;
}

export interface BiasAnalysisData {
  overall_bias: number; // -1 (좌) ~ 1 (우)
  bias_label: string;
  confidence: number;
  source_distribution: Record<string, number>;
  objectivity_score: number;
}

export interface FactcheckAnalysisData {
  reliability_score: number; // 0 ~ 1
  verified_claims: number;
  unverified_claims: number;
  source_reliability: Record<string, number>;
  citation_quality: number;
}

export interface TopicAnalysisData {
  main_topics: Array<{
    topic: string;
    relevance: number;
  }>;
  category_distribution: Record<string, number>;
  related_entities: string[];
  timeline?: Array<{
    date: string;
    count: number;
  }>;
}

export interface SentimentAnalysisData {
  overall_sentiment: 'positive' | 'negative' | 'neutral';
  sentiment_score: number; // -1 ~ 1
  confidence: number;
  distribution: {
    positive: number;
    negative: number;
    neutral: number;
  };
}

export interface ComprehensiveAnalysisResult {
  success: boolean;
  success_rate: number;
  results: {
    keyword: string;
    days: number;
    bias: MCPAddonResponse | { error: string };
    factcheck: MCPAddonResponse | { error: string };
    topic: MCPAddonResponse | { error: string };
    sentiment: MCPAddonResponse | { error: string };
  };
}

// ============================================
// MCP Add-on Management
// ============================================

/**
 * 등록된 MCP Add-on 목록 조회
 * GET /mcp/addons
 */
export const listMcpAddons = async (): Promise<MCPAddonInfo[]> => {
  const client = await getApiClient();
  // autonomous-crawler API endpoint
  const response = await client.get<MCPAddonInfo[]>('/api/v1/crawler/mcp/addons');
  return response.data;
};

/**
 * MCP 서버 헬스체크
 * GET /mcp/health
 */
export const checkMcpHealth = async (): Promise<MCPHealthResponse> => {
  const client = await getApiClient();
  const response = await client.get<MCPHealthResponse>('/api/v1/crawler/mcp/health');
  return response.data;
};

// ============================================
// Bias Analysis
// ============================================

/**
 * 키워드 관련 뉴스 편향도 분석
 * POST /mcp/bias/analyze
 */
export const analyzeBias = async (
  request: KeywordAnalysisRequest
): Promise<MCPAddonResponse> => {
  const client = await getApiClient();
  const response = await client.post<MCPAddonResponse>('/api/v1/crawler/mcp/bias/analyze', request);
  return response.data;
};

/**
 * 언론사별 편향 참조 데이터 조회
 * GET /mcp/bias/sources
 */
export const getSourceBiasList = async (): Promise<Record<string, unknown>[]> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/crawler/mcp/bias/sources');
  return response.data;
};

// ============================================
// Factcheck Analysis
// ============================================

/**
 * 키워드 관련 뉴스 신뢰도 분석
 * POST /mcp/factcheck/analyze
 */
export const analyzeFactcheck = async (
  request: KeywordAnalysisRequest
): Promise<MCPAddonResponse> => {
  const client = await getApiClient();
  const response = await client.post<MCPAddonResponse>(
    '/api/v1/crawler/mcp/factcheck/analyze',
    request
  );
  return response.data;
};

/**
 * 언론사별 신뢰도 참조 데이터 조회
 * GET /mcp/factcheck/sources
 */
export const getSourceReliabilityList = async (): Promise<Record<string, unknown>[]> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/crawler/mcp/factcheck/sources');
  return response.data;
};

// ============================================
// Topic Analysis
// ============================================

/**
 * 키워드 관련 토픽 분석
 * POST /mcp/topics/analyze
 */
export const analyzeTopic = async (
  request: KeywordAnalysisRequest
): Promise<MCPAddonResponse> => {
  const client = await getApiClient();
  const response = await client.post<MCPAddonResponse>(
    '/api/v1/crawler/mcp/topics/analyze',
    request
  );
  return response.data;
};

/**
 * 트렌딩 토픽 조회 (대시보드용)
 * GET /mcp/topics/trending
 */
export const getTrendingTopics = async (
  days: number = 1,
  limit: number = 10
): Promise<MCPAddonResponse> => {
  const client = await getApiClient();
  const response = await client.get<MCPAddonResponse>('/api/v1/crawler/mcp/topics/trending', {
    params: { days, limit },
  });
  return response.data;
};

/**
 * 뉴스 카테고리 목록 조회
 * GET /mcp/topics/categories
 */
export const getCategoryList = async (): Promise<string[]> => {
  const client = await getApiClient();
  const response = await client.get<string[]>('/api/v1/crawler/mcp/topics/categories');
  return response.data;
};

// ============================================
// Sentiment Analysis
// ============================================

/**
 * 키워드 관련 감성 분석
 * POST /mcp/sentiment/analyze
 */
export const analyzeSentiment = async (
  request: KeywordAnalysisRequest
): Promise<MCPAddonResponse> => {
  const client = await getApiClient();
  const response = await client.post<MCPAddonResponse>(
    '/api/v1/crawler/mcp/sentiment/analyze',
    request
  );
  return response.data;
};

// ============================================
// NLP Functions
// ============================================

/**
 * 텍스트 요약
 * POST /mcp/nlp/summarize
 */
export const summarizeText = async (request: TextAnalysisRequest): Promise<MCPAddonResponse> => {
  const client = await getApiClient();
  const response = await client.post<MCPAddonResponse>('/api/v1/crawler/mcp/nlp/summarize', request);
  return response.data;
};

/**
 * 개체명 추출
 * POST /mcp/nlp/entities
 */
export const extractEntities = async (text: string): Promise<MCPAddonResponse> => {
  const client = await getApiClient();
  const response = await client.post<MCPAddonResponse>('/api/v1/crawler/mcp/nlp/entities', null, {
    params: { text },
  });
  return response.data;
};

// ============================================
// Comprehensive Analysis
// ============================================

/**
 * 종합 분석 (편향도 + 신뢰도 + 토픽 + 감성)
 * POST /mcp/analyze/comprehensive
 */
export const analyzeComprehensive = async (
  request: KeywordAnalysisRequest
): Promise<ComprehensiveAnalysisResult> => {
  const client = await getApiClient();
  const response = await client.post<ComprehensiveAnalysisResult>(
    '/api/v1/crawler/mcp/analyze/comprehensive',
    request
  );
  return response.data;
};

// ============================================
// Utility Functions
// ============================================

/**
 * 편향도 점수를 한글 라벨로 변환
 */
export const getBiasLabel = (score: number): string => {
  if (score < -0.6) return '매우 진보';
  if (score < -0.2) return '진보 성향';
  if (score < 0.2) return '중도';
  if (score < 0.6) return '보수 성향';
  return '매우 보수';
};

/**
 * 편향도 점수에 따른 색상 반환
 */
export const getBiasColor = (score: number): string => {
  if (score < -0.6) return 'blue';
  if (score < -0.2) return 'sky';
  if (score < 0.2) return 'gray';
  if (score < 0.6) return 'orange';
  return 'red';
};

/**
 * 신뢰도 점수를 한글 라벨로 변환
 */
export const getReliabilityLabel = (score: number): string => {
  if (score >= 0.8) return '매우 높음';
  if (score >= 0.6) return '높음';
  if (score >= 0.4) return '보통';
  if (score >= 0.2) return '낮음';
  return '매우 낮음';
};

/**
 * 신뢰도 점수에 따른 색상 반환
 */
export const getReliabilityColor = (score: number): string => {
  if (score >= 0.8) return 'green';
  if (score >= 0.6) return 'lime';
  if (score >= 0.4) return 'yellow';
  if (score >= 0.2) return 'orange';
  return 'red';
};

/**
 * 감성 점수를 한글 라벨로 변환
 */
export const getSentimentLabel = (
  sentiment: 'positive' | 'negative' | 'neutral' | string
): string => {
  const labels: Record<string, string> = {
    positive: '긍정',
    negative: '부정',
    neutral: '중립',
  };
  return labels[sentiment] || sentiment;
};

/**
 * 감성에 따른 색상 반환
 */
export const getSentimentColor = (
  sentiment: 'positive' | 'negative' | 'neutral' | string
): string => {
  const colors: Record<string, string> = {
    positive: 'green',
    negative: 'red',
    neutral: 'gray',
  };
  return colors[sentiment] || 'gray';
};

/**
 * MCP 서버 상태 아이콘/색상 반환
 */
export const getMcpServerStatus = (
  status: string
): { color: string; icon: string; label: string } => {
  switch (status) {
    case 'healthy':
      return { color: 'green', icon: 'check-circle', label: '정상' };
    case 'degraded':
      return { color: 'yellow', icon: 'exclamation-circle', label: '성능 저하' };
    case 'unhealthy':
      return { color: 'red', icon: 'x-circle', label: '오류' };
    default:
      return { color: 'gray', icon: 'question-mark-circle', label: '알 수 없음' };
  }
};

```

---

## frontend/src/lib/api/ml.ts

```ts
/**
 * ML Add-on Controller API
 * Backend: /api/v1/ml
 *
 * ML 애드온 관리 및 분석 실행 API
 */

import { getApiClient } from '../api';
import type {
  MlAddon,
  MlAddonExecution,
  MlAddonRequest,
  MlAddonResponse,
  AddonCategory,
  ExecutionStatus,
  PageResponse,
} from '@/types/api';

// ============================================
// Add-on Registry Management
// ============================================

/**
 * 모든 ML Add-on 목록 조회
 * GET /api/v1/ml/addons
 */
export const listMlAddons = async (): Promise<MlAddon[]> => {
  const client = await getApiClient();
  const response = await client.get<MlAddon[]>('/api/v1/ml/addons');
  return response.data;
};

/**
 * 특정 ML Add-on 조회
 * GET /api/v1/ml/addons/{addonKey}
 */
export const getMlAddon = async (addonKey: string): Promise<MlAddon> => {
  const client = await getApiClient();
  const response = await client.get<MlAddon>(`/api/v1/ml/addons/${addonKey}`);
  return response.data;
};

/**
 * ML Add-on 등록
 * POST /api/v1/ml/addons
 */
export interface CreateMlAddonRequest {
  addonKey: string;
  name: string;
  description?: string;
  category: AddonCategory;
  invokeType: 'HTTP_SYNC' | 'HTTP_ASYNC' | 'QUEUE' | 'FILE_POLL';
  endpointUrl?: string;
  queueTopic?: string;
  storagePath?: string;
  authType?: 'NONE' | 'API_KEY' | 'BEARER_TOKEN' | 'BASIC' | 'OAUTH2';
  authCredentials?: string;
  timeoutMs?: number;
  maxQps?: number;
  maxRetries?: number;
  dependsOn?: string[];
  enabled?: boolean;
  priority?: number;
  config?: Record<string, unknown>;
  healthCheckUrl?: string;
}

export const createMlAddon = async (request: CreateMlAddonRequest): Promise<MlAddon> => {
  const client = await getApiClient();
  const response = await client.post<MlAddon>('/api/v1/ml/addons', request);
  return response.data;
};

/**
 * ML Add-on 수정
 * PUT /api/v1/ml/addons/{addonKey}
 */
export const updateMlAddon = async (
  addonKey: string,
  request: Partial<CreateMlAddonRequest>
): Promise<MlAddon> => {
  const client = await getApiClient();
  const response = await client.put<MlAddon>(`/api/v1/ml/addons/${addonKey}`, request);
  return response.data;
};

/**
 * ML Add-on 활성화/비활성화 토글
 * POST /api/v1/ml/addons/{addonKey}/toggle
 */
export const toggleMlAddon = async (addonKey: string): Promise<{
  addonKey: string;
  enabled: boolean;
  message: string;
}> => {
  const client = await getApiClient();
  const response = await client.post(`/api/v1/ml/addons/${addonKey}/toggle`);
  return response.data;
};

/**
 * ML Add-on 삭제
 * DELETE /api/v1/ml/addons/{addonKey}
 */
export const deleteMlAddon = async (addonKey: string): Promise<{
  message: string;
  deletedKey: string;
}> => {
  const client = await getApiClient();
  const response = await client.delete(`/api/v1/ml/addons/${addonKey}`);
  return response.data;
};

// ============================================
// Analysis Execution
// ============================================

/**
 * 단일 기사 분석 실행
 * POST /api/v1/ml/analyze/{articleId}
 */
export const analyzeArticle = async (
  articleId: number,
  importance: 'realtime' | 'batch' = 'batch'
): Promise<{
  articleId: number;
  batchId: string;
  executionIds: string[];
  message: string;
}> => {
  const client = await getApiClient();
  const response = await client.post(`/api/v1/ml/analyze/${articleId}`, null, {
    params: { importance },
  });
  return response.data;
};

/**
 * 여러 기사 일괄 분석
 * POST /api/v1/ml/analyze/batch
 */
export const analyzeArticlesBatch = async (
  articleIds: number[],
  importance: 'realtime' | 'batch' = 'batch'
): Promise<{
  batchId: string;
  articleCount: number;
  executionIds: string[];
  message: string;
}> => {
  const client = await getApiClient();
  const response = await client.post('/api/v1/ml/analyze/batch', articleIds, {
    params: { importance },
  });
  return response.data;
};

/**
 * 특정 카테고리 Add-on만 실행
 * POST /api/v1/ml/analyze/{articleId}/category/{category}
 */
export const analyzeByCategory = async (
  articleId: number,
  category: AddonCategory
): Promise<MlAddonResponse> => {
  const client = await getApiClient();
  const response = await client.post<MlAddonResponse>(
    `/api/v1/ml/analyze/${articleId}/category/${category}`
  );
  return response.data;
};

/**
 * 직접 분석 요청 (커스텀 입력)
 * POST /api/v1/ml/addons/{addonKey}/analyze
 */
export const analyzeWithAddon = async (
  addonKey: string,
  request: MlAddonRequest
): Promise<MlAddonResponse> => {
  const client = await getApiClient();
  const response = await client.post<MlAddonResponse>(
    `/api/v1/ml/addons/${addonKey}/analyze`,
    request
  );
  return response.data;
};

// ============================================
// Execution History
// ============================================

/**
 * 실행 이력 조회
 * GET /api/v1/ml/executions
 */
export const listMlExecutions = async (
  page: number = 0,
  size: number = 20,
  status?: ExecutionStatus,
  addonKey?: string
): Promise<PageResponse<MlAddonExecution>> => {
  const client = await getApiClient();
  const params: Record<string, string | number> = { page, size };
  if (status) params.status = status;
  if (addonKey) params.addonKey = addonKey;

  const response = await client.get<PageResponse<MlAddonExecution>>('/api/v1/ml/executions', {
    params,
  });
  return response.data;
};

/**
 * 특정 기사의 실행 이력
 * GET /api/v1/ml/executions/article/{articleId}
 */
export const getArticleExecutions = async (articleId: number): Promise<MlAddonExecution[]> => {
  const client = await getApiClient();
  const response = await client.get<MlAddonExecution[]>(
    `/api/v1/ml/executions/article/${articleId}`
  );
  return response.data;
};

// ============================================
// Monitoring & Health
// ============================================

/**
 * Add-on 상태 요약
 * GET /api/v1/ml/status
 */
export interface MlAddonStatusSummary {
  totalAddons: number;
  enabledAddons: number;
  healthyAddons: number;
  unhealthyAddons: number;
  totalExecutionsToday: number;
  successRate: number;
  avgLatencyMs: number;
  byCategory: Record<AddonCategory, number>;
}

export const getMlAddonStatus = async (): Promise<MlAddonStatusSummary> => {
  const client = await getApiClient();
  const response = await client.get<MlAddonStatusSummary>('/api/v1/ml/status');
  return response.data;
};

/**
 * 헬스체크 수동 실행
 * POST /api/v1/ml/health-check
 */
export const runMlHealthCheck = async (): Promise<{
  checkedAt: string;
  results: Array<{
    addonKey: string;
    status: 'HEALTHY' | 'DEGRADED' | 'UNHEALTHY' | 'UNKNOWN';
    latencyMs: number;
    error?: string;
  }>;
}> => {
  const client = await getApiClient();
  const response = await client.post('/api/v1/ml/health-check');
  return response.data;
};

// ============================================
// Utility Functions
// ============================================

/**
 * 카테고리 한글명 반환
 */
export const getCategoryLabel = (category: AddonCategory): string => {
  const labels: Record<AddonCategory, string> = {
    SENTIMENT: '감정 분석',
    CONTEXT: '문맥/의도 분석',
    FACTCHECK: '팩트체크',
    COMMUNITY: '커뮤니티 분석',
    SOURCE_QUALITY: '출처 신뢰도',
    ENTITY_EXTRACTION: '개체명 인식',
    SUMMARIZATION: '요약 생성',
    TOPIC_CLASSIFICATION: '주제 분류',
    TOXICITY: '독성/혐오 탐지',
    MISINFORMATION: '허위정보 탐지',
    CUSTOM: '커스텀',
  };
  return labels[category];
};

/**
 * 실행 상태 색상 반환
 */
export const getExecutionStatusColor = (status: ExecutionStatus): string => {
  const colors: Record<ExecutionStatus, string> = {
    PENDING: 'yellow',
    RUNNING: 'blue',
    SUCCESS: 'green',
    FAILED: 'red',
    TIMEOUT: 'orange',
    CANCELLED: 'gray',
    SKIPPED: 'slate',
  };
  return colors[status];
};

/**
 * 실행 상태 한글명 반환
 */
export const getExecutionStatusLabel = (status: ExecutionStatus): string => {
  const labels: Record<ExecutionStatus, string> = {
    PENDING: '대기 중',
    RUNNING: '실행 중',
    SUCCESS: '성공',
    FAILED: '실패',
    TIMEOUT: '타임아웃',
    CANCELLED: '취소됨',
    SKIPPED: '건너뜀',
  };
  return labels[status];
};

/**
 * 활성화된 Add-on만 필터링
 */
export const filterEnabledAddons = (addons: MlAddon[]): MlAddon[] => {
  return addons.filter((addon) => addon.enabled);
};

/**
 * 카테고리별 Add-on 그룹화
 */
export const groupAddonsByCategory = (addons: MlAddon[]): Record<AddonCategory, MlAddon[]> => {
  return addons.reduce(
    (groups, addon) => {
      const category = addon.category;
      if (!groups[category]) {
        groups[category] = [];
      }
      groups[category].push(addon);
      return groups;
    },
    {} as Record<AddonCategory, MlAddon[]>
  );
};

```

---

## frontend/src/lib/api.ts

```ts
import axios, { type AxiosError, type InternalAxiosRequestConfig } from 'axios';
import type {
  AnalysisResponse,
  ArticlesResponse,
  DataSource,
  PageResponse,
  SourceType,
} from '@/types/api';
import { getSessionId, getDeviceId } from './anonymous-session';

// Storage keys for tokens (shared with AuthContext)
const ACCESS_TOKEN_KEY = 'access_token';
// Note: Refresh token is now stored in HTTP-Only cookie, not localStorage

// Token refresh state management
let isRefreshing = false;
let refreshSubscribers: ((token: string) => void)[] = [];

const subscribeTokenRefresh = (callback: (token: string) => void) => {
  refreshSubscribers.push(callback);
};

const onTokenRefreshed = (token: string) => {
  refreshSubscribers.forEach((callback) => callback(token));
  refreshSubscribers = [];
};

const onRefreshError = () => {
  refreshSubscribers = [];
};

let apiInstance: ReturnType<typeof axios.create> | null = null;

/**
 * 개발 환경에서는 Vite proxy를 통해 상대 경로 사용
 * 프로덕션에서는 환경변수 또는 동적 config 사용
 */
const resolveInitialBaseUrl = (): string => {
  // 개발 환경: Vite proxy 사용 (상대 경로)
  if (import.meta.env.DEV) {
    return '';
  }

  // 프로덕션: 환경변수 우선
  if (import.meta.env.VITE_API_BASE_URL) {
    return import.meta.env.VITE_API_BASE_URL as string;
  }

  // 프로덕션 fallback: 현재 호스트 사용
  if (typeof window !== 'undefined') {
    return window.location.origin;
  }

  return '';
};

/**
 * Export API_BASE_URL for direct fetch usage (SSE, etc.)
 */
export const API_BASE_URL = resolveInitialBaseUrl();

const fetchConfiguredBaseUrl = async (initialBaseUrl: string): Promise<string> => {
  // 개발 환경에서는 proxy 사용하므로 config fetch 불필요
  if (import.meta.env.DEV) {
    return '';
  }

  try {
    const configUrl = initialBaseUrl 
      ? `${initialBaseUrl}/api/v1/config/frontend`
      : '/api/v1/config/frontend';
    const response = await fetch(configUrl);
    if (!response.ok) {
      return initialBaseUrl;
    }

    const data = await response.json().catch(() => null) as { apiBaseUrl?: string } | null;
    if (data && typeof data.apiBaseUrl === 'string' && data.apiBaseUrl.length > 0) {
      return data.apiBaseUrl;
    }

    return initialBaseUrl;
  } catch {
    return initialBaseUrl;
  }
};

/**
 * Get access token from localStorage
 */
const getAccessToken = (): string | null => {
  if (typeof window !== 'undefined') {
    return localStorage.getItem(ACCESS_TOKEN_KEY);
  }
  return null;
};

/**
 * Save access token to localStorage and cookie
 * Note: Refresh token is handled via HTTP-Only cookie by the server
 */
const saveTokens = (accessToken: string): void => {
  if (typeof window !== 'undefined') {
    localStorage.setItem(ACCESS_TOKEN_KEY, accessToken);
    // Also set access token as cookie for SSE/EventSource requests
    document.cookie = `access_token=${accessToken}; path=/; SameSite=Lax`;
  }
};

/**
 * Clear all auth tokens from storage
 * Note: HTTP-Only refresh token cookie is cleared by the logout endpoint
 */
const clearTokens = (): void => {
  if (typeof window !== 'undefined') {
    localStorage.removeItem(ACCESS_TOKEN_KEY);
    localStorage.removeItem('token_type');
    localStorage.removeItem('admin_user');
    document.cookie = 'access_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT';
  }
};

/**
 * Refresh access token using HTTP-Only cookie
 * The refresh token is stored in an HTTP-Only cookie and sent automatically
 * Returns new access token or null if refresh fails
 */
const refreshAccessToken = async (): Promise<string | null> => {
  try {
    // Use fetch directly to avoid interceptor loops
    // Browser will automatically send the HTTP-Only refresh_token cookie
    const baseURL = resolveInitialBaseUrl();
    const response = await fetch(`${baseURL}/api/v1/admin/auth/refresh`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include', // Important: include cookies in the request
    });

    if (!response.ok) {
      return null;
    }

    const data = await response.json();
    // Server sets new refresh token as HTTP-Only cookie automatically
    return data.access_token;
  } catch (error) {
    console.error('Token refresh failed:', error);
    return null;
  }
};

/**
 * Append authentication token to URL for SSE connections.
 * EventSource doesn't support custom headers, so we use query parameter.
 */
export const appendTokenToUrl = (url: string): string => {
  const token = getAccessToken();
  if (!token) return url;
  
  const separator = url.includes('?') ? '&' : '?';
  return `${url}${separator}token=${encodeURIComponent(token)}`;
};

/**
 * Create an authenticated EventSource for SSE connections.
 * Appends the JWT token as a query parameter since EventSource doesn't support headers.
 */
export const createAuthenticatedEventSource = (url: string): EventSource => {
  return new EventSource(appendTokenToUrl(url));
};

export const getApiClient = async () => {
  if (apiInstance) {
    return apiInstance;
  }

  const initialBase = resolveInitialBaseUrl();
  const baseURL = await fetchConfiguredBaseUrl(initialBase);

  apiInstance = axios.create({
    baseURL,
    timeout: 15000,
    headers: {
      'Content-Type': 'application/json',
    },
    withCredentials: true, // Include cookies in requests
  });

  // Request interceptor to add Authorization and Session headers
  apiInstance.interceptors.request.use(
    (config) => {
      const token = getAccessToken();
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      
      // Always add session headers for anonymous user tracking
      config.headers['X-Session-Id'] = getSessionId();
      config.headers['X-Device-Id'] = getDeviceId();
      
      return config;
    },
    (error) => {
      return Promise.reject(error);
    }
  );

  // Response interceptor to handle 401 errors with automatic token refresh
  apiInstance.interceptors.response.use(
    (response) => response,
    async (error: AxiosError) => {
      const originalRequest = error.config as InternalAxiosRequestConfig & { _retry?: boolean };
      
      // Check if error is 401 and we haven't already tried to refresh
      if (error.response?.status === 401 && originalRequest && !originalRequest._retry) {
        // Skip token refresh for auth endpoints to avoid infinite loops
        const isAuthEndpoint = originalRequest.url?.includes('/auth/refresh') || 
                               originalRequest.url?.includes('/auth/token') ||
                               originalRequest.url?.includes('/auth/login');
        
        // Skip token refresh for public endpoints that should work without auth
        // These endpoints may return 401 if an invalid token is sent, but they don't require auth
        const isPublicEndpoint = originalRequest.url?.includes('/api/v1/reports/') ||
                                 originalRequest.url?.includes('/api/v1/search/') ||
                                 originalRequest.url?.includes('/api/v1/analysis/') ||
                                 originalRequest.url?.includes('/api/v1/factcheck-chat/');
        
        if (isAuthEndpoint || isPublicEndpoint) {
          return Promise.reject(error);
        }

        // If already refreshing, wait for the refresh to complete
        if (isRefreshing) {
          return new Promise((resolve, reject) => {
            subscribeTokenRefresh((newToken: string) => {
              originalRequest.headers.Authorization = `Bearer ${newToken}`;
              resolve(apiInstance!.request(originalRequest));
            });
            // Add timeout to avoid hanging indefinitely
            setTimeout(() => reject(error), 10000);
          });
        }

        // Start refreshing
        originalRequest._retry = true;
        isRefreshing = true;

        try {
          // refreshAccessToken uses HTTP-Only cookie automatically
          const newAccessToken = await refreshAccessToken();
          
          if (newAccessToken) {
            // Save new access token (refresh token is in HTTP-Only cookie)
            saveTokens(newAccessToken);
            
            // Update the failed request with new token
            originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
            
            // Notify all subscribers
            onTokenRefreshed(newAccessToken);
            
            // Dispatch event for AuthContext to update its state
            if (typeof window !== 'undefined') {
              window.dispatchEvent(new CustomEvent('auth:tokenRefreshed', {
                detail: {
                  accessToken: newAccessToken,
                }
              }));
            }
            
            isRefreshing = false;
            
            // Retry the original request
            return apiInstance!.request(originalRequest);
          } else {
            // Refresh failed, clear tokens and notify
            onRefreshError();
            clearTokens();
            isRefreshing = false;
            
            if (typeof window !== 'undefined') {
              window.dispatchEvent(new CustomEvent('auth:unauthorized'));
            }
            return Promise.reject(error);
          }
        } catch (refreshError) {
          // Refresh threw an error
          onRefreshError();
          clearTokens();
          isRefreshing = false;
          
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new CustomEvent('auth:unauthorized'));
          }
          return Promise.reject(error);
        }
      }
      
      return Promise.reject(error);
    }
  );

  return apiInstance;
};

/**
 * Reset API client (useful after logout to clear any cached state)
 */
export const resetApiClient = () => {
  apiInstance = null;
};

export const getAnalysis = async (query: string, window: string = '7d'): Promise<AnalysisResponse> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/analysis', {
    params: { query, window },
  });
  return response.data;
};

/**
 * Check if live analysis is available.
 * Returns provider info (perplexity or crawl+aidove fallback).
 */
export const checkLiveAnalysisHealth = async (): Promise<{
  enabled: boolean;
  provider: string;
  perplexityEnabled?: boolean;
  crawlEnabled?: boolean;
  message: string;
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/analysis/live/health');
  return response.data;
};

export const openLiveAnalysisStream = async (
  query: string,
  window: string = '7d',
): Promise<EventSource> => {
  const initialBase = resolveInitialBaseUrl();
  const baseURL = await fetchConfiguredBaseUrl(initialBase);
  const url = new URL('/api/v1/analysis/live', baseURL);
  url.searchParams.set('query', query);
  url.searchParams.set('window', window);
  return createAuthenticatedEventSource(url.toString());
};

export const getArticles = async (query: string, limit: number = 50): Promise<ArticlesResponse> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/articles', {
    params: { query, limit },
  });
  return response.data;
};

export interface CreateDataSourcePayload {
  name: string;
  url: string;
  sourceType: SourceType;
  collectionFrequency?: number;
  metadata?: Record<string, unknown>;
  searchUrlTemplate?: string;
  searchPriority?: number;
}

export const listSources = async (
  page: number = 0,
  size: number = 20,
  sortBy: string = 'id',
  sortDirection: 'ASC' | 'DESC' = 'DESC',
): Promise<PageResponse<DataSource>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<DataSource>>('/api/v1/sources', {
    params: { page, size, sortBy, sortDirection },
  });
  return response.data;
};

export const createSource = async (payload: CreateDataSourcePayload): Promise<DataSource> => {
  const client = await getApiClient();
  const response = await client.post<DataSource>('/api/v1/sources', payload);
  return response.data;
};

export const setSourceActive = async (id: number, active: boolean): Promise<DataSource> => {
  const client = await getApiClient();
  const path = active ? `/api/v1/sources/${id}/activate` : `/api/v1/sources/${id}/deactivate`;
  const response = await client.post<DataSource>(path);
  return response.data;
};

/**
 * Get a single data source by ID
 * GET /api/v1/sources/{id}
 */
export const getSource = async (id: number): Promise<DataSource> => {
  const client = await getApiClient();
  const response = await client.get<DataSource>(`/api/v1/sources/${id}`);
  return response.data;
};

/**
 * Get all active data sources
 * GET /api/v1/sources/active
 */
export const listActiveSources = async (
  page: number = 0,
  size: number = 100,
): Promise<PageResponse<DataSource>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<DataSource>>('/api/v1/sources/active', {
    params: { page, size },
  });
  return response.data;
};

/**
 * Update data source request payload
 */
export interface UpdateDataSourcePayload {
  name?: string;
  url?: string;
  sourceType?: SourceType;
  collectionFrequency?: number;
  metadata?: Record<string, unknown>;
  searchUrlTemplate?: string;
  searchPriority?: number;
}

/**
 * Update a data source
 * PUT /api/v1/sources/{id}
 */
export const updateSource = async (id: number, payload: UpdateDataSourcePayload): Promise<DataSource> => {
  const client = await getApiClient();
  const response = await client.put<DataSource>(`/api/v1/sources/${id}`, payload);
  return response.data;
};

/**
 * Delete a data source
 * DELETE /api/v1/sources/{id}
 */
export const deleteSource = async (id: number): Promise<void> => {
  const client = await getApiClient();
  await client.delete(`/api/v1/sources/${id}`);
};

// ============================================
// Deep AI Search API (n8n Crawl Agent)
// ============================================

export interface DeepSearchJob {
  jobId: string;
  topic: string;
  baseUrl?: string;
  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED' | 'CANCELLED' | 'TIMEOUT';
  evidenceCount?: number;
  errorMessage?: string;
  createdAt: string;
  completedAt?: string;
}

export type SourceCategory = 'news' | 'community' | 'blog' | 'official' | 'academic';

export interface Evidence {
  id: number;
  url: string;
  title?: string;
  stance: 'pro' | 'con' | 'neutral';
  snippet: string;
  source?: string;
  sourceCategory?: SourceCategory;
}

export interface StanceDistribution {
  pro: number;
  con: number;
  neutral: number;
  proRatio: number;
  conRatio: number;
  neutralRatio: number;
}

export interface DeepSearchResult extends DeepSearchJob {
  evidence: Evidence[];
  stanceDistribution: StanceDistribution;
}

export interface DeepSearchRequest {
  topic: string;
  baseUrl?: string;
}

/**
 * Start a new deep AI search job.
 * Returns immediately with job details; results are delivered asynchronously.
 */
export const startDeepSearch = async (request: DeepSearchRequest): Promise<DeepSearchJob> => {
  const client = await getApiClient();
  const response = await client.post<DeepSearchJob>('/api/v1/analysis/deep', request);
  return response.data;
};

/**
 * Get the status of a deep search job.
 */
export const getDeepSearchStatus = async (jobId: string): Promise<DeepSearchJob> => {
  const client = await getApiClient();
  const response = await client.get<DeepSearchJob>(`/api/v1/analysis/deep/${jobId}`);
  return response.data;
};

/**
 * Get the full results of a completed deep search, including evidence.
 */
export const getDeepSearchResult = async (jobId: string): Promise<DeepSearchResult> => {
  const client = await getApiClient();
  const response = await client.get<DeepSearchResult>(`/api/v1/analysis/deep/${jobId}/result`);
  return response.data;
};

/**
 * List all deep search jobs with optional filtering.
 */
export const listDeepSearchJobs = async (
  page: number = 0,
  size: number = 20,
  status?: string,
): Promise<PageResponse<DeepSearchJob>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<DeepSearchJob>>('/api/v1/analysis/deep', {
    params: { page, size, ...(status && { status }) },
  });
  return response.data;
};

/**
 * Cancel a pending or in-progress deep search job.
 */
export const cancelDeepSearch = async (jobId: string): Promise<DeepSearchJob> => {
  const client = await getApiClient();
  const response = await client.post<DeepSearchJob>(`/api/v1/analysis/deep/${jobId}/cancel`);
  return response.data;
};

/**
 * Poll for deep search completion.
 * Returns when the job is completed, failed, or times out.
 * 
 * NOTE: Deep search can take several minutes. The default maxWaitMs is 10 minutes.
 * For real-time updates, consider using SSE via useDeepSearchSSE hook instead.
 */
export const pollDeepSearchResult = async (
  jobId: string,
  pollIntervalMs: number = 3000,
  maxWaitMs: number = 600000,  // 10 minutes (Deep search can take a long time)
): Promise<DeepSearchResult> => {
  const startTime = Date.now();
  
  while (Date.now() - startTime < maxWaitMs) {
    const status = await getDeepSearchStatus(jobId);
    
    if (status.status === 'COMPLETED') {
      return getDeepSearchResult(jobId);
    }
    
    if (status.status === 'FAILED' || status.status === 'CANCELLED' || status.status === 'TIMEOUT') {
      throw new Error(`Deep search ${status.status.toLowerCase()}: ${status.errorMessage || 'Unknown error'}`);
    }
    
    // Wait before next poll
    await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
  }
  
  throw new Error('Deep search polling timed out. The job may still be running in the background.');
};

/**
 * Check if deep search service is available.
 */
export const checkDeepSearchHealth = async (): Promise<{
  enabled: boolean;
  webhookUrl: string;
  callbackBaseUrl: string;
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/analysis/deep/health');
  return response.data;
};

/**
 * Drill-down request for deeper investigation on a specific evidence.
 */
export interface DrilldownRequest {
  /** Original topic of the parent search */
  parentTopic: string;
  /** Job ID of the parent search (for tracking) */
  parentJobId?: string;
  /** The evidence item to drill down on */
  evidence: {
    url: string;
    title?: string;
    snippet: string;
    stance: 'pro' | 'con' | 'neutral';
  };
  /** Specific aspect to focus on (optional) */
  focusAspect?: string;
  /** Depth level of drilling (default: 1) */
  depth?: number;
}

/**
 * Start a drill-down deep search based on a specific evidence item.
 * This allows users to dig deeper into a particular aspect or claim.
 */
export const startDrilldownSearch = async (request: DrilldownRequest): Promise<DeepSearchJob> => {
  const client = await getApiClient();
  
  // Generate a focused topic based on the evidence
  const focusedTopic = request.focusAspect 
    ? `${request.focusAspect} - ${request.parentTopic}`
    : request.evidence.title || request.evidence.snippet.substring(0, 100);
  
  const response = await client.post<DeepSearchJob>('/api/v1/analysis/deep', {
    topic: focusedTopic,
    baseUrl: request.evidence.url,
    parentJobId: request.parentJobId,
    depth: (request.depth || 0) + 1,
  });
  return response.data;
};

/**
 * Get the SSE stream URL for a deep search job.
 * This URL can be used with EventSource for real-time updates.
 */
export const getDeepSearchStreamUrl = async (jobId: string): Promise<string> => {
  const initialBase = resolveInitialBaseUrl();
  const baseURL = await fetchConfiguredBaseUrl(initialBase);
  return `${baseURL}/api/v1/analysis/deep/${jobId}/stream`;
};

/**
 * Open SSE stream for deep search job status updates.
 * Returns an EventSource that emits real-time updates about the job.
 * 
 * Event types:
 * - status: Job status changed (PENDING, IN_PROGRESS, COMPLETED, FAILED, etc.)
 * - progress: Progress update with percentage and message
 * - evidence: New evidence collected
 * - complete: Job completed with full result
 * - error: Error occurred
 * - heartbeat: Keep-alive signal
 */
export const openDeepSearchStream = async (jobId: string): Promise<EventSource> => {
  const url = await getDeepSearchStreamUrl(jobId);
  return createAuthenticatedEventSource(url);
};


// ============================================
// Browser-Use API with Human-in-the-Loop
// ============================================

/**
 * Browser-Use는 항상 API Gateway를 통해 상대 경로로 호출한다.
 * 외부 경로: /api/browser-use/**
 */
const getBrowserUseBaseUrl = (): string => {
  return '/api/browser-use';
};

const BROWSER_USE_BASE_URL = getBrowserUseBaseUrl();

export type BrowserJobStatus = 'pending' | 'running' | 'waiting_human' | 'completed' | 'failed' | 'cancelled';
export type InterventionType = 'captcha' | 'login' | 'navigation' | 'extraction' | 'confirmation' | 'custom';

export interface BrowseRequest {
  task: string;
  url?: string;
  session_id?: string;
  max_steps?: number;
  timeout_seconds?: number;
  headless?: boolean;
  enable_human_intervention?: boolean;
  auto_request_intervention?: boolean;
  use_proxy_rotation?: boolean;
}

export interface BrowseResponse {
  job_id: string;
  status: BrowserJobStatus;
  message: string;
  result?: string;
  steps_taken: number;
  urls_visited: string[];
  screenshots: string[];
  error?: string;
  started_at?: string;
  completed_at?: string;
  intervention_requested?: boolean;
  intervention_type?: InterventionType;
}

export interface BrowserJobStatusResponse {
  job_id: string;
  status: BrowserJobStatus;
  progress: number;
  current_step: number;
  max_steps: number;
  result?: string;
  error?: string;
  urls_visited: string[];
  started_at?: string;
  completed_at?: string;
  intervention_requested: boolean;
  intervention_type?: InterventionType;
  intervention_reason?: string;
  intervention_screenshot?: string;
  current_url?: string;
}

export interface HumanAction {
  action_type: 'click' | 'type' | 'navigate' | 'scroll' | 'custom' | 'skip' | 'abort';
  selector?: string;
  value?: string;
  x?: number;
  y?: number;
  custom_script?: string;
  message?: string;
}

export interface BrowserHealthResponse {
  status: string;
  version: string;
  uptime_seconds: number;
  active_jobs: number;
  waiting_intervention: number;
}

// WebSocket message types
export interface BrowserWSMessage {
  type: 'step_update' | 'intervention_requested' | 'completed' | 'failed' | 'cancelled' | 'screenshot' | 'intervention_accepted' | 'intervention_result' | 'error';
  job_id?: string;
  step?: number;
  progress?: number;
  current_url?: string;
  screenshot?: string;
  intervention_type?: InterventionType;
  reason?: string;
  suggested_actions?: string[];
  result?: string;
  error?: string;
  message?: string;
  success?: boolean;
  data?: string;
}

/**
 * Check browser-use service health
 */
export const checkBrowserUseHealth = async (): Promise<BrowserHealthResponse> => {
  const response = await fetch(`${BROWSER_USE_BASE_URL}/health`);
  if (!response.ok) {
    throw new Error('Browser-use service unavailable');
  }
  return response.json();
};

/**
 * Start a browser automation task
 */
export const startBrowserTask = async (request: BrowseRequest): Promise<BrowseResponse> => {
  const response = await fetch(`${BROWSER_USE_BASE_URL}/browse`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request),
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
    throw new Error(error.detail || 'Failed to start browser task');
  }
  return response.json();
};

/**
 * Get browser job status
 */
export const getBrowserJobStatus = async (jobId: string): Promise<BrowserJobStatusResponse> => {
  const response = await fetch(`${BROWSER_USE_BASE_URL}/jobs/${jobId}`);
  if (!response.ok) {
    throw new Error('Failed to get job status');
  }
  return response.json();
};

/**
 * Submit human intervention action
 */
export const submitIntervention = async (jobId: string, action: HumanAction): Promise<{ message: string }> => {
  const response = await fetch(`${BROWSER_USE_BASE_URL}/jobs/${jobId}/intervene`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(action),
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
    throw new Error(error.detail || 'Failed to submit intervention');
  }
  return response.json();
};

/**
 * Request manual intervention for a running job
 */
export const requestManualIntervention = async (
  jobId: string,
  interventionType: InterventionType = 'custom',
  reason: string = 'Manual intervention requested'
): Promise<{ message: string; screenshot?: string; current_url?: string }> => {
  const response = await fetch(
    `${BROWSER_USE_BASE_URL}/jobs/${jobId}/request-intervention?intervention_type=${interventionType}&reason=${encodeURIComponent(reason)}`,
    { method: 'POST' }
  );
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
    throw new Error(error.detail || 'Failed to request intervention');
  }
  return response.json();
};

/**
 * Get current screenshot from browser session
 */
export const getBrowserScreenshot = async (jobId: string): Promise<{ screenshot?: string; current_url?: string }> => {
  const response = await fetch(`${BROWSER_USE_BASE_URL}/jobs/${jobId}/screenshot`);
  if (!response.ok) {
    throw new Error('Failed to get screenshot');
  }
  return response.json();
};

/**
 * Cancel a browser job
 */
export const cancelBrowserJob = async (jobId: string): Promise<{ message: string }> => {
  const response = await fetch(`${BROWSER_USE_BASE_URL}/jobs/${jobId}`, {
    method: 'DELETE',
  });
  if (!response.ok) {
    throw new Error('Failed to cancel job');
  }
  return response.json();
};

/**
 * List browser jobs
 */
export const listBrowserJobs = async (
  status?: BrowserJobStatus,
  limit: number = 20
): Promise<Array<{
  job_id: string;
  task: string;
  status: BrowserJobStatus;
  progress: number;
  intervention_requested: boolean;
  intervention_type?: InterventionType;
  started_at?: string;
  completed_at?: string;
}>> => {
  const params = new URLSearchParams({ limit: String(limit) });
  if (status) params.append('status', status);
  
  const response = await fetch(`${BROWSER_USE_BASE_URL}/jobs?${params}`);
  if (!response.ok) {
    throw new Error('Failed to list jobs');
  }
  return response.json();
};

/**
 * Get WebSocket URL for browser job
 * 항상 API Gateway의 /api/browser-use/ws 경로를 사용한다.
 */
export const getBrowserWSUrl = (jobId: string): string => {
  return `/api/browser-use/ws/${jobId}`;
};


// ============================================
// API Key Provisioning API
// ============================================

/**
 * Supported API providers for auto-provisioning
 */
export type APIProvider = 'openai' | 'anthropic' | 'google' | 'openrouter' | 'together_ai' | 'perplexity' | 'brave_search' | 'tavily';

/**
 * API Key provision request
 */
export interface APIKeyProvisionRequest {
  provider: APIProvider;
  key_name?: string;
  auto_save?: boolean;
  timeout_seconds?: number;
  headless?: boolean;
}

/**
 * API Key provision response
 */
export interface APIKeyProvisionResponse {
  job_id: string;
  status: string;
  provider: string;
  message: string;
  api_key_masked?: string;
  saved_to_settings?: boolean;
  error?: string;
  requires_intervention?: boolean;
  intervention_type?: string;
}

/**
 * Provider info for display
 */
export interface ProviderInfo {
  name: string;
  display_name: string;
  api_keys_url: string;
}

/**
 * Get list of supported API providers
 */
export const getAPIKeyProviders = async (): Promise<{ providers: ProviderInfo[] }> => {
  const response = await fetch(`${BROWSER_USE_BASE_URL}/api-key/providers`);
  if (!response.ok) {
    throw new Error('Failed to get providers list');
  }
  return response.json();
};

/**
 * Start API key provisioning task
 */
export const startAPIKeyProvisioning = async (request: APIKeyProvisionRequest): Promise<APIKeyProvisionResponse> => {
  const response = await fetch(`${BROWSER_USE_BASE_URL}/api-key/provision`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request),
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
    throw new Error(error.detail || 'Failed to start API key provisioning');
  }
  return response.json();
};

/**
 * Notify that login has been completed for provisioning job
 */
export const notifyLoginComplete = async (jobId: string): Promise<{ message: string }> => {
  const response = await fetch(`${BROWSER_USE_BASE_URL}/api-key/provision/${jobId}/login-complete`, {
    method: 'POST',
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
    throw new Error(error.detail || 'Failed to notify login completion');
  }
  return response.json();
};

/**
 * Submit 2FA code for provisioning job
 */
export const submitProvision2FA = async (jobId: string, code: string): Promise<{ message: string }> => {
  const response = await fetch(`${BROWSER_USE_BASE_URL}/api-key/provision/${jobId}/submit-2fa?code=${encodeURIComponent(code)}`, {
    method: 'POST',
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
    throw new Error(error.detail || 'Failed to submit 2FA code');
  }
  return response.json();
};


// ============================================
// Unified Search API (Parallel Search + Deep Analysis)
// ============================================

/**
 * Search result from any source (database, web, AI)
 */
export interface UnifiedSearchResult {
  id: string;
  source: 'database' | 'web' | 'ai';
  sourceLabel: string;
  title: string;
  snippet?: string;
  /** Full content text (not truncated) - used for export/analysis */
  content?: string;
  url?: string;
  publishedAt?: string;
  relevanceScore?: number;
  category?: string;
  
  // Analysis fields (only for database source)
  analyzed?: boolean;
  analysisStatus?: 'pending' | 'partial' | 'complete';
  
  // Reliability
  reliabilityScore?: number;
  reliabilityGrade?: 'high' | 'medium' | 'low';
  reliabilityColor?: 'green' | 'yellow' | 'red';
  
  // Sentiment
  sentimentLabel?: 'positive' | 'negative' | 'neutral';
  sentimentScore?: number;
  
  // Bias
  biasLabel?: string;
  biasScore?: number;
  
  // Factcheck
  factcheckStatus?: 'verified' | 'suspicious' | 'conflicting' | 'unverified';
  misinfoRisk?: 'low' | 'mid' | 'high';
  
  // Tags & topics
  riskTags?: string[];
  topics?: string[];
  
  // Discussion
  hasDiscussion?: boolean;
  totalCommentCount?: number;
  discussionSentiment?: string;
}

/**
 * Search event from SSE stream
 */
export interface UnifiedSearchEvent {
  eventType: 'status' | 'result' | 'ai_chunk' | 'complete' | 'error';
  source: 'database' | 'web' | 'ai';
  message?: string;
  result?: UnifiedSearchResult;
  totalCount?: number;
}

/**
 * Fact verification status
 */
export type VerificationStatus = 
  | 'VERIFIED'
  | 'PARTIALLY_VERIFIED'
  | 'UNVERIFIED'
  | 'DISPUTED'
  | 'FALSE'
  | 'NEEDS_CONTEXT';

/**
 * Claim verification result
 */
export interface ClaimVerification {
  claim: string;
  status: VerificationStatus;
  credibilityScore: number;
  summary: string;
  sources: TrustedSource[];
  verifiedAt: string;
}

/**
 * Trusted source for fact verification
 */
export interface TrustedSource {
  name: string;
  url: string;
  excerpt: string;
  retrievedAt: string;
}

/**
 * Deep analysis event from SSE stream
 */
export interface DeepAnalysisEvent {
  eventType: 'status' | 'verification_result' | 'analysis_chunk' | 'complete' | 'error';
  message?: string;
  verification?: ClaimVerification;
  overallCredibility?: number;
}

/**
 * Open SSE stream for parallel search
 * @param query - Search query string
 * @param window - Time window (1d, 7d, 30d)
 * @param priorityUrls - Optional array of URLs to prioritize in the search
 */
export const openUnifiedSearchStream = async (
  query: string,
  window: string = '7d',
  priorityUrls?: string[],
): Promise<EventSource> => {
  const initialBase = resolveInitialBaseUrl();
  const baseURL = await fetchConfiguredBaseUrl(initialBase);
  
  // 개발 환경에서 baseURL이 빈 문자열이면 현재 origin 사용
  const effectiveBaseURL = baseURL || (typeof globalThis.window !== 'undefined' ? globalThis.window.location.origin : '');
  const url = new URL('/api/v1/search/stream', effectiveBaseURL);
  url.searchParams.set('query', query);
  url.searchParams.set('window', window);
  if (priorityUrls && priorityUrls.length > 0) {
    url.searchParams.set('priorityUrls', priorityUrls.join(','));
  }
  return createAuthenticatedEventSource(url.toString());
};

/**
 * Open SSE stream for deep analysis with fact verification
 * @param topic - Topic to analyze
 * @param claims - Claims to verify
 * @param referenceUrls - Optional array of URLs to use as additional sources
 */
export const openDeepAnalysisStream = async (
  topic: string,
  claims: string[],
  referenceUrls?: string[],
): Promise<Response> => {
  const initialBase = resolveInitialBaseUrl();
  const baseURL = await fetchConfiguredBaseUrl(initialBase);
  
  // For POST with body, we need to use fetch with ReadableStream
  const response = await fetch(`${baseURL}/api/v1/search/deep/stream`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'text/event-stream',
    },
    body: JSON.stringify({ 
      topic, 
      claims, 
      ...(referenceUrls && referenceUrls.length > 0 && { referenceUrls })
    }),
  });
  
  if (!response.ok) {
    throw new Error('Failed to start deep analysis');
  }
  
  return response;
};

/**
 * Check unified search service health
 */
export const checkUnifiedSearchHealth = async (): Promise<{
  status: string;
  features: {
    parallelSearch: boolean;
    deepAnalysis: boolean;
    factVerification: boolean;
  };
  description: string;
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/search/health');
  return response.data;
};

// ============================================
// Job-based Unified Search API (supports SSE reconnection)
// ============================================

/**
 * Search job response from the API
 */
export interface UnifiedSearchJob {
  jobId: string;
  query: string;
  window: string;
  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';
  createdAt: number;
  completedAt?: number;
  streamUrl: string;
}

/**
 * Start a new unified search job.
 * Returns immediately with job details; results are delivered via SSE.
 * 
 * @param query - Search query string
 * @param window - Time window (1d, 7d, 30d, or 'custom' for custom date range)
 * @param priorityUrls - Optional array of URLs to prioritize for web crawling
 * @param startDate - Optional start date for custom date range (ISO string)
 * @param endDate - Optional end date for custom date range (ISO string)
 */
export const startUnifiedSearchJob = async (
  query: string,
  window: string = '7d',
  priorityUrls?: string[],
  startDate?: string,
  endDate?: string,
): Promise<UnifiedSearchJob> => {
  const client = await getApiClient();
  const response = await client.post<UnifiedSearchJob>('/api/v1/search/jobs', {
    query,
    window,
    ...(priorityUrls && priorityUrls.length > 0 && { priorityUrls }),
    ...(startDate && { startDate }),
    ...(endDate && { endDate }),
  });
  return response.data;
};

/**
 * Get the status of a unified search job.
 */
export const getUnifiedSearchJobStatus = async (jobId: string): Promise<UnifiedSearchJob> => {
  const client = await getApiClient();
  const response = await client.get<UnifiedSearchJob>(`/api/v1/search/jobs/${jobId}`);
  return response.data;
};

/**
 * Get the SSE stream URL for a unified search job.
 */
export const getUnifiedSearchJobStreamUrl = async (jobId: string): Promise<string> => {
  const initialBase = resolveInitialBaseUrl();
  const baseURL = await fetchConfiguredBaseUrl(initialBase);
  const effectiveBaseURL = baseURL || (typeof globalThis.window !== 'undefined' ? globalThis.window.location.origin : '');
  return `${effectiveBaseURL}/api/v1/search/jobs/${jobId}/stream`;
};

/**
 * Open SSE stream for unified search job results.
 * Supports reconnection - client can reconnect with same jobId.
 * 
 * Event types:
 * - job_status: Initial job status on connection
 * - status: Source status update (database, web, ai)
 * - result: Search result from a source
 * - ai_chunk: AI response chunk for streaming
 * - source_complete: A source finished searching
 * - source_error: A source encountered an error
 * - done: All sources completed
 * - job_error: Job failed
 * - heartbeat: Keep-alive signal
 */
export const openUnifiedSearchJobStream = async (jobId: string): Promise<EventSource> => {
  const url = await getUnifiedSearchJobStreamUrl(jobId);
  return createAuthenticatedEventSource(url);
};

// ============================================
// Search History API
// ============================================

/**
 * Search type enumeration
 */
export type SearchHistoryType = 'UNIFIED' | 'DEEP_SEARCH' | 'FACT_CHECK' | 'BROWSER_AGENT';

/**
 * Search history record
 */
export interface SearchHistoryRecord {
  id: number;
  externalId?: string;
  searchType: SearchHistoryType;
  query: string;
  timeWindow?: string;
  userId?: string;
  sessionId?: string;
  parentSearchId?: number;
  depthLevel?: number;
  resultCount?: number;
  results?: Array<Record<string, unknown>>;
  aiSummary?: Record<string, unknown>;
  discoveredUrls?: string[];
  factCheckResults?: Array<Record<string, unknown>>;
  credibilityScore?: number;
  stanceDistribution?: Record<string, unknown>;
  metadata?: Record<string, unknown>;
  bookmarked?: boolean;
  tags?: string[];
  notes?: string;
  durationMs?: number;
  errorMessage?: string;
  success?: boolean;
  createdAt: string;
  updatedAt?: string;
}

/**
 * Request payload for saving search history
 */
export interface SaveSearchHistoryRequest {
  externalId?: string;
  searchType: SearchHistoryType;
  query: string;
  timeWindow?: string;
  userId?: string;
  sessionId?: string;
  parentSearchId?: number;
  depthLevel?: number;
  resultCount?: number;
  results?: Array<Record<string, unknown>>;
  aiSummary?: Record<string, unknown>;
  discoveredUrls?: string[];
  factCheckResults?: Array<Record<string, unknown>>;
  credibilityScore?: number;
  stanceDistribution?: Record<string, unknown>;
  metadata?: Record<string, unknown>;
  durationMs?: number;
  errorMessage?: string;
  success?: boolean;
}

/**
 * Save search history asynchronously (via Kafka)
 */
export const saveSearchHistory = async (request: SaveSearchHistoryRequest): Promise<{
  message: string;
  externalId: string;
  searchType: string;
  query: string;
}> => {
  const client = await getApiClient();
  const response = await client.post('/api/v1/search-history', request);
  return response.data;
};

/**
 * Save search history synchronously
 */
export const saveSearchHistorySync = async (request: SaveSearchHistoryRequest): Promise<SearchHistoryRecord> => {
  const client = await getApiClient();
  const response = await client.post<SearchHistoryRecord>('/api/v1/search-history/sync', request);
  return response.data;
};

/**
 * Get search history by ID
 */
export const getSearchHistoryById = async (id: number): Promise<SearchHistoryRecord> => {
  const client = await getApiClient();
  const response = await client.get<SearchHistoryRecord>(`/api/v1/search-history/${id}`);
  return response.data;
};

/**
 * Get search history by external ID (e.g., jobId)
 */
export const getSearchHistoryByExternalId = async (externalId: string): Promise<SearchHistoryRecord> => {
  const client = await getApiClient();
  const response = await client.get<SearchHistoryRecord>(`/api/v1/search-history/external/${externalId}`);
  return response.data;
};

/**
 * List search history with pagination and filtering
 */
export const listSearchHistory = async (
  page: number = 0,
  size: number = 20,
  sortBy: string = 'createdAt',
  sortDirection: 'ASC' | 'DESC' = 'DESC',
  type?: SearchHistoryType,
  userId?: string,
): Promise<PageResponse<SearchHistoryRecord>> => {
  const client = await getApiClient();
  const params: Record<string, string | number> = { page, size, sortBy, sortDirection };
  if (type) params.type = type;
  if (userId) params.userId = userId;
  
  const response = await client.get<PageResponse<SearchHistoryRecord>>('/api/v1/search-history', { params });
  return response.data;
};

/**
 * Search history by query text
 */
export const searchHistoryByQuery = async (
  query: string,
  page: number = 0,
  size: number = 20,
): Promise<PageResponse<SearchHistoryRecord>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<SearchHistoryRecord>>('/api/v1/search-history/search', {
    params: { q: query, page, size },
  });
  return response.data;
};

/**
 * Get bookmarked searches
 */
export const getBookmarkedSearches = async (
  page: number = 0,
  size: number = 20,
): Promise<PageResponse<SearchHistoryRecord>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<SearchHistoryRecord>>('/api/v1/search-history/bookmarked', {
    params: { page, size },
  });
  return response.data;
};

/**
 * Get derived (drill-down) searches from a parent
 */
export const getDerivedSearches = async (parentId: number): Promise<SearchHistoryRecord[]> => {
  const client = await getApiClient();
  const response = await client.get<SearchHistoryRecord[]>(`/api/v1/search-history/${parentId}/derived`);
  return response.data;
};

/**
 * Get searches by session
 */
export const getSearchesBySession = async (sessionId: string): Promise<SearchHistoryRecord[]> => {
  const client = await getApiClient();
  const response = await client.get<SearchHistoryRecord[]>(`/api/v1/search-history/session/${sessionId}`);
  return response.data;
};

/**
 * Toggle bookmark status
 */
export const toggleSearchBookmark = async (id: number): Promise<SearchHistoryRecord> => {
  const client = await getApiClient();
  const response = await client.post<SearchHistoryRecord>(`/api/v1/search-history/${id}/bookmark`);
  return response.data;
};

/**
 * Update tags for a search
 */
export const updateSearchTags = async (id: number, tags: string[]): Promise<SearchHistoryRecord> => {
  const client = await getApiClient();
  const response = await client.put<SearchHistoryRecord>(`/api/v1/search-history/${id}/tags`, tags);
  return response.data;
};

/**
 * Update notes for a search
 */
export const updateSearchNotes = async (id: number, notes: string): Promise<SearchHistoryRecord> => {
  const client = await getApiClient();
  const response = await client.put<SearchHistoryRecord>(`/api/v1/search-history/${id}/notes`, { notes });
  return response.data;
};

/**
 * Delete search history
 */
export const deleteSearchHistory = async (id: number): Promise<void> => {
  const client = await getApiClient();
  await client.delete(`/api/v1/search-history/${id}`);
};

/**
 * Create a derived (drill-down) search
 */
export const createDerivedSearch = async (
  parentId: number,
  request: SaveSearchHistoryRequest,
): Promise<{
  id: number;
  parentSearchId: number;
  depthLevel: number;
  query: string;
  message: string;
}> => {
  const client = await getApiClient();
  const response = await client.post(`/api/v1/search-history/${parentId}/derive`, request);
  return response.data;
};

/**
 * Get search statistics
 */
export const getSearchStatistics = async (days: number = 30): Promise<{
  totalSearches: number;
  byType: Array<{ searchType: string; count: number; avgResults: number }>;
  period: { days: number; since: string };
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/search-history/stats', { params: { days } });
  return response.data;
};

/**
 * Get recently discovered URLs from searches
 */
export const getDiscoveredUrls = async (days: number = 7, limit: number = 100): Promise<string[]> => {
  const client = await getApiClient();
  const response = await client.get<string[]>('/api/v1/search-history/discovered-urls', {
    params: { days, limit },
  });
  return response.data;
};

/**
 * Check search history service health
 */
export const checkSearchHistoryHealth = async (): Promise<{
  status: string;
  features: Record<string, boolean>;
  kafkaTopic: string;
  sseSubscribers?: number;
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/search-history/health');
  return response.data;
};

// ============================================
// Claim Extraction API (for FactCheck)
// ============================================

/**
 * Extracted claim from URL
 */
export interface ExtractedClaim {
  id: string;
  text: string;
  confidence: number;
  context?: string;
  claimType?: 'statistical' | 'event' | 'quote' | 'general';
  verifiable?: boolean;
}

/**
 * Response from claim extraction API
 */
export interface ClaimExtractionResponse {
  url: string;
  pageTitle?: string;
  claims: ExtractedClaim[];
  processingTimeMs?: number;
  extractionSource?: string;
  message?: string;
}

/**
 * Request payload for claim extraction
 */
export interface ClaimExtractionRequest {
  url: string;
  maxClaims?: number;
  minConfidence?: number;
}

/**
 * Extract verifiable claims from a URL.
 * The backend crawls the URL, analyzes content with AI, and returns structured claims.
 */
export const extractClaimsFromUrl = async (request: ClaimExtractionRequest): Promise<ClaimExtractionResponse> => {
  const client = await getApiClient();
  const response = await client.post<ClaimExtractionResponse>(
    '/api/v1/analysis/extract-claims',
    request,
    { timeout: 120000 },
  );
  return response.data;
};

/**
 * Check claim extraction service health
 */
export const checkClaimExtractionHealth = async (): Promise<{
  service: string;
  status: string;
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/analysis/extract-claims/health');
  return response.data;
};


/**
 * SSE event types for search history stream
 */
export interface SearchHistorySSEEvent {
  eventType: 'new_search' | 'updated_search' | 'deleted_search' | 'heartbeat';
  data: SearchHistoryRecord | { id: number } | { tick: number; subscribers: number };
  timestamp: number;
}

// ============================================
// Search Template API (SmartSearch Templates)
// ============================================

/**
 * Search template record
 */
export interface SearchTemplate {
  id: number;
  name: string;
  query: string;
  mode: 'unified' | 'deep' | 'factcheck';
  userId?: string;
  items: Array<{
    id: string;
    type: 'unified' | 'evidence' | 'factcheck';
    title: string;
    url?: string;
    snippet?: string;
    source?: string;
    stance?: string;
    verificationStatus?: string;
    addedAt?: string;
  }>;
  description?: string;
  favorite?: boolean;
  tags?: string[];
  metadata?: Record<string, unknown>;
  sourceSearchId?: number;
  useCount?: number;
  lastUsedAt?: string;
  createdAt: string;
  updatedAt?: string;
  itemCount?: number;
}

/**
 * Request payload for creating/updating a search template
 */
export interface SearchTemplateRequest {
  name: string;
  query: string;
  mode: 'unified' | 'deep' | 'factcheck';
  userId?: string;
  items: Array<{
    id: string;
    type: 'unified' | 'evidence' | 'factcheck';
    title: string;
    url?: string;
    snippet?: string;
    source?: string;
    stance?: string;
    verificationStatus?: string;
    addedAt?: string;
  }>;
  description?: string;
  tags?: string[];
  metadata?: Record<string, unknown>;
  sourceSearchId?: number;
}

/**
 * Create a new search template
 */
export const createSearchTemplate = async (request: SearchTemplateRequest): Promise<SearchTemplate> => {
  const client = await getApiClient();
  const response = await client.post<SearchTemplate>('/api/v1/search-templates', request);
  return response.data;
};

/**
 * Get search template by ID
 */
export const getSearchTemplateById = async (id: number): Promise<SearchTemplate> => {
  const client = await getApiClient();
  const response = await client.get<SearchTemplate>(`/api/v1/search-templates/${id}`);
  return response.data;
};

/**
 * List search templates with pagination
 */
export const listSearchTemplates = async (
  page: number = 0,
  size: number = 20,
  sortBy: string = 'createdAt',
  sortDirection: 'ASC' | 'DESC' = 'DESC',
  userId?: string,
  mode?: string,
): Promise<PageResponse<SearchTemplate>> => {
  const client = await getApiClient();
  const params: Record<string, string | number> = { page, size, sortBy, sortDirection };
  if (userId) params.userId = userId;
  if (mode) params.mode = mode;
  
  const response = await client.get<PageResponse<SearchTemplate>>('/api/v1/search-templates', { params });
  return response.data;
};

/**
 * Get all templates for a user (no pagination)
 */
export const getAllTemplatesByUser = async (userId: string): Promise<SearchTemplate[]> => {
  const client = await getApiClient();
  const response = await client.get<SearchTemplate[]>(`/api/v1/search-templates/user/${userId}`);
  return response.data;
};

/**
 * Get favorite templates for a user
 */
export const getFavoriteTemplates = async (userId: string): Promise<SearchTemplate[]> => {
  const client = await getApiClient();
  const response = await client.get<SearchTemplate[]>(`/api/v1/search-templates/user/${userId}/favorites`);
  return response.data;
};

/**
 * Get most used templates for a user
 */
export const getMostUsedTemplates = async (userId: string, limit: number = 10): Promise<SearchTemplate[]> => {
  const client = await getApiClient();
  const response = await client.get<SearchTemplate[]>(`/api/v1/search-templates/user/${userId}/most-used`, {
    params: { limit },
  });
  return response.data;
};

/**
 * Get recently used templates for a user
 */
export const getRecentlyUsedTemplates = async (userId: string, limit: number = 10): Promise<SearchTemplate[]> => {
  const client = await getApiClient();
  const response = await client.get<SearchTemplate[]>(`/api/v1/search-templates/user/${userId}/recent`, {
    params: { limit },
  });
  return response.data;
};

/**
 * Search templates by name
 */
export const searchTemplatesByName = async (
  query: string,
  userId?: string,
  page: number = 0,
  size: number = 20,
): Promise<PageResponse<SearchTemplate>> => {
  const client = await getApiClient();
  const params: Record<string, string | number> = { q: query, page, size };
  if (userId) params.userId = userId;
  
  const response = await client.get<PageResponse<SearchTemplate>>('/api/v1/search-templates/search', { params });
  return response.data;
};

/**
 * Update a search template
 */
export const updateSearchTemplate = async (id: number, request: Partial<SearchTemplateRequest>): Promise<SearchTemplate> => {
  const client = await getApiClient();
  const response = await client.put<SearchTemplate>(`/api/v1/search-templates/${id}`, request);
  return response.data;
};

/**
 * Toggle favorite status for a template
 */
export const toggleTemplateFavorite = async (id: number): Promise<SearchTemplate> => {
  const client = await getApiClient();
  const response = await client.post<SearchTemplate>(`/api/v1/search-templates/${id}/favorite`);
  return response.data;
};

/**
 * Record template usage (when loading a template)
 */
export const recordTemplateUsage = async (id: number): Promise<void> => {
  const client = await getApiClient();
  await client.post(`/api/v1/search-templates/${id}/use`);
};

/**
 * Duplicate a template
 */
export const duplicateTemplate = async (
  id: number,
  newName?: string,
  userId?: string,
): Promise<SearchTemplate> => {
  const client = await getApiClient();
  const params: Record<string, string> = {};
  if (newName) params.newName = newName;
  if (userId) params.userId = userId;
  
  const response = await client.post<SearchTemplate>(`/api/v1/search-templates/${id}/duplicate`, null, { params });
  return response.data;
};

/**
 * Delete a search template
 */
export const deleteSearchTemplate = async (id: number): Promise<void> => {
  const client = await getApiClient();
  await client.delete(`/api/v1/search-templates/${id}`);
};

/**
 * Get template statistics
 */
export const getTemplateStatistics = async (userId?: string): Promise<{
  totalTemplates: number;
  byMode: { unified: number; deep: number; factcheck: number };
  userId: string;
}> => {
  const client = await getApiClient();
  const params: Record<string, string> = {};
  if (userId) params.userId = userId;
  
  const response = await client.get('/api/v1/search-templates/stats', { params });
  return response.data;
};

/**
 * Check template service health
 */
export const checkTemplateServiceHealth = async (): Promise<{
  service: string;
  status: string;
  features: Record<string, boolean>;
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/search-templates/health');
  return response.data;
};

/**
 * Open SSE stream for real-time search history updates.
 * 
 * Event types:
 * - new_search: A new search was saved
 * - updated_search: An existing search was updated
 * - deleted_search: A search was deleted (data contains { id: number })
 * - heartbeat: Keep-alive signal (every 30 seconds)
 */
export const openSearchHistoryStream = async (): Promise<EventSource> => {
  const initialBase = resolveInitialBaseUrl();
  const baseURL = await fetchConfiguredBaseUrl(initialBase);
  const effectiveBaseURL = baseURL || (typeof globalThis.window !== 'undefined' ? globalThis.window.location.origin : '');
  const url = `${effectiveBaseURL}/api/v1/search-history/stream`;
  return createAuthenticatedEventSource(url);
};


/**
 * Check API Gateway health
 */
export const checkApiGatewayHealth = async (): Promise<{
  status: string;
  timestamp?: string;
  services?: Record<string, { status: string; instances?: number }>;
}> => {
  const response = await fetch('/api/actuator/health', {
    method: 'GET',
    headers: { 'Content-Type': 'application/json' },
  });
  
  if (!response.ok) {
    // Try alternative health endpoint
    const altResponse = await fetch('/api/health', {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' },
    });
    
    if (!altResponse.ok) {
      return { status: 'unhealthy' };
    }
    return altResponse.json();
  }
  
  return response.json();
};


// ============================================
// Browser-Use Session Management API
// ============================================

/**
 * Summary of browser job for display
 */
export interface BrowserJobSummary {
  job_id: string;
  task: string;
  status: BrowserJobStatus;
  progress: number;
  intervention_requested: boolean;
  intervention_type?: InterventionType;
  started_at?: string;
  completed_at?: string;
}

/**
 * Get all active (running or waiting) browser jobs
 */
export const getActiveBrowserJobs = async (): Promise<BrowserJobSummary[]> => {
  const jobs = await listBrowserJobs(undefined, 100);
  return jobs.filter(j => 
    j.status === 'running' || 
    j.status === 'waiting_human' || 
    j.status === 'pending'
  );
};

/**
 * Get jobs waiting for human intervention
 */
export const getJobsWaitingIntervention = async (): Promise<BrowserJobSummary[]> => {
  return listBrowserJobs('waiting_human', 50);
};

/**
 * Get recent completed jobs (for history)
 */
export const getRecentCompletedJobs = async (limit: number = 20): Promise<BrowserJobSummary[]> => {
  return listBrowserJobs('completed', limit);
};

/**
 * Cancel all active browser jobs
 */
export const cancelAllBrowserJobs = async (): Promise<{ cancelled: number; errors: string[] }> => {
  const activeJobs = await getActiveBrowserJobs();
  let cancelled = 0;
  const errors: string[] = [];
  
  for (const job of activeJobs) {
    try {
      await cancelBrowserJob(job.job_id);
      cancelled++;
    } catch (e) {
      errors.push(`Failed to cancel ${job.job_id}: ${e instanceof Error ? e.message : 'Unknown error'}`);
    }
  }
  
  return { cancelled, errors };
};

/**
 * Browser-Use service statistics
 */
export interface BrowserUseStats {
  totalJobs: number;
  activeJobs: number;
  waitingIntervention: number;
  completedJobs: number;
  failedJobs: number;
  recentJobs: BrowserJobSummary[];
}

/**
 * Get Browser-Use service statistics
 */
export const getBrowserUseStats = async (): Promise<BrowserUseStats> => {
  const allJobs = await listBrowserJobs(undefined, 200);
  
  return {
    totalJobs: allJobs.length,
    activeJobs: allJobs.filter(j => j.status === 'running' || j.status === 'pending').length,
    waitingIntervention: allJobs.filter(j => j.status === 'waiting_human').length,
    completedJobs: allJobs.filter(j => j.status === 'completed').length,
    failedJobs: allJobs.filter(j => j.status === 'failed' || j.status === 'cancelled').length,
    recentJobs: allJobs.slice(0, 10),
  };
};


// ============================================
// ML Add-ons API
// ============================================

export type MLAddonType = 'sentiment' | 'factcheck' | 'bias';

export interface MLAddonHealth {
  status: 'healthy' | 'unhealthy' | 'unknown';
  service: string;
}

export interface MLAddonConfig {
  id: MLAddonType;
  name: string;
  description: string;
  port: number;
  enabled: boolean;
  endpoint: string;
}

// Default add-on configurations
export const ML_ADDON_CONFIGS: MLAddonConfig[] = [
  {
    id: 'sentiment',
    name: '감정 분석',
    description: '뉴스 기사의 감정 톤(긍정/부정/중립)을 분석합니다.',
    port: 8100,
    enabled: true,
    endpoint: '/api/ml-addons/sentiment',
  },
  {
    id: 'factcheck',
    name: '팩트체크',
    description: '기사의 주장을 추출하고 신뢰도를 평가합니다.',
    port: 8101,
    enabled: true,
    endpoint: '/api/ml-addons/factcheck',
  },
  {
    id: 'bias',
    name: '편향도 분석',
    description: '기사의 정치적/이념적 편향성을 분석합니다.',
    port: 8102,
    enabled: true,
    endpoint: '/api/ml-addons/bias',
  },
];

/**
 * Check ML Add-on service health
 */
export const checkMLAddonHealth = async (addonType: MLAddonType): Promise<MLAddonHealth> => {
  const config = ML_ADDON_CONFIGS.find(c => c.id === addonType);
  if (!config) {
    return { status: 'unknown', service: addonType };
  }
  
  try {
    const response = await fetch(`${config.endpoint}/health`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' },
    });
    
    if (!response.ok) {
      return { status: 'unhealthy', service: addonType };
    }
    
    const data = await response.json();
    return {
      status: data.status === 'healthy' ? 'healthy' : 'unhealthy',
      service: data.service || addonType,
    };
  } catch {
    return { status: 'unhealthy', service: addonType };
  }
};

/**
 * Check health of all ML Add-ons
 */
export const checkAllMLAddonsHealth = async (): Promise<Record<MLAddonType, MLAddonHealth>> => {
  const results = await Promise.all(
    ML_ADDON_CONFIGS.map(async (config) => {
      const health = await checkMLAddonHealth(config.id);
      return [config.id, health] as [MLAddonType, MLAddonHealth];
    })
  );
  
  return Object.fromEntries(results) as Record<MLAddonType, MLAddonHealth>;
};

/**
 * ML Add-on analysis request
 */
export interface MLAddonAnalysisRequest {
  request_id: string;
  addon_id: string;
  task?: string;
  article: {
    id?: number;
    title?: string;
    content?: string;
    url?: string;
    source?: string;
    published_at?: string;
  };
  context?: {
    language?: string;
    country?: string;
  };
}

/**
 * Analyze article with a specific ML Add-on
 */
export const analyzeWithMLAddon = async (
  addonType: MLAddonType,
  request: MLAddonAnalysisRequest
): Promise<unknown> => {
  const config = ML_ADDON_CONFIGS.find(c => c.id === addonType);
  if (!config) {
    throw new Error(`Unknown addon type: ${addonType}`);
  }
  
  const response = await fetch(`${config.endpoint}/analyze`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request),
  });
  
  if (!response.ok) {
    throw new Error(`ML Addon analysis failed: ${response.statusText}`);
  }
  
  return response.json();
};


// ============================================
// AI Provider Models API
// ============================================

export type LLMProviderType = 'openai' | 'anthropic' | 'google' | 'openrouter' | 'ollama' | 'azure' | 'custom';

export interface ProviderModel {
  id: string;
  name: string;
  owned_by?: string;
  context_length?: number;
  pricing?: {
    prompt?: string;
    completion?: string;
  };
  size?: number;
  modified_at?: string;
}

export interface ProviderModelsResponse {
  provider: LLMProviderType;
  models: ProviderModel[];
  source: 'api' | 'static';
  total?: number;
  message?: string;
  error?: string;
  ollama_url?: string;
  base_url?: string;
}

/**
 * Fetch available models for a specific LLM provider.
 * 
 * For OpenAI, OpenRouter, and Ollama: fetches from their respective APIs.
 * For Anthropic, Google, Azure, Custom: returns static model lists.
 * 
 * @param provider - The LLM provider type
 * @param apiKey - Optional API key (uses environment variables if not provided)
 * @param baseUrl - Optional base URL (for Ollama or Custom providers)
 */
export const fetchProviderModels = async (
  provider: LLMProviderType,
  apiKey?: string,
  baseUrl?: string,
): Promise<ProviderModelsResponse> => {
  const params = new URLSearchParams();
  if (apiKey) params.append('api_key', apiKey);
  if (baseUrl) params.append('base_url', baseUrl);
  
  const queryString = params.toString();
  const url = `/api/v1/crawler/providers/${provider}/models${queryString ? `?${queryString}` : ''}`;
  
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      // Return static fallback on error
      return {
        provider,
        models: getStaticModels(provider),
        source: 'static',
        error: `API error: ${response.status}`,
      };
    }
    
    const data = await response.json();
    // Ensure models is always an array
    return {
      ...data,
      provider: data.provider || provider,
      models: Array.isArray(data.models) ? data.models : getStaticModels(provider),
      source: data.source || 'api',
    };
  } catch (error) {
    // Return static fallback on any error (network, JSON parse, etc.)
    console.error(`Failed to fetch models for ${provider}:`, error);
    return {
      provider,
      models: getStaticModels(provider),
      source: 'static',
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
};

/**
 * Static model lists as fallback when API is unavailable
 */
export const getStaticModels = (provider: LLMProviderType): ProviderModel[] => {
  const staticModels: Record<LLMProviderType, ProviderModel[]> = {
    openai: [
      { id: 'gpt-4o', name: 'GPT-4o (추천)' },
      { id: 'gpt-4o-mini', name: 'GPT-4o Mini (빠름)' },
      { id: 'gpt-4.1', name: 'GPT-4.1' },
      { id: 'gpt-4.1-mini', name: 'GPT-4.1 Mini' },
      { id: 'gpt-4-turbo', name: 'GPT-4 Turbo' },
      { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo (저렴)' },
      { id: 'o1', name: 'o1 (추론)' },
      { id: 'o1-preview', name: 'o1-preview (추론)' },
      { id: 'o1-mini', name: 'o1-mini (추론, 빠름)' },
      { id: 'o3-mini', name: 'o3-mini (최신 추론)' },
    ],
    anthropic: [
      { id: 'claude-sonnet-4-20250514', name: 'Claude Sonnet 4 (최신)' },
      { id: 'claude-3-5-sonnet-20241022', name: 'Claude 3.5 Sonnet (추천)' },
      { id: 'claude-3-5-haiku-20241022', name: 'Claude 3.5 Haiku (빠름)' },
      { id: 'claude-3-opus-20240229', name: 'Claude 3 Opus (강력)' },
    ],
    google: [
      { id: 'gemini-2.5-flash-preview-05-20', name: 'Gemini 2.5 Flash (최신)' },
      { id: 'gemini-2.5-pro-preview-05-06', name: 'Gemini 2.5 Pro (최신)' },
      { id: 'gemini-2.0-flash', name: 'Gemini 2.0 Flash' },
      { id: 'gemini-2.0-flash-lite', name: 'Gemini 2.0 Flash Lite (빠름)' },
      { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro' },
      { id: 'gemini-1.5-flash', name: 'Gemini 1.5 Flash' },
    ],
    openrouter: [
      { id: 'openai/gpt-4o', name: 'GPT-4o (OpenAI)' },
      { id: 'openai/gpt-4.1', name: 'GPT-4.1 (OpenAI)' },
      { id: 'anthropic/claude-sonnet-4', name: 'Claude Sonnet 4 (Anthropic)' },
      { id: 'anthropic/claude-3.5-sonnet', name: 'Claude 3.5 Sonnet' },
      { id: 'google/gemini-2.5-flash-preview', name: 'Gemini 2.5 Flash (Google)' },
      { id: 'google/gemini-2.0-flash-001', name: 'Gemini 2.0 Flash (Google)' },
      { id: 'google/gemini-pro-1.5', name: 'Gemini 1.5 Pro' },
      { id: 'meta-llama/llama-3.3-70b-instruct', name: 'Llama 3.3 70B' },
      { id: 'meta-llama/llama-3.1-405b-instruct', name: 'Llama 3.1 405B' },
      { id: 'deepseek/deepseek-r1', name: 'DeepSeek R1 (추론)' },
      { id: 'deepseek/deepseek-chat', name: 'DeepSeek Chat' },
      { id: 'qwen/qwen-2.5-72b-instruct', name: 'Qwen 2.5 72B' },
    ],
    ollama: [
      { id: 'llama3.3', name: 'Llama 3.3 (최신)' },
      { id: 'llama3.2', name: 'Llama 3.2' },
      { id: 'llama3.1', name: 'Llama 3.1' },
      { id: 'llama3.1:70b', name: 'Llama 3.1 70B' },
      { id: 'mistral', name: 'Mistral' },
      { id: 'mixtral', name: 'Mixtral' },
      { id: 'codellama', name: 'Code Llama' },
      { id: 'qwen2.5', name: 'Qwen 2.5' },
      { id: 'deepseek-r1', name: 'DeepSeek R1' },
      { id: 'gemma2', name: 'Gemma 2' },
    ],
    azure: [
      { id: 'gpt-4o', name: 'GPT-4o' },
      { id: 'gpt-4-turbo', name: 'GPT-4 Turbo' },
      { id: 'gpt-35-turbo', name: 'GPT-3.5 Turbo' },
    ],
    custom: [
      { id: 'default', name: '기본 모델' },
    ],
  };
  
  return staticModels[provider] || [];
};

/**
 * Test LLM provider connection
 */
export const testLLMProviderConnection = async (
  provider: LLMProviderType,
  model?: string,
): Promise<{
  status: 'success' | 'failed';
  provider: LLMProviderType;
  model: string;
  message: string;
  latency_ms?: number;
  error?: string;
}> => {
  const params = new URLSearchParams({ provider });
  if (model) params.append('model', model);
  
  const response = await fetch(`/api/v1/crawler/providers/test?${params}`, {
    method: 'POST',
  });
  
  return response.json();
};

// ============================================
// Analysis Stream APIs (Search Result Analysis)
// Backend: /api/v1/search/analysis
// ============================================

/**
 * Subscribe to analysis updates for specific articles via SSE
 * GET /api/v1/search/analysis/stream
 * 
 * @param articleIds - Comma-separated article IDs to watch
 * @param onEvent - Callback for each SSE event
 * @param onError - Callback for errors
 * @returns Cleanup function to close the connection
 */
export const subscribeToAnalysisUpdates = (
  articleIds: number[],
  onEvent: (event: {
    eventType: string;
    articleId?: number;
    addonKey?: string;
    data?: Record<string, unknown>;
  }) => void,
  onError?: (error: Event) => void
): (() => void) => {
  const baseUrl = resolveInitialBaseUrl();
  const params = articleIds.length > 0 ? `?articleIds=${articleIds.join(',')}` : '';
  const url = `${baseUrl}/api/v1/search/analysis/stream${params}`;
  
  // Use authenticated EventSource for SSE with token in query param
  const eventSource = createAuthenticatedEventSource(url);
  
  eventSource.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      onEvent(data);
    } catch (e) {
      console.error('Failed to parse analysis event:', e);
    }
  };
  
  // Named event handlers
  eventSource.addEventListener('analysis_started', (event: MessageEvent) => {
    try {
      onEvent({ eventType: 'analysis_started', ...JSON.parse(event.data) });
    } catch (e) {
      console.error('Failed to parse analysis_started event:', e);
    }
  });
  
  eventSource.addEventListener('partial_result', (event: MessageEvent) => {
    try {
      onEvent({ eventType: 'partial_result', ...JSON.parse(event.data) });
    } catch (e) {
      console.error('Failed to parse partial_result event:', e);
    }
  });
  
  eventSource.addEventListener('analysis_complete', (event: MessageEvent) => {
    try {
      onEvent({ eventType: 'analysis_complete', ...JSON.parse(event.data) });
    } catch (e) {
      console.error('Failed to parse analysis_complete event:', e);
    }
  });
  
  eventSource.addEventListener('analysis_error', (event: MessageEvent) => {
    try {
      onEvent({ eventType: 'analysis_error', ...JSON.parse(event.data) });
    } catch (e) {
      console.error('Failed to parse analysis_error event:', e);
    }
  });
  
  eventSource.onerror = (error) => {
    console.error('Analysis stream error:', error);
    onError?.(error);
  };
  
  return () => {
    eventSource.close();
  };
};

/**
 * Add articles to the analysis watch list
 * POST /api/v1/search/analysis/watch
 * 
 * @param articleIds - Article IDs to watch
 */
export const watchArticlesForAnalysis = async (
  articleIds: number[]
): Promise<{
  message: string;
  watchedCount: number;
}> => {
  const client = await getApiClient();
  const response = await client.post('/api/v1/search/analysis/watch', articleIds);
  return response.data;
};

/**
 * Get analysis stream status
 * GET /api/v1/search/analysis/stream/status
 */
export const getAnalysisStreamStatus = async (): Promise<{
  subscriberCount: number;
  watchedArticleCount: number;
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/search/analysis/stream/status');
  return response.data;
};


// ============================================
// PDF Report API
// ============================================

/**
 * Report type enumeration
 */
export type ReportType = 'UNIFIED_SEARCH' | 'DEEP_SEARCH' | 'ML_ANALYSIS' | 'ARTICLE_DETAIL';

/**
 * Report section enumeration
 */
export type ReportSection = 
  | 'COVER'              // 표지
  | 'EXECUTIVE_SUMMARY'  // 요약
  | 'DATA_SOURCE'        // 데이터 소스 분석
  | 'TREND_ANALYSIS'     // 시간별 트렌드
  | 'KEYWORD_ANALYSIS'   // 키워드 분석
  | 'SENTIMENT_ANALYSIS' // 감정 분석
  | 'RELIABILITY'        // 신뢰도 분석
  | 'BIAS_ANALYSIS'      // 편향성 분석
  | 'FACTCHECK'          // 팩트체크
  | 'EVIDENCE_LIST'      // 증거 목록
  | 'DETAILED_RESULTS';  // 상세 결과

/**
 * Report generation status
 */
export type ReportStatus = 'PENDING' | 'GENERATING' | 'COMPLETED' | 'FAILED' | 'EXPIRED';

/**
 * Report generation request
 */
export interface ReportRequest {
  reportType?: ReportType;
  targetId?: string;
  query?: string;
  timeWindow?: string;
  includeSections?: ReportSection[];
  chartImages?: Record<string, string>;  // Base64 encoded chart images
  customTitle?: string;
  logoImage?: string;  // Base64 or URL
  watermark?: string;
  language?: 'ko' | 'en';
}

/**
 * Report metadata response
 */
export interface ReportMetadata {
  reportId: string;
  title: string;
  reportType: ReportType;
  targetId: string;
  query: string;
  status: ReportStatus;
  fileSize?: number;
  pageCount?: number;
  generationTimeMs?: number;
  createdAt: string;
  expiresAt?: string;
  downloadUrl?: string;
  errorMessage?: string;
}

/**
 * Request unified search report generation (async)
 * POST /api/v1/reports/unified-search/{jobId}
 * 
 * @param jobId - Unified search job ID
 * @param request - Report generation options
 * @returns Report metadata with status
 */
export const requestUnifiedSearchReport = async (
  jobId: string,
  request: ReportRequest = {}
): Promise<ReportMetadata> => {
  const client = await getApiClient();
  const response = await client.post<ReportMetadata>(
    `/api/v1/reports/unified-search/${jobId}`,
    request
  );
  return response.data;
};

/**
 * Export unified search report immediately (sync download)
 * POST /api/v1/reports/unified-search/{jobId}/export
 * 
 * @param jobId - Unified search job ID
 * @param request - Report generation options
 * @returns PDF file as Blob
 */
export const exportUnifiedSearchReport = async (
  jobId: string,
  request: ReportRequest = {}
): Promise<Blob> => {
  const client = await getApiClient();
  const response = await client.post(
    `/api/v1/reports/unified-search/${jobId}/export`,
    request,
    {
      responseType: 'blob',
      timeout: 120000,  // 2 minute timeout for PDF generation
    }
  );
  return response.data;
};

/**
 * Get report status by report ID
 * GET /api/v1/reports/{reportId}
 * 
 * @param reportId - Report ID
 * @returns Report metadata
 */
export const getReportStatus = async (reportId: string): Promise<ReportMetadata> => {
  const client = await getApiClient();
  const response = await client.get<ReportMetadata>(`/api/v1/reports/${reportId}`);
  return response.data;
};

/**
 * Download generated report
 * GET /api/v1/reports/{reportId}/download
 * 
 * @param reportId - Report ID
 * @returns PDF file as Blob
 */
export const downloadReport = async (reportId: string): Promise<Blob> => {
  const client = await getApiClient();
  const response = await client.get(`/api/v1/reports/${reportId}/download`, {
    responseType: 'blob',
  });
  return response.data;
};

/**
 * Export DeepSearch report immediately (sync download)
 * POST /api/v1/reports/deep-search/{jobId}/export
 * 
 * @param jobId - DeepSearch job ID
 * @param request - Report generation options
 * @returns PDF file as Blob
 */
export const exportDeepSearchReport = async (
  jobId: string,
  request: ReportRequest = {}
): Promise<Blob> => {
  const client = await getApiClient();
  const response = await client.post(
    `/api/v1/reports/deep-search/${jobId}/export`,
    {
      ...request,
      reportType: 'DEEP_SEARCH',
    },
    {
      responseType: 'blob',
      timeout: 120000,
    }
  );
  return response.data;
};

/**
 * Export ML analysis report for an article (sync download)
 * POST /api/v1/reports/ml-analysis/{articleId}/export
 * 
 * @param articleId - Article ID
 * @param request - Report generation options
 * @returns PDF file as Blob
 */
export const exportMlAnalysisReport = async (
  articleId: number,
  request: ReportRequest = {}
): Promise<Blob> => {
  const client = await getApiClient();
  const response = await client.post(
    `/api/v1/reports/ml-analysis/${articleId}/export`,
    {
      ...request,
      reportType: 'ML_ANALYSIS',
    },
    {
      responseType: 'blob',
      timeout: 120000,
    }
  );
  return response.data;
};

/**
 * Poll for report completion
 * 
 * @param reportId - Report ID
 * @param pollIntervalMs - Polling interval in milliseconds
 * @param maxWaitMs - Maximum wait time in milliseconds
 * @returns Completed report metadata
 */
export const pollReportCompletion = async (
  reportId: string,
  pollIntervalMs: number = 2000,
  maxWaitMs: number = 120000
): Promise<ReportMetadata> => {
  const startTime = Date.now();
  
  while (Date.now() - startTime < maxWaitMs) {
    const metadata = await getReportStatus(reportId);
    
    if (metadata.status === 'COMPLETED') {
      return metadata;
    }
    
    if (metadata.status === 'FAILED' || metadata.status === 'EXPIRED') {
      throw new Error(`Report generation ${metadata.status.toLowerCase()}: ${metadata.errorMessage || 'Unknown error'}`);
    }
    
    await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
  }
  
  throw new Error('Report generation timed out');
};

/**
 * Helper function to trigger PDF download in browser
 * 
 * @param blob - PDF blob
 * @param filename - Download filename
 */
export const triggerPdfDownload = (blob: Blob, filename: string) => {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

/**
 * Default report sections for different report types
 */
export const DEFAULT_REPORT_SECTIONS: Record<ReportType, ReportSection[]> = {
  UNIFIED_SEARCH: [
    'COVER',
    'EXECUTIVE_SUMMARY',
    'DATA_SOURCE',
    'KEYWORD_ANALYSIS',
    'SENTIMENT_ANALYSIS',
    'RELIABILITY',
    'DETAILED_RESULTS',
  ],
  DEEP_SEARCH: [
    'COVER',
    'EXECUTIVE_SUMMARY',
    'DATA_SOURCE',
    'EVIDENCE_LIST',
    'SENTIMENT_ANALYSIS',
    'FACTCHECK',
    'DETAILED_RESULTS',
  ],
  ML_ANALYSIS: [
    'COVER',
    'EXECUTIVE_SUMMARY',
    'SENTIMENT_ANALYSIS',
    'BIAS_ANALYSIS',
    'FACTCHECK',
    'RELIABILITY',
  ],
  ARTICLE_DETAIL: [
    'COVER',
    'EXECUTIVE_SUMMARY',
    'SENTIMENT_ANALYSIS',
    'BIAS_ANALYSIS',
    'FACTCHECK',
  ],
};


// =============================================================================
// ML Training Service API (Port 8090)
// =============================================================================

const ML_TRAINER_BASE_URL = import.meta.env.VITE_ML_TRAINER_URL || '/api/ml-trainer';

/**
 * 지원되는 ML 모델 타입
 */
export type MLModelType = 
  | 'sentiment'     // 감정 분석
  | 'absa'          // Aspect-Based Sentiment Analysis
  | 'ner'           // Named Entity Recognition
  | 'classification' // 텍스트 분류
  | 'embedding'     // 임베딩 모델
  | 'transformer';  // 기본 트랜스포머

/**
 * 학습 작업 상태
 */
export type TrainingJobState = 
  | 'PENDING'
  | 'INITIALIZING'
  | 'RUNNING'
  | 'COMPLETED'
  | 'FAILED'
  | 'CANCELLED';

/**
 * 데이터셋 형식
 */
export type DatasetFormat = 'csv' | 'jsonl' | 'json' | 'parquet' | 'huggingface';

/**
 * 학습 메트릭
 */
export interface TrainingMetrics {
  epoch: number;
  total_epochs: number;
  step: number;
  total_steps: number;
  loss: number;
  accuracy: number;
  validation_loss: number;
  validation_accuracy: number;
  learning_rate: number;
  samples_processed: number;
  total_samples: number;
  f1_score: number;
  precision: number;
  recall: number;
}

/**
 * 학습 요청
 */
export interface TrainingRequest {
  model_name: string;
  model_type: MLModelType;
  dataset_path: string;
  dataset_format: DatasetFormat;
  base_model?: string;
  max_epochs?: number;
  validation_split?: number;
  hyperparameters?: {
    learning_rate?: number;
    batch_size?: number;
    warmup_steps?: number;
    weight_decay?: number;
    max_length?: number;
    gradient_accumulation_steps?: number;
  };
  callbacks?: {
    early_stopping?: boolean;
    early_stopping_patience?: number;
    save_best_model?: boolean;
  };
  metadata?: Record<string, unknown>;
}

/**
 * 학습 응답
 */
export interface TrainingResponse {
  job_id: string;
  model_name: string;
  model_type: string;
  state: TrainingJobState;
  progress: number;
  created_at: string;
  message: string;
}

/**
 * 학습 작업 상태
 */
export interface TrainingJobStatus {
  job_id: string;
  model_name: string;
  model_type: string;
  state: TrainingJobState;
  progress: number;
  metrics: TrainingMetrics;
  error_message?: string;
  model_path?: string;
  created_at: string;
  started_at?: string;
  completed_at?: string;
  current_epoch: number;
  total_epochs: number;
}

/**
 * 모델 아티팩트 정보
 */
export interface ModelArtifact {
  model_path: string;
  model_name: string;
  model_type: string;
  framework: string;
  version: string;
  size_bytes: number;
  checksum: string;
  metrics: Record<string, number>;
  model_filename: string;
}

/**
 * ML Trainer 헬스 상태
 */
export interface MLTrainerHealth {
  status: string;
  version: string;
  gpu_available: boolean;
  active_jobs: number;
  supported_model_types: string[];
  max_concurrent_jobs: number;
  redis_connected: boolean;
  persisted_jobs: number;
}

/**
 * 외부 학습 시작 요청 (Colab/Jupyter)
 */
export interface ExternalTrainingRequest {
  model_name: string;
  model_type?: MLModelType;
  base_model?: string;
  max_epochs?: number;
  metadata?: Record<string, unknown>;
}

/**
 * 외부 학습 시작 응답
 */
export interface ExternalTrainingResponse {
  job_id: string;
  upload_token: string;
  model_name: string;
  model_type: string;
  state: string;
  created_at: string;
  message: string;
  api_endpoints: {
    progress: string;
    upload: string;
    complete: string;
    stream: string;
  };
}

/**
 * 외부 학습 진행 상황 업데이트
 */
export interface ExternalProgressUpdate {
  upload_token: string;
  progress: number;
  epoch?: number;
  total_epochs?: number;
  step?: number;
  total_steps?: number;
  loss?: number;
  accuracy?: number;
  validation_loss?: number;
  validation_accuracy?: number;
  f1_score?: number;
  learning_rate?: number;
  message?: string;
}

/**
 * 추론 요청
 */
export interface InferenceRequest {
  text: string;
  return_probabilities?: boolean;
}

/**
 * 추론 응답
 */
export interface InferenceResponse {
  job_id: string;
  model_name: string;
  model_type: string;
  input_text: string;
  predicted_label: string | number;
  predicted_label_name?: string;
  confidence: number;
  probabilities?: Record<string, number>;
  inference_time_ms: number;
}

/**
 * HuggingFace 데이터셋 정보
 */
export interface HuggingFaceDataset {
  id: string;
  name: string;
  description: string;
  size: string;
  downloads: number;
  task: string;
  language: string;
}

/**
 * 사전 정의된 한국어 데이터셋 목록
 */
export const KOREAN_DATASETS: HuggingFaceDataset[] = [
  {
    id: 'e9t/nsmc',
    name: 'Naver Sentiment Movie Corpus',
    description: '네이버 영화 리뷰 감정 분석 데이터셋 (긍정/부정)',
    size: '200K',
    downloads: 500000,
    task: 'sentiment',
    language: 'ko',
  },
  {
    id: 'klue/nli',
    name: 'KLUE NLI',
    description: '한국어 자연어 추론 데이터셋 (config: nli)',
    size: '28K',
    downloads: 100000,
    task: 'classification',
    language: 'ko',
  },
  {
    id: 'klue/ner',
    name: 'KLUE NER',
    description: '한국어 개체명 인식 데이터셋 (config: ner)',
    size: '26K',
    downloads: 80000,
    task: 'ner',
    language: 'ko',
  },
  {
    id: 'klue/ynat',
    name: 'KLUE YNAT',
    description: '연합뉴스 주제 분류 데이터셋 (config: ynat)',
    size: '55K',
    downloads: 90000,
    task: 'classification',
    language: 'ko',
  },
  {
    id: 'jeanlee/kmhas_korean_hate_speech',
    name: 'Korean Hate Speech',
    description: '한국어 혐오 발언 데이터셋 (KMHAS)',
    size: '110K',
    downloads: 30000,
    task: 'classification',
    language: 'ko',
  },
  {
    id: 'KorQuAD/squad_kor_v1',
    name: 'KorQuAD',
    description: '한국어 기계독해 데이터셋',
    size: '66K',
    downloads: 120000,
    task: 'qa',
    language: 'ko',
  },
];

/**
 * 기본 베이스 모델 목록
 */
export const DEFAULT_BASE_MODELS: Record<MLModelType, string[]> = {
  sentiment: [
    'klue/bert-base',
    'klue/roberta-base',
    'monologg/koelectra-base-v3-discriminator',
    'beomi/kcbert-base',
  ],
  absa: [
    'monologg/koelectra-base-v3-discriminator',
    'klue/bert-base',
  ],
  ner: [
    'klue/bert-base',
    'klue/roberta-base',
    'monologg/koelectra-base-v3-discriminator',
  ],
  classification: [
    'klue/roberta-base',
    'klue/bert-base',
    'beomi/kcbert-base',
  ],
  embedding: [
    'sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2',
    'jhgan/ko-sroberta-multitask',
    'BM-K/KoSimCSE-roberta',
  ],
  transformer: [
    'klue/bert-base',
    'klue/roberta-base',
    'klue/roberta-large',
  ],
};

// ML Trainer API Functions

/**
 * ML Trainer 헬스 체크
 */
export const checkMLTrainerHealth = async (): Promise<MLTrainerHealth> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/health`);
  if (!response.ok) {
    throw new Error('ML Trainer health check failed');
  }
  return response.json();
};

/**
 * 학습 작업 시작
 */
export const startTraining = async (request: TrainingRequest): Promise<TrainingResponse> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/train`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request),
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'Training start failed' }));
    throw new Error(error.detail || 'Training start failed');
  }
  return response.json();
};

/**
 * 학습 작업 상태 조회
 */
export const getTrainingJobStatus = async (jobId: string): Promise<TrainingJobStatus> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/jobs/${jobId}/status`);
  if (!response.ok) {
    throw new Error('Failed to get job status');
  }
  return response.json();
};

/**
 * 학습 작업 취소
 */
export const cancelTrainingJob = async (jobId: string): Promise<{ message: string }> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/jobs/${jobId}/cancel`, {
    method: 'POST',
  });
  if (!response.ok) {
    throw new Error('Failed to cancel job');
  }
  return response.json();
};

/**
 * 모든 학습 작업 목록 조회
 */
export const listTrainingJobs = async (): Promise<TrainingJobStatus[]> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/jobs`);
  if (!response.ok) {
    throw new Error('Failed to list jobs');
  }
  return response.json();
};

/**
 * 학습된 모델 목록 조회
 */
export const listTrainedModels = async (): Promise<ModelArtifact[]> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/models`);
  if (!response.ok) {
    throw new Error('Failed to list models');
  }
  return response.json();
};

/**
 * 모델 아티팩트 다운로드
 */
export const downloadModelArtifact = async (jobId: string): Promise<Blob> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/jobs/${jobId}/artifact`);
  if (!response.ok) {
    throw new Error('Failed to download model artifact');
  }
  return response.blob();
};

/**
 * 지원되는 모델 타입 조회
 */
export const getSupportedModelTypes = async (): Promise<string[]> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/supported-types`);
  if (!response.ok) {
    throw new Error('Failed to get supported types');
  }
  return response.json();
};

/**
 * 외부 학습 시작 (Colab/Jupyter 연동)
 */
export const startExternalTraining = async (
  request: ExternalTrainingRequest
): Promise<ExternalTrainingResponse> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/train/external/start`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request),
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'External training start failed' }));
    throw new Error(error.detail || 'External training start failed');
  }
  return response.json();
};

/**
 * 외부 학습 진행 상황 업데이트
 */
export const updateExternalProgress = async (
  jobId: string,
  update: ExternalProgressUpdate
): Promise<{ message: string }> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/jobs/${jobId}/progress`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(update),
  });
  if (!response.ok) {
    throw new Error('Failed to update progress');
  }
  return response.json();
};

/**
 * 외부 학습 모델 업로드
 */
export const uploadExternalModel = async (
  jobId: string,
  uploadToken: string,
  modelFile: File
): Promise<{ message: string; model_path: string }> => {
  const formData = new FormData();
  formData.append('model_file', modelFile);
  formData.append('upload_token', uploadToken);

  const response = await fetch(`${ML_TRAINER_BASE_URL}/jobs/${jobId}/upload`, {
    method: 'POST',
    body: formData,
  });
  if (!response.ok) {
    throw new Error('Failed to upload model');
  }
  return response.json();
};

/**
 * 외부 학습 완료 처리
 */
export const completeExternalTraining = async (
  jobId: string,
  uploadToken: string,
  finalMetrics?: Record<string, number>
): Promise<{ message: string }> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/jobs/${jobId}/complete`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      upload_token: uploadToken,
      final_metrics: finalMetrics || {},
    }),
  });
  if (!response.ok) {
    throw new Error('Failed to complete training');
  }
  return response.json();
};

/**
 * 학습된 모델로 추론 실행
 */
export const runInference = async (
  jobId: string,
  request: InferenceRequest
): Promise<InferenceResponse> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/inference/${jobId}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request),
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'Inference failed' }));
    throw new Error(error.detail || 'Inference failed');
  }
  return response.json();
};

/**
 * 모델 이름으로 추론 실행
 */
export const runInferenceByName = async (
  modelName: string,
  request: InferenceRequest
): Promise<InferenceResponse> => {
  const response = await fetch(`${ML_TRAINER_BASE_URL}/inference/by-name/${encodeURIComponent(modelName)}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request),
  });
  if (!response.ok) {
    const error = await response.json().catch(() => ({ detail: 'Inference failed' }));
    throw new Error(error.detail || 'Inference failed');
  }
  return response.json();
};

/**
 * 학습 진행 상황 SSE 스트림 연결
 */
export const connectTrainingStream = (
  jobId: string,
  onEvent: (event: {
    type: string;
    job_id: string;
    progress: number;
    state: TrainingJobState;
    metrics: TrainingMetrics;
    [key: string]: unknown;
  }) => void,
  onError?: (error: Error) => void
): EventSource => {
  const eventSource = createAuthenticatedEventSource(`${ML_TRAINER_BASE_URL}/jobs/${jobId}/stream`);

  eventSource.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      onEvent(data);
    } catch (e) {
      console.error('Failed to parse SSE event:', e);
    }
  };

  eventSource.onerror = (event) => {
    console.error('SSE error:', event);
    onError?.(new Error('Training stream connection error'));
  };

  return eventSource;
};

/**
 * HuggingFace 데이터셋으로 학습 시작 (편의 함수)
 */
export const startTrainingWithHuggingFaceDataset = async (
  modelName: string,
  modelType: MLModelType,
  datasetId: string,
  options?: {
    baseModel?: string;
    maxEpochs?: number;
    validationSplit?: number;
    hyperparameters?: TrainingRequest['hyperparameters'];
  }
): Promise<TrainingResponse> => {
  const request: TrainingRequest = {
    model_name: modelName,
    model_type: modelType,
    dataset_path: `huggingface:${datasetId}`,
    dataset_format: 'huggingface',
    base_model: options?.baseModel || DEFAULT_BASE_MODELS[modelType][0],
    max_epochs: options?.maxEpochs || 3,
    validation_split: options?.validationSplit || 0.1,
    hyperparameters: options?.hyperparameters || {
      learning_rate: 2e-5,
      batch_size: 16,
      warmup_steps: 500,
      weight_decay: 0.01,
    },
    callbacks: {
      early_stopping: true,
      early_stopping_patience: 3,
      save_best_model: true,
    },
    metadata: {
      dataset_source: 'huggingface',
      dataset_id: datasetId,
    },
  };
  
  return startTraining(request);
};

/**
 * 분석된 기사 데이터로 학습 시작 (편의 함수)
 */
export const startTrainingWithAnalyzedData = async (
  modelName: string,
  modelType: MLModelType,
  articleIds: number[],
  options?: {
    baseModel?: string;
    maxEpochs?: number;
    labelField?: string;
  }
): Promise<TrainingResponse> => {
  // 분석된 기사 데이터를 데이터셋으로 변환하여 학습
  const request: TrainingRequest = {
    model_name: modelName,
    model_type: modelType,
    dataset_path: `newsinsight:analyzed_articles`,
    dataset_format: 'json',
    base_model: options?.baseModel || DEFAULT_BASE_MODELS[modelType][0],
    max_epochs: options?.maxEpochs || 5,
    validation_split: 0.15,
    hyperparameters: {
      learning_rate: 2e-5,
      batch_size: 8,
      warmup_steps: 100,
      weight_decay: 0.01,
    },
    metadata: {
      dataset_source: 'newsinsight',
      article_ids: articleIds,
      label_field: options?.labelField || 'sentiment_label',
    },
  };
  
  return startTraining(request);
};

// ============================================
// Search Job Queue API (Concurrent Jobs)
// ============================================

/**
 * Search job type
 */
export type SearchJobType = 'UNIFIED' | 'DEEP_SEARCH' | 'FACT_CHECK' | 'BROWSER_AGENT';

/**
 * Search job status
 */
export type SearchJobStatus = 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';

/**
 * Search job record
 */
export interface SearchJob {
  jobId: string;
  type: SearchJobType;
  query: string;
  timeWindow?: string;
  userId?: string;
  sessionId?: string;
  projectId?: number;
  status: SearchJobStatus;
  progress: number;
  currentPhase?: string;
  errorMessage?: string;
  startedAt: string;
  completedAt?: string;
  result?: Record<string, unknown>;
}

/**
 * Search job event from SSE
 */
export interface SearchJobEvent {
  jobId: string;
  eventType: 'started' | 'progress' | 'completed' | 'failed' | 'cancelled' | 'heartbeat';
  status: SearchJobStatus;
  progress: number;
  currentPhase?: string;
  message?: string;
  timestamp: number;
}

/**
 * Request payload for starting a search job
 */
export interface StartSearchJobRequest {
  type: SearchJobType;
  query: string;
  timeWindow?: string;
  userId?: string;
  sessionId?: string;
  projectId?: number;
  options?: Record<string, unknown>;
}

/**
 * Start a new search job
 */
export const startSearchJob = async (request: StartSearchJobRequest): Promise<{
  jobId: string;
  type: string;
  query: string;
  status: string;
  message: string;
}> => {
  const client = await getApiClient();
  const response = await client.post('/api/v1/jobs', request);
  return response.data;
};

/**
 * Start multiple search jobs concurrently (batch)
 */
export const startSearchJobsBatch = async (requests: StartSearchJobRequest[]): Promise<{
  jobs: Array<{ jobId: string; type: string; query: string; status: string }>;
  count: number;
  message: string;
}> => {
  const client = await getApiClient();
  const response = await client.post('/api/v1/jobs/batch', requests);
  return response.data;
};

/**
 * Get job status
 */
export const getSearchJobStatus = async (jobId: string): Promise<SearchJob> => {
  const client = await getApiClient();
  const response = await client.get<SearchJob>(`/api/v1/jobs/${jobId}`);
  return response.data;
};

/**
 * Get active jobs for user
 */
export const getActiveSearchJobs = async (userId: string = 'anonymous'): Promise<SearchJob[]> => {
  const client = await getApiClient();
  const response = await client.get<SearchJob[]>('/api/v1/jobs/active', { params: { userId } });
  return response.data;
};

/**
 * Get all jobs for user
 */
export const getAllSearchJobs = async (userId: string = 'anonymous', limit: number = 20): Promise<SearchJob[]> => {
  const client = await getApiClient();
  const response = await client.get<SearchJob[]>('/api/v1/jobs', { params: { userId, limit } });
  return response.data;
};

/**
 * Cancel a job
 */
export const cancelSearchJob = async (jobId: string): Promise<{
  jobId: string;
  status: string;
  message: string;
}> => {
  const client = await getApiClient();
  const response = await client.post(`/api/v1/jobs/${jobId}/cancel`);
  return response.data;
};

/**
 * Get SSE stream URL for job updates
 */
export const getSearchJobStreamUrl = async (jobId: string): Promise<string> => {
  const initialBase = resolveInitialBaseUrl();
  const baseURL = await fetchConfiguredBaseUrl(initialBase);
  const effectiveBaseURL = baseURL || (typeof globalThis.window !== 'undefined' ? globalThis.window.location.origin : '');
  return `${effectiveBaseURL}/api/v1/jobs/${jobId}/stream`;
};

/**
 * Open SSE stream for job updates
 */
export const openSearchJobStream = async (jobId: string): Promise<EventSource> => {
  const url = await getSearchJobStreamUrl(jobId);
  return createAuthenticatedEventSource(url);
};

/**
 * Get SSE stream URL for all user jobs
 */
export const getAllJobsStreamUrl = async (userId: string = 'anonymous'): Promise<string> => {
  const initialBase = resolveInitialBaseUrl();
  const baseURL = await fetchConfiguredBaseUrl(initialBase);
  const effectiveBaseURL = baseURL || (typeof globalThis.window !== 'undefined' ? globalThis.window.location.origin : '');
  return `${effectiveBaseURL}/api/v1/jobs/stream?userId=${encodeURIComponent(userId)}`;
};

/**
 * Open SSE stream for all user jobs
 */
export const openAllJobsStream = async (userId: string = 'anonymous'): Promise<EventSource> => {
  const url = await getAllJobsStreamUrl(userId);
  return createAuthenticatedEventSource(url);
};

/**
 * Check job service health
 */
export const checkJobServiceHealth = async (): Promise<{
  status: string;
  features: Record<string, boolean>;
  supportedTypes: string[];
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/jobs/health');
  return response.data;
};

// ============================================
// Continue Work API (Improved)
// ============================================

/**
 * Completion status for search history
 */
export type CompletionStatus = 'DRAFT' | 'IN_PROGRESS' | 'PARTIAL' | 'COMPLETED' | 'FAILED' | 'CANCELLED';

/**
 * Continue work item (extended search history)
 */
export interface ContinueWorkItem extends SearchHistoryRecord {
  completionStatus?: CompletionStatus;
  viewed?: boolean;
  viewedAt?: string;
  reportGenerated?: boolean;
  failurePhase?: string;
  failureDetails?: string;
  partialResults?: Record<string, unknown>;
  progress?: number;
  currentPhase?: string;
  projectId?: number;
}

/**
 * Get continue work items (actionable searches)
 */
export const getContinueWorkItems = async (
  userId: string = 'anonymous',
  sessionId?: string,
  limit: number = 10
): Promise<{
  items: ContinueWorkItem[];
  count: number;
  stats: {
    total: number;
    inProgress: number;
    failed: number;
    draft: number;
    partial: number;
    unviewedCompleted: number;
  };
}> => {
  const client = await getApiClient();
  const params: Record<string, string | number> = { userId, limit };
  if (sessionId) params.sessionId = sessionId;
  const response = await client.get('/api/v1/search-history/continue-work', { params });
  return response.data;
};

/**
 * Mark search as viewed
 */
export const markSearchAsViewed = async (id: number): Promise<SearchHistoryRecord> => {
  const client = await getApiClient();
  const response = await client.post<SearchHistoryRecord>(`/api/v1/search-history/${id}/viewed`);
  return response.data;
};

/**
 * Mark search as viewed by external ID
 */
export const markSearchAsViewedByExternalId = async (externalId: string): Promise<SearchHistoryRecord> => {
  const client = await getApiClient();
  const response = await client.post<SearchHistoryRecord>(`/api/v1/search-history/external/${externalId}/viewed`);
  return response.data;
};

/**
 * Update completion status
 */
export const updateSearchCompletionStatus = async (id: number, status: CompletionStatus): Promise<SearchHistoryRecord> => {
  const client = await getApiClient();
  const response = await client.put<SearchHistoryRecord>(`/api/v1/search-history/${id}/status`, { status });
  return response.data;
};

/**
 * Get searches by completion status
 */
export const getSearchesByCompletionStatus = async (
  status: CompletionStatus,
  page: number = 0,
  size: number = 20
): Promise<PageResponse<SearchHistoryRecord>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<SearchHistoryRecord>>(
    `/api/v1/search-history/status/${status}`,
    { params: { page, size } }
  );
  return response.data;
};

/**
 * Get searches by project ID
 */
export const getSearchesByProject = async (
  projectId: number,
  page: number = 0,
  size: number = 20
): Promise<PageResponse<SearchHistoryRecord>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<SearchHistoryRecord>>(
    `/api/v1/search-history/project/${projectId}`,
    { params: { page, size } }
  );
  return response.data;
};

/**
 * Get failed searches
 */
export const getFailedSearches = async (
  daysBack: number = 7,
  limit: number = 20
): Promise<SearchHistoryRecord[]> => {
  const client = await getApiClient();
  const response = await client.get<SearchHistoryRecord[]>('/api/v1/search-history/failed', {
    params: { daysBack, limit }
  });
  return response.data;
};

// ============================================
// Project API
// ============================================

/**
 * Project category
 */
export type ProjectCategory = 'RESEARCH' | 'MONITORING' | 'FACT_CHECK' | 'TREND_ANALYSIS' | 'CUSTOM';

/**
 * Project status
 */
export type ProjectStatus = 'ACTIVE' | 'PAUSED' | 'COMPLETED' | 'ARCHIVED';

/**
 * Project visibility
 */
export type ProjectVisibility = 'PRIVATE' | 'TEAM' | 'PUBLIC';

/**
 * Member role
 */
export type MemberRole = 'ADMIN' | 'EDITOR' | 'VIEWER';

/**
 * Member status
 */
export type MemberStatus = 'ACTIVE' | 'PENDING' | 'LEFT';

/**
 * Project settings
 */
export interface ProjectSettings {
  autoCollect?: boolean;
  collectInterval?: 'hourly' | 'daily' | 'weekly';
  collectSources?: string[];
  timeWindow?: string;
  notifications?: {
    newArticles?: boolean;
    importantUpdates?: boolean;
    weeklyDigest?: boolean;
    emailEnabled?: boolean;
    slackWebhook?: string;
  };
  aiAnalysis?: {
    enabled?: boolean;
    autoSummarize?: boolean;
    sentimentTracking?: boolean;
    trendDetection?: boolean;
    factCheck?: boolean;
  };
}

/**
 * Project record
 */
export interface Project {
  id: number;
  name: string;
  description?: string;
  keywords?: string[];
  category: ProjectCategory;
  status: ProjectStatus;
  visibility: ProjectVisibility;
  ownerId: string;
  color?: string;
  icon?: string;
  isDefault?: boolean;
  settings?: ProjectSettings;
  stats?: Record<string, unknown>;
  tags?: string[];
  metadata?: Record<string, unknown>;
  createdAt: string;
  updatedAt?: string;
  lastActivityAt?: string;
  lastCollectedAt?: string;
}

/**
 * Project member
 */
export interface ProjectMember {
  id: number;
  projectId: number;
  userId: string;
  role: MemberRole;
  status: MemberStatus;
  invitedBy?: string;
  inviteToken?: string;
  inviteExpiresAt?: string;
  permissions?: Record<string, boolean>;
  joinedAt?: string;
  lastActiveAt?: string;
}

/**
 * Project item type
 */
export type ProjectItemType = 'ARTICLE' | 'SEARCH_RESULT' | 'NOTE' | 'DOCUMENT' | 'URL' | 'EVIDENCE';

/**
 * Project item
 */
export interface ProjectItem {
  id: number;
  projectId: number;
  itemType: ProjectItemType;
  title: string;
  summary?: string;
  url?: string;
  imageUrl?: string;
  sourceName?: string;
  sourceId?: string;
  sourceType?: string;
  publishedAt?: string;
  category?: string;
  tags?: string[];
  sentiment?: string;
  importance?: number;
  isRead?: boolean;
  bookmarked?: boolean;
  addedBy?: string;
  addedAt?: string;
  metadata?: Record<string, unknown>;
}

/**
 * Project activity log
 */
export interface ProjectActivityLog {
  id: number;
  projectId: number;
  userId: string;
  activityType: string;
  description: string;
  entityType?: string;
  entityId?: string;
  details?: Record<string, unknown>;
  createdAt: string;
}

/**
 * Project notification
 */
export interface ProjectNotification {
  id: number;
  projectId: number;
  userId: string;
  notificationType: string;
  title: string;
  message?: string;
  actionUrl?: string;
  isRead: boolean;
  readAt?: string;
  createdAt: string;
}

/**
 * Create project request
 */
export interface CreateProjectRequest {
  name: string;
  description?: string;
  keywords?: string[];
  category?: ProjectCategory;
  visibility?: ProjectVisibility;
  ownerId: string;
  color?: string;
  icon?: string;
  isDefault?: boolean;
  settings?: ProjectSettings;
  tags?: string[];
}

/**
 * Update project request
 */
export interface UpdateProjectRequest {
  name?: string;
  description?: string;
  keywords?: string[];
  category?: ProjectCategory;
  visibility?: ProjectVisibility;
  color?: string;
  icon?: string;
  settings?: ProjectSettings;
  tags?: string[];
}

/**
 * Add project item request
 */
export interface AddProjectItemRequest {
  itemType: ProjectItemType;
  title: string;
  summary?: string;
  url?: string;
  imageUrl?: string;
  sourceName?: string;
  sourceId?: string;
  sourceType?: string;
  publishedAt?: string;
  category?: string;
  tags?: string[];
  sentiment?: string;
  importance?: number;
  metadata?: Record<string, unknown>;
}

// ============ Project CRUD ============

/**
 * Create a new project
 */
export const createProject = async (request: CreateProjectRequest): Promise<Project> => {
  const client = await getApiClient();
  const response = await client.post<Project>('/api/v1/projects', request);
  return response.data;
};

/**
 * Get project by ID
 */
export const getProject = async (id: number, userId?: string): Promise<Project> => {
  const client = await getApiClient();
  const params = userId ? { userId } : {};
  const response = await client.get<Project>(`/api/v1/projects/${id}`, { params });
  return response.data;
};

/**
 * Update project
 */
export const updateProject = async (id: number, request: UpdateProjectRequest, userId: string): Promise<Project> => {
  const client = await getApiClient();
  const response = await client.put<Project>(`/api/v1/projects/${id}`, request, { params: { userId } });
  return response.data;
};

/**
 * Update project status
 */
export const updateProjectStatus = async (id: number, status: ProjectStatus, userId: string): Promise<Project> => {
  const client = await getApiClient();
  const response = await client.put<Project>(`/api/v1/projects/${id}/status`, { status }, { params: { userId } });
  return response.data;
};

/**
 * Delete project
 */
export const deleteProject = async (id: number, userId: string): Promise<void> => {
  const client = await getApiClient();
  await client.delete(`/api/v1/projects/${id}`, { params: { userId } });
};

/**
 * Get projects by owner
 */
export const getProjectsByOwner = async (
  ownerId: string,
  status?: ProjectStatus,
  page: number = 0,
  size: number = 20
): Promise<PageResponse<Project>> => {
  const client = await getApiClient();
  const params: Record<string, string | number> = { ownerId, page, size };
  if (status) params.status = status;
  const response = await client.get<PageResponse<Project>>('/api/v1/projects', { params });
  return response.data;
};

/**
 * Search projects
 */
export const searchProjects = async (
  q: string,
  page: number = 0,
  size: number = 20
): Promise<PageResponse<Project>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<Project>>('/api/v1/projects/search', { params: { q, page, size } });
  return response.data;
};

/**
 * Get or create default project
 */
export const getDefaultProject = async (userId: string): Promise<Project> => {
  const client = await getApiClient();
  const response = await client.get<Project>('/api/v1/projects/default', { params: { userId } });
  return response.data;
};

/**
 * Get project statistics
 */
export const getProjectStats = async (id: number): Promise<{
  itemCount: number;
  unreadCount: number;
  memberCount: number;
  categories: string[];
}> => {
  const client = await getApiClient();
  const response = await client.get(`/api/v1/projects/${id}/stats`);
  return response.data;
};

// ============ Project Members ============

/**
 * Get project members
 */
export const getProjectMembers = async (projectId: number): Promise<ProjectMember[]> => {
  const client = await getApiClient();
  const response = await client.get<ProjectMember[]>(`/api/v1/projects/${projectId}/members`);
  return response.data;
};

/**
 * Get active members
 */
export const getActiveProjectMembers = async (projectId: number): Promise<ProjectMember[]> => {
  const client = await getApiClient();
  const response = await client.get<ProjectMember[]>(`/api/v1/projects/${projectId}/members/active`);
  return response.data;
};

/**
 * Invite member
 */
export const inviteProjectMember = async (
  projectId: number,
  userId: string,
  role: MemberRole,
  invitedBy: string
): Promise<ProjectMember> => {
  const client = await getApiClient();
  const response = await client.post<ProjectMember>(
    `/api/v1/projects/${projectId}/members/invite`,
    { userId, role },
    { params: { invitedBy } }
  );
  return response.data;
};

/**
 * Accept invitation
 */
export const acceptProjectInvitation = async (token: string, userId: string): Promise<ProjectMember> => {
  const client = await getApiClient();
  const response = await client.post<ProjectMember>(
    `/api/v1/projects/invitations/${token}/accept`,
    null,
    { params: { userId } }
  );
  return response.data;
};

/**
 * Remove member
 */
export const removeProjectMember = async (projectId: number, userId: string, removedBy: string): Promise<void> => {
  const client = await getApiClient();
  await client.delete(`/api/v1/projects/${projectId}/members/${userId}`, { params: { removedBy } });
};

/**
 * Update member role
 */
export const updateProjectMemberRole = async (
  projectId: number,
  userId: string,
  role: MemberRole,
  updatedBy: string
): Promise<ProjectMember> => {
  const client = await getApiClient();
  const response = await client.put<ProjectMember>(
    `/api/v1/projects/${projectId}/members/${userId}/role`,
    { role },
    { params: { updatedBy } }
  );
  return response.data;
};

// ============ Project Items ============

/**
 * Add item to project
 */
export const addProjectItem = async (
  projectId: number,
  request: AddProjectItemRequest,
  userId: string
): Promise<ProjectItem> => {
  const client = await getApiClient();
  const response = await client.post<ProjectItem>(
    `/api/v1/projects/${projectId}/items`,
    request,
    { params: { userId } }
  );
  return response.data;
};

/**
 * Get project items
 */
export const getProjectItems = async (
  projectId: number,
  type?: ProjectItemType,
  page: number = 0,
  size: number = 20
): Promise<PageResponse<ProjectItem>> => {
  const client = await getApiClient();
  const params: Record<string, string | number> = { page, size };
  if (type) params.type = type;
  const response = await client.get<PageResponse<ProjectItem>>(`/api/v1/projects/${projectId}/items`, { params });
  return response.data;
};

/**
 * Search project items
 */
export const searchProjectItems = async (
  projectId: number,
  q: string,
  page: number = 0,
  size: number = 20
): Promise<PageResponse<ProjectItem>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<ProjectItem>>(
    `/api/v1/projects/${projectId}/items/search`,
    { params: { q, page, size } }
  );
  return response.data;
};

/**
 * Mark item as read
 */
export const markProjectItemAsRead = async (projectId: number, itemId: number, userId: string): Promise<void> => {
  const client = await getApiClient();
  await client.post(`/api/v1/projects/${projectId}/items/${itemId}/read`, null, { params: { userId } });
};

/**
 * Toggle item bookmark
 */
export const toggleProjectItemBookmark = async (projectId: number, itemId: number, userId: string): Promise<void> => {
  const client = await getApiClient();
  await client.post(`/api/v1/projects/${projectId}/items/${itemId}/bookmark`, null, { params: { userId } });
};

/**
 * Delete item
 */
export const deleteProjectItem = async (projectId: number, itemId: number, userId: string): Promise<void> => {
  const client = await getApiClient();
  await client.delete(`/api/v1/projects/${projectId}/items/${itemId}`, { params: { userId } });
};

// ============ Project Activities ============

/**
 * Get project activity log
 */
export const getProjectActivityLog = async (
  projectId: number,
  page: number = 0,
  size: number = 20
): Promise<PageResponse<ProjectActivityLog>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<ProjectActivityLog>>(
    `/api/v1/projects/${projectId}/activities`,
    { params: { page, size } }
  );
  return response.data;
};

/**
 * Get recent activity
 */
export const getRecentProjectActivity = async (projectId: number): Promise<ProjectActivityLog[]> => {
  const client = await getApiClient();
  const response = await client.get<ProjectActivityLog[]>(`/api/v1/projects/${projectId}/activities/recent`);
  return response.data;
};

// ============ Project Notifications ============

/**
 * Get user notifications
 */
export const getProjectNotifications = async (
  userId: string,
  page: number = 0,
  size: number = 20
): Promise<PageResponse<ProjectNotification>> => {
  const client = await getApiClient();
  const response = await client.get<PageResponse<ProjectNotification>>(
    '/api/v1/projects/notifications',
    { params: { userId, page, size } }
  );
  return response.data;
};

/**
 * Get unread notifications
 */
export const getUnreadProjectNotifications = async (userId: string): Promise<ProjectNotification[]> => {
  const client = await getApiClient();
  const response = await client.get<ProjectNotification[]>('/api/v1/projects/notifications/unread', {
    params: { userId }
  });
  return response.data;
};

/**
 * Mark notification as read
 */
export const markProjectNotificationAsRead = async (notificationId: number): Promise<void> => {
  const client = await getApiClient();
  await client.post(`/api/v1/projects/notifications/${notificationId}/read`);
};

/**
 * Mark all notifications as read
 */
export const markAllProjectNotificationsAsRead = async (userId: string): Promise<void> => {
  const client = await getApiClient();
  await client.post('/api/v1/projects/notifications/read-all', null, { params: { userId } });
};

/**
 * Check project service health
 */
export const checkProjectServiceHealth = async (): Promise<{
  status: string;
  features: Record<string, boolean>;
}> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/projects/health');
  return response.data;
};

// ============================================
// LLM Provider Settings API
// Backend: /api/v1/llm-providers, /api/v1/admin/llm-providers
// ============================================

import type {
  LlmProviderType as LlmProviderTypeEnum,
  LlmProviderTypeInfo,
  LlmProviderSettings,
  LlmProviderSettingsRequest,
  LlmTestResult,
} from '@/types/api';

/**
 * 지원하는 LLM Provider 타입 목록 조회
 */
export const getLlmProviderTypes = async (): Promise<LlmProviderTypeInfo[]> => {
  const client = await getApiClient();
  const response = await client.get<LlmProviderTypeInfo[]>('/api/v1/admin/llm-providers/types');
  return response.data;
};

// ========== 관리자 전역 설정 API ==========

/**
 * 모든 전역(관리자) LLM 설정 조회
 */
export const getGlobalLlmSettings = async (): Promise<LlmProviderSettings[]> => {
  const client = await getApiClient();
  const response = await client.get<LlmProviderSettings[]>('/api/v1/admin/llm-providers/global');
  return response.data;
};

/**
 * 특정 Provider의 전역 설정 조회
 */
export const getGlobalLlmSetting = async (providerType: LlmProviderTypeEnum): Promise<LlmProviderSettings | null> => {
  const client = await getApiClient();
  try {
    const response = await client.get<LlmProviderSettings>(`/api/v1/admin/llm-providers/global/${providerType}`);
    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error) && error.response?.status === 404) {
      return null;
    }
    throw error;
  }
};

/**
 * 전역(관리자) LLM 설정 저장/수정
 */
export const saveGlobalLlmSetting = async (request: LlmProviderSettingsRequest): Promise<LlmProviderSettings> => {
  const client = await getApiClient();
  const response = await client.put<LlmProviderSettings>(`/api/v1/admin/llm-providers/global/${request.providerType}`, request);
  return response.data;
};

/**
 * 전역(관리자) LLM 설정 삭제
 */
export const deleteGlobalLlmSetting = async (providerType: LlmProviderTypeEnum): Promise<void> => {
  const client = await getApiClient();
  await client.delete(`/api/v1/admin/llm-providers/global/${providerType}`);
};

/**
 * 전역 설정 연결 테스트
 */
export const testGlobalLlmConnection = async (providerType: LlmProviderTypeEnum): Promise<LlmTestResult> => {
  const client = await getApiClient();
  const response = await client.post<LlmTestResult>('/api/v1/admin/llm-providers/test', null, {
    params: { providerType }
  });
  return response.data;
};

/**
 * 전역 설정 활성화/비활성화
 * NOTE: Backend 엔드포인트가 없어 saveGlobalLlmSetting을 통해 처리
 */
export const toggleGlobalLlmSetting = async (providerType: LlmProviderTypeEnum, enabled: boolean): Promise<void> => {
  const client = await getApiClient();
  // enabled 상태만 변경하는 최소한의 요청
  await client.put(`/api/v1/admin/llm-providers/global/${providerType}`, { 
    providerType, 
    enabled,
    defaultModel: '' // 기존 값 유지
  });
};

// ========== 사용자별 설정 API ==========

/**
 * 현재 사용자에게 유효한 모든 LLM 설정 조회 (사용자 설정 > 전역 설정)
 */
export const getEffectiveLlmSettings = async (userId?: string): Promise<LlmProviderSettings[]> => {
  const client = await getApiClient();
  const params: Record<string, string> = {};
  if (userId) params.user_id = userId;
  const response = await client.get<LlmProviderSettings[]>('/api/v1/admin/llm-providers/effective', { params });
  return response.data;
};

/**
 * 활성화된 Provider 목록 (Fallback 체인용)
 */
export const getEnabledLlmProviders = async (userId?: string): Promise<LlmProviderSettings[]> => {
  const client = await getApiClient();
  const params: Record<string, string> = {};
  if (userId) params.user_id = userId;
  const response = await client.get<LlmProviderSettings[]>('/api/v1/admin/llm-providers/enabled', { params });
  return response.data;
};

/**
 * 특정 Provider의 유효 설정 조회
 */
export const getEffectiveLlmSetting = async (
  providerType: LlmProviderTypeEnum,
  userId?: string
): Promise<LlmProviderSettings | null> => {
  const client = await getApiClient();
  const headers: Record<string, string> = {};
  if (userId) headers['X-User-Id'] = userId;
  try {
    const response = await client.get<LlmProviderSettings>(
      `/api/v1/llm-providers/config/${providerType}`,
      { headers }
    );
    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error) && error.response?.status === 404) {
      return null;
    }
    throw error;
  }
};

/**
 * 사용자의 개인 LLM 설정만 조회
 */
export const getUserLlmSettings = async (userId: string): Promise<LlmProviderSettings[]> => {
  const client = await getApiClient();
  const response = await client.get<LlmProviderSettings[]>('/api/v1/llm-providers/user', {
    headers: { 'X-User-Id': userId },
  });
  return response.data;
};

/**
 * 사용자 LLM 설정 저장/수정
 */
export const saveUserLlmSetting = async (
  userId: string,
  request: LlmProviderSettingsRequest
): Promise<LlmProviderSettings> => {
  const client = await getApiClient();
  const response = await client.put<LlmProviderSettings>('/api/v1/llm-providers/user', request, {
    headers: { 'X-User-Id': userId },
  });
  return response.data;
};

/**
 * 사용자 LLM 설정 삭제 (전역 설정으로 폴백)
 */
export const deleteUserLlmSetting = async (userId: string, providerType: LlmProviderTypeEnum): Promise<void> => {
  const client = await getApiClient();
  await client.delete(`/api/v1/llm-providers/user/${providerType}`, {
    headers: { 'X-User-Id': userId },
  });
};

/**
 * 사용자의 모든 개인 설정 삭제
 */
export const deleteAllUserLlmSettings = async (userId: string): Promise<void> => {
  const client = await getApiClient();
  await client.delete('/api/v1/llm-providers/user', {
    headers: { 'X-User-Id': userId },
  });
};

/**
 * 사용자 설정 연결 테스트
 */
export const testUserLlmConnection = async (id: number): Promise<LlmTestResult> => {
  const client = await getApiClient();
  const response = await client.post<LlmTestResult>(`/api/v1/llm-providers/user/${id}/test`);
  return response.data;
};

/**
 * 새 설정으로 연결 테스트 (저장 전)
 */
export const testNewLlmConnection = async (request: LlmProviderSettingsRequest): Promise<LlmTestResult> => {
  const client = await getApiClient();
  const response = await client.post<LlmTestResult>('/api/v1/llm-providers/test', request);
  return response.data;
};

// ============================================
// Config Export/Import API (관리자 설정 일괄 관리)
// ============================================

import type {
  SystemConfigExport,
  SystemConfigImport,
  ConfigImportResult,
  ConfigImportOptions,
} from '@/types/api';

/**
 * 전체 시스템 설정 Export (LLM Provider + ML Addon)
 */
export const exportSystemConfig = async (
  includeLlm: boolean = true,
  includeMl: boolean = true
): Promise<SystemConfigExport> => {
  const client = await getApiClient();
  const response = await client.get<SystemConfigExport>('/api/v1/admin/config-export/export', {
    params: { include_llm: includeLlm, include_ml: includeMl },
  });
  return response.data;
};

/**
 * 설정을 JSON 파일로 다운로드
 */
export const downloadSystemConfig = async (
  includeLlm: boolean = true,
  includeMl: boolean = true
): Promise<Blob> => {
  const client = await getApiClient();
  const response = await client.get('/api/v1/admin/config-export/export/download', {
    params: { include_llm: includeLlm, include_ml: includeMl },
    responseType: 'blob',
  });
  return response.data;
};

/**
 * JSON 설정을 시스템에 Import
 */
export const importSystemConfig = async (
  config: SystemConfigImport,
  options?: ConfigImportOptions
): Promise<ConfigImportResult> => {
  const client = await getApiClient();
  const response = await client.post<ConfigImportResult>('/api/v1/admin/config-export/import', config, {
    params: options,
  });
  return response.data;
};

/**
 * Import 설정 유효성 검증 (실제 import 안함)
 */
export const validateSystemConfig = async (
  config: SystemConfigImport
): Promise<ConfigImportResult> => {
  const client = await getApiClient();
  const response = await client.post<ConfigImportResult>('/api/v1/admin/config-export/import/validate', config);
  return response.data;
};

/**
 * Import용 설정 템플릿 가져오기
 */
export const getConfigTemplate = async (): Promise<SystemConfigImport> => {
  const client = await getApiClient();
  const response = await client.get<SystemConfigImport>('/api/v1/admin/config-export/template');
  return response.data;
};

```

---

## frontend/src/lib/publicAuthApi.ts

```ts
/**
 * Public Auth API - 일반 사용자용 인증 API
 * 
 * 엔드포인트: /api/v1/auth/...
 * - 회원가입, 로그인, 내 정보 조회 등
 */

import { getApiClient } from './api';
import type { Token, User } from '@/types/admin';

export interface RegisterRequest {
  username: string;
  email: string;
  password: string;
}

export interface UsernameCheckResponse {
  username: string;
  available: boolean;
}

export interface EmailCheckResponse {
  email: string;
  available: boolean;
}

/**
 * 일반 사용자용 공개 인증 API
 */
export const publicAuthApi = {
  /**
   * 회원가입
   * - 성공 시 즉시 토큰 반환 (자동 로그인)
   */
  register: async (data: RegisterRequest): Promise<Token> => {
    const client = await getApiClient();
    const response = await client.post<Token>('/api/v1/auth/register', data);
    return response.data;
  },

  /**
   * 로그인
   */
  login: async (username: string, password: string): Promise<Token> => {
    const client = await getApiClient();
    const formData = new URLSearchParams();
    formData.append('username', username);
    formData.append('password', password);
    
    const response = await client.post<Token>('/api/v1/auth/token', formData, {
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    });
    return response.data;
  },

  /**
   * 로그아웃
   */
  logout: async (): Promise<void> => {
    const client = await getApiClient();
    await client.post('/api/v1/auth/logout');
  },

  /**
   * 현재 사용자 정보 조회
   */
  me: async (): Promise<User> => {
    const client = await getApiClient();
    const response = await client.get<User>('/api/v1/auth/me');
    return response.data;
  },

  /**
   * 비밀번호 변경
   */
  changePassword: async (oldPassword: string, newPassword: string): Promise<void> => {
    const client = await getApiClient();
    await client.post('/api/v1/auth/change-password', {
      old_password: oldPassword,
      new_password: newPassword,
    });
  },

  /**
   * 계정 삭제 (회원탈퇴)
   */
  deleteAccount: async (): Promise<void> => {
    const client = await getApiClient();
    await client.delete('/api/v1/auth/me');
  },

  /**
   * 사용자명 중복 확인
   */
  checkUsername: async (username: string): Promise<UsernameCheckResponse> => {
    const client = await getApiClient();
    const response = await client.get<UsernameCheckResponse>(`/api/v1/auth/check-username/${encodeURIComponent(username)}`);
    return response.data;
  },

  /**
   * 이메일 중복 확인
   */
  checkEmail: async (email: string): Promise<EmailCheckResponse> => {
    const client = await getApiClient();
    const response = await client.get<EmailCheckResponse>(`/api/v1/auth/check-email/${encodeURIComponent(email)}`);
    return response.data;
  },

  /**
   * 이메일 인증 코드 발송 (회원가입 1단계)
   */
  sendVerification: async (data: RegisterRequest): Promise<{
    success: boolean;
    message: string;
    email: string;
    expires_in: number;
    code?: string; // 개발 환경에서만 반환
  }> => {
    const client = await getApiClient();
    const response = await client.post('/api/v1/auth/send-verification', data);
    return response.data;
  },

  /**
   * 이메일 인증 코드 검증 및 회원가입 완료 (회원가입 2단계)
   */
  verifyEmail: async (email: string, code: string): Promise<Token> => {
    const client = await getApiClient();
    const response = await client.post<Token>('/api/v1/auth/verify-email', { email, code });
    return response.data;
  },

  /**
   * 인증 코드 재발송
   */
  resendVerification: async (email: string): Promise<{
    success: boolean;
    message: string;
    email: string;
    expires_in: number;
    code?: string;
  }> => {
    const client = await getApiClient();
    const response = await client.post('/api/v1/auth/resend-verification', { email });
    return response.data;
  },
};

export default publicAuthApi;

```

---

## frontend/src/lib/utils.ts

```ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

```

---

## frontend/src/main.tsx

```tsx
import { createRoot } from "react-dom/client";
import App from "./App.tsx";
import "./index.css";

createRoot(document.getElementById("root")!).render(<App />);

```

---

## frontend/src/pages/AdminSources.tsx

```tsx
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { RefreshCw, AlertCircle, MoreHorizontal, Pencil, Trash2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { 
  listSources, 
  createSource, 
  updateSource,
  deleteSource,
  setSourceActive, 
  type CreateDataSourcePayload,
  type UpdateDataSourcePayload 
} from "@/lib/api";
import type { DataSource, SourceType } from "@/types/api";

const DEFAULT_FREQUENCY = 3600;

const AdminSources = () => {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Form states for creating new source
  const [name, setName] = useState("");
  const [url, setUrl] = useState("");
  const [sourceType, setSourceType] = useState<SourceType>("RSS");
  const [collectionFrequency, setCollectionFrequency] = useState<string>(String(DEFAULT_FREQUENCY));
  const [category, setCategory] = useState("");
  const [country, setCountry] = useState("KR");
  const [language, setLanguage] = useState("ko");
  const [searchUrlTemplate, setSearchUrlTemplate] = useState("");
  const [searchPriority, setSearchPriority] = useState<string>("100");

  // Edit dialog states
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [editingSource, setEditingSource] = useState<DataSource | null>(null);
  const [editName, setEditName] = useState("");
  const [editUrl, setEditUrl] = useState("");
  const [editSourceType, setEditSourceType] = useState<SourceType>("RSS");
  const [editFrequency, setEditFrequency] = useState<string>(String(DEFAULT_FREQUENCY));
  const [editCategory, setEditCategory] = useState("");
  const [editCountry, setEditCountry] = useState("KR");
  const [editLanguage, setEditLanguage] = useState("ko");
  const [editSearchUrlTemplate, setEditSearchUrlTemplate] = useState("");
  const [editSearchPriority, setEditSearchPriority] = useState<string>("100");

  // Delete dialog states
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [deletingSource, setDeletingSource] = useState<DataSource | null>(null);

  // Pagination states
  const [currentPage, setCurrentPage] = useState(0);
  const pageSize = 20;

  // React Query: 소스 목록 조회
  const {
    data: sourcesPage,
    isLoading,
    error,
    isFetching,
    refetch,
  } = useQuery({
    queryKey: ['sources', currentPage, pageSize],
    queryFn: () => listSources(currentPage, pageSize, 'id', 'DESC'),
    staleTime: 30_000, // 30초간 fresh
    gcTime: 5 * 60_000, // 5분간 캐시 유지
    refetchInterval: 60_000, // 1분마다 자동 갱신
    retry: 3,
  });

  const sources = sourcesPage?.content ?? [];
  const totalPages = sourcesPage?.totalPages ?? 0;
  const totalElements = sourcesPage?.totalElements ?? 0;

  // React Query: 소스 생성 Mutation
  const createMutation = useMutation({
    mutationFn: createSource,
    onSuccess: (created) => {
      // 캐시에 새 소스 추가
      queryClient.setQueryData(['sources'], (old: typeof sourcesPage) => {
        if (!old) return old;
        return {
          ...old,
          content: [created, ...old.content],
          totalElements: old.totalElements + 1,
        };
      });
      
      // 폼 초기화
      setName("");
      setUrl("");
      setCollectionFrequency(String(DEFAULT_FREQUENCY));
      
      toast({
        title: "소스 등록 완료",
        description: `'${created.name}' 소스가 등록되었습니다.`,
      });
    },
    onError: (error: any) => {
      toast({
        title: "등록 실패",
        description: error?.response?.data?.message || error?.message || "소스 등록 중 오류가 발생했습니다.",
        variant: "destructive",
      });
    },
  });

  // React Query: 소스 활성화/비활성화 Mutation
  const toggleActiveMutation = useMutation({
    mutationFn: ({ id, active }: { id: number; active: boolean }) => setSourceActive(id, active),
    onMutate: async ({ id, active }) => {
      // 낙관적 업데이트 - 현재 페이지의 쿼리 키 사용
      const queryKey = ['sources', currentPage, pageSize];
      await queryClient.cancelQueries({ queryKey });
      
      const previousData = queryClient.getQueryData(queryKey);
      
      queryClient.setQueryData(queryKey, (old: typeof sourcesPage) => {
        if (!old) return old;
        return {
          ...old,
          content: old.content.map((s: DataSource) => 
            s.id === id ? { ...s, isActive: active } : s
          ),
        };
      });
      
      return { previousData, queryKey };
    },
    onError: (error, variables, context) => {
      // 실패 시 롤백
      if (context?.previousData && context?.queryKey) {
        queryClient.setQueryData(context.queryKey, context.previousData);
      }
      toast({
        title: "상태 변경 실패",
        description: "잠시 후 다시 시도해주세요.",
        variant: "destructive",
      });
    },
    onSuccess: (updated, variables, context) => {
      // 성공 시 서버 데이터로 업데이트
      if (context?.queryKey) {
        queryClient.setQueryData(context.queryKey, (old: typeof sourcesPage) => {
          if (!old) return old;
          return {
            ...old,
            content: old.content.map((s: DataSource) => 
              s.id === updated.id ? updated : s
            ),
          };
        });
      }
      // 다른 페이지 캐시도 무효화
      queryClient.invalidateQueries({ queryKey: ['sources'] });
    },
  });

  // React Query: 소스 수정 Mutation
  const updateMutation = useMutation({
    mutationFn: ({ id, payload }: { id: number; payload: UpdateDataSourcePayload }) => 
      updateSource(id, payload),
    onSuccess: (updated) => {
      queryClient.setQueryData(['sources'], (old: typeof sourcesPage) => {
        if (!old) return old;
        return {
          ...old,
          content: old.content.map((s: DataSource) => 
            s.id === updated.id ? updated : s
          ),
        };
      });
      
      setEditDialogOpen(false);
      setEditingSource(null);
      
      toast({
        title: "수정 완료",
        description: `'${updated.name}' 소스가 수정되었습니다.`,
      });
    },
    onError: (error: any) => {
      toast({
        title: "수정 실패",
        description: error?.response?.data?.message || error?.message || "소스 수정 중 오류가 발생했습니다.",
        variant: "destructive",
      });
    },
  });

  // React Query: 소스 삭제 Mutation
  const deleteMutation = useMutation({
    mutationFn: (id: number) => deleteSource(id),
    onSuccess: (_, deletedId) => {
      queryClient.setQueryData(['sources'], (old: typeof sourcesPage) => {
        if (!old) return old;
        return {
          ...old,
          content: old.content.filter((s: DataSource) => s.id !== deletedId),
          totalElements: old.totalElements - 1,
        };
      });
      
      setDeleteDialogOpen(false);
      setDeletingSource(null);
      
      toast({
        title: "삭제 완료",
        description: "소스가 삭제되었습니다.",
      });
    },
    onError: (error: any) => {
      toast({
        title: "삭제 실패",
        description: error?.response?.data?.message || error?.message || "소스 삭제 중 오류가 발생했습니다.",
        variant: "destructive",
      });
    },
  });

  const handleCreate = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim() || !url.trim()) {
      toast({
        title: "입력 오류",
        description: "이름과 URL을 모두 입력해주세요.",
        variant: "destructive",
      });
      return;
    }

    const freq = Number.parseInt(collectionFrequency, 10);
    const safeFreq = Number.isFinite(freq) && freq >= 60 ? freq : DEFAULT_FREQUENCY;

    const metadata: Record<string, unknown> = {};
    if (category.trim()) metadata.category = category.trim();
    if (country.trim()) metadata.country = country.trim();
    if (language.trim()) metadata.language = language.trim();

    const payload: CreateDataSourcePayload = {
      name: name.trim(),
      url: url.trim(),
      sourceType,
      collectionFrequency: safeFreq,
      metadata,
      searchUrlTemplate: searchUrlTemplate.trim() || undefined,
      searchPriority: searchPriority ? Number.parseInt(searchPriority, 10) : undefined,
    };

    createMutation.mutate(payload);
  };

  const handleToggleActive = (source: DataSource, active: boolean) => {
    toggleActiveMutation.mutate({ id: source.id, active });
  };

  // 편집 다이얼로그 열기
  const handleOpenEdit = (source: DataSource) => {
    setEditingSource(source);
    setEditName(source.name);
    setEditUrl(source.url);
    setEditSourceType(source.sourceType);
    setEditFrequency(String(source.collectionFrequency || DEFAULT_FREQUENCY));
    setEditCategory((source.metadata?.category as string) || "");
    setEditCountry((source.metadata?.country as string) || "KR");
    setEditLanguage((source.metadata?.language as string) || "ko");
    setEditSearchUrlTemplate(source.searchUrlTemplate || "");
    setEditSearchPriority(String(source.searchPriority || 100));
    setEditDialogOpen(true);
  };

  // 편집 저장
  const handleSaveEdit = () => {
    if (!editingSource || !editName.trim() || !editUrl.trim()) {
      toast({
        title: "입력 오류",
        description: "이름과 URL을 모두 입력해주세요.",
        variant: "destructive",
      });
      return;
    }

    const freq = Number.parseInt(editFrequency, 10);
    const safeFreq = Number.isFinite(freq) && freq >= 60 ? freq : DEFAULT_FREQUENCY;

    const metadata: Record<string, unknown> = {};
    if (editCategory.trim()) metadata.category = editCategory.trim();
    if (editCountry.trim()) metadata.country = editCountry.trim();
    if (editLanguage.trim()) metadata.language = editLanguage.trim();

    const payload: UpdateDataSourcePayload = {
      name: editName.trim(),
      url: editUrl.trim(),
      sourceType: editSourceType,
      collectionFrequency: safeFreq,
      metadata,
      searchUrlTemplate: editSearchUrlTemplate.trim() || undefined,
      searchPriority: editSearchPriority ? Number.parseInt(editSearchPriority, 10) : undefined,
    };

    updateMutation.mutate({ id: editingSource.id, payload });
  };

  // 삭제 다이얼로그 열기
  const handleOpenDelete = (source: DataSource) => {
    setDeletingSource(source);
    setDeleteDialogOpen(true);
  };

  // 삭제 확인
  const handleConfirmDelete = () => {
    if (deletingSource) {
      deleteMutation.mutate(deletingSource.id);
    }
  };

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-6xl space-y-6">
        <header className="mb-4 flex items-center justify-between">
          <div>
            <h1 className="text-3xl font-bold mb-2">데이터 소스 관리</h1>
            <p className="text-muted-foreground text-sm">
              RSS / WEB / API / WEBHOOK / AI Agent 소스를 등록하고 활성화 상태를 관리하는 관리자 화면입니다.
            </p>
          </div>
          <div className="flex items-center gap-2">
            {isFetching && !isLoading && (
              <Badge variant="secondary" className="animate-pulse">
                <RefreshCw className="h-3 w-3 mr-1 animate-spin" />
                동기화 중
              </Badge>
            )}
            <Button variant="outline" size="sm" onClick={() => refetch()} disabled={isFetching}>
              <RefreshCw className={`h-4 w-4 mr-1 ${isFetching ? 'animate-spin' : ''}`} />
              새로고침
            </Button>
          </div>
        </header>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 items-start">
          <Card className="lg:col-span-1 shadow-elegant">
            <CardHeader>
              <CardTitle>새 소스 등록</CardTitle>
              <CardDescription>이름과 URL만 입력하면 나머지는 기본값으로 등록됩니다.</CardDescription>
            </CardHeader>
            <CardContent>
              <form onSubmit={handleCreate} className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="name">이름</Label>
                  <Input
                    id="name"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    placeholder="예: 연합뉴스 - 전체"
                    disabled={createMutation.isPending}
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="url">URL</Label>
                  <Input
                    id="url"
                    value={url}
                    onChange={(e) => setUrl(e.target.value)}
                    placeholder="예: https://www.yna.co.kr/rss/allheadline.xml"
                    disabled={createMutation.isPending}
                  />
                </div>
                <div className="grid grid-cols-2 gap-3">
                  <div className="space-y-2">
                    <Label htmlFor="sourceType">타입</Label>
                    <Select
                      value={sourceType}
                      onValueChange={(value) => setSourceType(value as SourceType)}
                      disabled={createMutation.isPending}
                    >
                      <SelectTrigger id="sourceType">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="RSS">RSS</SelectItem>
                        <SelectItem value="WEB">WEB</SelectItem>
                        <SelectItem value="WEB_SEARCH">웹 검색</SelectItem>
                        <SelectItem value="API">API</SelectItem>
                        <SelectItem value="WEBHOOK">WEBHOOK</SelectItem>
                        <SelectItem value="BROWSER_AGENT">AI Agent</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="frequency">수집 주기(초)</Label>
                    <Input
                      id="frequency"
                      type="number"
                      min={60}
                      value={collectionFrequency}
                      onChange={(e) => setCollectionFrequency(e.target.value)}
                      disabled={createMutation.isPending}
                    />
                  </div>
                </div>
                {sourceType === "WEB_SEARCH" && (
                  <div className="space-y-3 p-3 border rounded-md bg-muted/30">
                    <p className="text-sm font-medium">웹 검색 소스 설정</p>
                    <div className="space-y-2">
                      <Label htmlFor="searchUrlTemplate">검색 URL 템플릿 *</Label>
                      <Input
                        id="searchUrlTemplate"
                        value={searchUrlTemplate}
                        onChange={(e) => setSearchUrlTemplate(e.target.value)}
                        placeholder="예: https://search.naver.com/search.naver?where=news&query={query}"
                        disabled={createMutation.isPending}
                      />
                      <p className="text-xs text-muted-foreground">
                        {"{query}"}를 검색어 위치에 사용하세요. 검색어는 자동으로 URL 인코딩됩니다.
                      </p>
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="searchPriority">우선순위 (낮을수록 높음)</Label>
                      <Input
                        id="searchPriority"
                        type="number"
                        min={1}
                        value={searchPriority}
                        onChange={(e) => setSearchPriority(e.target.value)}
                        placeholder="100"
                        disabled={createMutation.isPending}
                      />
                    </div>
                  </div>
                )}
                <div className="grid grid-cols-3 gap-3">
                  <div className="space-y-2">
                    <Label htmlFor="category">카테고리</Label>
                    <Input
                      id="category"
                      value={category}
                      onChange={(e) => setCategory(e.target.value)}
                      placeholder="예: 종합, 경제, IT"
                      disabled={createMutation.isPending}
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="country">국가</Label>
                    <Input
                      id="country"
                      value={country}
                      onChange={(e) => setCountry(e.target.value)}
                      placeholder="KR"
                      disabled={createMutation.isPending}
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="language">언어</Label>
                    <Input
                      id="language"
                      value={language}
                      onChange={(e) => setLanguage(e.target.value)}
                      placeholder="ko"
                      disabled={createMutation.isPending}
                    />
                  </div>
                </div>
                <Button type="submit" className="w-full" disabled={createMutation.isPending}>
                  {createMutation.isPending ? "등록 중..." : "소스 등록"}
                </Button>
              </form>
            </CardContent>
          </Card>

          <Card className="lg:col-span-2 shadow-elegant">
            <CardHeader>
              <CardTitle>등록된 소스</CardTitle>
              <CardDescription>
                최근 등록 순으로 최대 100개까지 표시됩니다.
                {sourcesPage && (
                  <span className="ml-2 text-xs">
                    (총 {sourcesPage.totalElements}개)
                  </span>
                )}
              </CardDescription>
            </CardHeader>
            <CardContent>
              {isLoading ? (
                <div className="space-y-3">
                  {[1, 2, 3, 4, 5].map((i) => (
                    <div key={i} className="flex items-center gap-4">
                      <Skeleton className="h-4 w-12" />
                      <Skeleton className="h-4 w-32" />
                      <Skeleton className="h-4 w-16" />
                      <Skeleton className="h-4 flex-1" />
                      <Skeleton className="h-6 w-10" />
                    </div>
                  ))}
                </div>
              ) : error ? (
                <div className="text-center py-8">
                  <AlertCircle className="h-12 w-12 mx-auto mb-4 text-destructive" />
                  <p className="text-sm text-destructive mb-4">
                    {(error as Error).message || "데이터를 불러오는 중 오류가 발생했습니다."}
                  </p>
                  <Button variant="outline" onClick={() => refetch()}>
                    다시 시도
                  </Button>
                </div>
              ) : sources.length === 0 ? (
                <p className="text-sm text-muted-foreground text-center py-8">
                  등록된 소스가 없습니다. 왼쪽 폼에서 첫 소스를 등록해 보세요.
                </p>
              ) : (
                <div className="overflow-x-auto">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead className="w-[60px]">ID</TableHead>
                        <TableHead>이름</TableHead>
                        <TableHead>타입</TableHead>
                        <TableHead>URL</TableHead>
                        <TableHead className="w-[80px] text-center">활성</TableHead>
                        <TableHead className="w-[60px] text-center">작업</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {sources.map((source) => (
                        <TableRow key={source.id}>
                          <TableCell>{source.id}</TableCell>
                          <TableCell className="font-medium">{source.name}</TableCell>
                          <TableCell>
                            <Badge variant="outline">{source.sourceType}</Badge>
                          </TableCell>
                          <TableCell className="max-w-xs truncate">
                            <a
                              href={source.url}
                              target="_blank"
                              rel="noreferrer"
                              className="text-blue-500 hover:underline"
                            >
                              {source.url}
                            </a>
                          </TableCell>
                          <TableCell className="text-center">
                            <Switch
                              checked={source.isActive}
                              onCheckedChange={(checked) => handleToggleActive(source, checked)}
                              disabled={toggleActiveMutation.isPending}
                            />
                          </TableCell>
                          <TableCell className="text-center">
                            <DropdownMenu>
                              <DropdownMenuTrigger asChild>
                                <Button variant="ghost" size="icon" className="h-8 w-8">
                                  <MoreHorizontal className="h-4 w-4" />
                                </Button>
                              </DropdownMenuTrigger>
                              <DropdownMenuContent align="end">
                                <DropdownMenuItem onClick={() => handleOpenEdit(source)}>
                                  <Pencil className="mr-2 h-4 w-4" />
                                  편집
                                </DropdownMenuItem>
                                <DropdownMenuItem 
                                  onClick={() => handleOpenDelete(source)}
                                  className="text-destructive focus:text-destructive"
                                >
                                  <Trash2 className="mr-2 h-4 w-4" />
                                  삭제
                                </DropdownMenuItem>
                              </DropdownMenuContent>
                            </DropdownMenu>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              )}

              {/* Pagination */}
              {totalPages > 1 && (
                <div className="flex items-center justify-between pt-4">
                  <div className="text-sm text-muted-foreground">
                    총 {totalElements}개 중 {currentPage * pageSize + 1}-{Math.min((currentPage + 1) * pageSize, totalElements)}개 표시
                  </div>
                  <div className="flex items-center gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(0)}
                      disabled={currentPage === 0 || isFetching}
                    >
                      처음
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(p => Math.max(0, p - 1))}
                      disabled={currentPage === 0 || isFetching}
                    >
                      이전
                    </Button>
                    <span className="text-sm px-2">
                      {currentPage + 1} / {totalPages}
                    </span>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(p => Math.min(totalPages - 1, p + 1))}
                      disabled={currentPage >= totalPages - 1 || isFetching}
                    >
                      다음
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setCurrentPage(totalPages - 1)}
                      disabled={currentPage >= totalPages - 1 || isFetching}
                    >
                      마지막
                    </Button>
                  </div>
                </div>
              )}
            </CardContent>
          </Card>
        </div>

        {/* 편집 다이얼로그 */}
        <Dialog open={editDialogOpen} onOpenChange={setEditDialogOpen}>
          <DialogContent className="sm:max-w-[500px]">
            <DialogHeader>
              <DialogTitle>소스 편집</DialogTitle>
              <DialogDescription>
                소스 정보를 수정합니다. 변경사항은 즉시 적용됩니다.
              </DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              <div className="space-y-2">
                <Label htmlFor="edit-name">이름</Label>
                <Input
                  id="edit-name"
                  value={editName}
                  onChange={(e) => setEditName(e.target.value)}
                  placeholder="예: 연합뉴스 - 전체"
                  disabled={updateMutation.isPending}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="edit-url">URL</Label>
                <Input
                  id="edit-url"
                  value={editUrl}
                  onChange={(e) => setEditUrl(e.target.value)}
                  placeholder="예: https://www.yna.co.kr/rss/allheadline.xml"
                  disabled={updateMutation.isPending}
                />
              </div>
                <div className="grid grid-cols-2 gap-3">
                  <div className="space-y-2">
                    <Label htmlFor="edit-sourceType">타입</Label>
                    <Select
                      value={editSourceType}
                      onValueChange={(value) => setEditSourceType(value as SourceType)}
                      disabled={updateMutation.isPending}
                    >
                      <SelectTrigger id="edit-sourceType">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="RSS">RSS</SelectItem>
                        <SelectItem value="WEB">WEB</SelectItem>
                        <SelectItem value="WEB_SEARCH">웹 검색</SelectItem>
                        <SelectItem value="API">API</SelectItem>
                        <SelectItem value="WEBHOOK">WEBHOOK</SelectItem>
                        <SelectItem value="BROWSER_AGENT">AI Agent</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="edit-frequency">수집 주기(초)</Label>
                    <Input
                      id="edit-frequency"
                      type="number"
                      min={60}
                      value={editFrequency}
                      onChange={(e) => setEditFrequency(e.target.value)}
                      disabled={updateMutation.isPending}
                    />
                  </div>
                </div>
                {editSourceType === "WEB_SEARCH" && (
                  <div className="space-y-3 p-3 border rounded-md bg-muted/30">
                    <p className="text-sm font-medium">웹 검색 소스 설정</p>
                    <div className="space-y-2">
                      <Label htmlFor="edit-searchUrlTemplate">검색 URL 템플릿 *</Label>
                      <Input
                        id="edit-searchUrlTemplate"
                        value={editSearchUrlTemplate}
                        onChange={(e) => setEditSearchUrlTemplate(e.target.value)}
                        placeholder="예: https://search.naver.com/search.naver?where=news&query={query}"
                        disabled={updateMutation.isPending}
                      />
                      <p className="text-xs text-muted-foreground">
                        {"{query}"}를 검색어 위치에 사용하세요. 검색어는 자동으로 URL 인코딩됩니다.
                      </p>
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="edit-searchPriority">우선순위 (낮을수록 높음)</Label>
                      <Input
                        id="edit-searchPriority"
                        type="number"
                        min={1}
                        value={editSearchPriority}
                        onChange={(e) => setEditSearchPriority(e.target.value)}
                        placeholder="100"
                        disabled={updateMutation.isPending}
                      />
                    </div>
                  </div>
                )}
                <div className="grid grid-cols-3 gap-3">
                <div className="space-y-2">
                  <Label htmlFor="edit-category">카테고리</Label>
                  <Input
                    id="edit-category"
                    value={editCategory}
                    onChange={(e) => setEditCategory(e.target.value)}
                    placeholder="예: 종합, 경제"
                    disabled={updateMutation.isPending}
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="edit-country">국가</Label>
                  <Input
                    id="edit-country"
                    value={editCountry}
                    onChange={(e) => setEditCountry(e.target.value)}
                    placeholder="KR"
                    disabled={updateMutation.isPending}
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="edit-language">언어</Label>
                  <Input
                    id="edit-language"
                    value={editLanguage}
                    onChange={(e) => setEditLanguage(e.target.value)}
                    placeholder="ko"
                    disabled={updateMutation.isPending}
                  />
                </div>
              </div>
            </div>
            <DialogFooter>
              <Button
                variant="outline"
                onClick={() => setEditDialogOpen(false)}
                disabled={updateMutation.isPending}
              >
                취소
              </Button>
              <Button onClick={handleSaveEdit} disabled={updateMutation.isPending}>
                {updateMutation.isPending ? "저장 중..." : "저장"}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

        {/* 삭제 확인 다이얼로그 */}
        <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>소스 삭제</AlertDialogTitle>
              <AlertDialogDescription>
                정말로 '{deletingSource?.name}' 소스를 삭제하시겠습니까?
                <br />
                이 작업은 되돌릴 수 없으며, 관련된 수집 데이터에 영향을 줄 수 있습니다.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel disabled={deleteMutation.isPending}>
                취소
              </AlertDialogCancel>
              <AlertDialogAction
                onClick={handleConfirmDelete}
                disabled={deleteMutation.isPending}
                className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
              >
                {deleteMutation.isPending ? "삭제 중..." : "삭제"}
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </div>
  );
};

export default AdminSources;

```

---

## frontend/src/pages/AiJobs.tsx

```tsx
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import {
  ArrowLeft,
  Brain,
  RefreshCw,
  Loader2,
  Clock,
  CheckCircle2,
  XCircle,
  AlertCircle,
  PlayCircle,
  StopCircle,
  RotateCcw,
  ChevronDown,
  ChevronUp,
  Zap,
  Server,
  Activity,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Alert, AlertDescription } from '@/components/ui/alert';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@/components/ui/collapsible';
import { Separator } from '@/components/ui/separator';
import { useToast } from '@/hooks/use-toast';
import { useAiJobs, useAiProviders, useAiHealth } from '@/hooks/useAiJobs';
import {
  getAiJobStatusColor,
  getAiJobStatusLabel,
  calculateAiJobProgress,
  type AiJobDTO,
  type AiJobStatus,
  type AiSubTaskDTO,
} from '@/lib/api/ai';

// ============================================
// Status Badge Component
// ============================================

const JobStatusBadge: React.FC<{ status: AiJobStatus }> = ({ status }) => {
  const getVariant = () => {
    switch (status) {
      case 'COMPLETED':
        return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-100';
      case 'RUNNING':
        return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-100';
      case 'PENDING':
        return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-100';
      case 'FAILED':
        return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-100';
      case 'CANCELLED':
        return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-100';
      default:
        return '';
    }
  };

  const getIcon = () => {
    switch (status) {
      case 'COMPLETED':
        return <CheckCircle2 className="h-3 w-3" />;
      case 'RUNNING':
        return <Loader2 className="h-3 w-3 animate-spin" />;
      case 'PENDING':
        return <Clock className="h-3 w-3" />;
      case 'FAILED':
        return <XCircle className="h-3 w-3" />;
      case 'CANCELLED':
        return <StopCircle className="h-3 w-3" />;
      default:
        return null;
    }
  };

  return (
    <Badge className={`${getVariant()} flex items-center gap-1`}>
      {getIcon()}
      {getAiJobStatusLabel(status)}
    </Badge>
  );
};

// ============================================
// Sub Task Item
// ============================================

const SubTaskItem: React.FC<{ task: AiSubTaskDTO }> = ({ task }) => {
  return (
    <div className="flex items-center justify-between p-2 rounded border bg-muted/30">
      <div className="flex items-center gap-2">
        <Badge variant="outline" className="text-xs">
          {task.providerId}
        </Badge>
        <span className="text-sm">{task.taskType}</span>
      </div>
      <div className="flex items-center gap-2">
        {task.retryCount > 0 && (
          <Badge variant="secondary" className="text-xs">
            재시도: {task.retryCount}
          </Badge>
        )}
        <JobStatusBadge status={task.status as AiJobStatus} />
      </div>
    </div>
  );
};

// ============================================
// Job Card Component
// ============================================

interface JobCardProps {
  job: AiJobDTO;
  onCancel: (jobId: string) => Promise<void>;
  onRetry: (jobId: string) => Promise<void>;
}

const JobCard: React.FC<JobCardProps> = ({ job, onCancel, onRetry }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [isCancelling, setIsCancelling] = useState(false);
  const [isRetrying, setIsRetrying] = useState(false);
  const progress = calculateAiJobProgress(job);
  const isRunning = job.overallStatus === 'RUNNING' || job.overallStatus === 'PENDING';
  const canRetry = job.overallStatus === 'FAILED' && job.failedTasks > 0;

  const handleCancel = async () => {
    setIsCancelling(true);
    try {
      await onCancel(job.jobId);
    } finally {
      setIsCancelling(false);
    }
  };

  const handleRetry = async () => {
    setIsRetrying(true);
    try {
      await onRetry(job.jobId);
    } finally {
      setIsRetrying(false);
    }
  };

  return (
    <Card className={isRunning ? 'border-blue-500/50' : ''}>
      <CardHeader className="pb-3">
        <div className="flex items-start justify-between gap-4">
          <div className="flex-1 min-w-0">
            <CardTitle className="text-base truncate">{job.topic}</CardTitle>
            <CardDescription className="text-xs mt-1">
              {job.baseUrl && (
                <span className="truncate block">{job.baseUrl}</span>
              )}
              <span className="flex items-center gap-2 mt-1">
                <Clock className="h-3 w-3" />
                {new Date(job.createdAt).toLocaleString('ko-KR')}
              </span>
            </CardDescription>
          </div>
          <JobStatusBadge status={job.overallStatus} />
        </div>
      </CardHeader>
      <CardContent className="space-y-3">
        {/* Progress */}
        {isRunning && (
          <div className="space-y-1">
            <div className="flex justify-between text-xs text-muted-foreground">
              <span>진행률</span>
              <span>{progress}%</span>
            </div>
            <Progress value={progress} className="h-2" />
          </div>
        )}

        {/* Task Stats */}
        <div className="flex items-center gap-4 text-xs text-muted-foreground">
          <span className="flex items-center gap-1">
            <CheckCircle2 className="h-3 w-3 text-green-500" />
            완료: {job.completedTasks}
          </span>
          {job.failedTasks > 0 && (
            <span className="flex items-center gap-1">
              <XCircle className="h-3 w-3 text-red-500" />
              실패: {job.failedTasks}
            </span>
          )}
          <span className="flex items-center gap-1">
            <Activity className="h-3 w-3" />
            전체: {job.totalTasks}
          </span>
        </div>

        {/* Error Message */}
        {job.errorMessage && (
          <Alert variant="destructive" className="py-2">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription className="text-xs">
              {job.errorMessage}
            </AlertDescription>
          </Alert>
        )}

        {/* Actions */}
        <div className="flex items-center justify-between">
          <Collapsible open={isOpen} onOpenChange={setIsOpen}>
            <CollapsibleTrigger asChild>
              <Button variant="ghost" size="sm" className="text-xs">
                {isOpen ? (
                  <ChevronUp className="h-4 w-4 mr-1" />
                ) : (
                  <ChevronDown className="h-4 w-4 mr-1" />
                )}
                세부 작업 ({job.subTasks.length})
              </Button>
            </CollapsibleTrigger>
          </Collapsible>

          <div className="flex gap-1">
            {canRetry && (
              <Button
                variant="outline"
                size="sm"
                onClick={handleRetry}
                disabled={isRetrying}
              >
                {isRetrying ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <RotateCcw className="h-4 w-4" />
                )}
              </Button>
            )}
            {isRunning && (
              <Button
                variant="outline"
                size="sm"
                onClick={handleCancel}
                disabled={isCancelling}
              >
                {isCancelling ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <StopCircle className="h-4 w-4" />
                )}
              </Button>
            )}
          </div>
        </div>

        {/* SubTasks */}
        <Collapsible open={isOpen} onOpenChange={setIsOpen}>
          <CollapsibleContent className="space-y-2 pt-2">
            {job.subTasks.map((task) => (
              <SubTaskItem key={task.subTaskId} task={task} />
            ))}
          </CollapsibleContent>
        </Collapsible>
      </CardContent>
    </Card>
  );
};

// ============================================
// Provider Card
// ============================================

const ProviderCard: React.FC<{
  provider: { id: string; name: string; description?: string };
  isHealthy?: boolean;
}> = ({ provider, isHealthy }) => {
  return (
    <Card className="p-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Server className="h-4 w-4 text-muted-foreground" />
          <div>
            <p className="font-medium text-sm">{provider.name}</p>
            {provider.description && (
              <p className="text-xs text-muted-foreground">{provider.description}</p>
            )}
          </div>
        </div>
        {isHealthy !== undefined && (
          <div
            className={`h-2 w-2 rounded-full ${
              isHealthy ? 'bg-green-500' : 'bg-red-500'
            }`}
          />
        )}
      </div>
    </Card>
  );
};

// ============================================
// AI Jobs Page Component
// ============================================

const AiJobs: React.FC = () => {
  const { toast } = useToast();
  const [statusFilter, setStatusFilter] = useState<AiJobStatus | 'ALL'>('ALL');

  // Hooks
  const {
    jobs,
    total,
    totalPages,
    currentPage,
    loading: jobsLoading,
    error: jobsError,
    refresh: refreshJobs,
    setPage,
    cancel,
    retry,
  } = useAiJobs({
    size: 10,
    status: statusFilter === 'ALL' ? undefined : statusFilter,
    autoRefresh: true,
    refreshInterval: 5000,
  });

  const {
    providers,
    loading: providersLoading,
    refresh: refreshProviders,
  } = useAiProviders();

  const {
    health,
    loading: healthLoading,
    refresh: refreshHealth,
    isHealthy,
  } = useAiHealth();

  const [isRefreshing, setIsRefreshing] = useState(false);

  const handleRefreshAll = async () => {
    setIsRefreshing(true);
    try {
      await Promise.all([refreshJobs(), refreshProviders(), refreshHealth()]);
    } finally {
      setIsRefreshing(false);
    }
  };

  const handleCancel = async (jobId: string) => {
    try {
      await cancel(jobId);
      toast({ title: '작업이 취소되었습니다.' });
    } catch (e) {
      toast({
        title: '취소 실패',
        description: e instanceof Error ? e.message : '알 수 없는 오류',
        variant: 'destructive',
      });
    }
  };

  const handleRetry = async (jobId: string) => {
    try {
      await retry(jobId);
      toast({ title: '재시도가 시작되었습니다.' });
    } catch (e) {
      toast({
        title: '재시도 실패',
        description: e instanceof Error ? e.message : '알 수 없는 오류',
        variant: 'destructive',
      });
    }
  };

  // Stats
  const runningCount = jobs.filter(
    (j) => j.overallStatus === 'RUNNING' || j.overallStatus === 'PENDING'
  ).length;
  const completedCount = jobs.filter((j) => j.overallStatus === 'COMPLETED').length;
  const failedCount = jobs.filter((j) => j.overallStatus === 'FAILED').length;

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-6xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to="/"
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            검색으로 돌아가기
          </Link>
          <div className="flex items-center justify-between flex-wrap gap-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-primary/10 rounded-lg">
                <Brain className="h-6 w-6 text-primary" />
              </div>
              <div>
                <h1 className="text-3xl font-bold">AI 작업 관리</h1>
                <p className="text-muted-foreground">
                  AI 분석 작업 상태를 모니터링하고 관리합니다.
                </p>
              </div>
            </div>
            <Button
              variant="outline"
              onClick={handleRefreshAll}
              disabled={isRefreshing}
            >
              <RefreshCw
                className={`h-4 w-4 mr-2 ${isRefreshing ? 'animate-spin' : ''}`}
              />
              새로고침
            </Button>
          </div>
        </header>

        {/* Overview */}
        <Card className="mb-6">
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle className="flex items-center gap-2">
                  <Activity className="h-5 w-5" />
                  서비스 상태
                </CardTitle>
                <CardDescription>AI 분석 서비스 및 작업 현황</CardDescription>
              </div>
              <Badge
                className={
                  isHealthy
                    ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-100'
                    : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-100'
                }
              >
                {isHealthy ? '정상' : '점검 필요'}
              </Badge>
            </div>
          </CardHeader>
          <CardContent>
            <div className="grid gap-4 md:grid-cols-4">
              <div className="flex items-center gap-2">
                <PlayCircle className="h-4 w-4 text-blue-500" />
                <span className="text-sm">
                  진행 중: <strong>{runningCount}</strong>
                </span>
              </div>
              <div className="flex items-center gap-2">
                <CheckCircle2 className="h-4 w-4 text-green-500" />
                <span className="text-sm">
                  완료: <strong>{completedCount}</strong>
                </span>
              </div>
              <div className="flex items-center gap-2">
                <XCircle className="h-4 w-4 text-red-500" />
                <span className="text-sm">
                  실패: <strong>{failedCount}</strong>
                </span>
              </div>
              <div className="flex items-center gap-2">
                <Zap className="h-4 w-4 text-yellow-500" />
                <span className="text-sm">
                  전체: <strong>{total}</strong>
                </span>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Error Alert */}
        {jobsError && (
          <Alert variant="destructive" className="mb-6">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              작업 목록을 불러오는데 실패했습니다: {jobsError.message}
            </AlertDescription>
          </Alert>
        )}

        <div className="grid gap-6 lg:grid-cols-3">
          {/* Jobs List */}
          <div className="lg:col-span-2">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-lg font-semibold">작업 목록</h2>
              <Select
                value={statusFilter}
                onValueChange={(v) => setStatusFilter(v as AiJobStatus | 'ALL')}
              >
                <SelectTrigger className="w-32">
                  <SelectValue placeholder="상태 필터" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="ALL">전체</SelectItem>
                  <SelectItem value="PENDING">대기 중</SelectItem>
                  <SelectItem value="RUNNING">진행 중</SelectItem>
                  <SelectItem value="COMPLETED">완료</SelectItem>
                  <SelectItem value="FAILED">실패</SelectItem>
                  <SelectItem value="CANCELLED">취소됨</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <ScrollArea className="h-[600px]">
              {jobsLoading && jobs.length === 0 ? (
                <div className="flex items-center justify-center py-12">
                  <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
                </div>
              ) : jobs.length === 0 ? (
                <Card className="p-8 text-center text-muted-foreground">
                  표시할 작업이 없습니다.
                </Card>
              ) : (
                <div className="space-y-4 pr-4">
                  {jobs.map((job) => (
                    <JobCard
                      key={job.jobId}
                      job={job}
                      onCancel={handleCancel}
                      onRetry={handleRetry}
                    />
                  ))}
                </div>
              )}
            </ScrollArea>

            {/* Pagination */}
            {totalPages > 1 && (
              <div className="flex items-center justify-center gap-2 mt-4">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setPage(currentPage - 1)}
                  disabled={currentPage === 0}
                >
                  이전
                </Button>
                <span className="text-sm text-muted-foreground">
                  {currentPage + 1} / {totalPages}
                </span>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setPage(currentPage + 1)}
                  disabled={currentPage >= totalPages - 1}
                >
                  다음
                </Button>
              </div>
            )}
          </div>

          {/* Providers Sidebar */}
          <div className="lg:col-span-1">
            <h2 className="text-lg font-semibold mb-4">AI 제공자</h2>
            <div className="space-y-3">
              {providersLoading ? (
                <div className="flex items-center justify-center py-8">
                  <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
                </div>
              ) : providers.length === 0 ? (
                <Card className="p-4 text-center text-muted-foreground text-sm">
                  등록된 제공자가 없습니다.
                </Card>
              ) : (
                providers.map((provider) => (
                  <ProviderCard
                    key={provider.id}
                    provider={provider}
                    isHealthy={health?.providers?.[provider.id]}
                  />
                ))
              )}
            </div>

            <Separator className="my-6" />

            <h2 className="text-lg font-semibold mb-4">빠른 링크</h2>
            <div className="space-y-2">
              <Link to="/deep-search">
                <Button variant="outline" className="w-full justify-start">
                  <Brain className="h-4 w-4 mr-2" />
                  Deep Search
                </Button>
              </Link>
              <Link to="/parallel-search">
                <Button variant="outline" className="w-full justify-start">
                  <Activity className="h-4 w-4 mr-2" />
                  Parallel Search
                </Button>
              </Link>
              <Link to="/ml-addons">
                <Button variant="outline" className="w-full justify-start">
                  <Zap className="h-4 w-4 mr-2" />
                  ML Add-ons
                </Button>
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default AiJobs;

```

---

## frontend/src/pages/BrowserAgent.tsx

```tsx
import { useState, useCallback, useEffect, useRef } from "react";
import { Link, useNavigate, useLocation } from "react-router-dom";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  Bot,
  Loader2,
  AlertCircle,
  CheckCircle2,
  XCircle,
  Clock,
  ExternalLink,
  ArrowLeft,
  RefreshCw,
  Trash2,
  Play,
  Hand,
  MousePointer,
  Type,
  Navigation,
  Eye,
  Send,
  Pause,
  Camera,
  Globe,
  MonitorPlay,
  Wifi,
  WifiOff,
  FolderPlus,
  BookmarkPlus,
  History,
  Save,
  Download,
  FileJson,
  FileText,
  Search,
  Shield,
  Microscope,
  MoreVertical,
  ChevronDown,
  ChevronUp,
  X,
  Copy,
  BarChart3,
  StopCircle,
  AlertTriangle,
  TrendingUp,
} from "lucide-react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { useToast } from "@/hooks/use-toast";
import { useUrlCollection } from "@/hooks/useUrlCollection";
import { useAgentResultsStorage, SavedAgentResult } from "@/hooks/useAgentResultsStorage";
import { useAutoSaveSearch } from "@/hooks/useSearchHistory";
import { TaskTemplates, TaskTemplate } from "@/components/TaskTemplates";
import {
  checkBrowserUseHealth,
  startBrowserTask,
  getBrowserJobStatus,
  submitIntervention,
  requestManualIntervention,
  cancelBrowserJob,
  getBrowserWSUrl,
  getBrowserUseStats,
  getActiveBrowserJobs,
  cancelAllBrowserJobs,
  type BrowserJobStatus,
  type BrowserJobStatusResponse,
  type BrowserWSMessage,
  type HumanAction,
  type InterventionType,
  type BrowserUseStats,
  type BrowserJobSummary,
} from "@/lib/api";

const STATUS_CONFIG: Record<BrowserJobStatus, { label: string; icon: typeof Clock; color: string }> = {
  pending: { label: "Pending", icon: Clock, color: "bg-yellow-500" },
  running: { label: "Running", icon: Loader2, color: "bg-blue-500" },
  waiting_human: { label: "Needs Help", icon: Hand, color: "bg-orange-500" },
  completed: { label: "Completed", icon: CheckCircle2, color: "bg-green-500" },
  failed: { label: "Failed", icon: XCircle, color: "bg-red-500" },
  cancelled: { label: "Cancelled", icon: XCircle, color: "bg-gray-500" },
};

const INTERVENTION_CONFIG: Record<InterventionType, { label: string; description: string }> = {
  captcha: { label: "CAPTCHA", description: "Solve verification challenge" },
  login: { label: "Login", description: "Authentication required" },
  navigation: { label: "Navigation", description: "Help navigate the page" },
  extraction: { label: "Extraction", description: "Help extract content" },
  confirmation: { label: "Confirmation", description: "Confirm before proceeding" },
  custom: { label: "Custom", description: "Custom intervention" },
};

interface InterventionPanelProps {
  job: BrowserJobStatusResponse;
  onSubmit: (action: HumanAction) => void;
  isSubmitting: boolean;
}

const InterventionPanel = ({ job, onSubmit, isSubmitting }: InterventionPanelProps) => {
  const [actionType, setActionType] = useState<HumanAction["action_type"]>("click");
  const [selector, setSelector] = useState("");
  const [value, setValue] = useState("");
  const [clickX, setClickX] = useState<number | undefined>();
  const [clickY, setClickY] = useState<number | undefined>();
  const [customScript, setCustomScript] = useState("");
  const [message, setMessage] = useState("");

  const handleSubmit = () => {
    const action: HumanAction = {
      action_type: actionType,
      selector: selector || undefined,
      value: value || undefined,
      x: clickX,
      y: clickY,
      custom_script: customScript || undefined,
      message: message || undefined,
    };
    onSubmit(action);
  };

  const handleImageClick = (e: React.MouseEvent<HTMLImageElement>) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const scaleX = e.currentTarget.naturalWidth / rect.width;
    const scaleY = e.currentTarget.naturalHeight / rect.height;
    const x = Math.round((e.clientX - rect.left) * scaleX);
    const y = Math.round((e.clientY - rect.top) * scaleY);
    setClickX(x);
    setClickY(y);
    setActionType("click");
  };

  const interventionInfo = job.intervention_type ? INTERVENTION_CONFIG[job.intervention_type] : null;

  return (
    <Card className="border-orange-500 border-2">
      <CardHeader className="bg-orange-50 dark:bg-orange-900/20">
        <div className="flex items-center gap-2">
          <Hand className="h-5 w-5 text-orange-500" />
          <CardTitle className="text-lg">Human Intervention Required</CardTitle>
        </div>
        {interventionInfo && (
          <CardDescription>
            <Badge variant="outline" className="mr-2">{interventionInfo.label}</Badge>
            {interventionInfo.description}
          </CardDescription>
        )}
        {job.intervention_reason && (
          <p className="text-sm text-muted-foreground mt-2">{job.intervention_reason}</p>
        )}
      </CardHeader>
      <CardContent className="pt-4 space-y-4">
        {/* Screenshot with click support */}
        {job.intervention_screenshot && (
          <div className="relative">
            <Label className="text-sm font-medium mb-2 block">
              Browser View (Click to select position)
            </Label>
            <div className="border rounded-lg overflow-hidden cursor-crosshair relative">
              <img
                src={`data:image/jpeg;base64,${job.intervention_screenshot}`}
                alt="Browser screenshot"
                className="w-full"
                onClick={handleImageClick}
              />
              {clickX !== undefined && clickY !== undefined && (
                <div
                  className="absolute w-4 h-4 bg-red-500 rounded-full border-2 border-white transform -translate-x-1/2 -translate-y-1/2 pointer-events-none"
                  style={{ left: `${(clickX / 1920) * 100}%`, top: `${(clickY / 1080) * 100}%` }}
                />
              )}
            </div>
            {job.current_url && (
              <div className="flex items-center gap-2 mt-2 text-xs text-muted-foreground">
                <Globe className="h-3 w-3" />
                <span className="truncate">{job.current_url}</span>
              </div>
            )}
          </div>
        )}

        {/* Action Type */}
        <div className="space-y-2">
          <Label>Action Type</Label>
          <Select value={actionType} onValueChange={(v) => setActionType(v as HumanAction["action_type"])}>
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="click">
                <div className="flex items-center gap-2">
                  <MousePointer className="h-4 w-4" /> Click
                </div>
              </SelectItem>
              <SelectItem value="type">
                <div className="flex items-center gap-2">
                  <Type className="h-4 w-4" /> Type Text
                </div>
              </SelectItem>
              <SelectItem value="navigate">
                <div className="flex items-center gap-2">
                  <Navigation className="h-4 w-4" /> Navigate to URL
                </div>
              </SelectItem>
              <SelectItem value="scroll">
                <div className="flex items-center gap-2">
                  <Eye className="h-4 w-4" /> Scroll
                </div>
              </SelectItem>
              <SelectItem value="custom">
                <div className="flex items-center gap-2">
                  <Bot className="h-4 w-4" /> Custom Script
                </div>
              </SelectItem>
              <SelectItem value="skip">
                <div className="flex items-center gap-2">
                  <Play className="h-4 w-4" /> Skip (Continue)
                </div>
              </SelectItem>
              <SelectItem value="abort">
                <div className="flex items-center gap-2">
                  <XCircle className="h-4 w-4" /> Abort Task
                </div>
              </SelectItem>
            </SelectContent>
          </Select>
        </div>

        {/* Action-specific inputs */}
        {(actionType === "click" || actionType === "type") && (
          <div className="space-y-2">
            <Label>CSS Selector (optional if clicking on screenshot)</Label>
            <Input
              value={selector}
              onChange={(e) => setSelector(e.target.value)}
              placeholder="e.g., #submit-btn, .login-button, input[name='email']"
            />
          </div>
        )}

        {actionType === "click" && (
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label>X Coordinate</Label>
              <Input
                type="number"
                value={clickX ?? ""}
                onChange={(e) => setClickX(e.target.value ? parseInt(e.target.value) : undefined)}
                placeholder="X position"
              />
            </div>
            <div className="space-y-2">
              <Label>Y Coordinate</Label>
              <Input
                type="number"
                value={clickY ?? ""}
                onChange={(e) => setClickY(e.target.value ? parseInt(e.target.value) : undefined)}
                placeholder="Y position"
              />
            </div>
          </div>
        )}

        {actionType === "type" && (
          <div className="space-y-2">
            <Label>Text to Type</Label>
            <Input
              value={value}
              onChange={(e) => setValue(e.target.value)}
              placeholder="Enter text to type"
            />
          </div>
        )}

        {actionType === "navigate" && (
          <div className="space-y-2">
            <Label>URL</Label>
            <Input
              value={value}
              onChange={(e) => setValue(e.target.value)}
              placeholder="https://example.com"
            />
          </div>
        )}

        {actionType === "scroll" && (
          <div className="space-y-2">
            <Label>Scroll Amount (pixels, negative for up)</Label>
            <Input
              type="number"
              value={clickY ?? 500}
              onChange={(e) => setClickY(parseInt(e.target.value) || 500)}
              placeholder="500"
            />
          </div>
        )}

        {actionType === "custom" && (
          <div className="space-y-2">
            <Label>JavaScript Code</Label>
            <Textarea
              value={customScript}
              onChange={(e) => setCustomScript(e.target.value)}
              placeholder="document.querySelector('button').click();"
              rows={4}
            />
          </div>
        )}

        {/* Message to AI */}
        <div className="space-y-2">
          <Label>Message to AI (optional)</Label>
          <Input
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            placeholder="Additional context for the AI agent"
          />
        </div>

        {/* Submit buttons */}
        <div className="flex gap-2">
          <Button
            onClick={handleSubmit}
            disabled={isSubmitting}
            className="flex-1"
          >
            {isSubmitting ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                Submitting...
              </>
            ) : (
              <>
                <Send className="h-4 w-4 mr-2" />
                Submit Action
              </>
            )}
          </Button>
          <Button
            variant="outline"
            onClick={() => onSubmit({ action_type: "skip" })}
            disabled={isSubmitting}
          >
            Skip
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

const BrowserAgent = () => {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const location = useLocation();
  const wsRef = useRef<WebSocket | null>(null);
  const jobStartTimeRef = useRef<string | null>(null);
  const { addUrl, addFolder, collection, urlExists } = useUrlCollection();
  const { saveBrowserAgent, saveFailedSearch } = useAutoSaveSearch();
  
  // Agent results storage
  const {
    savedResults,
    isLoaded: storageLoaded,
    saveResult,
    deleteResult,
    updateResult,
    exportToJson,
    exportToMarkdown,
    exportToCsv,
    getStats,
    clearAllResults,
  } = useAgentResultsStorage();

  // Form state
  const [task, setTask] = useState("");
  const [url, setUrl] = useState("");
  const [maxSteps, setMaxSteps] = useState(25);
  const [enableIntervention, setEnableIntervention] = useState(true);
  const [autoIntervention, setAutoIntervention] = useState(true);
  const [autoSaveUrls, setAutoSaveUrls] = useState(true);
  const [useProxyRotation, setUseProxyRotation] = useState(false);

  // Job state
  const [currentJobId, setCurrentJobId] = useState<string | null>(null);
  const [wsConnected, setWsConnected] = useState(false);
  const [liveScreenshot, setLiveScreenshot] = useState<string | null>(null);
  const [liveUrl, setLiveUrl] = useState<string | null>(null);
  
  // Track saved URLs in this session
  const savedUrlsRef = useRef<Set<string>>(new Set());
  const [savedUrlCount, setSavedUrlCount] = useState(0);
  
  // History panel state
  const [showHistory, setShowHistory] = useState(false);
  const [selectedHistoryItem, setSelectedHistoryItem] = useState<SavedAgentResult | null>(null);
  const [historyDetailOpen, setHistoryDetailOpen] = useState(false);
  const [historyFilter, setHistoryFilter] = useState<"all" | "completed" | "failed">("all");
  
  // Auto-save URL to collection with citation metadata
  const autoSaveVisitedUrl = useCallback((visitedUrl: string, pageTitle?: string) => {
    if (!autoSaveUrls || !visitedUrl) return;
    
    // Skip if already saved in this session or in collection
    if (savedUrlsRef.current.has(visitedUrl) || urlExists(visitedUrl)) {
      return;
    }
    
    // Skip common non-content URLs
    const skipPatterns = [
      /^about:/,
      /^chrome:/,
      /^data:/,
      /^javascript:/,
      /google\.com\/search/,
      /bing\.com\/search/,
      /duckduckgo\.com\/\?q/,
    ];
    
    if (skipPatterns.some(pattern => pattern.test(visitedUrl))) {
      return;
    }
    
    // Find or create "Browser Agent" folder
    let agentFolderId = 'root';
    const agentFolder = collection.root.children.find(
      (item) => item.type === 'folder' && item.name === '브라우저 에이전트'
    );
    
    if (!agentFolder) {
      agentFolderId = addFolder('root', '브라우저 에이전트', 'AI 브라우저 에이전트가 방문한 URL 자동 저장');
    } else {
      agentFolderId = agentFolder.id;
    }
    
    // Extract title from URL if not provided
    let title: string | undefined = pageTitle;
    try {
      if (!title) {
        const urlObj = new URL(visitedUrl);
        title = urlObj.hostname + urlObj.pathname.slice(0, 50);
      }
    } catch {
      // Ignore URL parse errors
    }
    
    // Add URL with citation metadata
    addUrl(agentFolderId, visitedUrl, title, undefined, undefined, {
      sourceType: 'browser_agent',
      sourceQuery: task,
      citationIndex: savedUrlsRef.current.size + 1,
    });
    savedUrlsRef.current.add(visitedUrl);
    setSavedUrlCount(prev => prev + 1);
  }, [autoSaveUrls, urlExists, collection.root.children, addFolder, addUrl, task]);

  // Health check
  const { data: health } = useQuery({
    queryKey: ["browserUse", "health"],
    queryFn: checkBrowserUseHealth,
    staleTime: 30_000,
    retry: 1,
  });

  const isHealthy = health?.status === "healthy";

  // Browser stats query
  const [showStats, setShowStats] = useState(false);
  const { data: browserStats, refetch: refetchStats, isLoading: statsLoading } = useQuery({
    queryKey: ["browserUse", "stats"],
    queryFn: getBrowserUseStats,
    enabled: showStats,
    staleTime: 10_000,
    refetchInterval: showStats ? 15_000 : false,
  });

  // Active jobs query
  const { data: activeJobs, refetch: refetchActiveJobs } = useQuery({
    queryKey: ["browserUse", "activeJobs"],
    queryFn: getActiveBrowserJobs,
    enabled: showStats,
    staleTime: 5_000,
    refetchInterval: showStats ? 10_000 : false,
  });

  // Cancel all jobs mutation
  const cancelAllMutation = useMutation({
    mutationFn: cancelAllBrowserJobs,
    onSuccess: (result) => {
      toast({
        title: "Jobs Cancelled",
        description: `${result.cancelled} jobs cancelled${result.errors.length > 0 ? `, ${result.errors.length} errors` : ''}`,
      });
      refetchStats();
      refetchActiveJobs();
      queryClient.invalidateQueries({ queryKey: ["browserUse"] });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to Cancel Jobs",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Job status polling
  const { data: currentJob } = useQuery({
    queryKey: ["browserUse", "job", currentJobId],
    queryFn: () => getBrowserJobStatus(currentJobId!),
    enabled: !!currentJobId,
    refetchInterval: (query) => {
      const data = query.state.data as BrowserJobStatusResponse | undefined;
      if (!data) return 2000;
      if (["completed", "failed", "cancelled"].includes(data.status)) return false;
      return 2000;
    },
    staleTime: 1000,
  });

  // Load task from location state (e.g., from Search History page)
  useEffect(() => {
    const locationState = location.state as { 
      query?: string; 
      fromHistory?: boolean; 
      historyId?: number;
      parentSearchId?: number;
      deriveFrom?: number;
      depthLevel?: number;
    } | null;
    
    if (locationState?.query && !currentJobId) {
      // Set the query as task
      setTask(locationState.query);
      
      if (locationState.fromHistory) {
        toast({
          title: "검색 기록에서 연결됨",
          description: `"${locationState.query}" 작업으로 AI 에이전트를 시작할 수 있습니다.`,
        });
        // Clear the location state to prevent showing toast again
        window.history.replaceState({}, document.title);
      }
      
      if (locationState.deriveFrom) {
        toast({
          title: "파생 검색",
          description: "이전 검색에서 파생된 AI 에이전트 작업을 시작합니다.",
        });
        // Clear the location state
        window.history.replaceState({}, document.title);
      }
    }
  }, [location.state, currentJobId, toast]);

  // WebSocket connection
  useEffect(() => {
    if (!currentJobId) {
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
        setWsConnected(false);
      }
      return;
    }

    const wsUrl = getBrowserWSUrl(currentJobId);
    const ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      setWsConnected(true);
      toast({ title: "Connected", description: "Real-time updates enabled" });
    };

    ws.onmessage = (event) => {
      try {
        const message: BrowserWSMessage = JSON.parse(event.data);

        switch (message.type) {
          case "step_update":
            if (message.screenshot) setLiveScreenshot(message.screenshot);
            if (message.current_url) {
              setLiveUrl(message.current_url);
              // Auto-save visited URL
              autoSaveVisitedUrl(message.current_url);
            }
            queryClient.invalidateQueries({ queryKey: ["browserUse", "job", currentJobId] });
            break;

          case "intervention_requested":
            toast({
              title: "Intervention Needed",
              description: message.reason || "AI agent needs your help",
              variant: "destructive",
            });
            if (message.screenshot) setLiveScreenshot(message.screenshot);
            queryClient.invalidateQueries({ queryKey: ["browserUse", "job", currentJobId] });
            break;

          case "completed":
            toast({
              title: "Task Completed",
              description: "Browser task finished successfully",
            });
            queryClient.invalidateQueries({ queryKey: ["browserUse", "job", currentJobId] });
            break;

          case "failed":
            toast({
              title: "Task Failed",
              description: message.error || "An error occurred",
              variant: "destructive",
            });
            queryClient.invalidateQueries({ queryKey: ["browserUse", "job", currentJobId] });
            break;

          case "cancelled":
            toast({
              title: "Task Cancelled",
              description: "The task was cancelled",
            });
            queryClient.invalidateQueries({ queryKey: ["browserUse", "job", currentJobId] });
            break;

          case "screenshot":
            if (message.data) setLiveScreenshot(message.data);
            if (message.current_url) {
              setLiveUrl(message.current_url);
              // Auto-save visited URL
              autoSaveVisitedUrl(message.current_url);
            }
            break;
        }
      } catch (e) {
        console.error("Failed to parse WebSocket message:", e);
      }
    };

    ws.onerror = () => {
      toast({
        title: "Connection Error",
        description: "WebSocket connection failed",
        variant: "destructive",
      });
    };

    ws.onclose = () => {
      setWsConnected(false);
    };

    wsRef.current = ws;

    return () => {
      ws.close();
    };
  }, [currentJobId, toast, queryClient]);

  // Start task mutation
  const startMutation = useMutation({
    mutationFn: startBrowserTask,
    onSuccess: (response) => {
      setCurrentJobId(response.job_id);
      setLiveScreenshot(null);
      setLiveUrl(null);
      toast({
        title: "Task Started",
        description: `Job ID: ${response.job_id}`,
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to Start",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Submit intervention mutation
  const interventionMutation = useMutation({
    mutationFn: (action: HumanAction) => submitIntervention(currentJobId!, action),
    onSuccess: () => {
      toast({
        title: "Action Submitted",
        description: "The AI agent will continue with your input",
      });
      queryClient.invalidateQueries({ queryKey: ["browserUse", "job", currentJobId] });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to Submit",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Manual intervention request
  const manualInterventionMutation = useMutation({
    mutationFn: () => requestManualIntervention(currentJobId!, "custom", "Manual takeover requested"),
    onSuccess: (response) => {
      if (response.screenshot) setLiveScreenshot(response.screenshot);
      if (response.current_url) setLiveUrl(response.current_url);
      toast({
        title: "Takeover Mode",
        description: "You can now control the browser",
      });
      queryClient.invalidateQueries({ queryKey: ["browserUse", "job", currentJobId] });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Cancel job mutation
  const cancelMutation = useMutation({
    mutationFn: () => cancelBrowserJob(currentJobId!),
    onSuccess: () => {
      toast({ title: "Cancelled", description: "Task has been cancelled" });
      queryClient.invalidateQueries({ queryKey: ["browserUse", "job", currentJobId] });
    },
  });

  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    if (!task.trim()) return;

    // 작업 시작 시간 기록
    jobStartTimeRef.current = new Date().toISOString();

    await startMutation.mutateAsync({
      task: task.trim(),
      url: url.trim() || undefined,
      max_steps: maxSteps,
      headless: false,
      enable_human_intervention: enableIntervention,
      auto_request_intervention: autoIntervention,
      use_proxy_rotation: useProxyRotation,
    });
  }, [task, url, maxSteps, enableIntervention, autoIntervention, useProxyRotation, startMutation]);

  const handleReset = useCallback(() => {
    setCurrentJobId(null);
    setTask("");
    setUrl("");
    setMaxSteps(25);
    setEnableIntervention(true);
    setAutoIntervention(true);
    setAutoSaveUrls(true);
    setUseProxyRotation(false);
    setWsConnected(false);
    setLiveScreenshot(null);
    setLiveUrl(null);
    savedUrlsRef.current.clear();
    setSavedUrlCount(0);
    jobStartTimeRef.current = null;
    queryClient.removeQueries({ queryKey: ["browserUse", "job"] });
  }, [queryClient]);

  // 결과 저장 핸들러
  const handleSaveResult = useCallback(async () => {
    if (!currentJob || !currentJobId) {
      toast({
        title: "저장할 결과가 없습니다",
        description: "먼저 작업을 실행해주세요.",
        variant: "destructive",
      });
      return;
    }

    const completedAt = new Date().toISOString();
    const startedAt = jobStartTimeRef.current || completedAt;
    const durationMs = new Date(completedAt).getTime() - new Date(startedAt).getTime();

    try {
      const savedId = await saveResult({
        task: task || "Unknown task",
        startUrl: url || undefined,
        jobId: currentJobId,
        status: currentJob.status as "completed" | "failed" | "cancelled",
        result: currentJob.result || undefined,
        error: currentJob.error || undefined,
        executionStats: {
          totalSteps: currentJob.current_step,
          maxSteps: currentJob.max_steps,
          durationMs,
          startedAt,
          completedAt,
        },
        visitedUrls: currentJob.urls_visited || [],
        lastScreenshot: liveScreenshot || undefined,
      });

      toast({
        title: "결과 저장됨",
        description: `작업 결과가 저장되었습니다. (ID: ${savedId.slice(0, 8)}...)`,
      });
    } catch (err) {
      toast({
        title: "결과 저장 실패",
        description: err instanceof Error ? err.message : "저장 중 오류가 발생했습니다.",
        variant: "destructive",
      });
    }
  }, [currentJob, currentJobId, task, url, liveScreenshot, saveResult, toast]);

  // Deep Search로 분석 연계
  const handleDeepSearchAnalysis = useCallback((resultText?: string, taskText?: string) => {
    const query = resultText || taskText || task;
    if (!query.trim()) {
      toast({
        title: "분석할 내용이 없습니다",
        description: "작업 결과 또는 주제가 필요합니다.",
        variant: "destructive",
      });
      return;
    }

    // 결과 텍스트에서 주요 내용 추출 (너무 길면 자름)
    const truncatedQuery = query.length > 500 ? query.substring(0, 500) + "..." : query;
    navigate(`/deep-search?q=${encodeURIComponent(truncatedQuery)}&fromAgent=true`);

    toast({
      title: "Deep Search로 이동",
      description: "추출된 내용에 대한 심층 분석을 시작합니다.",
    });
  }, [task, navigate, toast]);

  // FactCheck로 분석 연계
  const handleFactCheckAnalysis = useCallback((resultText?: string, taskText?: string) => {
    const content = resultText || taskText || task;
    if (!content.trim()) {
      toast({
        title: "분석할 내용이 없습니다",
        description: "작업 결과 또는 주제가 필요합니다.",
        variant: "destructive",
      });
      return;
    }

    // 세션 스토리지에 저장하여 FactCheck 페이지에서 사용
    sessionStorage.setItem("factCheck_fromAgent", JSON.stringify({
      topic: taskText || task,
      content: resultText || "",
    }));

    navigate("/fact-check");

    toast({
      title: "FactCheck로 이동",
      description: "추출된 내용에 대한 팩트체크를 시작합니다.",
    });
  }, [task, navigate, toast]);

  // 히스토리 항목에서 작업 복제
  const handleCopyTask = useCallback((savedTask: string, savedUrl?: string) => {
    setTask(savedTask);
    setUrl(savedUrl || "");
    setShowHistory(false);
    toast({
      title: "작업 복사됨",
      description: "이전 작업이 입력란에 복사되었습니다.",
    });
  }, [toast]);

  // 템플릿 선택 핸들러
  const handleSelectTemplate = useCallback((template: TaskTemplate) => {
    setTask(template.task);
    if (template.url) {
      setUrl(template.url);
    }
    if (template.maxSteps) {
      setMaxSteps(template.maxSteps);
    }
    toast({
      title: "템플릿 적용됨",
      description: `"${template.name}" 템플릿이 적용되었습니다.`,
    });
  }, [toast]);

  // 히스토리 내보내기
  const handleExport = useCallback((id: string, format: "json" | "markdown") => {
    let filename: string | null = null;
    if (format === "json") {
      filename = exportToJson(id);
    } else {
      filename = exportToMarkdown(id);
    }
    
    if (filename) {
      toast({
        title: "내보내기 완료",
        description: `${filename} 파일이 다운로드되었습니다.`,
      });
    }
  }, [exportToJson, exportToMarkdown, toast]);

  // 히스토리 삭제
  const handleDeleteHistoryItem = useCallback((id: string) => {
    deleteResult(id);
    toast({
      title: "삭제됨",
      description: "저장된 결과가 삭제되었습니다.",
    });
  }, [deleteResult, toast]);

  // 필터링된 히스토리
  const filteredHistory = savedResults.filter((r) => {
    if (historyFilter === "all") return true;
    return r.status === historyFilter;
  });

  // 통계 정보
  const stats = getStats();

  const isProcessing = currentJob && ["pending", "running"].includes(currentJob.status);
  const needsIntervention = currentJob?.status === "waiting_human";
  const isTerminal = currentJob && ["completed", "failed", "cancelled"].includes(currentJob.status);

  // Auto-save to DB when job completes (in addition to local storage)
  useEffect(() => {
    if (isTerminal && currentJob && currentJobId && task.trim()) {
      const completedAt = new Date().toISOString();
      const startedAt = jobStartTimeRef.current || completedAt;
      const durationMs = new Date(completedAt).getTime() - new Date(startedAt).getTime();
      
      if (currentJob.status === "completed") {
        // Save successful browser agent results to DB
        saveBrowserAgent(
          task.trim(),
          currentJob.result ? [{ result: currentJob.result }] : [],
          currentJob.urls_visited || [],
          durationMs,
        );
      } else if (currentJob.status === "failed") {
        // Save failed search to DB
        saveFailedSearch('BROWSER_AGENT', task.trim(), currentJob.error || 'Unknown error', durationMs);
      }
    }
  }, [isTerminal, currentJob, currentJobId, task, saveBrowserAgent, saveFailedSearch]);

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-6xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to="/"
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            Back to Main
          </Link>
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-3xl md:text-4xl font-bold mb-2 bg-gradient-to-r from-primary to-accent bg-clip-text text-transparent">
                Browser AI Agent
              </h1>
              <p className="text-muted-foreground">
                AI-powered browser automation with human-in-the-loop intervention
              </p>
            </div>
            <div className="flex items-center gap-2">
              {/* Stats Button */}
              <Button
                variant="outline"
                size="sm"
                onClick={() => setShowStats(!showStats)}
                className="gap-1"
              >
                <TrendingUp className="h-4 w-4" />
                통계
              </Button>
              {/* History Button */}
              <Button
                variant="outline"
                size="sm"
                onClick={() => setShowHistory(!showHistory)}
                className="gap-1"
              >
                <History className="h-4 w-4" />
                기록
                {savedResults.length > 0 && (
                  <Badge variant="secondary" className="ml-1 h-5 min-w-5 px-1">
                    {savedResults.length}
                  </Badge>
                )}
              </Button>
              {wsConnected ? (
                <Badge variant="secondary" className="flex items-center gap-1">
                  <Wifi className="h-3 w-3 text-green-500" />
                  Live
                </Badge>
              ) : currentJobId ? (
                <Badge variant="outline" className="flex items-center gap-1">
                  <WifiOff className="h-3 w-3 text-red-500" />
                  Disconnected
                </Badge>
              ) : null}
              {health && (
                <Badge variant="outline">
                  {health.active_jobs} active / {health.waiting_intervention} waiting
                </Badge>
              )}
            </div>
          </div>
          {!isHealthy && (
            <div className="mt-4 p-3 rounded-md bg-destructive/10 text-destructive text-sm flex items-center gap-2">
              <AlertCircle className="h-4 w-4" />
              Browser agent service is currently unavailable.
            </div>
          )}
        </header>

        {/* Stats Dashboard Panel */}
        {showStats && (
          <Card className="mb-6">
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <CardTitle className="text-lg flex items-center gap-2">
                  <TrendingUp className="h-5 w-5" />
                  Browser Agent 통계
                </CardTitle>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => {
                      refetchStats();
                      refetchActiveJobs();
                    }}
                    disabled={statsLoading}
                  >
                    <RefreshCw className={`h-4 w-4 ${statsLoading ? 'animate-spin' : ''}`} />
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setShowStats(false)}
                    className="h-8 w-8 p-0"
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            </CardHeader>
            <CardContent>
              {statsLoading && !browserStats ? (
                <div className="flex items-center justify-center py-8">
                  <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
                </div>
              ) : browserStats ? (
                <div className="space-y-6">
                  {/* Stats Grid */}
                  <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                    <div className="text-center p-4 bg-muted/50 rounded-lg">
                      <p className="text-3xl font-bold">{browserStats.totalJobs}</p>
                      <p className="text-xs text-muted-foreground">전체 작업</p>
                    </div>
                    <div className="text-center p-4 bg-blue-500/10 rounded-lg border border-blue-500/20">
                      <p className="text-3xl font-bold text-blue-600">{browserStats.activeJobs}</p>
                      <p className="text-xs text-muted-foreground">실행 중</p>
                    </div>
                    <div className="text-center p-4 bg-orange-500/10 rounded-lg border border-orange-500/20">
                      <p className="text-3xl font-bold text-orange-600">{browserStats.waitingIntervention}</p>
                      <p className="text-xs text-muted-foreground">대기 중</p>
                    </div>
                    <div className="text-center p-4 bg-green-500/10 rounded-lg border border-green-500/20">
                      <p className="text-3xl font-bold text-green-600">{browserStats.completedJobs}</p>
                      <p className="text-xs text-muted-foreground">완료</p>
                    </div>
                    <div className="text-center p-4 bg-red-500/10 rounded-lg border border-red-500/20">
                      <p className="text-3xl font-bold text-red-600">{browserStats.failedJobs}</p>
                      <p className="text-xs text-muted-foreground">실패/취소</p>
                    </div>
                  </div>

                  {/* Active Jobs List */}
                  {activeJobs && activeJobs.length > 0 && (
                    <div>
                      <div className="flex items-center justify-between mb-3">
                        <h4 className="text-sm font-medium flex items-center gap-2">
                          <Activity className="h-4 w-4" />
                          활성 작업 ({activeJobs.length}개)
                        </h4>
                        <Button
                          variant="destructive"
                          size="sm"
                          onClick={() => {
                            if (confirm(`${activeJobs.length}개의 모든 활성 작업을 취소하시겠습니까?`)) {
                              cancelAllMutation.mutate();
                            }
                          }}
                          disabled={cancelAllMutation.isPending}
                          className="gap-1"
                        >
                          {cancelAllMutation.isPending ? (
                            <Loader2 className="h-4 w-4 animate-spin" />
                          ) : (
                            <StopCircle className="h-4 w-4" />
                          )}
                          모두 취소
                        </Button>
                      </div>
                      <ScrollArea className="max-h-[200px]">
                        <div className="space-y-2">
                          {activeJobs.map((job) => (
                            <div
                              key={job.job_id}
                              className="flex items-center justify-between p-3 rounded-lg border bg-card"
                            >
                              <div className="flex-1 min-w-0 mr-4">
                                <div className="flex items-center gap-2 mb-1">
                                  <Badge className={STATUS_CONFIG[job.status]?.color || 'bg-gray-500'}>
                                    {STATUS_CONFIG[job.status]?.label || job.status}
                                  </Badge>
                                  {job.intervention_requested && (
                                    <Badge variant="outline" className="text-orange-600 border-orange-300">
                                      <AlertTriangle className="h-3 w-3 mr-1" />
                                      개입 필요
                                    </Badge>
                                  )}
                                </div>
                                <p className="text-xs text-muted-foreground truncate">
                                  ID: {job.job_id}
                                </p>
                                <p className="text-xs text-muted-foreground">
                                  진행: {Math.round(job.progress * 100)}%
                                  {job.started_at && ` · 시작: ${new Date(job.started_at).toLocaleTimeString('ko-KR')}`}
                                </p>
                              </div>
                              <div className="flex items-center gap-1">
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={() => {
                                    setCurrentJobId(job.job_id);
                                    setShowStats(false);
                                  }}
                                  className="h-8 w-8 p-0"
                                  title="작업 보기"
                                >
                                  <Eye className="h-4 w-4" />
                                </Button>
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={async () => {
                                    try {
                                      await cancelBrowserJob(job.job_id);
                                      toast({ title: "취소됨", description: `작업 ${job.job_id.slice(0, 8)}... 취소됨` });
                                      refetchActiveJobs();
                                      refetchStats();
                                    } catch (e) {
                                      toast({
                                        title: "취소 실패",
                                        description: e instanceof Error ? e.message : "Unknown error",
                                        variant: "destructive",
                                      });
                                    }
                                  }}
                                  className="h-8 w-8 p-0 text-destructive hover:text-destructive"
                                  title="취소"
                                >
                                  <XCircle className="h-4 w-4" />
                                </Button>
                              </div>
                            </div>
                          ))}
                        </div>
                      </ScrollArea>
                    </div>
                  )}

                  {/* Recent Jobs */}
                  {browserStats.recentJobs.length > 0 && (
                    <Collapsible>
                      <CollapsibleTrigger asChild>
                        <Button variant="ghost" size="sm" className="w-full justify-between">
                          <span className="flex items-center gap-2">
                            <History className="h-4 w-4" />
                            최근 작업 ({browserStats.recentJobs.length}개)
                          </span>
                          <ChevronDown className="h-4 w-4" />
                        </Button>
                      </CollapsibleTrigger>
                      <CollapsibleContent>
                        <ScrollArea className="max-h-[250px] mt-2">
                          <div className="space-y-2">
                            {browserStats.recentJobs.map((job) => (
                              <div
                                key={job.job_id}
                                className="flex items-center justify-between p-2 rounded border text-sm"
                              >
                                <div className="flex items-center gap-2">
                                  <Badge className={`${STATUS_CONFIG[job.status]?.color || 'bg-gray-500'} text-xs`}>
                                    {STATUS_CONFIG[job.status]?.label || job.status}
                                  </Badge>
                                  <span className="text-xs text-muted-foreground truncate max-w-[200px]">
                                    {job.job_id}
                                  </span>
                                </div>
                                <span className="text-xs text-muted-foreground">
                                  {Math.round(job.progress * 100)}%
                                </span>
                              </div>
                            ))}
                          </div>
                        </ScrollArea>
                      </CollapsibleContent>
                    </Collapsible>
                  )}

                  {/* No active jobs message */}
                  {(!activeJobs || activeJobs.length === 0) && (
                    <div className="text-center py-4 text-muted-foreground text-sm">
                      현재 활성화된 작업이 없습니다.
                    </div>
                  )}
                </div>
              ) : (
                <div className="text-center py-8 text-muted-foreground">
                  통계를 불러올 수 없습니다.
                </div>
              )}
            </CardContent>
          </Card>
        )}

        {/* History Panel */}
        {showHistory && storageLoaded && (
          <Card className="mb-6">
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-4">
                  <CardTitle className="text-lg flex items-center gap-2">
                    <History className="h-5 w-5" />
                    작업 기록
                  </CardTitle>
                  {/* Stats */}
                  <div className="flex items-center gap-2 text-xs text-muted-foreground">
                    <span className="flex items-center gap-1">
                      <CheckCircle2 className="h-3 w-3 text-green-500" />
                      {stats.completed}
                    </span>
                    <span className="flex items-center gap-1">
                      <XCircle className="h-3 w-3 text-red-500" />
                      {stats.failed}
                    </span>
                    <span>성공률 {stats.successRate.toFixed(0)}%</span>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  {/* Filter */}
                  <Select value={historyFilter} onValueChange={(v) => setHistoryFilter(v as typeof historyFilter)}>
                    <SelectTrigger className="w-[100px] h-8 text-xs">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">전체</SelectItem>
                      <SelectItem value="completed">성공</SelectItem>
                      <SelectItem value="failed">실패</SelectItem>
                    </SelectContent>
                  </Select>
                  {/* Export All */}
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="outline" size="sm" className="h-8">
                        <Download className="h-3 w-3 mr-1" />
                        내보내기
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem onClick={() => {
                        const filename = exportToJson();
                        if (filename) toast({ title: "내보내기 완료", description: `${filename}` });
                      }}>
                        <FileJson className="h-4 w-4 mr-2" />
                        전체 JSON
                      </DropdownMenuItem>
                      <DropdownMenuItem onClick={() => {
                        const filename = exportToCsv();
                        if (filename) toast({ title: "내보내기 완료", description: `${filename}` });
                      }}>
                        <BarChart3 className="h-4 w-4 mr-2" />
                        전체 CSV
                      </DropdownMenuItem>
                      <DropdownMenuSeparator />
                      <DropdownMenuItem
                        onClick={() => {
                          if (confirm("모든 기록을 삭제하시겠습니까?")) {
                            clearAllResults();
                            toast({ title: "삭제됨", description: "모든 기록이 삭제되었습니다." });
                          }
                        }}
                        className="text-destructive"
                      >
                        <Trash2 className="h-4 w-4 mr-2" />
                        전체 삭제
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setShowHistory(false)}
                    className="h-8 w-8 p-0"
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            </CardHeader>
            <CardContent>
              {filteredHistory.length === 0 ? (
                <p className="text-sm text-muted-foreground text-center py-8">
                  {savedResults.length === 0 
                    ? "저장된 작업 기록이 없습니다. 작업 완료 후 '결과 저장' 버튼을 클릭하세요."
                    : "해당 필터에 맞는 기록이 없습니다."}
                </p>
              ) : (
                <ScrollArea className="max-h-[400px]">
                  <div className="space-y-2">
                    {filteredHistory.map((item) => (
                      <div
                        key={item.id}
                        className="flex items-start justify-between p-3 rounded-lg border bg-card hover:bg-muted/50 transition-colors"
                      >
                        <div className="flex-1 min-w-0 mr-4">
                          <div className="flex items-center gap-2 mb-1">
                            {item.status === "completed" ? (
                              <CheckCircle2 className="h-4 w-4 text-green-500 shrink-0" />
                            ) : item.status === "failed" ? (
                              <XCircle className="h-4 w-4 text-red-500 shrink-0" />
                            ) : (
                              <XCircle className="h-4 w-4 text-gray-400 shrink-0" />
                            )}
                            <h4 className="font-medium text-sm truncate">{item.task}</h4>
                          </div>
                          <p className="text-xs text-muted-foreground">
                            {new Date(item.savedAt).toLocaleString("ko-KR")} · 
                            {item.executionStats.totalSteps}/{item.executionStats.maxSteps} 단계 · 
                            {item.visitedUrls.length}개 URL 방문
                          </p>
                          {item.result && (
                            <p className="text-xs text-muted-foreground mt-1 line-clamp-2">
                              결과: {item.result.substring(0, 100)}...
                            </p>
                          )}
                        </div>
                        <div className="flex items-center gap-1 shrink-0">
                          {/* Copy Task */}
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleCopyTask(item.task, item.startUrl)}
                            title="작업 복사"
                            className="h-8 w-8 p-0"
                          >
                            <Copy className="h-4 w-4" />
                          </Button>
                          {/* Deep Search */}
                          {item.result && (
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => handleDeepSearchAnalysis(item.result, item.task)}
                              title="Deep Search 분석"
                              className="h-8 w-8 p-0 text-purple-600 hover:text-purple-700"
                            >
                              <Microscope className="h-4 w-4" />
                            </Button>
                          )}
                          {/* FactCheck */}
                          {item.result && (
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => handleFactCheckAnalysis(item.result, item.task)}
                              title="팩트체크"
                              className="h-8 w-8 p-0 text-green-600 hover:text-green-700"
                            >
                              <Shield className="h-4 w-4" />
                            </Button>
                          )}
                          {/* More Actions */}
                          <DropdownMenu>
                            <DropdownMenuTrigger asChild>
                              <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                                <MoreVertical className="h-4 w-4" />
                              </Button>
                            </DropdownMenuTrigger>
                            <DropdownMenuContent align="end">
                              <DropdownMenuItem onClick={() => {
                                setSelectedHistoryItem(item);
                                setHistoryDetailOpen(true);
                              }}>
                                <Eye className="h-4 w-4 mr-2" />
                                상세 보기
                              </DropdownMenuItem>
                              <DropdownMenuSeparator />
                              <DropdownMenuItem onClick={() => handleExport(item.id, "json")}>
                                <FileJson className="h-4 w-4 mr-2" />
                                JSON 내보내기
                              </DropdownMenuItem>
                              <DropdownMenuItem onClick={() => handleExport(item.id, "markdown")}>
                                <FileText className="h-4 w-4 mr-2" />
                                Markdown 내보내기
                              </DropdownMenuItem>
                              <DropdownMenuSeparator />
                              <DropdownMenuItem
                                onClick={() => handleDeleteHistoryItem(item.id)}
                                className="text-destructive"
                              >
                                <Trash2 className="h-4 w-4 mr-2" />
                                삭제
                              </DropdownMenuItem>
                            </DropdownMenuContent>
                          </DropdownMenu>
                        </div>
                      </div>
                    ))}
                  </div>
                </ScrollArea>
              )}
            </CardContent>
          </Card>
        )}

        {/* History Detail Dialog */}
        <Dialog open={historyDetailOpen} onOpenChange={setHistoryDetailOpen}>
          <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
            {selectedHistoryItem && (
              <>
                <DialogHeader>
                  <DialogTitle className="flex items-center gap-2">
                    {selectedHistoryItem.status === "completed" ? (
                      <CheckCircle2 className="h-5 w-5 text-green-500" />
                    ) : (
                      <XCircle className="h-5 w-5 text-red-500" />
                    )}
                    작업 상세
                  </DialogTitle>
                  <DialogDescription>
                    {new Date(selectedHistoryItem.savedAt).toLocaleString("ko-KR")}
                  </DialogDescription>
                </DialogHeader>
                <div className="space-y-4">
                  {/* Task */}
                  <div>
                    <Label className="text-sm font-medium">작업 설명</Label>
                    <p className="mt-1 text-sm bg-muted p-2 rounded">{selectedHistoryItem.task}</p>
                  </div>
                  
                  {/* Start URL */}
                  {selectedHistoryItem.startUrl && (
                    <div>
                      <Label className="text-sm font-medium">시작 URL</Label>
                      <p className="mt-1 text-sm">
                        <a 
                          href={selectedHistoryItem.startUrl} 
                          target="_blank" 
                          rel="noopener noreferrer"
                          className="text-blue-600 hover:underline flex items-center gap-1"
                        >
                          {selectedHistoryItem.startUrl}
                          <ExternalLink className="h-3 w-3" />
                        </a>
                      </p>
                    </div>
                  )}
                  
                  {/* Stats */}
                  <div className="grid grid-cols-3 gap-4">
                    <div className="text-center p-2 bg-muted rounded">
                      <p className="text-2xl font-bold">{selectedHistoryItem.executionStats.totalSteps}</p>
                      <p className="text-xs text-muted-foreground">실행 단계</p>
                    </div>
                    <div className="text-center p-2 bg-muted rounded">
                      <p className="text-2xl font-bold">{selectedHistoryItem.visitedUrls.length}</p>
                      <p className="text-xs text-muted-foreground">방문 URL</p>
                    </div>
                    <div className="text-center p-2 bg-muted rounded">
                      <p className="text-2xl font-bold">
                        {selectedHistoryItem.executionStats.durationMs 
                          ? `${Math.round(selectedHistoryItem.executionStats.durationMs / 1000)}s`
                          : "-"}
                      </p>
                      <p className="text-xs text-muted-foreground">소요 시간</p>
                    </div>
                  </div>
                  
                  {/* Result */}
                  {selectedHistoryItem.result && (
                    <div>
                      <Label className="text-sm font-medium">추출 결과</Label>
                      <ScrollArea className="mt-1 h-[200px] bg-muted p-2 rounded">
                        <pre className="text-xs whitespace-pre-wrap">{selectedHistoryItem.result}</pre>
                      </ScrollArea>
                    </div>
                  )}
                  
                  {/* Error */}
                  {selectedHistoryItem.error && (
                    <div>
                      <Label className="text-sm font-medium text-destructive">오류</Label>
                      <p className="mt-1 text-sm text-destructive bg-destructive/10 p-2 rounded">
                        {selectedHistoryItem.error}
                      </p>
                    </div>
                  )}
                  
                  {/* Visited URLs */}
                  {selectedHistoryItem.visitedUrls.length > 0 && (
                    <Collapsible>
                      <CollapsibleTrigger asChild>
                        <Button variant="ghost" size="sm" className="w-full justify-between">
                          방문한 URL ({selectedHistoryItem.visitedUrls.length}개)
                          <ChevronDown className="h-4 w-4" />
                        </Button>
                      </CollapsibleTrigger>
                      <CollapsibleContent>
                        <ScrollArea className="h-[150px] mt-2">
                          <ul className="text-xs space-y-1">
                            {selectedHistoryItem.visitedUrls.map((visitedUrl, i) => (
                              <li key={i} className="flex items-center gap-1">
                                <Globe className="h-3 w-3 text-muted-foreground shrink-0" />
                                <a 
                                  href={visitedUrl} 
                                  target="_blank" 
                                  rel="noopener noreferrer"
                                  className="text-blue-600 hover:underline truncate"
                                >
                                  {visitedUrl}
                                </a>
                              </li>
                            ))}
                          </ul>
                        </ScrollArea>
                      </CollapsibleContent>
                    </Collapsible>
                  )}
                </div>
                <DialogFooter className="mt-4">
                  <div className="flex gap-2 w-full">
                    <Button
                      variant="outline"
                      onClick={() => handleCopyTask(selectedHistoryItem.task, selectedHistoryItem.startUrl)}
                      className="flex-1"
                    >
                      <Copy className="h-4 w-4 mr-2" />
                      작업 복사
                    </Button>
                    {selectedHistoryItem.result && (
                      <>
                        <Button
                          variant="outline"
                          onClick={() => {
                            handleDeepSearchAnalysis(selectedHistoryItem.result, selectedHistoryItem.task);
                            setHistoryDetailOpen(false);
                          }}
                          className="flex-1 text-purple-600 hover:text-purple-700"
                        >
                          <Microscope className="h-4 w-4 mr-2" />
                          Deep Search
                        </Button>
                        <Button
                          variant="outline"
                          onClick={() => {
                            handleFactCheckAnalysis(selectedHistoryItem.result, selectedHistoryItem.task);
                            setHistoryDetailOpen(false);
                          }}
                          className="flex-1 text-green-600 hover:text-green-700"
                        >
                          <Shield className="h-4 w-4 mr-2" />
                          팩트체크
                        </Button>
                      </>
                    )}
                  </div>
                </DialogFooter>
              </>
            )}
          </DialogContent>
        </Dialog>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Left Column: Task Form & Status */}
          <div className="lg:col-span-1 space-y-6">
            {/* Task Form */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Bot className="h-5 w-5" />
                  New Task
                </CardTitle>
                <CardDescription>
                  Describe what you want the AI to do in the browser
                </CardDescription>
              </CardHeader>
              <CardContent>
                {/* Task Templates */}
                <TaskTemplates
                  onSelectTemplate={handleSelectTemplate}
                  disabled={isProcessing || needsIntervention}
                  className="mb-4"
                />

                <form onSubmit={handleSubmit} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="task">Task Description *</Label>
                    <Textarea
                      id="task"
                      value={task}
                      onChange={(e) => setTask(e.target.value)}
                      placeholder="e.g., Go to news.ycombinator.com and extract the top 5 headlines"
                      disabled={isProcessing || needsIntervention}
                      rows={3}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="url">Starting URL (optional)</Label>
                    <Input
                      id="url"
                      value={url}
                      onChange={(e) => setUrl(e.target.value)}
                      placeholder="https://example.com"
                      disabled={isProcessing || needsIntervention}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="maxSteps">Max Steps</Label>
                    <Input
                      id="maxSteps"
                      type="number"
                      value={maxSteps}
                      onChange={(e) => setMaxSteps(parseInt(e.target.value) || 25)}
                      min={1}
                      max={100}
                      disabled={isProcessing || needsIntervention}
                    />
                  </div>

                  <div className="flex items-center justify-between">
                    <Label htmlFor="enableIntervention">Human Intervention</Label>
                    <Switch
                      id="enableIntervention"
                      checked={enableIntervention}
                      onCheckedChange={setEnableIntervention}
                      disabled={isProcessing || needsIntervention}
                    />
                  </div>

                  {enableIntervention && (
                    <div className="flex items-center justify-between">
                      <Label htmlFor="autoIntervention">Auto-detect Issues</Label>
                      <Switch
                        id="autoIntervention"
                        checked={autoIntervention}
                        onCheckedChange={setAutoIntervention}
                        disabled={isProcessing || needsIntervention}
                      />
                    </div>
                  )}

                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <Label htmlFor="autoSaveUrls">Auto-save URLs</Label>
                      <Badge variant="outline" className="text-xs">
                        <BookmarkPlus className="h-3 w-3 mr-1" />
                        컬렉션에 저장
                      </Badge>
                    </div>
                    <Switch
                      id="autoSaveUrls"
                      checked={autoSaveUrls}
                      onCheckedChange={setAutoSaveUrls}
                      disabled={isProcessing || needsIntervention}
                    />
                  </div>

                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <Label htmlFor="useProxyRotation">Proxy Rotation</Label>
                      <Badge variant="outline" className="text-xs">
                        <Shield className="h-3 w-3 mr-1" />
                        ip-rotation
                      </Badge>
                    </div>
                    <Switch
                      id="useProxyRotation"
                      checked={useProxyRotation}
                      onCheckedChange={setUseProxyRotation}
                      disabled={isProcessing || needsIntervention}
                    />
                  </div>

                  <div className="flex gap-2">
                    <Button
                      type="submit"
                      disabled={!task.trim() || isProcessing || needsIntervention || !isHealthy}
                      className="flex-1"
                    >
                      {startMutation.isPending ? (
                        <>
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          Starting...
                        </>
                      ) : (
                        <>
                          <Play className="h-4 w-4 mr-2" />
                          Start Task
                        </>
                      )}
                    </Button>
                    {(currentJob || isTerminal) && (
                      <Button type="button" variant="outline" onClick={handleReset}>
                        <RefreshCw className="h-4 w-4" />
                      </Button>
                    )}
                  </div>
                </form>
              </CardContent>
            </Card>

            {/* Job Status */}
            {currentJob && (
              <Card>
                <CardHeader className="pb-2">
                  <CardTitle className="text-lg flex items-center justify-between">
                    <span>Job Status</span>
                    <Badge className={STATUS_CONFIG[currentJob.status].color}>
                      {STATUS_CONFIG[currentJob.status].label}
                    </Badge>
                  </CardTitle>
                  <CardDescription>
                    Job ID: {currentJob.job_id}
                  </CardDescription>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div>
                    <div className="flex justify-between text-sm mb-1">
                      <span>Progress</span>
                      <span>{currentJob.current_step} / {currentJob.max_steps} steps</span>
                    </div>
                    <Progress value={currentJob.progress * 100} />
                  </div>

                  {currentJob.urls_visited.length > 0 && (
                    <div>
                      <div className="flex items-center justify-between mb-1">
                        <Label className="text-sm">Visited URLs</Label>
                        {autoSaveUrls && savedUrlCount > 0 && (
                          <Badge variant="secondary" className="text-xs">
                            <FolderPlus className="h-3 w-3 mr-1" />
                            {savedUrlCount}개 저장됨
                          </Badge>
                        )}
                      </div>
                      <div className="mt-1 max-h-32 overflow-y-auto space-y-1">
                        {currentJob.urls_visited.map((visitedUrl, i) => (
                          <div key={i} className="text-xs text-muted-foreground flex items-center gap-1">
                            <Globe className="h-3 w-3 shrink-0" />
                            <a
                              href={visitedUrl}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="truncate hover:underline"
                            >
                              {visitedUrl}
                            </a>
                            {savedUrlsRef.current.has(visitedUrl) && (
                              <CheckCircle2 className="h-3 w-3 shrink-0 text-green-500" />
                            )}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {currentJob.result && (
                    <div>
                      <Label className="text-sm">Result</Label>
                      <div className="mt-1 p-2 bg-muted rounded text-xs max-h-40 overflow-y-auto whitespace-pre-wrap">
                        {currentJob.result}
                      </div>
                    </div>
                  )}

                  {currentJob.error && (
                    <div className="p-2 bg-destructive/10 text-destructive rounded text-sm">
                      {currentJob.error}
                    </div>
                  )}

                  {/* Action buttons */}
                  <div className="flex gap-2">
                    {isProcessing && enableIntervention && (
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => manualInterventionMutation.mutate()}
                        disabled={manualInterventionMutation.isPending}
                      >
                        <Hand className="h-4 w-4 mr-1" />
                        Take Over
                      </Button>
                    )}
                    {(isProcessing || needsIntervention) && (
                      <Button
                        variant="destructive"
                        size="sm"
                        onClick={() => cancelMutation.mutate()}
                        disabled={cancelMutation.isPending}
                      >
                        <Trash2 className="h-4 w-4 mr-1" />
                        Cancel
                      </Button>
                    )}
                  </div>
                </CardContent>
              </Card>
            )}
          </div>

          {/* Right Column: Browser View & Intervention */}
          <div className="lg:col-span-2 space-y-6">
            {/* Intervention Panel */}
            {needsIntervention && currentJob && (
              <InterventionPanel
                job={currentJob}
                onSubmit={(action) => interventionMutation.mutate(action)}
                isSubmitting={interventionMutation.isPending}
              />
            )}

            {/* Live Browser View */}
            {currentJobId && !needsIntervention && (
              <Card>
                <CardHeader className="pb-2">
                  <CardTitle className="text-lg flex items-center gap-2">
                    <MonitorPlay className="h-5 w-5" />
                    Live Browser View
                  </CardTitle>
                  {liveUrl && (
                    <CardDescription className="flex items-center gap-2">
                      <Globe className="h-3 w-3" />
                      <a
                        href={liveUrl}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="hover:underline truncate"
                      >
                        {liveUrl}
                      </a>
                      <ExternalLink className="h-3 w-3" />
                    </CardDescription>
                  )}
                </CardHeader>
                <CardContent>
                  {liveScreenshot ? (
                    <div className="border rounded-lg overflow-hidden">
                      <img
                        src={`data:image/jpeg;base64,${liveScreenshot}`}
                        alt="Live browser view"
                        className="w-full"
                      />
                    </div>
                  ) : (
                    <div className="h-64 flex items-center justify-center bg-muted rounded-lg">
                      {isProcessing ? (
                        <div className="text-center text-muted-foreground">
                          <Loader2 className="h-8 w-8 mx-auto mb-2 animate-spin" />
                          <p>Waiting for browser updates...</p>
                        </div>
                      ) : (
                        <div className="text-center text-muted-foreground">
                          <Camera className="h-8 w-8 mx-auto mb-2" />
                          <p>No screenshot available</p>
                        </div>
                      )}
                    </div>
                  )}
                </CardContent>
              </Card>
            )}

            {/* Empty State */}
            {!currentJobId && (
              <Card>
                <CardContent className="py-16">
                  <div className="text-center">
                    <div className="inline-block p-4 rounded-full bg-accent/10 mb-4">
                      <Bot className="h-12 w-12 text-accent" />
                    </div>
                    <h2 className="text-xl font-semibold mb-2">Ready to Browse</h2>
                    <p className="text-muted-foreground max-w-md mx-auto">
                      Describe a task and the AI agent will automate browser actions.
                      You can take control at any time if the agent needs help.
                    </p>
                  </div>
                </CardContent>
              </Card>
            )}

            {/* Completed State */}
            {isTerminal && currentJob && (
              <Card>
                <CardContent className="py-8">
                  <div className="text-center">
                    {currentJob.status === "completed" ? (
                      <>
                        <CheckCircle2 className="h-12 w-12 mx-auto text-green-500 mb-4" />
                        <h2 className="text-xl font-semibold mb-2">Task Completed</h2>
                        <p className="text-muted-foreground">
                          Visited {currentJob.urls_visited.length} pages in {currentJob.current_step} steps
                        </p>
                      </>
                    ) : currentJob.status === "failed" ? (
                      <>
                        <XCircle className="h-12 w-12 mx-auto text-destructive mb-4" />
                        <h2 className="text-xl font-semibold mb-2">Task Failed</h2>
                        <p className="text-muted-foreground">{currentJob.error}</p>
                      </>
                    ) : (
                      <>
                        <XCircle className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
                        <h2 className="text-xl font-semibold mb-2">Task Cancelled</h2>
                      </>
                    )}
                    
                    {/* Action Buttons */}
                    <div className="flex flex-wrap justify-center gap-2 mt-6">
                      {/* Save Result */}
                      <Button 
                        onClick={handleSaveResult}
                        variant="default"
                      >
                        <Save className="h-4 w-4 mr-2" />
                        결과 저장
                      </Button>
                      
                      {/* Deep Search (only if has result) */}
                      {currentJob.result && (
                        <Button
                          variant="outline"
                          onClick={() => handleDeepSearchAnalysis(currentJob.result, task)}
                          className="text-purple-600 hover:text-purple-700 border-purple-300"
                        >
                          <Microscope className="h-4 w-4 mr-2" />
                          Deep Search 분석
                        </Button>
                      )}
                      
                      {/* FactCheck (only if has result) */}
                      {currentJob.result && (
                        <Button
                          variant="outline"
                          onClick={() => handleFactCheckAnalysis(currentJob.result, task)}
                          className="text-green-600 hover:text-green-700 border-green-300"
                        >
                          <Shield className="h-4 w-4 mr-2" />
                          팩트체크
                        </Button>
                      )}
                      
                      {/* New Task */}
                      <Button onClick={handleReset} variant="outline">
                        <RefreshCw className="h-4 w-4 mr-2" />
                        새 작업 시작
                      </Button>
                    </div>
                    
                    {/* Result Preview (if exists) */}
                    {currentJob.result && (
                      <div className="mt-6 text-left">
                        <Collapsible>
                          <CollapsibleTrigger asChild>
                            <Button variant="ghost" size="sm" className="w-full justify-between mb-2">
                              <span className="flex items-center gap-2">
                                <FileText className="h-4 w-4" />
                                추출된 결과 미리보기
                              </span>
                              <ChevronDown className="h-4 w-4" />
                            </Button>
                          </CollapsibleTrigger>
                          <CollapsibleContent>
                            <ScrollArea className="h-[200px] bg-muted p-3 rounded-lg">
                              <pre className="text-xs whitespace-pre-wrap text-left">
                                {currentJob.result}
                              </pre>
                            </ScrollArea>
                          </CollapsibleContent>
                        </Collapsible>
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default BrowserAgent;

```

---

## frontend/src/pages/CollectedDataPage.tsx

```tsx
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import {
  ArrowLeft,
  Database,
  RefreshCw,
  Loader2,
  Clock,
  CheckCircle2,
  FileText,
  ExternalLink,
  Filter,
  Inbox,
  AlertCircle,
  Activity,
  Brain,
  Sparkles,
  MoreHorizontal,
  Search,
  X,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Separator } from '@/components/ui/separator';
import { useToast } from '@/hooks/use-toast';
import {
  useCollectedData,
  useUnprocessedData,
  useDataStats,
} from '@/hooks/useCollectedData';
import { useMlAnalysis } from '@/hooks/useMlAnalysis';
import { type CollectedDataDTO, summarizeData } from '@/lib/api/data';
import type { AddonCategory } from '@/types/api';

// ============================================
// Data Item Card Component
// ============================================

interface DataItemCardProps {
  item: CollectedDataDTO;
  onMarkProcessed: (id: number) => Promise<void>;
  onAnalyze: (id: number, importance?: 'realtime' | 'batch') => Promise<void>;
  onAnalyzeCategory: (id: number, category: AddonCategory) => Promise<void>;
  showProcessedBadge?: boolean;
}

const DataItemCard: React.FC<DataItemCardProps> = ({
  item,
  onMarkProcessed,
  onAnalyze,
  onAnalyzeCategory,
  showProcessedBadge = true,
}) => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  const handleMarkProcessed = async () => {
    setIsProcessing(true);
    try {
      await onMarkProcessed(item.id);
    } finally {
      setIsProcessing(false);
    }
  };

  const handleAnalyze = async (importance: 'realtime' | 'batch' = 'batch') => {
    setIsAnalyzing(true);
    try {
      await onAnalyze(item.id, importance);
    } finally {
      setIsAnalyzing(false);
    }
  };

  const handleAnalyzeCategory = async (category: AddonCategory) => {
    setIsAnalyzing(true);
    try {
      await onAnalyzeCategory(item.id, category);
    } finally {
      setIsAnalyzing(false);
    }
  };

  return (
    <Card className="overflow-hidden">
      <CardHeader className="pb-2">
        <div className="flex items-start justify-between gap-2">
          <div className="flex-1 min-w-0">
            <CardTitle className="text-sm line-clamp-2">
              {item.title || '제목 없음'}
            </CardTitle>
            <CardDescription className="text-xs mt-1 flex items-center gap-2">
              <Clock className="h-3 w-3" />
              {new Date(item.collectedAt).toLocaleString('ko-KR')}
              {item.publishedDate && (
                <span className="text-muted-foreground">
                  (발행: {new Date(item.publishedDate).toLocaleDateString('ko-KR')})
                </span>
              )}
            </CardDescription>
          </div>
          {showProcessedBadge && (
            <Badge variant={item.processed ? 'default' : 'outline'}>
              {item.processed ? '처리됨' : '대기'}
            </Badge>
          )}
        </div>
      </CardHeader>
      <CardContent className="space-y-3">
        {/* Content Preview */}
        <p className="text-sm text-muted-foreground line-clamp-3">
          {summarizeData(item, 200) || '내용 없음'}
        </p>

        {/* Metadata */}
        {item.metadata && Object.keys(item.metadata).length > 0 && (
          <div className="flex flex-wrap gap-1">
            {Object.entries(item.metadata)
              .slice(0, 3)
              .map(([key, value]) => (
                <Badge key={key} variant="secondary" className="text-xs">
                  {key}: {String(value).slice(0, 20)}
                </Badge>
              ))}
          </div>
        )}

        {/* Actions */}
        <div className="flex items-center justify-between pt-2">
          <div className="flex items-center gap-2">
            {item.url && (
              <a
                href={item.url}
                target="_blank"
                rel="noopener noreferrer"
                className="text-xs text-blue-500 hover:underline flex items-center gap-1"
              >
                <ExternalLink className="h-3 w-3" />
                원본 보기
              </a>
            )}
            <Badge variant="outline" className="text-xs">
              소스 #{item.sourceId}
            </Badge>
          </div>
          <div className="flex items-center gap-1">
            {/* ML 분석 드롭다운 */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button
                  variant="outline"
                  size="sm"
                  disabled={isAnalyzing}
                  className="gap-1"
                >
                  {isAnalyzing ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    <Brain className="h-4 w-4" />
                  )}
                  <span className="text-xs">분석</span>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onClick={() => handleAnalyze('realtime')}>
                  <Sparkles className="mr-2 h-4 w-4 text-yellow-500" />
                  실시간 분석
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => handleAnalyze('batch')}>
                  <Brain className="mr-2 h-4 w-4" />
                  배치 분석
                </DropdownMenuItem>
                <DropdownMenuSeparator />
                <DropdownMenuItem onClick={() => handleAnalyzeCategory('SENTIMENT')}>
                  감정 분석
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => handleAnalyzeCategory('FACTCHECK')}>
                  팩트체크
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => handleAnalyzeCategory('CONTEXT')}>
                  문맥/의도 분석
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => handleAnalyzeCategory('ENTITY_EXTRACTION')}>
                  개체명 추출
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => handleAnalyzeCategory('SUMMARIZATION')}>
                  요약 생성
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>

            {/* 처리됨 표시 버튼 */}
            {!item.processed && (
              <Button
                variant="outline"
                size="sm"
                onClick={handleMarkProcessed}
                disabled={isProcessing}
              >
                {isProcessing ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <CheckCircle2 className="h-4 w-4" />
                )}
                <span className="ml-1 text-xs">처리됨</span>
              </Button>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

// ============================================
// Stats Card Component
// ============================================

interface StatsCardProps {
  title: string;
  value: number;
  icon: React.ReactNode;
  description?: string;
  className?: string;
}

const StatsCard: React.FC<StatsCardProps> = ({
  title,
  value,
  icon,
  description,
  className,
}) => {
  return (
    <Card className={className}>
      <CardContent className="p-4">
        <div className="flex items-center justify-between">
          <div>
            <p className="text-sm text-muted-foreground">{title}</p>
            <p className="text-2xl font-bold">{value.toLocaleString()}</p>
            {description && (
              <p className="text-xs text-muted-foreground mt-1">{description}</p>
            )}
          </div>
          <div className="p-2 bg-primary/10 rounded-lg">{icon}</div>
        </div>
      </CardContent>
    </Card>
  );
};

// ============================================
// Collected Data Page Component
// ============================================

const CollectedDataPage: React.FC = () => {
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState<'all' | 'unprocessed'>('all');
  const [processedFilter, setProcessedFilter] = useState<'all' | 'processed' | 'unprocessed'>(
    'all'
  );
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');

  // ML 분석 Hook
  const { startAnalysis, startBatchAnalysis, startCategoryAnalysis, isAnalyzing } = useMlAnalysis();

  // Debounce search query
  React.useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(searchQuery);
    }, 300);
    return () => clearTimeout(timer);
  }, [searchQuery]);

  // Stats Hook
  const { stats, loading: statsLoading, refresh: refreshStats } = useDataStats();

  // All Data Hook
  const {
    data: allData,
    total: allTotal,
    totalPages: allTotalPages,
    currentPage: allCurrentPage,
    loading: allLoading,
    error: allError,
    refresh: refreshAllData,
    setPage: setAllPage,
    markAsProcessed: markAllAsProcessed,
  } = useCollectedData({
    size: 20,
    processed: processedFilter === 'all' ? undefined : processedFilter === 'processed',
    query: debouncedQuery || undefined,
    autoRefresh: true,
    refreshInterval: 30000,
  });

  // Unprocessed Data Hook
  const {
    data: unprocessedData,
    total: unprocessedTotal,
    totalPages: unprocessedTotalPages,
    currentPage: unprocessedCurrentPage,
    loading: unprocessedLoading,
    error: unprocessedError,
    refresh: refreshUnprocessedData,
    setPage: setUnprocessedPage,
    markAsProcessed: markUnprocessedAsProcessed,
  } = useUnprocessedData({
    size: 20,
    autoRefresh: true,
    refreshInterval: 10000,
  });

  const [isRefreshing, setIsRefreshing] = useState(false);

  const handleRefreshAll = async () => {
    setIsRefreshing(true);
    try {
      await Promise.all([refreshStats(), refreshAllData(), refreshUnprocessedData()]);
    } finally {
      setIsRefreshing(false);
    }
  };

  const handleMarkProcessed = async (id: number) => {
    try {
      if (activeTab === 'all') {
        await markAllAsProcessed(id);
      } else {
        await markUnprocessedAsProcessed(id);
      }
      toast({ title: '처리됨으로 표시되었습니다.' });
      refreshStats();
    } catch (e) {
      toast({
        title: '처리 실패',
        description: e instanceof Error ? e.message : '알 수 없는 오류',
        variant: 'destructive',
      });
    }
  };

  const handleAnalyze = async (id: number, importance: 'realtime' | 'batch' = 'batch') => {
    await startAnalysis(id, importance);
  };

  const handleAnalyzeCategory = async (id: number, category: AddonCategory) => {
    await startCategoryAnalysis(id, category);
  };

  const handleBatchAnalyze = async () => {
    const unprocessedIds = unprocessedData.map(d => d.id);
    if (unprocessedIds.length === 0) {
      toast({ title: '분석할 데이터가 없습니다.', variant: 'destructive' });
      return;
    }
    
    await startBatchAnalysis(unprocessedIds.slice(0, 50)); // 최대 50개
  };

  // Current data based on active tab
  const currentData = activeTab === 'all' ? allData : unprocessedData;
  const currentTotal = activeTab === 'all' ? allTotal : unprocessedTotal;
  const currentTotalPages = activeTab === 'all' ? allTotalPages : unprocessedTotalPages;
  const currentPage = activeTab === 'all' ? allCurrentPage : unprocessedCurrentPage;
  const currentLoading = activeTab === 'all' ? allLoading : unprocessedLoading;
  const currentError = activeTab === 'all' ? allError : unprocessedError;
  const setCurrentPage = activeTab === 'all' ? setAllPage : setUnprocessedPage;

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-6xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to="/"
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            검색으로 돌아가기
          </Link>
          <div className="flex items-center justify-between flex-wrap gap-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-primary/10 rounded-lg">
                <Database className="h-6 w-6 text-primary" />
              </div>
              <div>
                <h1 className="text-3xl font-bold">수집 데이터</h1>
                <p className="text-muted-foreground">
                  수집된 뉴스 데이터를 확인하고 처리 상태를 관리합니다.
                </p>
              </div>
            </div>
            <Button
              variant="outline"
              onClick={handleRefreshAll}
              disabled={isRefreshing}
            >
              <RefreshCw
                className={`h-4 w-4 mr-2 ${isRefreshing ? 'animate-spin' : ''}`}
              />
              새로고침
            </Button>
            {unprocessedData.length > 0 && (
              <Button
                onClick={handleBatchAnalyze}
                className="gap-2"
              >
                <Brain className="h-4 w-4" />
                일괄 분석 ({Math.min(unprocessedData.length, 50)}건)
              </Button>
            )}
          </div>
        </header>

        {/* Stats */}
        <div className="grid gap-4 md:grid-cols-3 mb-6">
          <StatsCard
            title="전체 데이터"
            value={stats?.total ?? 0}
            icon={<Database className="h-5 w-5 text-primary" />}
            description="수집된 전체 문서"
          />
          <StatsCard
            title="대기 중"
            value={stats?.unprocessed ?? 0}
            icon={<Inbox className="h-5 w-5 text-yellow-500" />}
            description="처리 대기 중인 문서"
          />
          <StatsCard
            title="처리 완료"
            value={stats?.processed ?? 0}
            icon={<CheckCircle2 className="h-5 w-5 text-green-500" />}
            description="분석 완료된 문서"
          />
        </div>

        {/* Search Bar */}
        <div className="mb-6">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="제목 또는 내용으로 검색..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 pr-10"
            />
            {searchQuery && (
              <Button
                variant="ghost"
                size="icon"
                className="absolute right-1 top-1/2 -translate-y-1/2 h-7 w-7"
                onClick={() => setSearchQuery('')}
              >
                <X className="h-4 w-4" />
              </Button>
            )}
          </div>
          {debouncedQuery && (
            <p className="text-sm text-muted-foreground mt-2">
              "{debouncedQuery}" 검색 결과: {allTotal}건
            </p>
          )}
        </div>

        {/* Error Alert */}
        {currentError && (
          <Alert variant="destructive" className="mb-6">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              데이터를 불러오는데 실패했습니다: {currentError.message}
            </AlertDescription>
          </Alert>
        )}

        {/* Tabs */}
        <Tabs
          value={activeTab}
          onValueChange={(v) => setActiveTab(v as 'all' | 'unprocessed')}
        >
          <div className="flex items-center justify-between mb-4">
            <TabsList>
              <TabsTrigger value="all" className="flex items-center gap-1">
                <FileText className="h-4 w-4" />
                전체 데이터
                <Badge variant="secondary" className="ml-1">
                  {allTotal}
                </Badge>
              </TabsTrigger>
              <TabsTrigger value="unprocessed" className="flex items-center gap-1">
                <Inbox className="h-4 w-4" />
                미처리
                {unprocessedTotal > 0 && (
                  <Badge className="ml-1 bg-yellow-500">
                    {unprocessedTotal}
                  </Badge>
                )}
              </TabsTrigger>
            </TabsList>

            {activeTab === 'all' && (
              <div className="flex items-center gap-2">
                <Filter className="h-4 w-4 text-muted-foreground" />
                <Select
                  value={processedFilter}
                  onValueChange={(v) =>
                    setProcessedFilter(v as 'all' | 'processed' | 'unprocessed')
                  }
                >
                  <SelectTrigger className="w-32">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">전체</SelectItem>
                    <SelectItem value="processed">처리됨</SelectItem>
                    <SelectItem value="unprocessed">미처리</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            )}
          </div>

          <TabsContent value="all">
            <DataList
              data={allData}
              loading={allLoading}
              onMarkProcessed={handleMarkProcessed}
              onAnalyze={handleAnalyze}
              onAnalyzeCategory={handleAnalyzeCategory}
            />
          </TabsContent>

          <TabsContent value="unprocessed">
            <DataList
              data={unprocessedData}
              loading={unprocessedLoading}
              onMarkProcessed={handleMarkProcessed}
              onAnalyze={handleAnalyze}
              onAnalyzeCategory={handleAnalyzeCategory}
              showProcessedBadge={false}
            />
          </TabsContent>
        </Tabs>

        {/* Pagination */}
        {currentTotalPages > 1 && (
          <div className="flex items-center justify-center gap-2 mt-6">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentPage(currentPage - 1)}
              disabled={currentPage === 0}
            >
              이전
            </Button>
            <span className="text-sm text-muted-foreground">
              {currentPage + 1} / {currentTotalPages}
            </span>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentPage(currentPage + 1)}
              disabled={currentPage >= currentTotalPages - 1}
            >
              다음
            </Button>
          </div>
        )}

        {/* Help Section */}
        <Alert className="mt-6">
          <Activity className="h-4 w-4" />
          <AlertDescription>
            <strong>데이터 처리 워크플로우:</strong> 수집된 데이터는 자동으로 ML Add-on을 통해 분석됩니다.
            수동으로 처리됨 표시를 하면 해당 데이터는 분석 대기열에서 제외됩니다.
          </AlertDescription>
        </Alert>
      </div>
    </div>
  );
};

// ============================================
// Data List Component
// ============================================

interface DataListProps {
  data: CollectedDataDTO[];
  loading: boolean;
  onMarkProcessed: (id: number) => Promise<void>;
  onAnalyze: (id: number, importance?: 'realtime' | 'batch') => Promise<void>;
  onAnalyzeCategory: (id: number, category: AddonCategory) => Promise<void>;
  showProcessedBadge?: boolean;
}

const DataList: React.FC<DataListProps> = ({
  data,
  loading,
  onMarkProcessed,
  onAnalyze,
  onAnalyzeCategory,
  showProcessedBadge = true,
}) => {
  if (loading && data.length === 0) {
    return (
      <div className="flex items-center justify-center py-12">
        <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (data.length === 0) {
    return (
      <Card className="p-8 text-center">
        <Inbox className="h-12 w-12 mx-auto mb-4 text-muted-foreground" />
        <p className="text-muted-foreground">표시할 데이터가 없습니다.</p>
      </Card>
    );
  }

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {data.map((item) => (
        <DataItemCard
          key={item.id}
          item={item}
          onMarkProcessed={onMarkProcessed}
          onAnalyze={onAnalyze}
          onAnalyzeCategory={onAnalyzeCategory}
          showProcessedBadge={showProcessedBadge}
        />
      ))}
    </div>
  );
};

export default CollectedDataPage;

```

---

## frontend/src/pages/DeepSearch.tsx

```tsx
import { useState, useCallback, useEffect, useMemo } from "react";
import { Link, useLocation, useSearchParams } from "react-router-dom";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  Search,
  Loader2,
  AlertCircle,
  CheckCircle2,
  XCircle,
  Clock,
  ExternalLink,
  ThumbsUp,
  ThumbsDown,
  Minus,
  ArrowLeft,
  RefreshCw,
  Trash2,
  LayoutGrid,
  List,
  Wifi,
  WifiOff,
  Layers,
  ArrowDownRight,
  History,
  ChevronRight,
  Newspaper,
  Users,
  FileText,
  Shield,
  GraduationCap,
} from "lucide-react";
import { ExportButton } from "@/components/ExportButton";
import { ReportExportButton } from "@/components/ReportExportButton";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useToast } from "@/hooks/use-toast";
import { InsightFlow } from "@/components/insight";
import { useDeepSearchSSE } from "@/hooks/useDeepSearchSSE";
import { useBackgroundTasks } from "@/contexts/BackgroundTaskContext";
import { useAutoSaveSearch } from "@/hooks/useSearchHistory";
import { useSearchRecordFromState } from "@/hooks/useSearchRecord";
import { AnalysisProgressTimeline, type AnalysisStep } from "@/components/AnalysisProgressTimeline";
import { PriorityUrlEditor, type PriorityUrl } from "@/components/PriorityUrlEditor";
import {
  startDeepSearch,
  startDrilldownSearch,
  getDeepSearchStatus,
  getDeepSearchResult,
  cancelDeepSearch,
  checkDeepSearchHealth,
  type DeepSearchJob,
  type DeepSearchResult,
  type Evidence,
  type DrilldownRequest,
} from "@/lib/api";

const DEEPSEARCH_PRIORITY_URLS_KEY = "deepSearch_priorityUrls";

const STATUS_CONFIG = {
  PENDING: { label: "대기 중", icon: Clock, color: "bg-yellow-500" },
  IN_PROGRESS: { label: "분석 중", icon: Loader2, color: "bg-blue-500" },
  COMPLETED: { label: "완료", icon: CheckCircle2, color: "bg-green-500" },
  FAILED: { label: "실패", icon: XCircle, color: "bg-red-500" },
  CANCELLED: { label: "취소됨", icon: XCircle, color: "bg-gray-500" },
  TIMEOUT: { label: "시간 초과", icon: AlertCircle, color: "bg-orange-500" },
} as const;

const STANCE_CONFIG = {
  pro: { label: "긍정", icon: ThumbsUp, color: "text-teal-600", bgColor: "bg-teal-100 dark:bg-teal-900/30" },
  con: { label: "부정", icon: ThumbsDown, color: "text-coral-600", bgColor: "bg-coral-100 dark:bg-coral-900/30" },
  neutral: { label: "중립", icon: Minus, color: "text-gray-600", bgColor: "bg-gray-100 dark:bg-gray-800" },
} as const;

const SOURCE_CATEGORY_CONFIG = {
  news: { label: "뉴스", icon: Newspaper, color: "text-blue-600", bgColor: "bg-blue-100 dark:bg-blue-900/30" },
  community: { label: "커뮤니티", icon: Users, color: "text-orange-600", bgColor: "bg-orange-100 dark:bg-orange-900/30" },
  blog: { label: "블로그", icon: FileText, color: "text-purple-600", bgColor: "bg-purple-100 dark:bg-purple-900/30" },
  official: { label: "공식", icon: Shield, color: "text-green-600", bgColor: "bg-green-100 dark:bg-green-900/30" },
  academic: { label: "학술", icon: GraduationCap, color: "text-indigo-600", bgColor: "bg-indigo-100 dark:bg-indigo-900/30" },
} as const;

interface EvidenceCardProps {
  evidence: Evidence;
  onDrilldown?: (evidence: Evidence) => void;
  drilldownEnabled?: boolean;
}

const EvidenceCard = ({ evidence, onDrilldown, drilldownEnabled = true }: EvidenceCardProps) => {
  const stanceInfo = STANCE_CONFIG[evidence.stance];
  const StanceIcon = stanceInfo.icon;

  return (
    <Card className={`${stanceInfo.bgColor} border-l-4 ${evidence.stance === 'pro' ? 'border-l-teal-500' : evidence.stance === 'con' ? 'border-l-coral-500' : 'border-l-gray-400'}`}>
      <CardContent className="p-4">
        <div className="flex items-start justify-between gap-4">
          <div className="flex-1 min-w-0">
            <div className="flex items-center gap-2 mb-2 flex-wrap">
              <Badge variant="outline" className={`${stanceInfo.color} flex items-center gap-1`}>
                <StanceIcon className="h-3 w-3" />
                {stanceInfo.label}
              </Badge>
              {evidence.sourceCategory && SOURCE_CATEGORY_CONFIG[evidence.sourceCategory] && (
                <Badge variant="secondary" className={`${SOURCE_CATEGORY_CONFIG[evidence.sourceCategory].color} flex items-center gap-1`}>
                  {(() => { const Icon = SOURCE_CATEGORY_CONFIG[evidence.sourceCategory].icon; return <Icon className="h-3 w-3" />; })()}
                  {SOURCE_CATEGORY_CONFIG[evidence.sourceCategory].label}
                </Badge>
              )}
              {evidence.source && (
                <span className="text-xs text-muted-foreground truncate">{evidence.source}</span>
              )}
            </div>
            {evidence.title && (
              <h4 className="font-semibold text-sm mb-1 line-clamp-2">{evidence.title}</h4>
            )}
            <p className="text-sm text-muted-foreground line-clamp-3">{evidence.snippet}</p>
          </div>
          <div className="flex flex-col gap-1">
            <a
              href={evidence.url}
              target="_blank"
              rel="noopener noreferrer"
              className="shrink-0 p-2 rounded-md hover:bg-muted transition-colors"
              title="원문 보기"
            >
              <ExternalLink className="h-4 w-4" />
            </a>
            {drilldownEnabled && onDrilldown && (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <button
                      onClick={() => onDrilldown(evidence)}
                      className="shrink-0 p-2 rounded-md hover:bg-primary/10 transition-colors text-primary"
                      title="심층 조사"
                    >
                      <ArrowDownRight className="h-4 w-4" />
                    </button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>이 주제로 심층 조사</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

interface StanceChartProps {
  distribution: DeepSearchResult["stanceDistribution"];
}

const StanceChart = ({ distribution }: StanceChartProps) => {
  const total = distribution.pro + distribution.con + distribution.neutral;
  if (total === 0) return null;

  return (
    <Card className="glass">
      <CardHeader className="pb-2">
        <CardTitle className="text-lg">관점 분석</CardTitle>
        <CardDescription>수집된 자료의 관점 분포</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="flex gap-1 h-8 rounded-lg overflow-hidden">
          {distribution.proRatio > 0 && (
            <div
              className="bg-teal-500 flex items-center justify-center text-white text-xs font-medium transition-all"
              style={{ width: `${distribution.proRatio}%` }}
            >
              {distribution.proRatio >= 10 && `${distribution.proRatio.toFixed(0)}%`}
            </div>
          )}
          {distribution.neutralRatio > 0 && (
            <div
              className="bg-gray-400 flex items-center justify-center text-white text-xs font-medium transition-all"
              style={{ width: `${distribution.neutralRatio}%` }}
            >
              {distribution.neutralRatio >= 10 && `${distribution.neutralRatio.toFixed(0)}%`}
            </div>
          )}
          {distribution.conRatio > 0 && (
            <div
              className="bg-coral-500 flex items-center justify-center text-white text-xs font-medium transition-all"
              style={{ width: `${distribution.conRatio}%` }}
            >
              {distribution.conRatio >= 10 && `${distribution.conRatio.toFixed(0)}%`}
            </div>
          )}
        </div>
        <div className="grid grid-cols-3 gap-4 text-center">
          <div>
            <div className="flex items-center justify-center gap-1 text-teal-600 mb-1">
              <ThumbsUp className="h-4 w-4" />
              <span className="font-bold">{distribution.pro}</span>
            </div>
            <span className="text-xs text-muted-foreground">찬성</span>
          </div>
          <div>
            <div className="flex items-center justify-center gap-1 text-gray-600 mb-1">
              <Minus className="h-4 w-4" />
              <span className="font-bold">{distribution.neutral}</span>
            </div>
            <span className="text-xs text-muted-foreground">중립</span>
          </div>
          <div>
            <div className="flex items-center justify-center gap-1 text-coral-600 mb-1">
              <ThumbsDown className="h-4 w-4" />
              <span className="font-bold">{distribution.con}</span>
            </div>
            <span className="text-xs text-muted-foreground">반대</span>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

const isTerminalStatus = (status: string) => 
  ['COMPLETED', 'FAILED', 'CANCELLED', 'TIMEOUT'].includes(status);

// Drilldown history item
interface DrilldownHistoryItem {
  jobId: string;
  topic: string;
  parentJobId?: string;
  depth: number;
  createdAt: string;
}

const DeepSearch = () => {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const location = useLocation();
  const [searchParams, setSearchParams] = useSearchParams();
  const { getTask } = useBackgroundTasks();
  const { saveDeepSearch, saveFailedSearch } = useAutoSaveSearch();
  
  // Load priority URLs and context from parent search record (if navigating from SearchHistory)
  const { 
    priorityUrls: parentPriorityUrls, 
    parentQuery,
    parentSearchId,
    depthLevel: parentDepthLevel,
    isFromHistory: isFromParentSearch,
    loading: parentLoading,
  } = useSearchRecordFromState(location.state);
  
  // Track search start time for duration calculation
  const [searchStartTime, setSearchStartTime] = useState<number | null>(null);
  
  const [topic, setTopic] = useState("");
  const [baseUrl, setBaseUrl] = useState("");
  const [currentJobId, setCurrentJobId] = useState<string | null>(null);
  const [activeStance, setActiveStance] = useState<"all" | "pro" | "con" | "neutral">("all");
  const [viewMode, setViewMode] = useState<"insight" | "list">("insight");
  
  // Priority URLs state
  const [priorityUrls, setPriorityUrls] = useState<PriorityUrl[]>([]);
  
  // Drilldown state
  const [drilldownHistory, setDrilldownHistory] = useState<DrilldownHistoryItem[]>([]);
  const [currentDepth, setCurrentDepth] = useState(0);
  const [drilldownDialogOpen, setDrilldownDialogOpen] = useState(false);
  const [selectedEvidence, setSelectedEvidence] = useState<Evidence | null>(null);
  const [focusAspect, setFocusAspect] = useState("");
  const [showHistory, setShowHistory] = useState(false);

  // Load jobId from URL params or background task
  useEffect(() => {
    const jobIdFromUrl = searchParams.get('jobId');
    if (jobIdFromUrl && jobIdFromUrl !== currentJobId) {
      setCurrentJobId(jobIdFromUrl);
    }
  }, [searchParams, currentJobId]);

  // Load query from location state (e.g., from Search History page)
  useEffect(() => {
    const locationState = location.state as { 
      query?: string; 
      fromHistory?: boolean; 
      historyId?: number;
      parentSearchId?: number;
      deriveFrom?: number;
    } | null;
    
    if (locationState?.query && !currentJobId) {
      setTopic(locationState.query);
      
      if (locationState.fromHistory) {
        toast({
          title: "검색 기록에서 연결됨",
          description: `"${locationState.query}" 주제로 Deep Search를 시작할 수 있습니다.`,
        });
        // Clear the location state to prevent showing toast again
        window.history.replaceState({}, document.title);
      }
      
      if (locationState.deriveFrom) {
        setCurrentDepth(1);
        toast({
          title: "파생 검색",
          description: "이전 검색에서 파생된 심층 검색을 시작합니다.",
        });
        // Clear the location state
        window.history.replaceState({}, document.title);
      }
    }
  }, [location.state, currentJobId, toast]);
  
  // Load priority URLs from sessionStorage on mount
  useEffect(() => {
    const stored = sessionStorage.getItem(DEEPSEARCH_PRIORITY_URLS_KEY);
    if (stored) {
      try {
        const parsed = JSON.parse(stored) as PriorityUrl[];
        setPriorityUrls(parsed);
      } catch {
        // Ignore parse errors
      }
    }
  }, []);
  
  // Load context from parent search record (when navigating from SearchHistory with derive context)
  useEffect(() => {
    if (!parentLoading && isFromParentSearch && !currentJobId) {
      // Set topic from parent query if not already set
      if (parentQuery && !topic) {
        setTopic(parentQuery);
      }
      
      // Merge parent priority URLs with existing ones
      if (parentPriorityUrls.length > 0) {
        setPriorityUrls((prev) => {
          const existingUrls = new Set(prev.map((p) => p.url));
          const newUrls = parentPriorityUrls
            .filter((p) => !existingUrls.has(p.url))
            .map((p): PriorityUrl => ({
              id: p.id,
              url: p.url,
              name: p.name,
              reliability: p.reliability,
            }));
          
          if (newUrls.length === 0) return prev;
          
          const merged = [...prev, ...newUrls];
          sessionStorage.setItem(DEEPSEARCH_PRIORITY_URLS_KEY, JSON.stringify(merged));
          return merged;
        });
        
        // Use first priority URL as base URL for starting the search
        if (!baseUrl) {
          const firstUrl = parentPriorityUrls[0]?.url;
          if (firstUrl) {
            setBaseUrl(firstUrl);
          }
        }
      }
      
      // Set initial depth from parent
      if (parentDepthLevel > 0) {
        setCurrentDepth(parentDepthLevel);
      }
      
      toast({
        title: "이전 검색에서 연결됨",
        description: `${parentPriorityUrls.length}개의 참고 URL이 있는 파생 검색입니다.`,
      });
    }
  }, [parentLoading, isFromParentSearch, parentQuery, parentPriorityUrls, parentDepthLevel, currentJobId, topic, baseUrl, toast]);

  // Load query from URL params (e.g., from FactCheck page)
  useEffect(() => {
    const queryFromUrl = searchParams.get('q');
    const fromFactCheck = searchParams.get('fromFactCheck') === 'true';
    
    if (queryFromUrl && !currentJobId) {
      setTopic(queryFromUrl);
      
      // Show toast if coming from FactCheck
      if (fromFactCheck) {
        toast({
          title: "팩트체크에서 연결됨",
          description: "해당 주제에 대해 Deep Search를 시작할 수 있습니다.",
        });
        // Clear the fromFactCheck param to prevent showing toast again
        const newParams = new URLSearchParams(searchParams);
        newParams.delete('fromFactCheck');
        setSearchParams(newParams, { replace: true });
      }
      
      // Handle fromAgent parameter
      const fromAgent = searchParams.get('fromAgent') === 'true';
      if (fromAgent) {
        toast({
          title: "Browser Agent에서 연결됨",
          description: "추출된 데이터에 대해 Deep Search를 시작할 수 있습니다.",
        });
        // Clear the fromAgent param to prevent showing toast again
        const newParams = new URLSearchParams(searchParams);
        newParams.delete('fromAgent');
        setSearchParams(newParams, { replace: true });
      }
    }
  }, [searchParams, currentJobId, setSearchParams, toast]);

  // React Query: 서비스 헬스 체크
  const { data: healthData } = useQuery({
    queryKey: ['deepSearch', 'health'],
    queryFn: checkDeepSearchHealth,
    staleTime: 60_000,
    retry: 1,
  });

  const isHealthy = healthData?.enabled ?? null;

  // SSE connection for real-time updates
  const sseEnabled = !!currentJobId;

  const {
    status: sseStatus,
    currentStatus,
    progress,
    progressMessage,
    evidenceCount,
    result: sseResult,
    error: sseError,
  } = useDeepSearchSSE({
    jobId: currentJobId,
    topic,
    enabled: sseEnabled,
    autoAddToBackground: true,
    onComplete: (result) => {
      queryClient.setQueryData(['deepSearch', 'result', currentJobId], result);
      toast({
        title: "분석 완료",
        description: `${result.evidence.length}개의 증거를 수집했습니다.`,
      });
      
      // Auto-save search results
      const durationMs = searchStartTime ? Date.now() - searchStartTime : undefined;
      saveDeepSearch(
        result.jobId,
        result.topic,
        result.evidence as Array<Record<string, unknown>>,
        result.stanceDistribution as Record<string, unknown>,
        durationMs,
        drilldownHistory.length > 0 ? undefined : undefined, // Will be set if this is a drilldown
      );
    },
    onError: (error) => {
      toast({
        title: "분석 실패",
        description: error,
        variant: "destructive",
      });
      
      // Auto-save failed search
      const durationMs = searchStartTime ? Date.now() - searchStartTime : undefined;
      saveFailedSearch('DEEP_SEARCH', topic, error, durationMs);
    },
  });

  // Fallback: Get job status if we have jobId but no SSE connection yet
  // This must be defined BEFORE the result fetch query so we can use fetchedJob in the enabled condition
  const { data: fetchedJob } = useQuery({
    queryKey: ['deepSearch', 'job', currentJobId],
    queryFn: () => getDeepSearchStatus(currentJobId!),
    enabled: !!currentJobId && sseStatus === 'disconnected',
    staleTime: 5000,
  });

  // Compute jobStatus early so it can be used in the result fetch condition
  const jobStatus = currentStatus || fetchedJob?.status;

  // Fallback: Fetch result if we have jobId but no SSE result (e.g., page refresh or returning from background task)
  // Use jobStatus instead of currentStatus to include the fallback from fetchedJob
  const { data: fetchedResult } = useQuery({
    queryKey: ['deepSearch', 'result', currentJobId],
    queryFn: () => getDeepSearchResult(currentJobId!),
    enabled: !!currentJobId && !sseResult,
    staleTime: Infinity,
    retry: 2,
  });

  const result = sseResult || fetchedResult;

  // React Query: 검색 시작 Mutation
  const startMutation = useMutation({
    mutationFn: startDeepSearch,
    onSuccess: (job) => {
      setCurrentJobId(job.jobId);
      setSearchParams({ jobId: job.jobId });
      setSearchStartTime(Date.now()); // Track start time
      toast({
        title: "분석 시작",
        description: "Deep AI Search를 시작했습니다. 백그라운드에서 계속 실행됩니다.",
      });
    },
    onError: (error: any) => {
      toast({
        title: "오류",
        description: error.response?.data?.message || error.message || "분석 시작에 실패했습니다.",
        variant: "destructive",
      });
    },
  });

  // React Query: 취소 Mutation
  const cancelMutation = useMutation({
    mutationFn: () => cancelDeepSearch(currentJobId!),
    onSuccess: () => {
      toast({
        title: "취소됨",
        description: "분석이 취소되었습니다.",
      });
    },
    onError: () => {
      toast({
        title: "오류",
        description: "취소에 실패했습니다.",
        variant: "destructive",
      });
    },
  });

  // React Query: 드릴다운 검색 Mutation
  const drilldownMutation = useMutation({
    mutationFn: startDrilldownSearch,
    onSuccess: (job) => {
      // 현재 결과를 히스토리에 저장
      if (result) {
        setDrilldownHistory(prev => [...prev, {
          jobId: currentJobId!,
          topic: result.topic,
          parentJobId: undefined,
          depth: currentDepth,
          createdAt: new Date().toISOString(),
        }]);
      }
      
      setCurrentJobId(job.jobId);
      setCurrentDepth(prev => prev + 1);
      setSearchParams({ jobId: job.jobId });
      setDrilldownDialogOpen(false);
      setSelectedEvidence(null);
      setFocusAspect("");
      
      toast({
        title: "심층 조사 시작",
        description: `'${selectedEvidence?.title || '선택한 증거'}'에 대한 심층 분석을 시작합니다.`,
      });
    },
    onError: (error: any) => {
      toast({
        title: "오류",
        description: error.response?.data?.message || error.message || "심층 조사 시작에 실패했습니다.",
        variant: "destructive",
      });
    },
  });

  const handleSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    if (!topic.trim() || startMutation.isPending) return;

    // 이전 결과 초기화
    setCurrentJobId(null);
    setSearchParams({});
    queryClient.removeQueries({ queryKey: ['deepSearch', 'job'] });
    queryClient.removeQueries({ queryKey: ['deepSearch', 'result'] });

    startMutation.mutate({
      topic: topic.trim(),
      baseUrl: baseUrl.trim() || undefined,
    });
  }, [topic, baseUrl, startMutation, queryClient, setSearchParams]);

  const handleCancel = useCallback(() => {
    if (!currentJobId) return;
    cancelMutation.mutate();
  }, [currentJobId, cancelMutation]);

  const handleReset = useCallback(() => {
    setCurrentJobId(null);
    setTopic("");
    setBaseUrl("");
    setActiveStance("all");
    setSearchParams({});
    setDrilldownHistory([]);
    setCurrentDepth(0);
    setPriorityUrls([]);
    sessionStorage.removeItem(DEEPSEARCH_PRIORITY_URLS_KEY);
    queryClient.removeQueries({ queryKey: ['deepSearch', 'job'] });
    queryClient.removeQueries({ queryKey: ['deepSearch', 'result'] });
  }, [queryClient, setSearchParams]);

  // Handler for PriorityUrlEditor changes
  const handlePriorityUrlsChange = useCallback((newUrls: PriorityUrl[]) => {
    setPriorityUrls(newUrls);
    // If a URL is added and no baseUrl is set, use the first URL as baseUrl
    if (newUrls.length > 0 && !baseUrl) {
      setBaseUrl(newUrls[0].url);
    }
  }, [baseUrl]);

  // 드릴다운 핸들러
  const handleDrilldown = useCallback((evidence: Evidence) => {
    setSelectedEvidence(evidence);
    setDrilldownDialogOpen(true);
  }, []);

  // 드릴다운 실행
  const executeDrilldown = useCallback(() => {
    if (!selectedEvidence || !result) return;
    
    drilldownMutation.mutate({
      parentTopic: result.topic,
      parentJobId: currentJobId || undefined,
      evidence: {
        url: selectedEvidence.url,
        title: selectedEvidence.title,
        snippet: selectedEvidence.snippet,
        stance: selectedEvidence.stance,
      },
      focusAspect: focusAspect.trim() || undefined,
      depth: currentDepth,
    });
  }, [selectedEvidence, result, currentJobId, focusAspect, currentDepth, drilldownMutation]);

  // 히스토리에서 이전 결과로 이동
  const navigateToHistory = useCallback((item: DrilldownHistoryItem) => {
    setCurrentJobId(item.jobId);
    setCurrentDepth(item.depth);
    setSearchParams({ jobId: item.jobId });
    setTopic(item.topic);
    
    // 현재 항목 이후의 히스토리 제거
    setDrilldownHistory(prev => {
      const index = prev.findIndex(h => h.jobId === item.jobId);
      return prev.slice(0, index);
    });
    
    toast({
      title: "이전 분석으로 이동",
      description: `'${item.topic}' 분석 결과를 불러옵니다.`,
    });
  }, [setSearchParams, toast]);

  const filteredEvidence = result?.evidence.filter(
    (e) => activeStance === "all" || e.stance === activeStance
  ) ?? [];

  const isProcessing = currentJobId && 
    (jobStatus === "PENDING" || jobStatus === "IN_PROGRESS");

  const connectionStatusBadge = () => {
    if (!currentJobId || isTerminalStatus(jobStatus || '')) return null;
    
    switch (sseStatus) {
      case 'connected':
        return (
          <Badge variant="secondary" className="text-green-600">
            <Wifi className="h-3 w-3 mr-1" />
            실시간 연결됨
          </Badge>
        );
      case 'connecting':
        return (
          <Badge variant="secondary" className="animate-pulse">
            <Loader2 className="h-3 w-3 mr-1 animate-spin" />
            연결 중...
          </Badge>
        );
      case 'error':
        return (
          <Badge variant="secondary" className="text-orange-600">
            <WifiOff className="h-3 w-3 mr-1" />
            재연결 시도 중
          </Badge>
        );
      default:
        return null;
    }
  };

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-5xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to="/"
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            메인으로 돌아가기
          </Link>
          <div className="flex items-center justify-between flex-wrap gap-4">
            <div>
              <div className="flex items-center gap-2 mb-2">
                <h1 className="text-3xl md:text-4xl font-bold bg-gradient-to-r from-primary to-accent bg-clip-text text-transparent">
                  Deep AI Search
                </h1>
                {currentDepth > 0 && (
                  <Badge variant="secondary" className="flex items-center gap-1">
                    <Layers className="h-3 w-3" />
                    깊이 {currentDepth}
                  </Badge>
                )}
              </div>
              <p className="text-muted-foreground">
                AI 기반 심층 분석으로 주제에 대한 다양한 입장과 증거를 수집합니다.
              </p>
            </div>
            <div className="flex items-center gap-2">
              {connectionStatusBadge()}
              {drilldownHistory.length > 0 && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setShowHistory(!showHistory)}
                  className="gap-1"
                >
                  <History className="h-4 w-4" />
                  분석 기록
                  <Badge variant="secondary" className="ml-1 h-5 min-w-5 px-1">
                    {drilldownHistory.length}
                  </Badge>
                </Button>
              )}
            </div>
          </div>
          {isHealthy === false && (
            <div className="mt-4 p-3 rounded-md bg-destructive/10 text-destructive text-sm flex items-center gap-2">
              <AlertCircle className="h-4 w-4" />
              Deep Search 서비스가 현재 사용 불가능합니다.
            </div>
          )}
        </header>

        {/* Drilldown History Breadcrumb */}
        {drilldownHistory.length > 0 && showHistory && (
          <Card className="mb-6 border-primary/20 bg-primary/5">
            <CardContent className="py-4">
              <div className="flex items-center gap-2 text-sm overflow-x-auto">
                <span className="text-muted-foreground shrink-0">분석 경로:</span>
                {drilldownHistory.map((item, index) => (
                  <div key={item.jobId} className="flex items-center shrink-0">
                    <button
                      onClick={() => navigateToHistory(item)}
                      className="px-2 py-1 rounded hover:bg-primary/10 transition-colors text-primary underline-offset-2 hover:underline"
                    >
                      {item.topic.length > 30 ? `${item.topic.substring(0, 30)}...` : item.topic}
                    </button>
                    <ChevronRight className="h-4 w-4 text-muted-foreground mx-1" />
                  </div>
                ))}
                <Badge variant="default" className="shrink-0">
                  현재: {result?.topic || topic || '새 분석'}
                </Badge>
              </div>
            </CardContent>
          </Card>
        )}

        {/* Drilldown Dialog */}
        <Dialog open={drilldownDialogOpen} onOpenChange={setDrilldownDialogOpen}>
          <DialogContent className="sm:max-w-[500px]">
            <DialogHeader>
              <DialogTitle className="flex items-center gap-2">
                <ArrowDownRight className="h-5 w-5 text-primary" />
                심층 조사
              </DialogTitle>
              <DialogDescription>
                선택한 증거를 기반으로 더 깊이 파고드는 분석을 시작합니다.
              </DialogDescription>
            </DialogHeader>
            {selectedEvidence && (
              <div className="space-y-4 py-4">
                <div className="p-3 rounded-lg bg-muted">
                  <p className="text-sm font-medium mb-1">{selectedEvidence.title || '제목 없음'}</p>
                  <p className="text-xs text-muted-foreground line-clamp-2">{selectedEvidence.snippet}</p>
                </div>
                <div>
                  <label className="block text-sm font-medium mb-2">
                    집중 분석할 측면 (선택사항)
                  </label>
                  <Input
                    value={focusAspect}
                    onChange={(e) => setFocusAspect(e.target.value)}
                    placeholder="예: 경제적 영향, 환경적 측면, 사회적 논쟁 등"
                  />
                  <p className="text-xs text-muted-foreground mt-1">
                    비워두면 증거의 제목/내용을 기반으로 분석합니다.
                  </p>
                </div>
              </div>
            )}
            <DialogFooter>
              <Button variant="outline" onClick={() => setDrilldownDialogOpen(false)}>
                취소
              </Button>
              <Button 
                onClick={executeDrilldown}
                disabled={drilldownMutation.isPending}
              >
                {drilldownMutation.isPending ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    시작 중...
                  </>
                ) : (
                  <>
                    <ArrowDownRight className="h-4 w-4 mr-2" />
                    심층 조사 시작
                  </>
                )}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

        {/* Search Form */}
        <Card className="mb-8">
          <CardContent className="pt-6">
            <form onSubmit={handleSubmit} className="space-y-4">
              <div>
                <label htmlFor="topic" className="block text-sm font-medium mb-2">
                  분석 주제 *
                </label>
                <Input
                  id="topic"
                  value={topic}
                  onChange={(e) => setTopic(e.target.value)}
                  placeholder="예: 원자력 발전의 장단점"
                  disabled={isProcessing || isHealthy === false}
                  className="text-lg"
                />
              </div>
              <div>
                <label htmlFor="baseUrl" className="block text-sm font-medium mb-2">
                  검색 시작 URL (선택)
                </label>
                <Input
                  id="baseUrl"
                  value={baseUrl}
                  onChange={(e) => setBaseUrl(e.target.value)}
                  placeholder="https://example.com"
                  disabled={isProcessing || isHealthy === false}
                />
                <p className="text-xs text-muted-foreground mt-1">
                  특정 사이트에서 시작하여 검색하려면 URL을 입력하세요.
                </p>
              </div>
              <div className="flex gap-3">
                <Button
                  type="submit"
                  disabled={!topic.trim() || isProcessing || isHealthy === false || startMutation.isPending}
                  className="flex-1"
                >
                  {startMutation.isPending ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      시작 중...
                    </>
                  ) : (
                    <>
                      <Search className="h-4 w-4 mr-2" />
                      분석 시작
                    </>
                  )}
                </Button>
                {(currentJobId || result) && (
                  <Button type="button" variant="outline" onClick={handleReset}>
                    <RefreshCw className="h-4 w-4 mr-2" />
                    초기화
                  </Button>
                )}
              </div>
            </form>
          </CardContent>
        </Card>

        {/* Priority URLs Editor */}
        <PriorityUrlEditor
          storageKey={DEEPSEARCH_PRIORITY_URLS_KEY}
          urls={priorityUrls}
          onUrlsChange={handlePriorityUrlsChange}
          disabled={isProcessing}
          maxUrls={10}
          title="참고 URL"
          description="분석 시 우선적으로 참고할 URL을 추가하세요. 첫 번째 URL이 검색 시작점으로 사용됩니다."
          defaultCollapsed={priorityUrls.length === 0}
          className="mb-8"
        />

        {/* Processing Status */}
        {isProcessing && (
          <Card className="mb-8">
            <CardContent className="py-6">
              <AnalysisProgressTimeline
                currentStep={
                  jobStatus === "PENDING" ? "queued" :
                  progress < 20 ? "initializing" :
                  progress < 40 ? "searching" :
                  progress < 60 ? "collecting" :
                  progress < 80 ? "analyzing" :
                  progress < 95 ? "classifying" :
                  "summarizing"
                }
                overallProgress={progress || (jobStatus === "PENDING" ? 5 : 25)}
                message={progressMessage}
                collectedCount={evidenceCount}
                topic={topic}
              />
              <div className="flex justify-center mt-6">
                <Button 
                  variant="outline" 
                  size="sm" 
                  onClick={handleCancel}
                  disabled={cancelMutation.isPending}
                >
                  <Trash2 className="h-4 w-4 mr-2" />
                  {cancelMutation.isPending ? "취소 중..." : "분석 취소"}
                </Button>
              </div>
            </CardContent>
          </Card>
        )}

        {/* Error/Cancelled State */}
        {currentJobId && (jobStatus === "FAILED" || jobStatus === "CANCELLED" || jobStatus === "TIMEOUT") && !result && (
          <Card className="mb-8">
            <CardContent className="py-8">
              <div className="text-center space-y-4">
                {jobStatus === "FAILED" ? (
                  <XCircle className="h-12 w-12 mx-auto text-destructive" />
                ) : jobStatus === "TIMEOUT" ? (
                  <AlertCircle className="h-12 w-12 mx-auto text-orange-500" />
                ) : (
                  <XCircle className="h-12 w-12 mx-auto text-muted-foreground" />
                )}
                <div>
                  <h3 className="font-semibold text-lg">
                    {STATUS_CONFIG[jobStatus as keyof typeof STATUS_CONFIG]?.label || jobStatus}
                  </h3>
                  <p className="text-sm text-muted-foreground">
                    {sseError || "분석이 완료되지 않았습니다."}
                  </p>
                </div>
                <Button variant="outline" onClick={handleReset}>
                  <RefreshCw className="h-4 w-4 mr-2" />
                  다시 시도
                </Button>
              </div>
            </CardContent>
          </Card>
        )}

        {/* Results */}
        {result && (
          <div className="space-y-6">
            {/* View Mode Toggle */}
            <div className="flex items-center justify-between flex-wrap gap-2">
              <h2 className="text-xl font-semibold">분석 결과</h2>
              <div className="flex items-center gap-2">
                <ReportExportButton
                  jobId={result.jobId}
                  query={result.topic}
                  reportType="DEEP_SEARCH"
                  variant="default"
                  size="sm"
                  disabled={result.evidence.length === 0}
                />
                <ExportButton
                  data={result.evidence.map(e => ({
                    id: e.id,
                    title: e.title,
                    snippet: e.snippet,
                    url: e.url,
                    source: e.source,
                    stance: e.stance,
                    stanceLabel: e.stance === 'pro' ? '찬성' : e.stance === 'con' ? '반대' : '중립',
                  }))}
                  options={{
                    filename: `newsinsight-deepsearch-${result.topic.replace(/\s+/g, '-')}`,
                    title: `"${result.topic}" Deep Search 결과`,
                    metadata: {
                      주제: result.topic,
                      분석완료: result.completedAt ? new Date(result.completedAt).toLocaleString("ko-KR") : "-",
                      총증거: result.evidence.length,
                      '찬성 증거': result.stanceDistribution.pro,
                      '반대 증거': result.stanceDistribution.con,
                      '중립 증거': result.stanceDistribution.neutral,
                      '찬성 비율': `${result.stanceDistribution.proRatio.toFixed(1)}%`,
                      '반대 비율': `${result.stanceDistribution.conRatio.toFixed(1)}%`,
                      '중립 비율': `${result.stanceDistribution.neutralRatio.toFixed(1)}%`,
                      jobId: result.jobId,
                    },
                    sections: [
                      {
                        title: '입장 분포 요약',
                        content: `총 ${result.evidence.length}개의 증거 중:\n` +
                          `- 찬성: ${result.stanceDistribution.pro}건 (${result.stanceDistribution.proRatio.toFixed(1)}%)\n` +
                          `- 반대: ${result.stanceDistribution.con}건 (${result.stanceDistribution.conRatio.toFixed(1)}%)\n` +
                          `- 중립: ${result.stanceDistribution.neutral}건 (${result.stanceDistribution.neutralRatio.toFixed(1)}%)`,
                      },
                    ],
                  }}
                  size="sm"
                  disabled={result.evidence.length === 0}
                />
                <div className="flex items-center gap-2 p-1 rounded-lg bg-muted">
                  <Button
                    variant={viewMode === "insight" ? "default" : "ghost"}
                    size="sm"
                    onClick={() => setViewMode("insight")}
                    className="gap-2"
                  >
                    <LayoutGrid className="h-4 w-4" />
                    <span className="hidden sm:inline">인사이트 뷰</span>
                  </Button>
                  <Button
                    variant={viewMode === "list" ? "default" : "ghost"}
                    size="sm"
                    onClick={() => setViewMode("list")}
                    className="gap-2"
                  >
                    <List className="h-4 w-4" />
                    <span className="hidden sm:inline">상세 목록</span>
                  </Button>
                </div>
              </div>
            </div>

            {/* Insight Flow View (Card Carousel) */}
            {viewMode === "insight" && (
              <InsightFlow
                result={result}
                onShare={() => {
                  navigator.clipboard.writeText(window.location.href);
                  toast({
                    title: "링크 복사됨",
                    description: "분석 결과 링크가 클립보드에 복사되었습니다.",
                  });
                }}
                onDownload={() => {
                  toast({
                    title: "준비 중",
                    description: "이미지 다운로드 기능은 곧 제공될 예정입니다.",
                  });
                }}
              />
            )}

            {/* List View (Original) */}
            {viewMode === "list" && (
              <>
                {/* 분석 개요 */}
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                  <Card className="glass">
                    <CardContent className="pt-6">
                      <div className="text-center">
                        <p className="text-3xl font-bold">{result.evidence.length}</p>
                        <p className="text-sm text-muted-foreground">총 수집 자료</p>
                      </div>
                    </CardContent>
                  </Card>
                  <Card className="glass">
                    <CardContent className="pt-6">
                      <div className="text-center">
                        <p className="text-3xl font-bold text-green-600">
                          {new Set(result.evidence.map(e => e.source).filter(Boolean)).size}
                        </p>
                        <p className="text-sm text-muted-foreground">참조 출처</p>
                      </div>
                    </CardContent>
                  </Card>
                  <Card className="glass">
                    <CardContent className="pt-6">
                      <div className="text-center">
                        <p className="text-3xl font-bold text-blue-600">
                          {result.evidence.filter(e => e.title).length}
                        </p>
                        <p className="text-sm text-muted-foreground">기사/문서</p>
                      </div>
                    </CardContent>
                  </Card>
                </div>

                {/* 관점 분석 (선택적) */}
                <StanceChart distribution={result.stanceDistribution} />

                {/* 수집된 자료 목록 */}
                <Card>
                  <CardHeader>
                    <CardTitle>수집된 자료</CardTitle>
                    <CardDescription>
                      '{result.topic}'에 대해 수집된 관련 자료입니다.
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <Tabs value={activeStance} onValueChange={(v) => setActiveStance(v as typeof activeStance)}>
                      <TabsList className="mb-4">
                        <TabsTrigger value="all">
                          전체 ({result.evidence.length})
                        </TabsTrigger>
                        <TabsTrigger value="pro" className="text-teal-600">
                          긍정 ({result.stanceDistribution.pro})
                        </TabsTrigger>
                        <TabsTrigger value="neutral">
                          중립 ({result.stanceDistribution.neutral})
                        </TabsTrigger>
                        <TabsTrigger value="con" className="text-coral-600">
                          부정 ({result.stanceDistribution.con})
                        </TabsTrigger>
                      </TabsList>
                      <TabsContent value={activeStance} className="space-y-4">
                        {filteredEvidence.length > 0 ? (
                          filteredEvidence.map((evidence) => (
                            <EvidenceCard 
                              key={evidence.id} 
                              evidence={evidence}
                              onDrilldown={handleDrilldown}
                              drilldownEnabled={!isProcessing}
                            />
                          ))
                        ) : (
                          <div className="text-center py-8 text-muted-foreground">
                            해당 관점의 자료가 없습니다.
                          </div>
                        )}
                      </TabsContent>
                    </Tabs>
                  </CardContent>
                </Card>
              </>
            )}

            {/* Meta Info */}
            <div className="text-center text-xs text-muted-foreground">
              분석 완료: {result.completedAt ? new Date(result.completedAt).toLocaleString("ko-KR") : "-"}
              {" | "}
              Job ID: {result.jobId}
            </div>
          </div>
        )}

        {/* Empty State */}
        {!currentJobId && !result && (
          <div className="text-center py-16">
            <div className="inline-block p-4 rounded-full bg-accent/10 mb-4">
              <Search className="h-12 w-12 text-accent" />
            </div>
            <h2 className="text-xl font-semibold mb-2">심층 보고서 생성</h2>
            <p className="text-muted-foreground max-w-md mx-auto mb-4">
              분석하고 싶은 주제를 입력하면 AI가 웹에서 관련 자료를 수집하고 심층 분석 보고서를 생성합니다.
            </p>
            <p className="text-sm text-muted-foreground">
              분석 중에도 다른 페이지를 탐색할 수 있으며, 상단의 작업 인디케이터에서 진행 상황을 확인할 수 있습니다.
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default DeepSearch;

```

---

## frontend/src/pages/FactCheck.tsx

```tsx
import { FactCheckChatbot } from "@/components/FactCheckChatbot";

/**
 * 팩트체크 페이지
 * 
 * 챗봇 인터페이스를 통해 실시간으로 팩트체크를 수행합니다.
 */
export default function FactCheck() {
  return (
    <div className="container mx-auto p-6">
      <FactCheckChatbot />
    </div>
  );
}

```

---

## frontend/src/pages/LiveDashboard.tsx

```tsx
import { useEffect, useState } from "react";
import { LiveNewsTicker } from "@/components/dashboard/LiveNewsTicker";
import { TrendChart } from "@/components/dashboard/TrendChart";
import { Button } from "@/components/ui/button";
import { RefreshCcw, Calendar, LayoutDashboard, Database, Brain, AlertTriangle, Activity, Wifi, WifiOff, Terminal } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { LiveCounter } from "@/components/admin/LiveCounter";
import { LiveStream } from "@/components/admin/LiveStream";
import { CrawlerLogsViewer } from "@/components/admin/CrawlerLogsViewer";
import { useLiveDashboard } from "@/hooks/useDashboardEvents";
import { getCollectionStats, type CollectionStatsDTO } from "@/lib/api/collection";
import { cn } from "@/lib/utils";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

export default function LiveDashboard() {
  const today = new Date().toLocaleDateString('ko-KR', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric', 
    weekday: 'long' 
  });

  // 실시간 대시보드 훅
  const {
    stats,
    previousStats,
    activityLogs,
    eventsStatus,
    statsStatus,
    isConnected,
    reconnectEvents,
    reconnectStats,
    clearLogs,
  } = useLiveDashboard({ maxActivityLogs: 50 });

  // 초기 데이터 로드용 (SSE 연결 전 또는 실패 시 폴백)
  const [fallbackStats, setFallbackStats] = useState<CollectionStatsDTO | null>(null);
  const [isLoadingFallback, setIsLoadingFallback] = useState(false);

  // SSE 연결 실패 시 폴백 데이터 로드
  useEffect(() => {
    if (statsStatus === 'error' || statsStatus === 'disconnected') {
      const loadFallback = async () => {
        setIsLoadingFallback(true);
        try {
          const data = await getCollectionStats();
          setFallbackStats(data);
        } catch (e) {
          console.error('Failed to load fallback stats:', e);
        } finally {
          setIsLoadingFallback(false);
        }
      };
      loadFallback();
    }
  }, [statsStatus]);

  // 표시할 통계 (SSE 우선, 없으면 폴백)
  const displayStats = stats || (fallbackStats ? {
    total: fallbackStats.totalItemsCollected,
    unprocessed: 0,
    processed: fallbackStats.totalItemsCollected,
    todayCount: fallbackStats.itemsCollectedToday,
  } : null);

  const handleReconnect = () => {
    reconnectEvents();
    reconnectStats();
  };

  return (
    <div className="container py-6 space-y-6">
      {/* Header */}
      <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <LayoutDashboard className="h-6 w-6 text-primary" />
            Live Dashboard
          </h1>
          <div className="text-muted-foreground text-sm flex items-center gap-2 mt-1">
            <Calendar className="h-3 w-3" />
            {today}
            <Badge 
              variant="outline" 
              className={cn(
                "ml-2",
                isConnected 
                  ? "bg-green-50 text-green-600 border-green-200 dark:bg-green-950 dark:text-green-400 dark:border-green-800"
                  : "bg-yellow-50 text-yellow-600 border-yellow-200 dark:bg-yellow-950 dark:text-yellow-400 dark:border-yellow-800"
              )}
            >
              {isConnected ? (
                <>
                  <Wifi className="h-3 w-3 mr-1" />
                  실시간 연결됨
                </>
              ) : (
                <>
                  <WifiOff className="h-3 w-3 mr-1" />
                  오프라인
                </>
              )}
            </Badge>
          </div>
        </div>
        <div className="flex gap-2">
          {!isConnected && (
            <Button variant="outline" size="sm" onClick={handleReconnect}>
              <RefreshCcw className="h-4 w-4 mr-2" />
              재연결
            </Button>
          )}
          <Button variant="outline" size="sm" onClick={() => window.location.reload()}>
            <RefreshCcw className="h-4 w-4 mr-2" />
            새로고침
          </Button>
        </div>
      </div>

      {/* Live KPI Cards */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <LiveCounter
          value={displayStats?.total ?? 0}
          previousValue={previousStats?.total}
          label="총 수집 문서"
          icon={<Database className="h-4 w-4" />}
          subtitle={displayStats?.todayCount ? `오늘 +${displayStats.todayCount}` : undefined}
          isLoading={!displayStats && isLoadingFallback}
        />
        <LiveCounter
          value={displayStats?.processed ?? 0}
          previousValue={previousStats?.processed}
          label="처리 완료"
          icon={<Brain className="h-4 w-4" />}
          subtitle="AI 분석 완료"
          isLoading={!displayStats && isLoadingFallback}
        />
        <LiveCounter
          value={displayStats?.unprocessed ?? 0}
          previousValue={previousStats?.unprocessed}
          label="대기 중"
          icon={<Activity className="h-4 w-4" />}
          subtitle="분석 대기열"
          isLoading={!displayStats && isLoadingFallback}
        />
        <LiveCounter
          value={displayStats?.errorCount ?? 0}
          previousValue={previousStats?.errorCount}
          label="오류"
          icon={<AlertTriangle className="h-4 w-4" />}
          subtitle="처리 실패"
          showChange={true}
          isLoading={!displayStats && isLoadingFallback}
        />
      </div>

      {/* Main Content Grid */}
      <div className="grid gap-6 lg:grid-cols-7">
        {/* Left Col (News) - span 3 */}
        <div className="lg:col-span-3 h-[500px]">
          <LiveNewsTicker />
        </div>
        
        {/* Middle Col (Trends) - span 2 */}
        <div className="lg:col-span-2 h-[500px]">
          <TrendChart />
        </div>

        {/* Right Col (Live Activity Stream) - span 2 */}
        <div className="lg:col-span-2 h-[500px]">
          <Tabs defaultValue="activity" className="h-full flex flex-col">
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="activity" className="text-xs">
                <Activity className="h-3 w-3 mr-1" />
                실시간 활동
              </TabsTrigger>
              <TabsTrigger value="crawler" className="text-xs">
                <Terminal className="h-3 w-3 mr-1" />
                수집 로그
              </TabsTrigger>
            </TabsList>
            <TabsContent value="activity" className="flex-1 mt-2">
              <LiveStream
                logs={activityLogs}
                status={eventsStatus}
                maxVisible={15}
                title="실시간 활동"
                onClear={clearLogs}
                className="h-full"
              />
            </TabsContent>
            <TabsContent value="crawler" className="flex-1 mt-2">
              <CrawlerLogsViewer
                maxVisible={50}
                className="h-full"
              />
            </TabsContent>
          </Tabs>
        </div>
      </div>

      {/* Full Width Crawler Logs Section */}
      <div className="h-[400px]">
        <CrawlerLogsViewer
          maxVisible={100}
          className="h-full"
        />
      </div>
    </div>
  );
}

```

---

## frontend/src/pages/Login.tsx

```tsx
/**
 * Login - 로그인 페이지
 * 
 * 일반 사용자와 관리자 모두 사용 가능한 통합 로그인 페이지
 */

import { useState, useEffect } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useForm } from 'react-hook-form';
import { Eye, EyeOff, User, Lock, Loader2 } from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { useToast } from '@/components/ui/use-toast';
import { publicAuthApi } from '@/lib/publicAuthApi';
import { useAuth } from '@/contexts/AuthContext';

interface LoginFormData {
  username: string;
  password: string;
}

export default function Login() {
  const navigate = useNavigate();
  const location = useLocation();
  const { toast } = useToast();
  const { isAuthenticated, user, passwordChangeRequired } = useAuth();
  
  const [showPassword, setShowPassword] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>();
  
  // 리다이렉트 대상 URL (로그인 전 방문하려던 페이지)
  const from = (location.state as any)?.from?.pathname || '/';
  
  // 이미 로그인된 경우 처리
  useEffect(() => {
    if (isAuthenticated && user) {
      // 비밀번호 변경이 필요한 경우 (기본 관리자 등)
      if (passwordChangeRequired) {
        navigate('/admin/setup');
      } else if (user.role === 'admin' || user.role === 'operator' || user.role === 'viewer') {
        // 관리자 권한이면 관리자 페이지로
        navigate('/admin/environments');
      } else {
        // 일반 사용자면 원래 목적지 또는 홈으로
        navigate(from, { replace: true });
      }
    }
  }, [isAuthenticated, user, passwordChangeRequired, navigate, from]);
  
  const onSubmit = async (data: LoginFormData) => {
    setIsSubmitting(true);
    
    try {
      // 로그인 API 호출
      const token = await publicAuthApi.login(data.username, data.password);
      
      // 토큰 저장
      localStorage.setItem('access_token', token.access_token);
      document.cookie = `access_token=${token.access_token}; path=/; SameSite=Lax`;
      
      toast({
        title: '로그인 성공',
        description: `환영합니다!`,
      });
      
      // 새로고침하여 AuthContext 초기화
      window.location.href = from;
      
    } catch (error: any) {
      const message = error.response?.data?.detail || '로그인에 실패했습니다. 아이디와 비밀번호를 확인해주세요.';
      toast({
        variant: 'destructive',
        title: '로그인 실패',
        description: message,
      });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-b from-background to-muted/20 px-4 py-8">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1 text-center">
          <div className="flex justify-center mb-4">
            <img 
              src="/initial_logo-v0.1.png" 
              alt="NewsInsight" 
              className="h-12 w-12"
            />
          </div>
          <CardTitle className="text-2xl font-bold">로그인</CardTitle>
          <CardDescription>
            계정에 로그인하여 검색 기록과 분석 결과를 확인하세요
          </CardDescription>
        </CardHeader>
        
        <form onSubmit={handleSubmit(onSubmit)}>
          <CardContent className="space-y-4">
            {/* 사용자명 */}
            <div className="space-y-2">
              <Label htmlFor="username">사용자명</Label>
              <div className="relative">
                <User className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  id="username"
                  placeholder="사용자명 입력"
                  className="pl-10"
                  autoComplete="username"
                  {...register('username', {
                    required: '사용자명을 입력해주세요',
                  })}
                />
              </div>
              {errors.username && (
                <p className="text-sm text-red-500">{errors.username.message}</p>
              )}
            </div>
            
            {/* 비밀번호 */}
            <div className="space-y-2">
              <Label htmlFor="password">비밀번호</Label>
              <div className="relative">
                <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  id="password"
                  type={showPassword ? 'text' : 'password'}
                  placeholder="비밀번호 입력"
                  className="pl-10 pr-10"
                  autoComplete="current-password"
                  {...register('password', {
                    required: '비밀번호를 입력해주세요',
                  })}
                />
                <button
                  type="button"
                  className="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
                  onClick={() => setShowPassword(!showPassword)}
                >
                  {showPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                </button>
              </div>
              {errors.password && (
                <p className="text-sm text-red-500">{errors.password.message}</p>
              )}
            </div>
          </CardContent>
          
          <CardFooter className="flex flex-col gap-4">
            <Button
              type="submit"
              className="w-full"
              disabled={isSubmitting}
            >
              {isSubmitting ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  로그인 중...
                </>
              ) : (
                '로그인'
              )}
            </Button>
            
            <div className="text-center text-sm text-muted-foreground">
              계정이 없으신가요?{' '}
              <Link to="/register" className="text-primary hover:underline font-medium">
                회원가입
              </Link>
            </div>
            
            <div className="text-center text-xs text-muted-foreground">
              로그인 없이{' '}
              <Link to="/" className="text-primary hover:underline">
                익명으로 사용하기
              </Link>
            </div>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
}

```

---

## frontend/src/pages/MLAddons.tsx

```tsx
import React, { useMemo } from 'react';
import { Link } from 'react-router-dom';
import {
  ArrowLeft,
  Cpu,
  Activity,
  RefreshCw,
  CheckCircle2,
  XCircle,
  AlertCircle,
  Loader2,
  MessageSquare,
  Shield,
  Scale,
  Zap,
  Settings,
  TrendingUp,
  Clock,
  BarChart3,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Progress } from '@/components/ui/progress';
import { ScrollArea } from '@/components/ui/scroll-area';
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { useToast } from '@/hooks/use-toast';
import { useMlAddons, useMlAddonStatus, useMlExecutions } from '@/hooks/useMlAddons';
import { getCategoryLabel, getExecutionStatusLabel, getExecutionStatusColor } from '@/lib/api/ml';
import type { MlAddon, AddonCategory, MlAddonExecution } from '@/types/api';

// ============================================
// Category Icon Helper
// ============================================

const getCategoryIcon = (category: AddonCategory) => {
  switch (category) {
    case 'SENTIMENT':
      return <MessageSquare className="h-5 w-5" />;
    case 'FACTCHECK':
      return <Shield className="h-5 w-5" />;
    case 'CONTEXT':
      return <Scale className="h-5 w-5" />;
    case 'TOXICITY':
    case 'MISINFORMATION':
      return <AlertCircle className="h-5 w-5" />;
    case 'SUMMARIZATION':
      return <BarChart3 className="h-5 w-5" />;
    default:
      return <Cpu className="h-5 w-5" />;
  }
};

const getCategoryColor = (category: AddonCategory) => {
  switch (category) {
    case 'SENTIMENT':
      return 'bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-300';
    case 'FACTCHECK':
      return 'bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-300';
    case 'CONTEXT':
      return 'bg-purple-100 text-purple-600 dark:bg-purple-900 dark:text-purple-300';
    case 'TOXICITY':
    case 'MISINFORMATION':
      return 'bg-red-100 text-red-600 dark:bg-red-900 dark:text-red-300';
    case 'SUMMARIZATION':
      return 'bg-amber-100 text-amber-600 dark:bg-amber-900 dark:text-amber-300';
    default:
      return 'bg-gray-100 text-gray-600 dark:bg-gray-900 dark:text-gray-300';
  }
};

// ============================================
// ML Add-on Card Component
// ============================================

interface MLAddonCardProps {
  addon: MlAddon;
  isToggling: boolean;
  onToggle: (addonKey: string) => void;
}

const MLAddonCard: React.FC<MLAddonCardProps> = ({
  addon,
  isToggling,
  onToggle,
}) => {
  const getHealthStatusIcon = () => {
    switch (addon.healthStatus) {
      case 'HEALTHY':
        return <CheckCircle2 className="h-4 w-4 text-green-500" />;
      case 'UNHEALTHY':
        return <XCircle className="h-4 w-4 text-red-500" />;
      case 'DEGRADED':
        return <AlertCircle className="h-4 w-4 text-yellow-500" />;
      default:
        return <AlertCircle className="h-4 w-4 text-muted-foreground" />;
    }
  };

  const getHealthStatusBadge = () => {
    switch (addon.healthStatus) {
      case 'HEALTHY':
        return <Badge className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-100">정상</Badge>;
      case 'UNHEALTHY':
        return <Badge variant="destructive">오프라인</Badge>;
      case 'DEGRADED':
        return <Badge className="bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-100">저하</Badge>;
      default:
        return <Badge variant="outline">미확인</Badge>;
    }
  };

  return (
    <Card className={!addon.enabled ? 'opacity-60' : ''}>
      <CardHeader className="pb-3">
        <div className="flex items-start justify-between">
          <div className="flex items-center gap-3">
            <div className={`p-2 rounded-lg ${getCategoryColor(addon.category)}`}>
              {getCategoryIcon(addon.category)}
            </div>
            <div>
              <CardTitle className="text-base">{addon.name}</CardTitle>
              <CardDescription className="text-xs mt-0.5">
                {getCategoryLabel(addon.category)}
              </CardDescription>
            </div>
          </div>
          <div className="flex items-center gap-2">
            {getHealthStatusIcon()}
            {getHealthStatusBadge()}
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        <p className="text-sm text-muted-foreground">
          {addon.description || '설명 없음'}
        </p>
        
        {/* Metrics */}
        {addon.successRate != null && (
          <div className="space-y-1">
            <div className="flex justify-between text-xs">
              <span>성공률</span>
              <span>{(addon.successRate * 100).toFixed(1)}%</span>
            </div>
            <Progress value={addon.successRate * 100} className="h-1" />
          </div>
        )}

        {addon.avgLatencyMs != null && (
          <div className="flex items-center gap-2 text-xs text-muted-foreground">
            <Clock className="h-3 w-3" />
            <span>평균 응답: {addon.avgLatencyMs.toFixed(0)}ms</span>
          </div>
        )}
        
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Switch
              id={`addon-${addon.addonKey}`}
              checked={addon.enabled}
              onCheckedChange={() => onToggle(addon.addonKey)}
              disabled={isToggling}
            />
            <Label htmlFor={`addon-${addon.addonKey}`} className="text-sm">
              {addon.enabled ? '활성화됨' : '비활성화됨'}
            </Label>
          </div>
          
          {addon.priority != null && (
            <Badge variant="outline" className="text-xs">
              우선순위: {addon.priority}
            </Badge>
          )}
        </div>

        {addon.healthStatus === 'UNHEALTHY' && (
          <Alert variant="destructive" className="py-2">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription className="text-xs">
              서비스에 연결할 수 없습니다. Docker 컨테이너가 실행 중인지 확인하세요.
            </AlertDescription>
          </Alert>
        )}
      </CardContent>
    </Card>
  );
};

// ============================================
// Execution History Item
// ============================================

interface ExecutionItemProps {
  execution: MlAddonExecution;
}

const ExecutionItem: React.FC<ExecutionItemProps> = ({ execution }) => {
  const statusColor = getExecutionStatusColor(execution.status);
  
  return (
    <div className="flex items-center justify-between p-2 rounded border bg-card">
      <div className="flex items-center gap-2">
        <Badge 
          variant="outline" 
          className={`bg-${statusColor}-100 text-${statusColor}-800 dark:bg-${statusColor}-900 dark:text-${statusColor}-100 text-xs`}
        >
          {getExecutionStatusLabel(execution.status)}
        </Badge>
        <span className="text-sm font-medium">{execution.addonKey}</span>
      </div>
      <div className="flex items-center gap-4 text-xs text-muted-foreground">
        {execution.executionTimeMs && (
          <span>{execution.executionTimeMs}ms</span>
        )}
        <span>{new Date(execution.createdAt).toLocaleTimeString('ko-KR')}</span>
      </div>
    </div>
  );
};

// ============================================
// ML Add-ons Page Component
// ============================================

const MLAddons = () => {
  const { toast } = useToast();
  
  // ML Add-ons hooks
  const {
    addons,
    loading: addonsLoading,
    error: addonsError,
    refresh: refreshAddons,
    toggle,
    groupedByCategory,
  } = useMlAddons({ autoRefresh: true, refreshInterval: 30000 });

  const {
    status,
    loading: statusLoading,
    refresh: refreshStatus,
    runHealthCheck,
  } = useMlAddonStatus();

  const {
    executions,
    loading: executionsLoading,
    refresh: refreshExecutions,
  } = useMlExecutions({ size: 10, autoRefresh: true, refreshInterval: 10000 });

  const [isToggling, setIsToggling] = React.useState<string | null>(null);
  const [isRefreshing, setIsRefreshing] = React.useState(false);
  const [isHealthChecking, setIsHealthChecking] = React.useState(false);

  const handleToggle = async (addonKey: string) => {
    setIsToggling(addonKey);
    try {
      await toggle(addonKey);
      const addon = addons.find(a => a.addonKey === addonKey);
      toast({
        title: addon?.enabled ? 'Add-on 비활성화됨' : 'Add-on 활성화됨',
        description: `${addon?.name} Add-on이 ${addon?.enabled ? '비활성화' : '활성화'}되었습니다.`,
      });
    } catch (e) {
      toast({
        title: '상태 변경 실패',
        description: e instanceof Error ? e.message : '알 수 없는 오류',
        variant: 'destructive',
      });
    } finally {
      setIsToggling(null);
    }
  };

  const handleRefreshAll = async () => {
    setIsRefreshing(true);
    try {
      await Promise.all([refreshAddons(), refreshStatus(), refreshExecutions()]);
      toast({ title: '새로고침 완료' });
    } catch (e) {
      toast({
        title: '새로고침 실패',
        variant: 'destructive',
      });
    } finally {
      setIsRefreshing(false);
    }
  };

  const handleHealthCheck = async () => {
    setIsHealthChecking(true);
    try {
      await runHealthCheck();
      toast({ title: '헬스체크 완료', description: '모든 Add-on 상태가 업데이트되었습니다.' });
    } catch (e) {
      toast({
        title: '헬스체크 실패',
        variant: 'destructive',
      });
    } finally {
      setIsHealthChecking(false);
    }
  };

  // Calculate stats
  const healthyCount = addons.filter(a => a.healthStatus === 'HEALTHY').length;
  const enabledCount = addons.filter(a => a.enabled).length;
  const totalCount = addons.length;

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-6xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to="/"
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            검색으로 돌아가기
          </Link>
          <div className="flex items-center justify-between flex-wrap gap-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-primary/10 rounded-lg">
                <Cpu className="h-6 w-6 text-primary" />
              </div>
              <div>
                <h1 className="text-3xl font-bold">ML Add-ons</h1>
                <p className="text-muted-foreground">
                  뉴스 분석을 위한 머신러닝 서비스를 관리합니다.
                </p>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={handleHealthCheck}
                disabled={isHealthChecking}
              >
                {isHealthChecking ? (
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                ) : (
                  <Activity className="h-4 w-4 mr-2" />
                )}
                헬스체크
              </Button>
              <Link to="/settings">
                <Button variant="outline" size="sm">
                  <Settings className="h-4 w-4 mr-2" />
                  전체 설정
                </Button>
              </Link>
            </div>
          </div>
        </header>

        {/* Overview Card */}
        <Card className="mb-6">
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle className="flex items-center gap-2">
                  <Activity className="h-5 w-5" />
                  ML Add-on 상태
                </CardTitle>
                <CardDescription>
                  뉴스 분석에 사용되는 ML Add-on 서비스 상태를 확인하고 관리합니다.
                </CardDescription>
              </div>
              <Button
                variant="outline"
                onClick={handleRefreshAll}
                disabled={isRefreshing}
              >
                <RefreshCw className={`h-4 w-4 mr-2 ${isRefreshing ? 'animate-spin' : ''}`} />
                전체 새로고침
              </Button>
            </div>
          </CardHeader>
          <CardContent>
            <div className="grid gap-4 md:grid-cols-4">
              <div className="flex items-center gap-2">
                <div className={`h-3 w-3 rounded-full ${
                  healthyCount === totalCount ? 'bg-green-500' :
                  healthyCount > 0 ? 'bg-yellow-500' : 'bg-red-500'
                }`} />
                <span className="text-sm font-medium">
                  {healthyCount}/{totalCount} 서비스 정상
                </span>
              </div>
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <Zap className="h-4 w-4" />
                활성화된 Add-on: {enabledCount}개
              </div>
              {status && (
                <>
                  {status.totalExecutionsToday != null && (
                    <div className="flex items-center gap-2 text-sm text-muted-foreground">
                      <TrendingUp className="h-4 w-4" />
                      오늘 실행: {status.totalExecutionsToday.toLocaleString()}회
                    </div>
                  )}
                  {status.successRate != null && (
                    <div className="flex items-center gap-2 text-sm text-muted-foreground">
                      <BarChart3 className="h-4 w-4" />
                      성공률: {status.successRate.toFixed(1)}%
                    </div>
                  )}
                </>
              )}
            </div>
          </CardContent>
        </Card>

        {/* Error Alert */}
        {addonsError && (
          <Alert variant="destructive" className="mb-6">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              Add-on 목록을 불러오는데 실패했습니다: {addonsError.message}
            </AlertDescription>
          </Alert>
        )}

        {/* Loading State */}
        {addonsLoading && addons.length === 0 ? (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
          </div>
        ) : (
          <div className="grid gap-6 lg:grid-cols-3">
            {/* Add-on Cards - 2 columns */}
            <div className="lg:col-span-2">
              <h2 className="text-lg font-semibold mb-4">등록된 Add-on</h2>
              {addons.length === 0 ? (
                <Card className="p-8 text-center text-muted-foreground">
                  등록된 ML Add-on이 없습니다.
                </Card>
              ) : (
                <div className="grid gap-4 md:grid-cols-2">
                  {addons.map((addon) => (
                    <MLAddonCard
                      key={addon.addonKey}
                      addon={addon}
                      isToggling={isToggling === addon.addonKey}
                      onToggle={handleToggle}
                    />
                  ))}
                </div>
              )}
            </div>

            {/* Recent Executions - 1 column */}
            <div className="lg:col-span-1">
              <h2 className="text-lg font-semibold mb-4">최근 실행 내역</h2>
              <Card>
                <CardContent className="p-4">
                  <ScrollArea className="h-[400px]">
                    {executionsLoading && executions.length === 0 ? (
                      <div className="flex items-center justify-center py-8">
                        <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
                      </div>
                    ) : executions.length === 0 ? (
                      <p className="text-sm text-muted-foreground text-center py-8">
                        실행 내역이 없습니다.
                      </p>
                    ) : (
                      <div className="space-y-2">
                        {executions.map((execution) => (
                          <ExecutionItem key={execution.id} execution={execution} />
                        ))}
                      </div>
                    )}
                  </ScrollArea>
                </CardContent>
              </Card>
            </div>
          </div>
        )}

        {/* Help */}
        <Alert className="mt-6">
          <Zap className="h-4 w-4" />
          <AlertDescription>
            <strong>ML Add-on 실행 방법:</strong> <code className="px-1 py-0.5 bg-muted rounded text-xs">cd backend/ml-addons && docker-compose up -d</code>
            <br />
            <span className="text-muted-foreground">
              ML Add-on은 Docker 컨테이너로 실행됩니다. API Gateway를 통해 자동으로 라우팅됩니다.
            </span>
          </AlertDescription>
        </Alert>

        {/* Feature Description */}
        <div className="mt-8 grid gap-4 md:grid-cols-3">
          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-base flex items-center gap-2">
                <MessageSquare className="h-4 w-4 text-blue-500" />
                감성 분석
              </CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground">
                뉴스 기사의 감성(긍정/부정/중립)을 분석하여 기사의 톤을 파악합니다.
              </p>
            </CardContent>
          </Card>
          
          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-base flex items-center gap-2">
                <Shield className="h-4 w-4 text-green-500" />
                팩트체크
              </CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground">
                기사 내 주장의 사실 여부를 검증하고 신뢰도 점수를 제공합니다.
              </p>
            </CardContent>
          </Card>
          
          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-base flex items-center gap-2">
                <Scale className="h-4 w-4 text-purple-500" />
                편향성 분석
              </CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-muted-foreground">
                기사의 정치적 편향성을 분석하여 객관적인 정보 판단을 돕습니다.
              </p>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default MLAddons;

```

---

## frontend/src/pages/MLResults.tsx

```tsx
/**
 * ML 분석 결과 페이지
 * 
 * - 특정 기사의 ML 분석 결과 확인
 * - 전체 ML 실행 이력 조회
 * - 분석 결과 상세 보기 (시각화)
 */

import React, { useState, useEffect, useCallback } from 'react';
import { Link, useSearchParams } from 'react-router-dom';
import {
  ArrowLeft,
  Brain,
  RefreshCw,
  Loader2,
  CheckCircle2,
  XCircle,
  Clock,
  AlertCircle,
  ExternalLink,
  ChevronDown,
  ChevronUp,
  Filter,
  Search,
  Activity,
  Inbox,
  ThumbsUp,
  ThumbsDown,
  Minus,
  MessageSquare,
  Shield,
  Scale,
  Tag,
  Users,
  MapPin,
  Building,
  FileText,
  AlertTriangle,
  Info,
  TrendingUp,
  TrendingDown,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { Progress } from '@/components/ui/progress';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@/components/ui/collapsible';
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { useMlExecutions, useArticleAnalysis } from '@/hooks/useMlAddons';
import { getCollectedData, type CollectedDataDTO } from '@/lib/api/data';
import { getCategoryLabel, getExecutionStatusLabel, getExecutionStatusColor } from '@/lib/api/ml';
import type { MlAddonExecution, ExecutionStatus, MlAnalysisResults } from '@/types/api';

// ============================================
// Status Badge Component
// ============================================

const StatusBadge: React.FC<{ status: ExecutionStatus }> = ({ status }) => {
  const label = getExecutionStatusLabel(status);
  const colorKey = getExecutionStatusColor(status);
  
  const colorClasses: Record<string, string> = {
    yellow: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200',
    blue: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200',
    green: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200',
    red: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200',
    orange: 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200',
    gray: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200',
    slate: 'bg-slate-100 text-slate-800 dark:bg-slate-700 dark:text-slate-200',
  };

  const StatusIcon = () => {
    switch (status) {
      case 'SUCCESS':
        return <CheckCircle2 className="h-3 w-3" />;
      case 'FAILED':
        return <XCircle className="h-3 w-3" />;
      case 'RUNNING':
        return <Loader2 className="h-3 w-3 animate-spin" />;
      case 'PENDING':
        return <Clock className="h-3 w-3" />;
      default:
        return <AlertCircle className="h-3 w-3" />;
    }
  };

  return (
    <Badge className={`${colorClasses[colorKey] || colorClasses.gray} flex items-center gap-1`}>
      <StatusIcon />
      {label}
    </Badge>
  );
};

// ============================================
// Analysis Result Renderers
// ============================================

// 감정 분석 결과
const SentimentResult: React.FC<{ data: MlAnalysisResults['sentiment'] }> = ({ data }) => {
  if (!data) return null;
  
  const getSentimentIcon = () => {
    switch (data.label) {
      case 'positive': return <ThumbsUp className="h-5 w-5 text-green-500" />;
      case 'negative': return <ThumbsDown className="h-5 w-5 text-red-500" />;
      default: return <Minus className="h-5 w-5 text-gray-500" />;
    }
  };
  
  const getSentimentColor = () => {
    switch (data.label) {
      case 'positive': return 'text-green-600';
      case 'negative': return 'text-red-600';
      default: return 'text-gray-600';
    }
  };
  
  const getSentimentLabel = () => {
    switch (data.label) {
      case 'positive': return '긍정적';
      case 'negative': return '부정적';
      default: return '중립';
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-3">
        {getSentimentIcon()}
        <div>
          <p className={`text-lg font-semibold ${getSentimentColor()}`}>
            {getSentimentLabel()}
          </p>
          <p className="text-sm text-muted-foreground">
            신뢰도: {(data.score * 100).toFixed(1)}%
          </p>
        </div>
      </div>
      
      {data.distribution && (
        <div className="space-y-2">
          <p className="text-sm font-medium">감정 분포</p>
          {Object.entries(data.distribution).map(([key, value]) => (
            <div key={key} className="flex items-center gap-2">
              <span className="text-xs w-16 capitalize">{key}</span>
              <Progress value={value * 100} className="flex-1 h-2" />
              <span className="text-xs w-12 text-right">{(value * 100).toFixed(0)}%</span>
            </div>
          ))}
        </div>
      )}
      
      {data.emotions && Object.keys(data.emotions).length > 0 && (
        <div className="space-y-2">
          <p className="text-sm font-medium">세부 감정</p>
          <div className="flex flex-wrap gap-2">
            {Object.entries(data.emotions).map(([emotion, score]) => (
              <Badge key={emotion} variant="outline" className="text-xs">
                {emotion}: {(score * 100).toFixed(0)}%
              </Badge>
            ))}
          </div>
        </div>
      )}
      
      {data.explanations && data.explanations.length > 0 && (
        <div className="space-y-1">
          <p className="text-sm font-medium">분석 근거</p>
          <ul className="text-sm text-muted-foreground space-y-1">
            {data.explanations.map((exp, i) => (
              <li key={i} className="flex items-start gap-2">
                <Info className="h-4 w-4 mt-0.5 shrink-0" />
                {exp}
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

// 편향성 분석 결과
const BiasResult: React.FC<{ data: MlAnalysisResults['bias'] }> = ({ data }) => {
  if (!data) return null;
  
  const getBiasColor = () => {
    if (data.score > 0.7) return 'text-red-600';
    if (data.score > 0.4) return 'text-yellow-600';
    return 'text-green-600';
  };
  
  const getBiasLevel = () => {
    if (data.score > 0.7) return '높음';
    if (data.score > 0.4) return '중간';
    return '낮음';
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-3">
        <Scale className="h-5 w-5 text-purple-500" />
        <div>
          <p className={`text-lg font-semibold ${getBiasColor()}`}>
            편향성: {getBiasLevel()}
          </p>
          <p className="text-sm text-muted-foreground">
            {data.label} (점수: {(data.score * 100).toFixed(1)}%)
          </p>
        </div>
      </div>
      
      <div className="space-y-2">
        <div className="flex items-center gap-2">
          <span className="text-xs">낮음</span>
          <Progress value={data.score * 100} className="flex-1 h-3" />
          <span className="text-xs">높음</span>
        </div>
      </div>
      
      {data.details && Object.keys(data.details).length > 0 && (
        <div className="space-y-2">
          <p className="text-sm font-medium">편향 유형별 점수</p>
          {Object.entries(data.details).map(([type, score]) => (
            <div key={type} className="flex items-center gap-2">
              <span className="text-xs w-24">{type}</span>
              <Progress value={score * 100} className="flex-1 h-2" />
              <span className="text-xs w-12 text-right">{(score * 100).toFixed(0)}%</span>
            </div>
          ))}
        </div>
      )}
      
      {data.explanations && data.explanations.length > 0 && (
        <div className="space-y-1">
          <p className="text-sm font-medium">분석 근거</p>
          <ul className="text-sm text-muted-foreground space-y-1">
            {data.explanations.map((exp, i) => (
              <li key={i} className="flex items-start gap-2">
                <Info className="h-4 w-4 mt-0.5 shrink-0" />
                {exp}
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

// 팩트체크 결과
const FactcheckResult: React.FC<{ data: MlAnalysisResults['factcheck'] }> = ({ data }) => {
  if (!data) return null;
  
  const getStatusColor = () => {
    switch (data.status) {
      case 'verified': return 'text-green-600';
      case 'suspicious': return 'text-yellow-600';
      case 'conflicting': return 'text-orange-600';
      default: return 'text-gray-600';
    }
  };
  
  const getStatusLabel = () => {
    switch (data.status) {
      case 'verified': return '검증됨';
      case 'suspicious': return '의심';
      case 'conflicting': return '상충';
      default: return '미검증';
    }
  };
  
  const getStatusIcon = () => {
    switch (data.status) {
      case 'verified': return <CheckCircle2 className="h-5 w-5 text-green-500" />;
      case 'suspicious': return <AlertTriangle className="h-5 w-5 text-yellow-500" />;
      case 'conflicting': return <AlertCircle className="h-5 w-5 text-orange-500" />;
      default: return <Info className="h-5 w-5 text-gray-500" />;
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-3">
        {getStatusIcon()}
        <div>
          <p className={`text-lg font-semibold ${getStatusColor()}`}>
            {getStatusLabel()}
          </p>
          <p className="text-sm text-muted-foreground">
            신뢰도: {(data.confidence * 100).toFixed(1)}%
          </p>
        </div>
      </div>
      
      {data.claims && data.claims.length > 0 && (
        <div className="space-y-3">
          <p className="text-sm font-medium">주요 주장 검증</p>
          {data.claims.map((claim, i) => (
            <Card key={i} className="p-3">
              <p className="text-sm font-medium mb-2">"{claim.claim}"</p>
              <div className="flex items-center gap-2 mb-2">
                <Badge variant={claim.verdict === 'true' ? 'default' : claim.verdict === 'false' ? 'destructive' : 'secondary'}>
                  {claim.verdict === 'true' ? '사실' : claim.verdict === 'false' ? '거짓' : '불확실'}
                </Badge>
                <span className="text-xs text-muted-foreground">
                  신뢰도: {(claim.confidence * 100).toFixed(0)}%
                </span>
              </div>
              {claim.sources && claim.sources.length > 0 && (
                <div className="flex flex-wrap gap-1">
                  {claim.sources.map((src, j) => (
                    <Badge key={j} variant="outline" className="text-xs">
                      {src}
                    </Badge>
                  ))}
                </div>
              )}
            </Card>
          ))}
        </div>
      )}
      
      {data.sources && data.sources.length > 0 && (
        <div className="space-y-2">
          <p className="text-sm font-medium">참조 출처</p>
          <div className="flex flex-wrap gap-2">
            {data.sources.map((source, i) => (
              <Badge key={i} variant="outline" className="text-xs">
                {source}
              </Badge>
            ))}
          </div>
        </div>
      )}
      
      {data.notes && (
        <Alert>
          <Info className="h-4 w-4" />
          <AlertDescription className="text-sm">{data.notes}</AlertDescription>
        </Alert>
      )}
    </div>
  );
};

// 개체명 인식 결과
const EntitiesResult: React.FC<{ data: MlAnalysisResults['entities'] }> = ({ data }) => {
  if (!data) return null;
  
  const sections = [
    { key: 'persons', label: '인물', icon: <Users className="h-4 w-4" />, data: data.persons },
    { key: 'organizations', label: '조직', icon: <Building className="h-4 w-4" />, data: data.organizations },
    { key: 'locations', label: '장소', icon: <MapPin className="h-4 w-4" />, data: data.locations },
    { key: 'misc', label: '기타', icon: <Tag className="h-4 w-4" />, data: data.misc },
  ].filter(s => s.data && s.data.length > 0);

  if (sections.length === 0) return <p className="text-sm text-muted-foreground">추출된 개체가 없습니다.</p>;

  return (
    <div className="space-y-4">
      {sections.map(section => (
        <div key={section.key} className="space-y-2">
          <div className="flex items-center gap-2">
            {section.icon}
            <p className="text-sm font-medium">{section.label}</p>
            <Badge variant="secondary" className="text-xs">{section.data!.length}</Badge>
          </div>
          <div className="flex flex-wrap gap-2">
            {section.data!.map((entity, i) => (
              <Tooltip key={i}>
                <TooltipTrigger>
                  <Badge variant="outline" className="text-xs">
                    {entity.name}
                    {entity.count > 1 && <span className="ml-1 text-muted-foreground">×{entity.count}</span>}
                  </Badge>
                </TooltipTrigger>
                {entity.context && (
                  <TooltipContent>
                    <p className="max-w-xs text-xs">{entity.context}</p>
                  </TooltipContent>
                )}
              </Tooltip>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
};

// 요약 결과
const SummaryResult: React.FC<{ data: MlAnalysisResults['summary'] }> = ({ data }) => {
  if (!data) return null;

  return (
    <div className="space-y-4">
      {data.abstractiveSummary && (
        <div className="space-y-2">
          <p className="text-sm font-medium flex items-center gap-2">
            <FileText className="h-4 w-4" />
            요약
          </p>
          <Card className="p-3 bg-muted/50">
            <p className="text-sm">{data.abstractiveSummary}</p>
          </Card>
        </div>
      )}
      
      {data.keyPoints && data.keyPoints.length > 0 && (
        <div className="space-y-2">
          <p className="text-sm font-medium">핵심 포인트</p>
          <ul className="space-y-1">
            {data.keyPoints.map((point, i) => (
              <li key={i} className="flex items-start gap-2 text-sm">
                <span className="text-primary font-bold">{i + 1}.</span>
                {point}
              </li>
            ))}
          </ul>
        </div>
      )}
      
      {data.extractiveSentences && data.extractiveSentences.length > 0 && (
        <div className="space-y-2">
          <p className="text-sm font-medium">주요 문장</p>
          <ul className="space-y-2">
            {data.extractiveSentences.map((sentence, i) => (
              <li key={i} className="text-sm text-muted-foreground italic border-l-2 border-primary/30 pl-3">
                "{sentence}"
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

// 주제 분류 결과
const TopicsResult: React.FC<{ data: MlAnalysisResults['topics'] }> = ({ data }) => {
  if (!data) return null;

  return (
    <div className="space-y-4">
      {data.primaryTopic && (
        <div className="flex items-center gap-2">
          <Tag className="h-5 w-5 text-primary" />
          <span className="text-lg font-semibold">{data.primaryTopic}</span>
        </div>
      )}
      
      {data.labels && data.labels.length > 0 && (
        <div className="space-y-2">
          <p className="text-sm font-medium">관련 주제</p>
          <div className="flex flex-wrap gap-2">
            {data.labels.map((label, i) => (
              <Badge 
                key={i} 
                variant={label === data.primaryTopic ? 'default' : 'outline'}
                className="text-sm"
              >
                {label}
                {data.scores && data.scores[label] && (
                  <span className="ml-1 text-xs opacity-70">
                    {(data.scores[label] * 100).toFixed(0)}%
                  </span>
                )}
              </Badge>
            ))}
          </div>
        </div>
      )}
      
      {data.scores && Object.keys(data.scores).length > 0 && (
        <div className="space-y-2">
          <p className="text-sm font-medium">주제별 점수</p>
          {Object.entries(data.scores)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 5)
            .map(([topic, score]) => (
              <div key={topic} className="flex items-center gap-2">
                <span className="text-xs w-24 truncate">{topic}</span>
                <Progress value={score * 100} className="flex-1 h-2" />
                <span className="text-xs w-12 text-right">{(score * 100).toFixed(0)}%</span>
              </div>
            ))}
        </div>
      )}
    </div>
  );
};

// 신뢰도 분석 결과
const ReliabilityResult: React.FC<{ data: MlAnalysisResults['reliability'] }> = ({ data }) => {
  if (!data) return null;
  
  const getGradeColor = () => {
    switch (data.grade) {
      case 'high': return 'text-green-600';
      case 'medium': return 'text-yellow-600';
      default: return 'text-red-600';
    }
  };
  
  const getGradeLabel = () => {
    switch (data.grade) {
      case 'high': return '높음';
      case 'medium': return '중간';
      default: return '낮음';
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-3">
        <Shield className="h-5 w-5 text-blue-500" />
        <div>
          <p className={`text-lg font-semibold ${getGradeColor()}`}>
            신뢰도: {getGradeLabel()}
          </p>
          <p className="text-sm text-muted-foreground">
            점수: {(data.score * 100).toFixed(1)}%
          </p>
        </div>
      </div>
      
      {data.factors && Object.keys(data.factors).length > 0 && (
        <div className="space-y-2">
          <p className="text-sm font-medium">평가 요소</p>
          {Object.entries(data.factors).map(([factor, score]) => (
            <div key={factor} className="flex items-center gap-2">
              <span className="text-xs w-24">{factor}</span>
              <Progress value={score * 100} className="flex-1 h-2" />
              <span className="text-xs w-12 text-right">{(score * 100).toFixed(0)}%</span>
            </div>
          ))}
        </div>
      )}
      
      {data.warnings && data.warnings.length > 0 && (
        <Alert variant="destructive">
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>
            <ul className="text-sm space-y-1">
              {data.warnings.map((warning, i) => (
                <li key={i}>{warning}</li>
              ))}
            </ul>
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
};

// ============================================
// Analysis Result Display Component
// ============================================

interface AnalysisResultDisplayProps {
  responsePayload?: Record<string, unknown>;
  category?: string;
}

const AnalysisResultDisplay: React.FC<AnalysisResultDisplayProps> = ({ responsePayload, category }) => {
  if (!responsePayload || Object.keys(responsePayload).length === 0) {
    return (
      <div className="text-center py-4 text-muted-foreground">
        <Info className="h-8 w-8 mx-auto mb-2 opacity-50" />
        <p className="text-sm">분석 결과 데이터가 없습니다.</p>
      </div>
    );
  }

  // responsePayload에서 results 추출 (또는 직접 사용)
  const results = (responsePayload.results as MlAnalysisResults) || responsePayload as MlAnalysisResults;
  
  // 결과 타입별 렌더링
  const hasSpecificResult = results.sentiment || results.bias || results.factcheck || 
    results.entities || results.summary || results.topics || results.reliability ||
    results.toxicity || results.misinformation || results.discussion;

  if (!hasSpecificResult) {
    // 구조화된 결과가 없으면 JSON 표시
    return (
      <div className="space-y-2">
        <p className="text-xs font-medium text-muted-foreground">원시 데이터:</p>
        <ScrollArea className="h-48 rounded-md border p-3 bg-muted/30">
          <pre className="text-xs whitespace-pre-wrap font-mono">
            {JSON.stringify(responsePayload, null, 2)}
          </pre>
        </ScrollArea>
      </div>
    );
  }

  return (
    <Tabs defaultValue={getDefaultTab(results)} className="w-full">
      <TabsList className="w-full justify-start flex-wrap h-auto gap-1 bg-transparent p-0 mb-4">
        {results.sentiment && <TabsTrigger value="sentiment" className="text-xs">감정 분석</TabsTrigger>}
        {results.bias && <TabsTrigger value="bias" className="text-xs">편향성</TabsTrigger>}
        {results.factcheck && <TabsTrigger value="factcheck" className="text-xs">팩트체크</TabsTrigger>}
        {results.reliability && <TabsTrigger value="reliability" className="text-xs">신뢰도</TabsTrigger>}
        {results.entities && <TabsTrigger value="entities" className="text-xs">개체명</TabsTrigger>}
        {results.summary && <TabsTrigger value="summary" className="text-xs">요약</TabsTrigger>}
        {results.topics && <TabsTrigger value="topics" className="text-xs">주제</TabsTrigger>}
        {results.toxicity && <TabsTrigger value="toxicity" className="text-xs">독성</TabsTrigger>}
        <TabsTrigger value="raw" className="text-xs">원시 데이터</TabsTrigger>
      </TabsList>
      
      {results.sentiment && (
        <TabsContent value="sentiment">
          <SentimentResult data={results.sentiment} />
        </TabsContent>
      )}
      {results.bias && (
        <TabsContent value="bias">
          <BiasResult data={results.bias} />
        </TabsContent>
      )}
      {results.factcheck && (
        <TabsContent value="factcheck">
          <FactcheckResult data={results.factcheck} />
        </TabsContent>
      )}
      {results.reliability && (
        <TabsContent value="reliability">
          <ReliabilityResult data={results.reliability} />
        </TabsContent>
      )}
      {results.entities && (
        <TabsContent value="entities">
          <EntitiesResult data={results.entities} />
        </TabsContent>
      )}
      {results.summary && (
        <TabsContent value="summary">
          <SummaryResult data={results.summary} />
        </TabsContent>
      )}
      {results.topics && (
        <TabsContent value="topics">
          <TopicsResult data={results.topics} />
        </TabsContent>
      )}
      {results.toxicity && (
        <TabsContent value="toxicity">
          <div className="space-y-3">
            <div className="flex items-center gap-2">
              <AlertTriangle className="h-5 w-5 text-orange-500" />
              <span className="font-semibold">독성 점수: {((results.toxicity.score || 0) * 100).toFixed(1)}%</span>
            </div>
            {results.toxicity.categories && (
              <div className="space-y-2">
                {Object.entries(results.toxicity.categories).map(([cat, score]) => (
                  <div key={cat} className="flex items-center gap-2">
                    <span className="text-xs w-24">{cat}</span>
                    <Progress value={score * 100} className="flex-1 h-2" />
                    <span className="text-xs w-12 text-right">{(score * 100).toFixed(0)}%</span>
                  </div>
                ))}
              </div>
            )}
          </div>
        </TabsContent>
      )}
      <TabsContent value="raw">
        <ScrollArea className="h-48 rounded-md border p-3 bg-muted/30">
          <pre className="text-xs whitespace-pre-wrap font-mono">
            {JSON.stringify(responsePayload, null, 2)}
          </pre>
        </ScrollArea>
      </TabsContent>
    </Tabs>
  );
};

function getDefaultTab(results: MlAnalysisResults): string {
  if (results.sentiment) return 'sentiment';
  if (results.bias) return 'bias';
  if (results.factcheck) return 'factcheck';
  if (results.reliability) return 'reliability';
  if (results.entities) return 'entities';
  if (results.summary) return 'summary';
  if (results.topics) return 'topics';
  return 'raw';
}

// ============================================
// Execution Card Component
// ============================================

interface ExecutionCardProps {
  execution: MlAddonExecution;
}

const ExecutionCard: React.FC<ExecutionCardProps> = ({ execution }) => {
  const [isOpen, setIsOpen] = useState(execution.status === 'SUCCESS');
  
  const hasResult = execution.responsePayload && Object.keys(execution.responsePayload).length > 0;
  const addonName = execution.addon?.name || execution.addon?.addonKey || '알 수 없음';
  const category = execution.addon?.category;
  
  return (
    <Card className="overflow-hidden">
      <Collapsible open={isOpen} onOpenChange={setIsOpen}>
        <CollapsibleTrigger asChild>
          <CardHeader className="cursor-pointer hover:bg-muted/50 transition-colors pb-3">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className={`p-2 rounded-lg ${execution.status === 'SUCCESS' ? 'bg-green-100 dark:bg-green-900/30' : execution.status === 'FAILED' ? 'bg-red-100 dark:bg-red-900/30' : 'bg-primary/10'}`}>
                  <Brain className={`h-4 w-4 ${execution.status === 'SUCCESS' ? 'text-green-600' : execution.status === 'FAILED' ? 'text-red-600' : 'text-primary'}`} />
                </div>
                <div>
                  <CardTitle className="text-sm font-medium">
                    {addonName}
                  </CardTitle>
                  <CardDescription className="text-xs">
                    {category ? getCategoryLabel(category) : '분석'} 
                    {execution.articleId && ` - 기사 #${execution.articleId}`}
                    {execution.latencyMs && ` - ${execution.latencyMs}ms`}
                  </CardDescription>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <StatusBadge status={execution.status} />
                {(hasResult || execution.errorMessage) && (
                  isOpen ? <ChevronUp className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />
                )}
              </div>
            </div>
          </CardHeader>
        </CollapsibleTrigger>
        
        <CollapsibleContent>
          <CardContent className="pt-0 space-y-4">
            <Separator />
            
            {/* 메타 정보 */}
            <div className="grid grid-cols-2 gap-2 text-xs text-muted-foreground">
              <div>
                <span className="font-medium">요청 ID:</span>{' '}
                <code className="bg-muted px-1 rounded">{execution.requestId.slice(0, 12)}...</code>
              </div>
              {execution.batchId && (
                <div>
                  <span className="font-medium">배치 ID:</span>{' '}
                  <code className="bg-muted px-1 rounded">{execution.batchId.slice(0, 12)}...</code>
                </div>
              )}
              <div>
                <span className="font-medium">생성:</span>{' '}
                {new Date(execution.createdAt).toLocaleString('ko-KR')}
              </div>
              {execution.completedAt && (
                <div>
                  <span className="font-medium">완료:</span>{' '}
                  {new Date(execution.completedAt).toLocaleString('ko-KR')}
                </div>
              )}
            </div>
            
            {/* 에러 메시지 */}
            {execution.errorMessage && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription className="text-sm">
                  {execution.errorCode && <span className="font-mono mr-2">[{execution.errorCode}]</span>}
                  {execution.errorMessage}
                </AlertDescription>
              </Alert>
            )}
            
            {/* 분석 결과 */}
            {hasResult && (
              <div className="space-y-2">
                <p className="text-sm font-medium">분석 결과</p>
                <AnalysisResultDisplay 
                  responsePayload={execution.responsePayload} 
                  category={category}
                />
              </div>
            )}
          </CardContent>
        </CollapsibleContent>
      </Collapsible>
    </Card>
  );
};

// ============================================
// Article Info Card
// ============================================

interface ArticleInfoCardProps {
  article: CollectedDataDTO;
}

const ArticleInfoCard: React.FC<ArticleInfoCardProps> = ({ article }) => {
  return (
    <Card className="mb-6">
      <CardHeader className="pb-3">
        <div className="flex items-start justify-between gap-4">
          <div className="flex-1">
            <CardTitle className="text-lg line-clamp-2">
              {article.title || '제목 없음'}
            </CardTitle>
            <CardDescription className="mt-1">
              기사 #{article.id} - {new Date(article.collectedAt).toLocaleString('ko-KR')}
            </CardDescription>
          </div>
          {article.url && (
            <Button variant="outline" size="sm" asChild>
              <a href={article.url} target="_blank" rel="noopener noreferrer">
                <ExternalLink className="h-4 w-4 mr-1" />
                원본
              </a>
            </Button>
          )}
        </div>
      </CardHeader>
      <CardContent>
        <p className="text-sm text-muted-foreground line-clamp-3">
          {article.content?.slice(0, 300) || '내용 없음'}
          {article.content && article.content.length > 300 && '...'}
        </p>
      </CardContent>
    </Card>
  );
};

// ============================================
// Main Page Component
// ============================================

const MLResults: React.FC = () => {
  const [searchParams] = useSearchParams();
  const articleIdParam = searchParams.get('articleId');
  const articleId = articleIdParam ? parseInt(articleIdParam, 10) : null;
  
  const [statusFilter, setStatusFilter] = useState<ExecutionStatus | 'ALL'>('ALL');
  const [searchQuery, setSearchQuery] = useState('');
  const [article, setArticle] = useState<CollectedDataDTO | null>(null);
  const [articleLoading, setArticleLoading] = useState(false);
  
  // 기사별 분석 결과
  const {
    executions: articleExecutions,
    loading: articleExecLoading,
    error: articleExecError,
    refresh: refreshArticleExec,
    isAnalyzing,
  } = useArticleAnalysis(articleId);
  
  // 전체 실행 이력
  const {
    executions: allExecutions,
    loading: allExecLoading,
    error: allExecError,
    refresh: refreshAllExec,
    total: totalExecutions,
    totalPages,
    currentPage,
    setPage,
  } = useMlExecutions({ size: 20 });
  
  // 기사 정보 로드
  useEffect(() => {
    if (articleId) {
      setArticleLoading(true);
      getCollectedData(articleId)
        .then(setArticle)
        .catch(() => setArticle(null))
        .finally(() => setArticleLoading(false));
    }
  }, [articleId]);
  
  const handleRefresh = useCallback(async () => {
    if (articleId) {
      await refreshArticleExec();
    } else {
      await refreshAllExec();
    }
  }, [articleId, refreshArticleExec, refreshAllExec]);
  
  // 현재 표시할 실행 목록
  const executions = articleId ? articleExecutions : allExecutions;
  const loading = articleId ? articleExecLoading : allExecLoading;
  const error = articleId ? articleExecError : allExecError;
  
  // 필터링
  const filteredExecutions = executions.filter(exec => {
    if (statusFilter !== 'ALL' && exec.status !== statusFilter) return false;
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      const addonKey = exec.addon?.addonKey || '';
      return (
        addonKey.toLowerCase().includes(query) ||
        exec.requestId.toLowerCase().includes(query) ||
        (exec.batchId && exec.batchId.toLowerCase().includes(query))
      );
    }
    return true;
  });
  
  // 통계
  const stats = {
    total: executions.length,
    success: executions.filter(e => e.status === 'SUCCESS').length,
    failed: executions.filter(e => e.status === 'FAILED').length,
    running: executions.filter(e => e.status === 'RUNNING' || e.status === 'PENDING').length,
  };

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-4xl">
        {/* Header */}
        <header className="mb-6">
          <Link
            to={articleId ? '/collected-data' : '/'}
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            {articleId ? '수집 데이터로 돌아가기' : '홈으로 돌아가기'}
          </Link>
          
          <div className="flex items-center justify-between flex-wrap gap-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-primary/10 rounded-lg">
                <Brain className="h-6 w-6 text-primary" />
              </div>
              <div>
                <h1 className="text-2xl font-bold">
                  {articleId ? `기사 #${articleId} 분석 결과` : 'ML 분석 결과'}
                </h1>
                <p className="text-muted-foreground text-sm">
                  {articleId 
                    ? '이 기사에 대한 ML 분석 결과를 확인합니다.'
                    : '전체 ML 분석 실행 이력을 확인합니다.'
                  }
                </p>
              </div>
            </div>
            
            <Button
              variant="outline"
              onClick={handleRefresh}
              disabled={loading || isAnalyzing}
            >
              <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />
              새로고침
            </Button>
          </div>
        </header>
        
        {/* 기사 정보 (기사 ID가 있을 때) */}
        {articleId && articleLoading && (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
          </div>
        )}
        {articleId && article && !articleLoading && (
          <ArticleInfoCard article={article} />
        )}
        
        {/* 통계 */}
        <div className="grid grid-cols-4 gap-3 mb-6">
          <Card className="p-3">
            <div className="flex items-center gap-2">
              <Activity className="h-4 w-4 text-muted-foreground" />
              <div>
                <p className="text-xs text-muted-foreground">전체</p>
                <p className="text-lg font-bold">{articleId ? stats.total : totalExecutions}</p>
              </div>
            </div>
          </Card>
          <Card className="p-3">
            <div className="flex items-center gap-2">
              <CheckCircle2 className="h-4 w-4 text-green-500" />
              <div>
                <p className="text-xs text-muted-foreground">성공</p>
                <p className="text-lg font-bold text-green-600">{stats.success}</p>
              </div>
            </div>
          </Card>
          <Card className="p-3">
            <div className="flex items-center gap-2">
              <XCircle className="h-4 w-4 text-red-500" />
              <div>
                <p className="text-xs text-muted-foreground">실패</p>
                <p className="text-lg font-bold text-red-600">{stats.failed}</p>
              </div>
            </div>
          </Card>
          <Card className="p-3">
            <div className="flex items-center gap-2">
              <Loader2 className="h-4 w-4 text-blue-500" />
              <div>
                <p className="text-xs text-muted-foreground">진행중</p>
                <p className="text-lg font-bold text-blue-600">{stats.running}</p>
              </div>
            </div>
          </Card>
        </div>
        
        {/* 필터 */}
        <div className="flex items-center gap-3 mb-4">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Add-on 키, 요청 ID로 검색..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10"
            />
          </div>
          <Select
            value={statusFilter}
            onValueChange={(v) => setStatusFilter(v as ExecutionStatus | 'ALL')}
          >
            <SelectTrigger className="w-32">
              <Filter className="h-4 w-4 mr-2" />
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="ALL">전체</SelectItem>
              <SelectItem value="SUCCESS">성공</SelectItem>
              <SelectItem value="FAILED">실패</SelectItem>
              <SelectItem value="RUNNING">실행 중</SelectItem>
              <SelectItem value="PENDING">대기 중</SelectItem>
            </SelectContent>
          </Select>
        </div>
        
        {/* 에러 */}
        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{error.message}</AlertDescription>
          </Alert>
        )}
        
        {/* 로딩 */}
        {loading && executions.length === 0 && (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
          </div>
        )}
        
        {/* 결과 없음 */}
        {!loading && filteredExecutions.length === 0 && (
          <Card className="p-8 text-center">
            <Inbox className="h-12 w-12 mx-auto mb-4 text-muted-foreground" />
            <p className="text-muted-foreground">
              {searchQuery || statusFilter !== 'ALL'
                ? '검색 조건에 맞는 결과가 없습니다.'
                : articleId
                  ? '이 기사에 대한 분석 결과가 없습니다.'
                  : 'ML 분석 이력이 없습니다.'
              }
            </p>
            {articleId && (
              <Button asChild className="mt-4">
                <Link to="/collected-data">수집 데이터에서 분석 시작</Link>
              </Button>
            )}
          </Card>
        )}
        
        {/* 결과 목록 */}
        {filteredExecutions.length > 0 && (
          <div className="space-y-3">
            {filteredExecutions.map((execution) => (
              <ExecutionCard key={execution.requestId} execution={execution} />
            ))}
          </div>
        )}
        
        {/* 페이지네이션 (전체 목록일 때만) */}
        {!articleId && totalPages > 1 && (
          <div className="flex items-center justify-center gap-2 mt-6">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setPage(currentPage - 1)}
              disabled={currentPage === 0}
            >
              이전
            </Button>
            <span className="text-sm text-muted-foreground">
              {currentPage + 1} / {totalPages}
            </span>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setPage(currentPage + 1)}
              disabled={currentPage >= totalPages - 1}
            >
              다음
            </Button>
          </div>
        )}
        
        {/* 도움말 */}
        <Alert className="mt-6">
          <Brain className="h-4 w-4" />
          <AlertDescription>
            <strong>분석 결과 확인:</strong> 각 카드를 클릭하면 감정, 편향성, 팩트체크 등 상세 분석 결과를 시각적으로 확인할 수 있습니다.
            탭을 전환하여 다양한 분석 유형의 결과를 살펴보세요.
          </AlertDescription>
        </Alert>
      </div>
    </div>
  );
};

export default MLResults;

```

---

## frontend/src/pages/MLTraining.tsx

```tsx
import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { Link } from 'react-router-dom';
import {
  ArrowLeft,
  Brain,
  Play,
  Pause,
  RefreshCw,
  CheckCircle2,
  XCircle,
  AlertCircle,
  Loader2,
  Database,
  Upload,
  Download,
  Zap,
  Settings,
  TrendingUp,
  Clock,
  BarChart3,
  Cpu,
  HardDrive,
  Layers,
  FileText,
  ExternalLink,
  Trash2,
  ChevronDown,
  ChevronUp,
  PlayCircle,
  StopCircle,
  Activity,
  Radio,
  Cloud,
  Copy,
  Check,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Progress } from '@/components/ui/progress';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@/components/ui/collapsible';
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
  TooltipProvider,
} from '@/components/ui/tooltip';
import { useToast } from '@/hooks/use-toast';
import {
  checkMLTrainerHealth,
  startTraining,
  getTrainingJobStatus,
  cancelTrainingJob,
  listTrainingJobs,
  listTrainedModels,
  downloadModelArtifact,
  connectTrainingStream,
  startTrainingWithHuggingFaceDataset,
  runInference,
  startExternalTraining,
  uploadExternalModel,
  completeExternalTraining,
  KOREAN_DATASETS,
  DEFAULT_BASE_MODELS,
  type MLTrainerHealth,
  type TrainingJobStatus,
  type TrainingRequest,
  type ModelArtifact,
  type MLModelType,
  type TrainingJobState,
  type InferenceResponse,
  type ExternalTrainingRequest,
  type ExternalTrainingResponse,
} from '@/lib/api';

// =============================================================================
// Types & Constants
// =============================================================================

interface SSEMetrics {
  loss?: number;
  accuracy?: number;
  validation_loss?: number;
  f1_score?: number;
  learning_rate?: number;
  [key: string]: number | undefined;
}

interface SSEEvent {
  type: string;
  job_id: string;
  progress: number;
  state: TrainingJobState;
  metrics: SSEMetrics;
  current_epoch?: number;
  total_epochs?: number;
  step?: number;
  total_steps?: number;
  [key: string]: unknown;
}

const MODEL_TYPE_LABELS: Record<MLModelType, string> = {
  sentiment: '감정 분석',
  absa: 'ABSA (관점 기반 감정)',
  ner: '개체명 인식',
  classification: '텍스트 분류',
  embedding: '임베딩 모델',
  transformer: '트랜스포머',
};

const JOB_STATE_CONFIG: Record<TrainingJobState, { label: string; color: string; icon: React.ElementType }> = {
  PENDING: { label: '대기 중', color: 'bg-yellow-100 text-yellow-700', icon: Clock },
  INITIALIZING: { label: '초기화 중', color: 'bg-blue-100 text-blue-700', icon: Loader2 },
  RUNNING: { label: '학습 중', color: 'bg-green-100 text-green-700', icon: PlayCircle },
  COMPLETED: { label: '완료', color: 'bg-emerald-100 text-emerald-700', icon: CheckCircle2 },
  FAILED: { label: '실패', color: 'bg-red-100 text-red-700', icon: XCircle },
  CANCELLED: { label: '취소됨', color: 'bg-gray-100 text-gray-700', icon: StopCircle },
};

// =============================================================================
// Helper Components
// =============================================================================

interface MetricCardProps {
  label: string;
  value: string | number;
  icon: React.ElementType;
  trend?: 'up' | 'down' | 'neutral';
}

const MetricCard = ({ label, value, icon: Icon, trend }: MetricCardProps) => (
  <div className="flex items-center gap-3 p-3 rounded-lg bg-muted/50">
    <div className="p-2 rounded-md bg-primary/10">
      <Icon className="h-4 w-4 text-primary" />
    </div>
    <div>
      <p className="text-xs text-muted-foreground">{label}</p>
      <p className="font-semibold">{value}</p>
    </div>
    {trend && (
      <TrendingUp
        className={`h-4 w-4 ml-auto ${
          trend === 'up' ? 'text-green-500' : trend === 'down' ? 'text-red-500 rotate-180' : 'text-gray-400'
        }`}
      />
    )}
  </div>
);

// =============================================================================
// Training Job Card
// =============================================================================

interface TrainingJobCardProps {
  job: TrainingJobStatus;
  onCancel: (jobId: string) => void;
  onInference: (jobId: string) => void;
  onDownload: (jobId: string) => void;
  isLive?: boolean;
}

const TrainingJobCard = ({ job, onCancel, onInference, onDownload, isLive }: TrainingJobCardProps) => {
  const stateConfig = JOB_STATE_CONFIG[job.state];
  const StateIcon = stateConfig.icon;
  const isRunning = job.state === 'RUNNING' || job.state === 'INITIALIZING';
  const isCompleted = job.state === 'COMPLETED';

  return (
    <Card className={isRunning ? 'border-primary/50 shadow-md' : ''}>
      <CardHeader className="pb-2">
        <div className="flex items-start justify-between">
          <div>
            <CardTitle className="text-lg flex items-center gap-2">
              {job.model_name}
              <Badge className={stateConfig.color}>
                <StateIcon className={`h-3 w-3 mr-1 ${isRunning ? 'animate-spin' : ''}`} />
                {stateConfig.label}
              </Badge>
              {isLive && (
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <span className="relative flex h-3 w-3">
                        <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                        <span className="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
                      </span>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>실시간 업데이트 연결됨</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              )}
            </CardTitle>
            <CardDescription className="flex items-center gap-2 mt-1">
              <Badge variant="outline">{MODEL_TYPE_LABELS[job.model_type as MLModelType] || job.model_type}</Badge>
              <span className="text-xs">Job ID: {job.job_id.slice(0, 8)}...</span>
            </CardDescription>
          </div>
          <div className="flex gap-2">
            {isRunning && (
              <Button variant="destructive" size="sm" onClick={() => onCancel(job.job_id)}>
                <Pause className="h-4 w-4 mr-1" />
                취소
              </Button>
            )}
            {isCompleted && (
              <>
                <Button variant="outline" size="sm" onClick={() => onInference(job.job_id)}>
                  <Zap className="h-4 w-4 mr-1" />
                  테스트
                </Button>
                <Button variant="outline" size="sm" onClick={() => onDownload(job.job_id)}>
                  <Download className="h-4 w-4 mr-1" />
                  다운로드
                </Button>
              </>
            )}
          </div>
        </div>
      </CardHeader>
      <CardContent>
        {/* Progress */}
        <div className="space-y-2 mb-4">
          <div className="flex justify-between text-sm">
            <span>진행률</span>
            <span>{job.progress.toFixed(1)}%</span>
          </div>
          <Progress value={job.progress} className="h-2" />
          {job.current_epoch > 0 && (
            <p className="text-xs text-muted-foreground">
              Epoch {job.current_epoch} / {job.total_epochs}
            </p>
          )}
        </div>

        {/* Metrics */}
        {job.metrics && (
          <div className="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm">
            <div className="p-2 rounded bg-muted/50">
              <p className="text-xs text-muted-foreground">Loss</p>
              <p className="font-mono">{job.metrics.loss?.toFixed(4) || '-'}</p>
            </div>
            <div className="p-2 rounded bg-muted/50">
              <p className="text-xs text-muted-foreground">Accuracy</p>
              <p className="font-mono">{job.metrics.accuracy ? `${(job.metrics.accuracy * 100).toFixed(2)}%` : '-'}</p>
            </div>
            <div className="p-2 rounded bg-muted/50">
              <p className="text-xs text-muted-foreground">Val Loss</p>
              <p className="font-mono">{job.metrics.validation_loss?.toFixed(4) || '-'}</p>
            </div>
            <div className="p-2 rounded bg-muted/50">
              <p className="text-xs text-muted-foreground">F1 Score</p>
              <p className="font-mono">{job.metrics.f1_score ? job.metrics.f1_score.toFixed(4) : '-'}</p>
            </div>
          </div>
        )}

        {/* Error Message */}
        {job.error_message && (
          <Alert variant="destructive" className="mt-4">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{job.error_message}</AlertDescription>
          </Alert>
        )}

        {/* Timestamps */}
        <div className="flex gap-4 mt-4 text-xs text-muted-foreground">
          <span>생성: {new Date(job.created_at).toLocaleString('ko-KR')}</span>
          {job.started_at && <span>시작: {new Date(job.started_at).toLocaleString('ko-KR')}</span>}
          {job.completed_at && <span>완료: {new Date(job.completed_at).toLocaleString('ko-KR')}</span>}
        </div>
      </CardContent>
    </Card>
  );
};

// =============================================================================
// Dataset Card
// =============================================================================

interface DatasetCardProps {
  dataset: typeof KOREAN_DATASETS[number];
  onSelect: (datasetId: string) => void;
  isSelected: boolean;
}

const DatasetCard = ({ dataset, onSelect, isSelected }: DatasetCardProps) => (
  <Card
    className={`cursor-pointer transition-all hover:shadow-md ${isSelected ? 'border-primary ring-2 ring-primary/20' : ''}`}
    onClick={() => onSelect(dataset.id)}
  >
    <CardContent className="p-4">
      <div className="flex items-start justify-between">
        <div>
          <h4 className="font-semibold">{dataset.name}</h4>
          <p className="text-xs text-muted-foreground mt-1">{dataset.description}</p>
        </div>
        {isSelected && <CheckCircle2 className="h-5 w-5 text-primary" />}
      </div>
      <div className="flex gap-2 mt-3">
        <Badge variant="outline">{dataset.size}</Badge>
        <Badge variant="secondary">{dataset.task}</Badge>
      </div>
    </CardContent>
  </Card>
);

// =============================================================================
// New Training Dialog
// =============================================================================

interface NewTrainingDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSubmit: (request: TrainingRequest) => Promise<void>;
  isSubmitting: boolean;
}

const NewTrainingDialog = ({ open, onOpenChange, onSubmit, isSubmitting }: NewTrainingDialogProps) => {
  const [modelName, setModelName] = useState('');
  const [modelType, setModelType] = useState<MLModelType>('sentiment');
  const [selectedDataset, setSelectedDataset] = useState<string>('');
  const [baseModel, setBaseModel] = useState<string>('');
  const [maxEpochs, setMaxEpochs] = useState(3);
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [learningRate, setLearningRate] = useState(2e-5);
  const [batchSize, setBatchSize] = useState(16);

  const filteredDatasets = useMemo(() => {
    return KOREAN_DATASETS.filter(
      (d) => d.task === modelType || d.task === 'classification' || modelType === 'classification'
    );
  }, [modelType]);

  const handleSubmit = async () => {
    if (!modelName || !selectedDataset) return;

    const request: TrainingRequest = {
      model_name: modelName,
      model_type: modelType,
      dataset_path: `huggingface:${selectedDataset}`,
      dataset_format: 'huggingface',
      base_model: baseModel || DEFAULT_BASE_MODELS[modelType][0],
      max_epochs: maxEpochs,
      validation_split: 0.1,
      hyperparameters: {
        learning_rate: learningRate,
        batch_size: batchSize,
        warmup_steps: 500,
        weight_decay: 0.01,
      },
      callbacks: {
        early_stopping: true,
        early_stopping_patience: 3,
        save_best_model: true,
      },
    };

    await onSubmit(request);
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Brain className="h-5 w-5" />
            새 ML 모델 학습
          </DialogTitle>
          <DialogDescription>
            HuggingFace 데이터셋을 사용하여 ML 모델을 학습합니다.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6 py-4">
          {/* Model Name */}
          <div className="space-y-2">
            <Label htmlFor="model-name">모델 이름 *</Label>
            <Input
              id="model-name"
              placeholder="예: my-sentiment-model-v1"
              value={modelName}
              onChange={(e) => setModelName(e.target.value)}
            />
          </div>

          {/* Model Type */}
          <div className="space-y-2">
            <Label>모델 타입 *</Label>
            <Select value={modelType} onValueChange={(v) => setModelType(v as MLModelType)}>
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {Object.entries(MODEL_TYPE_LABELS).map(([value, label]) => (
                  <SelectItem key={value} value={value}>
                    {label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Dataset Selection */}
          <div className="space-y-2">
            <Label>데이터셋 선택 *</Label>
            <ScrollArea className="h-48 rounded-md border p-2">
              <div className="grid gap-2">
                {filteredDatasets.map((dataset) => (
                  <DatasetCard
                    key={dataset.id}
                    dataset={dataset}
                    isSelected={selectedDataset === dataset.id}
                    onSelect={setSelectedDataset}
                  />
                ))}
              </div>
            </ScrollArea>
          </div>

          {/* Base Model */}
          <div className="space-y-2">
            <Label>베이스 모델</Label>
            <Select value={baseModel} onValueChange={setBaseModel}>
              <SelectTrigger>
                <SelectValue placeholder="기본값 사용" />
              </SelectTrigger>
              <SelectContent>
                {DEFAULT_BASE_MODELS[modelType].map((model) => (
                  <SelectItem key={model} value={model}>
                    {model}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Epochs */}
          <div className="space-y-2">
            <Label>최대 Epochs</Label>
            <Input
              type="number"
              min={1}
              max={100}
              value={maxEpochs}
              onChange={(e) => setMaxEpochs(parseInt(e.target.value) || 3)}
            />
          </div>

          {/* Advanced Settings */}
          <Collapsible open={showAdvanced} onOpenChange={setShowAdvanced}>
            <CollapsibleTrigger asChild>
              <Button variant="ghost" className="w-full justify-between">
                고급 설정
                {showAdvanced ? <ChevronUp className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />}
              </Button>
            </CollapsibleTrigger>
            <CollapsibleContent className="space-y-4 pt-4">
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label>Learning Rate</Label>
                  <Input
                    type="number"
                    step="0.00001"
                    value={learningRate}
                    onChange={(e) => setLearningRate(parseFloat(e.target.value))}
                  />
                </div>
                <div className="space-y-2">
                  <Label>Batch Size</Label>
                  <Input
                    type="number"
                    min={1}
                    max={128}
                    value={batchSize}
                    onChange={(e) => setBatchSize(parseInt(e.target.value))}
                  />
                </div>
              </div>
            </CollapsibleContent>
          </Collapsible>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            취소
          </Button>
          <Button onClick={handleSubmit} disabled={!modelName || !selectedDataset || isSubmitting}>
            {isSubmitting ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                시작 중...
              </>
            ) : (
              <>
                <Play className="h-4 w-4 mr-2" />
                학습 시작
              </>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

// =============================================================================
// Inference Test Dialog
// =============================================================================

interface InferenceDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  jobId: string | null;
  modelName: string;
}

const InferenceDialog = ({ open, onOpenChange, jobId, modelName }: InferenceDialogProps) => {
  const [inputText, setInputText] = useState('');
  const [result, setResult] = useState<InferenceResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleInference = async () => {
    if (!jobId || !inputText.trim()) return;
    
    setIsLoading(true);
    setError(null);
    setResult(null);

    try {
      const response = await runInference(jobId, {
        text: inputText,
        return_probabilities: true,
      });
      setResult(response);
    } catch (e) {
      setError(e instanceof Error ? e.message : '추론 실패');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-lg">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Zap className="h-5 w-5" />
            모델 테스트
          </DialogTitle>
          <DialogDescription>
            {modelName} 모델로 텍스트를 분석합니다.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <div className="space-y-2">
            <Label>입력 텍스트</Label>
            <textarea
              className="w-full min-h-24 p-3 rounded-md border bg-background resize-none"
              placeholder="분석할 텍스트를 입력하세요..."
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
            />
          </div>

          <Button onClick={handleInference} disabled={!inputText.trim() || isLoading} className="w-full">
            {isLoading ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                분석 중...
              </>
            ) : (
              <>
                <Zap className="h-4 w-4 mr-2" />
                분석 실행
              </>
            )}
          </Button>

          {error && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          {result && (
            <div className="space-y-3 p-4 rounded-lg bg-muted">
              <div className="flex justify-between items-center">
                <span className="font-medium">예측 결과</span>
                <Badge variant="default" className="text-lg px-3">
                  {result.predicted_label_name || result.predicted_label}
                </Badge>
              </div>
              <div className="flex justify-between text-sm">
                <span className="text-muted-foreground">신뢰도</span>
                <span className="font-mono">{(result.confidence * 100).toFixed(2)}%</span>
              </div>
              <div className="flex justify-between text-sm">
                <span className="text-muted-foreground">추론 시간</span>
                <span className="font-mono">{result.inference_time_ms.toFixed(2)}ms</span>
              </div>
              {result.probabilities && (
                <div className="pt-2 border-t">
                  <p className="text-sm text-muted-foreground mb-2">확률 분포</p>
                  {Object.entries(result.probabilities).map(([label, prob]) => (
                    <div key={label} className="flex items-center gap-2 text-sm">
                      <span className="w-20 truncate">{label}</span>
                      <Progress value={prob * 100} className="flex-1 h-2" />
                      <span className="w-16 text-right font-mono">{(prob * 100).toFixed(1)}%</span>
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};

// =============================================================================
// Main Component
// =============================================================================

const MLTraining = () => {
  const { toast } = useToast();
  const [health, setHealth] = useState<MLTrainerHealth | null>(null);
  const [jobs, setJobs] = useState<TrainingJobStatus[]>([]);
  const [models, setModels] = useState<ModelArtifact[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isNewTrainingOpen, setIsNewTrainingOpen] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [inferenceJob, setInferenceJob] = useState<{ jobId: string; modelName: string } | null>(null);
  const [activeTab, setActiveTab] = useState('jobs');
  const [liveUpdates, setLiveUpdates] = useState<Record<string, SSEEvent>>({});
  const [sseConnected, setSseConnected] = useState<Record<string, boolean>>({});
  
  // External Training State
  const [externalTrainingOpen, setExternalTrainingOpen] = useState(false);
  const [externalResponse, setExternalResponse] = useState<ExternalTrainingResponse | null>(null);
  const [externalModelName, setExternalModelName] = useState('');
  const [externalModelType, setExternalModelType] = useState<MLModelType>('sentiment');
  const [externalMaxEpochs, setExternalMaxEpochs] = useState(3);
  const [externalStarting, setExternalStarting] = useState(false);
  const [externalUploadFile, setExternalUploadFile] = useState<File | null>(null);
  const [externalUploading, setExternalUploading] = useState(false);
  const [copiedEndpoint, setCopiedEndpoint] = useState<string | null>(null);
  
  // SSE event sources ref
  const eventSourcesRef = useRef<Record<string, EventSource>>({});

  // Connect to SSE stream for a specific job
  const connectToJobStream = useCallback((jobId: string) => {
    // Don't connect if already connected
    if (eventSourcesRef.current[jobId]) return;
    
    try {
      const eventSource = connectTrainingStream(
        jobId,
        (event) => {
          // Update live metrics
          setLiveUpdates(prev => ({
            ...prev,
            [jobId]: event,
          }));
          
          // Update job status if state changed
          if (event.state === 'COMPLETED' || event.state === 'FAILED' || event.state === 'CANCELLED') {
            // Disconnect and refresh data
            disconnectFromJobStream(jobId);
            fetchData();
          }
        },
        (error) => {
          console.error(`SSE error for job ${jobId}:`, error);
          setSseConnected(prev => ({ ...prev, [jobId]: false }));
          // Try to reconnect after 5 seconds
          setTimeout(() => {
            if (jobs.some(j => j.job_id === jobId && (j.state === 'RUNNING' || j.state === 'INITIALIZING'))) {
              connectToJobStream(jobId);
            }
          }, 5000);
        }
      );
      
      eventSourcesRef.current[jobId] = eventSource;
      setSseConnected(prev => ({ ...prev, [jobId]: true }));
    } catch (e) {
      console.error(`Failed to connect SSE for job ${jobId}:`, e);
    }
  }, [jobs]);

  // Disconnect from SSE stream
  const disconnectFromJobStream = useCallback((jobId: string) => {
    const eventSource = eventSourcesRef.current[jobId];
    if (eventSource) {
      eventSource.close();
      delete eventSourcesRef.current[jobId];
      setSseConnected(prev => {
        const updated = { ...prev };
        delete updated[jobId];
        return updated;
      });
    }
  }, []);

  // Fetch health, jobs, and models
  const fetchData = useCallback(async () => {
    try {
      const [healthData, jobsData, modelsData] = await Promise.all([
        checkMLTrainerHealth().catch(() => null),
        listTrainingJobs().catch(() => []),
        listTrainedModels().catch(() => []),
      ]);
      setHealth(healthData);
      setJobs(jobsData);
      setModels(modelsData);
    } catch (e) {
      console.error('Failed to fetch ML trainer data:', e);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Initial fetch and polling
  useEffect(() => {
    fetchData();
    const interval = setInterval(fetchData, 15000); // Refresh every 15s (reduced since we have SSE)
    return () => clearInterval(interval);
  }, [fetchData]);

  // Connect SSE for running jobs
  useEffect(() => {
    const runningJobs = jobs.filter(j => j.state === 'RUNNING' || j.state === 'INITIALIZING');
    
    // Connect to running jobs
    runningJobs.forEach(job => {
      if (!eventSourcesRef.current[job.job_id]) {
        connectToJobStream(job.job_id);
      }
    });
    
    // Disconnect from jobs that are no longer running
    Object.keys(eventSourcesRef.current).forEach(jobId => {
      if (!runningJobs.some(j => j.job_id === jobId)) {
        disconnectFromJobStream(jobId);
      }
    });
  }, [jobs, connectToJobStream, disconnectFromJobStream]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      Object.values(eventSourcesRef.current).forEach(es => es.close());
    };
  }, []);

  // Merge live updates with job data
  const mergedJobs = useMemo(() => {
    return jobs.map(job => {
      const liveData = liveUpdates[job.job_id];
      if (liveData) {
        return {
          ...job,
          progress: liveData.progress ?? job.progress,
          state: liveData.state ?? job.state,
          current_epoch: liveData.current_epoch ?? job.current_epoch,
          total_epochs: liveData.total_epochs ?? job.total_epochs,
          metrics: {
            ...job.metrics,
            ...liveData.metrics,
          },
        };
      }
      return job;
    });
  }, [jobs, liveUpdates]);

  // Handle new training submission
  const handleNewTraining = async (request: TrainingRequest) => {
    setIsSubmitting(true);
    try {
      const response = await startTraining(request);
      toast({
        title: '학습 시작됨',
        description: `${response.model_name} 모델 학습이 시작되었습니다.`,
      });
      fetchData();
    } catch (e) {
      toast({
        title: '학습 시작 실패',
        description: e instanceof Error ? e.message : '알 수 없는 오류',
        variant: 'destructive',
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle job cancellation
  const handleCancelJob = async (jobId: string) => {
    try {
      await cancelTrainingJob(jobId);
      toast({
        title: '학습 취소됨',
        description: '학습 작업이 취소되었습니다.',
      });
      fetchData();
    } catch (e) {
      toast({
        title: '취소 실패',
        description: e instanceof Error ? e.message : '알 수 없는 오류',
        variant: 'destructive',
      });
    }
  };

  // Handle model download
  const handleDownloadModel = async (jobId: string) => {
    try {
      const blob = await downloadModelArtifact(jobId);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `model-${jobId}.zip`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      toast({
        title: '다운로드 시작',
        description: '모델 파일 다운로드가 시작되었습니다.',
      });
    } catch (e) {
      toast({
        title: '다운로드 실패',
        description: e instanceof Error ? e.message : '알 수 없는 오류',
        variant: 'destructive',
      });
    }
  };

  // Handle inference test
  const handleInference = (jobId: string) => {
    const job = mergedJobs.find((j) => j.job_id === jobId);
    if (job) {
      setInferenceJob({ jobId, modelName: job.model_name });
    }
  };

  // External Training Handlers
  const handleStartExternalTraining = async () => {
    if (!externalModelName.trim()) {
      toast({
        title: "모델 이름 필요",
        description: "모델 이름을 입력해주세요.",
        variant: "destructive",
      });
      return;
    }

    setExternalStarting(true);
    try {
      const request: ExternalTrainingRequest = {
        model_name: externalModelName.trim(),
        model_type: externalModelType,
        max_epochs: externalMaxEpochs,
      };
      const response = await startExternalTraining(request);
      setExternalResponse(response);
      toast({
        title: "외부 학습 준비 완료",
        description: `Job ID: ${response.job_id} - Colab/Jupyter에서 학습을 진행하세요.`,
      });
      fetchData();
    } catch (e) {
      toast({
        title: "외부 학습 시작 실패",
        description: e instanceof Error ? e.message : "알 수 없는 오류",
        variant: "destructive",
      });
    } finally {
      setExternalStarting(false);
    }
  };

  const handleUploadExternalModel = async () => {
    if (!externalResponse || !externalUploadFile) {
      toast({
        title: "파일 필요",
        description: "업로드할 모델 파일을 선택해주세요.",
        variant: "destructive",
      });
      return;
    }

    setExternalUploading(true);
    try {
      await uploadExternalModel(
        externalResponse.job_id,
        externalResponse.upload_token,
        externalUploadFile
      );
      toast({
        title: "모델 업로드 완료",
        description: "학습 완료 처리를 진행합니다...",
      });

      // Complete the training
      await completeExternalTraining(
        externalResponse.job_id,
        externalResponse.upload_token
      );
      toast({
        title: "외부 학습 완료",
        description: "모델이 성공적으로 등록되었습니다.",
      });

      // Reset state
      setExternalResponse(null);
      setExternalUploadFile(null);
      setExternalModelName('');
      setExternalTrainingOpen(false);
      fetchData();
    } catch (e) {
      toast({
        title: "업로드 실패",
        description: e instanceof Error ? e.message : "알 수 없는 오류",
        variant: "destructive",
      });
    } finally {
      setExternalUploading(false);
    }
  };

  const copyToClipboard = async (text: string, label: string) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopiedEndpoint(label);
      setTimeout(() => setCopiedEndpoint(null), 2000);
      toast({
        title: "복사됨",
        description: `${label}이(가) 클립보드에 복사되었습니다.`,
      });
    } catch (e) {
      toast({
        title: "복사 실패",
        description: "클립보드에 복사할 수 없습니다.",
        variant: "destructive",
      });
    }
  };

  const runningJobs = mergedJobs.filter((j) => j.state === 'RUNNING' || j.state === 'INITIALIZING' || j.state === 'PENDING');
  const completedJobs = mergedJobs.filter((j) => j.state === 'COMPLETED');
  const failedJobs = mergedJobs.filter((j) => j.state === 'FAILED' || j.state === 'CANCELLED');
  
  // Count live connections
  const liveConnectionCount = Object.keys(sseConnected).filter(k => sseConnected[k]).length;

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-6xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to="/"
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            메인으로 돌아가기
          </Link>
          <div className="flex items-center justify-between flex-wrap gap-4">
            <div>
              <h1 className="text-3xl md:text-4xl font-bold bg-gradient-to-r from-primary to-accent bg-clip-text text-transparent">
                ML 모델 학습
              </h1>
              <p className="text-muted-foreground">
                HuggingFace 기반 ML 모델을 학습하고 관리합니다.
              </p>
            </div>
            <div className="flex items-center gap-2">
              {liveConnectionCount > 0 && (
                <Badge variant="outline" className="animate-pulse border-green-500 text-green-600">
                  <Radio className="h-3 w-3 mr-1" />
                  Live ({liveConnectionCount})
                </Badge>
              )}
              <Button variant="outline" size="sm" onClick={fetchData}>
                <RefreshCw className="h-4 w-4 mr-2" />
                새로고침
              </Button>
              <Button onClick={() => setIsNewTrainingOpen(true)}>
                <Play className="h-4 w-4 mr-2" />
                새 학습 시작
              </Button>
            </div>
          </div>
        </header>

        {/* Health Status */}
        {health ? (
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
            <MetricCard
              label="서비스 상태"
              value={health.status === 'healthy' ? '정상' : '비정상'}
              icon={health.status === 'healthy' ? CheckCircle2 : XCircle}
            />
            <MetricCard
              label="GPU 사용 가능"
              value={health.gpu_available ? '예' : '아니오'}
              icon={Cpu}
            />
            <MetricCard
              label="활성 작업"
              value={`${health.active_jobs} / ${health.max_concurrent_jobs}`}
              icon={Activity}
            />
            <MetricCard
              label="저장된 작업"
              value={health.persisted_jobs}
              icon={HardDrive}
            />
          </div>
        ) : (
          <Alert variant="destructive" className="mb-8">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>연결 실패</AlertTitle>
            <AlertDescription>
              ML Trainer 서비스에 연결할 수 없습니다. 서비스가 실행 중인지 확인하세요.
            </AlertDescription>
          </Alert>
        )}

        {/* Main Content */}
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <TabsList className="mb-6">
            <TabsTrigger value="jobs" className="gap-2">
              <Activity className="h-4 w-4" />
              학습 작업
              {runningJobs.length > 0 && (
                <Badge variant="secondary" className="ml-1">
                  {runningJobs.length}
                </Badge>
              )}
            </TabsTrigger>
            <TabsTrigger value="models" className="gap-2">
              <Layers className="h-4 w-4" />
              학습된 모델
              {models.length > 0 && (
                <Badge variant="secondary" className="ml-1">
                  {models.length}
                </Badge>
              )}
            </TabsTrigger>
            <TabsTrigger value="datasets" className="gap-2">
              <Database className="h-4 w-4" />
              데이터셋
            </TabsTrigger>
            <TabsTrigger value="external" className="gap-2">
              <Cloud className="h-4 w-4" />
              외부 학습
            </TabsTrigger>
          </TabsList>

          {/* Jobs Tab */}
          <TabsContent value="jobs" className="space-y-6">
            {runningJobs.length > 0 && (
              <div className="space-y-4">
                <h3 className="text-lg font-semibold flex items-center gap-2">
                  <PlayCircle className="h-5 w-5 text-green-500" />
                  진행 중인 학습
                </h3>
                {runningJobs.map((job) => (
                  <TrainingJobCard
                    key={job.job_id}
                    job={job}
                    onCancel={handleCancelJob}
                    onInference={handleInference}
                    onDownload={handleDownloadModel}
                    isLive={sseConnected[job.job_id]}
                  />
                ))}
              </div>
            )}

            {completedJobs.length > 0 && (
              <div className="space-y-4">
                <h3 className="text-lg font-semibold flex items-center gap-2">
                  <CheckCircle2 className="h-5 w-5 text-emerald-500" />
                  완료된 학습
                </h3>
                {completedJobs.map((job) => (
                  <TrainingJobCard
                    key={job.job_id}
                    job={job}
                    onCancel={handleCancelJob}
                    onInference={handleInference}
                    onDownload={handleDownloadModel}
                    isLive={false}
                  />
                ))}
              </div>
            )}

            {failedJobs.length > 0 && (
              <div className="space-y-4">
                <h3 className="text-lg font-semibold flex items-center gap-2">
                  <XCircle className="h-5 w-5 text-red-500" />
                  실패/취소된 학습
                </h3>
                {failedJobs.slice(0, 5).map((job) => (
                  <TrainingJobCard
                    key={job.job_id}
                    job={job}
                    onCancel={handleCancelJob}
                    onInference={handleInference}
                    onDownload={handleDownloadModel}
                    isLive={false}
                  />
                ))}
              </div>
            )}

            {jobs.length === 0 && (
              <div className="text-center py-16">
                <Brain className="h-16 w-16 mx-auto text-muted-foreground/50 mb-4" />
                <h3 className="text-xl font-semibold mb-2">학습 작업이 없습니다</h3>
                <p className="text-muted-foreground mb-4">
                  새 ML 모델 학습을 시작해보세요.
                </p>
                <Button onClick={() => setIsNewTrainingOpen(true)}>
                  <Play className="h-4 w-4 mr-2" />
                  새 학습 시작
                </Button>
              </div>
            )}
          </TabsContent>

          {/* Models Tab */}
          <TabsContent value="models" className="space-y-4">
            {models.length > 0 ? (
              <div className="grid gap-4">
                {models.map((model) => (
                  <Card key={model.model_path}>
                    <CardContent className="p-4">
                      <div className="flex items-center justify-between">
                        <div>
                          <h4 className="font-semibold">{model.model_name}</h4>
                          <div className="flex items-center gap-2 mt-1">
                            <Badge variant="outline">{model.model_type}</Badge>
                            <Badge variant="secondary">{model.framework}</Badge>
                            <span className="text-xs text-muted-foreground">
                              {(model.size_bytes / 1024 / 1024).toFixed(2)} MB
                            </span>
                          </div>
                        </div>
                        <div className="flex gap-2">
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <Button variant="outline" size="icon">
                                  <Zap className="h-4 w-4" />
                                </Button>
                              </TooltipTrigger>
                              <TooltipContent>테스트</TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <Button variant="outline" size="icon">
                                  <Download className="h-4 w-4" />
                                </Button>
                              </TooltipTrigger>
                              <TooltipContent>다운로드</TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        </div>
                      </div>
                      {model.metrics && Object.keys(model.metrics).length > 0 && (
                        <div className="grid grid-cols-4 gap-2 mt-4 text-sm">
                          {Object.entries(model.metrics).slice(0, 4).map(([key, value]) => (
                            <div key={key} className="p-2 rounded bg-muted/50">
                              <p className="text-xs text-muted-foreground capitalize">{key.replace('_', ' ')}</p>
                              <p className="font-mono">{typeof value === 'number' ? value.toFixed(4) : value}</p>
                            </div>
                          ))}
                        </div>
                      )}
                    </CardContent>
                  </Card>
                ))}
              </div>
            ) : (
              <div className="text-center py-16">
                <Layers className="h-16 w-16 mx-auto text-muted-foreground/50 mb-4" />
                <h3 className="text-xl font-semibold mb-2">학습된 모델이 없습니다</h3>
                <p className="text-muted-foreground">
                  학습이 완료되면 여기에 모델이 표시됩니다.
                </p>
              </div>
            )}
          </TabsContent>

          {/* Datasets Tab */}
          <TabsContent value="datasets" className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {KOREAN_DATASETS.map((dataset) => (
                <Card key={dataset.id}>
                  <CardContent className="p-4">
                    <div className="flex items-start justify-between">
                      <div>
                        <h4 className="font-semibold">{dataset.name}</h4>
                        <p className="text-sm text-muted-foreground mt-1">{dataset.description}</p>
                      </div>
                      <a
                        href={`https://huggingface.co/datasets/${dataset.id}`}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-primary hover:underline"
                      >
                        <ExternalLink className="h-4 w-4" />
                      </a>
                    </div>
                    <div className="flex items-center gap-2 mt-3">
                      <Badge variant="outline">{dataset.size}</Badge>
                      <Badge variant="secondary">{MODEL_TYPE_LABELS[dataset.task as MLModelType] || dataset.task}</Badge>
                      <span className="text-xs text-muted-foreground ml-auto">
                        {dataset.downloads.toLocaleString()} downloads
                      </span>
                    </div>
                    <Button
                      className="w-full mt-3"
                      variant="outline"
                      onClick={() => {
                        setIsNewTrainingOpen(true);
                      }}
                    >
                      <Play className="h-4 w-4 mr-2" />
                      이 데이터셋으로 학습
                    </Button>
                  </CardContent>
                </Card>
              ))}
            </div>
          </TabsContent>

          {/* External Training Tab */}
          <TabsContent value="external" className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Cloud className="h-5 w-5" />
                  외부 환경에서 학습하기
                </CardTitle>
                <CardDescription>
                  Google Colab이나 Jupyter Notebook에서 직접 모델을 학습하고, 완료된 모델을 업로드하세요.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-6">
                {/* Step 1: Start External Training */}
                {!externalResponse ? (
                  <div className="space-y-4">
                    <h3 className="text-lg font-semibold flex items-center gap-2">
                      <span className="flex items-center justify-center w-6 h-6 rounded-full bg-primary text-primary-foreground text-sm">1</span>
                      외부 학습 시작
                    </h3>
                    
                    <div className="grid gap-4 md:grid-cols-2">
                      <div className="space-y-2">
                        <Label htmlFor="external-model-name">모델 이름 *</Label>
                        <Input
                          id="external-model-name"
                          placeholder="예: colab-sentiment-model"
                          value={externalModelName}
                          onChange={(e) => setExternalModelName(e.target.value)}
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label>모델 타입</Label>
                        <Select value={externalModelType} onValueChange={(v) => setExternalModelType(v as MLModelType)}>
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            {Object.entries(MODEL_TYPE_LABELS).map(([value, label]) => (
                              <SelectItem key={value} value={value}>
                                {label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </div>
                    </div>
                    
                    <div className="space-y-2">
                      <Label>최대 에폭 수</Label>
                      <Input
                        type="number"
                        value={externalMaxEpochs}
                        onChange={(e) => setExternalMaxEpochs(parseInt(e.target.value) || 3)}
                        min={1}
                        max={100}
                        className="w-32"
                      />
                    </div>
                    
                    <Button
                      onClick={handleStartExternalTraining}
                      disabled={externalStarting || !externalModelName.trim()}
                    >
                      {externalStarting ? (
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      ) : (
                        <Play className="h-4 w-4 mr-2" />
                      )}
                      외부 학습 시작
                    </Button>
                  </div>
                ) : (
                  <>
                    {/* Step 2: Copy API Endpoints */}
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold flex items-center gap-2">
                        <span className="flex items-center justify-center w-6 h-6 rounded-full bg-primary text-primary-foreground text-sm">2</span>
                        API 엔드포인트 복사
                      </h3>
                      
                      <Alert>
                        <AlertCircle className="h-4 w-4" />
                        <AlertTitle>Job ID: {externalResponse.job_id}</AlertTitle>
                        <AlertDescription>
                          아래 엔드포인트를 Colab/Jupyter에서 사용하세요. Upload Token은 안전하게 보관하세요.
                        </AlertDescription>
                      </Alert>
                      
                      <div className="grid gap-3">
                        <div className="flex items-center justify-between p-3 rounded-lg bg-muted/50">
                          <div>
                            <p className="text-sm font-medium">Upload Token</p>
                            <p className="text-xs text-muted-foreground font-mono truncate max-w-[300px]">
                              {externalResponse.upload_token}
                            </p>
                          </div>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => copyToClipboard(externalResponse.upload_token, 'Upload Token')}
                          >
                            {copiedEndpoint === 'Upload Token' ? (
                              <Check className="h-4 w-4 text-green-500" />
                            ) : (
                              <Copy className="h-4 w-4" />
                            )}
                          </Button>
                        </div>
                        
                        {Object.entries(externalResponse.api_endpoints).map(([key, value]) => (
                          <div key={key} className="flex items-center justify-between p-3 rounded-lg bg-muted/50">
                            <div>
                              <p className="text-sm font-medium capitalize">{key} Endpoint</p>
                              <p className="text-xs text-muted-foreground font-mono">{value}</p>
                            </div>
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => copyToClipboard(value, `${key} Endpoint`)}
                            >
                              {copiedEndpoint === `${key} Endpoint` ? (
                                <Check className="h-4 w-4 text-green-500" />
                              ) : (
                                <Copy className="h-4 w-4" />
                              )}
                            </Button>
                          </div>
                        ))}
                      </div>
                    </div>

                    <Separator />

                    {/* Step 3: Upload Completed Model */}
                    <div className="space-y-4">
                      <h3 className="text-lg font-semibold flex items-center gap-2">
                        <span className="flex items-center justify-center w-6 h-6 rounded-full bg-primary text-primary-foreground text-sm">3</span>
                        학습 완료 후 모델 업로드
                      </h3>
                      
                      <div className="space-y-2">
                        <Label htmlFor="model-file">모델 파일 (.pt, .bin, .safetensors 등)</Label>
                        <Input
                          id="model-file"
                          type="file"
                          accept=".pt,.bin,.safetensors,.ckpt,.h5,.pth"
                          onChange={(e) => setExternalUploadFile(e.target.files?.[0] || null)}
                        />
                        {externalUploadFile && (
                          <p className="text-sm text-muted-foreground">
                            선택됨: {externalUploadFile.name} ({(externalUploadFile.size / 1024 / 1024).toFixed(2)} MB)
                          </p>
                        )}
                      </div>
                      
                      <div className="flex gap-2">
                        <Button
                          onClick={handleUploadExternalModel}
                          disabled={externalUploading || !externalUploadFile}
                        >
                          {externalUploading ? (
                            <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                          ) : (
                            <Upload className="h-4 w-4 mr-2" />
                          )}
                          모델 업로드 및 완료
                        </Button>
                        <Button
                          variant="outline"
                          onClick={() => {
                            setExternalResponse(null);
                            setExternalUploadFile(null);
                          }}
                        >
                          취소
                        </Button>
                      </div>
                    </div>
                  </>
                )}

                <Separator />

                {/* Instructions */}
                <Collapsible>
                  <CollapsibleTrigger asChild>
                    <Button variant="ghost" className="w-full justify-between">
                      <span className="flex items-center gap-2">
                        <FileText className="h-4 w-4" />
                        Colab/Jupyter 사용 가이드
                      </span>
                      <ChevronDown className="h-4 w-4" />
                    </Button>
                  </CollapsibleTrigger>
                  <CollapsibleContent className="pt-4">
                    <div className="rounded-lg bg-muted p-4 text-sm space-y-3">
                      <p><strong>1. 외부 학습 시작:</strong> 위에서 모델 이름과 타입을 입력하고 시작하세요.</p>
                      <p><strong>2. API 정보 복사:</strong> 생성된 Job ID, Upload Token, API 엔드포인트를 복사하세요.</p>
                      <p><strong>3. Colab에서 학습:</strong> 제공된 API를 사용하여 진행 상황을 업데이트할 수 있습니다.</p>
                      <pre className="bg-background p-2 rounded text-xs overflow-x-auto">
{`# 진행 상황 업데이트 예시
import requests

requests.post(
    "{progress_endpoint}",
    json={
        "upload_token": "{token}",
        "progress": 50,
        "epoch": 2,
        "total_epochs": 4,
        "loss": 0.25
    }
)`}
                      </pre>
                      <p><strong>4. 모델 업로드:</strong> 학습이 완료되면 여기서 모델 파일을 업로드하세요.</p>
                    </div>
                  </CollapsibleContent>
                </Collapsible>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>

        {/* New Training Dialog */}
        <NewTrainingDialog
          open={isNewTrainingOpen}
          onOpenChange={setIsNewTrainingOpen}
          onSubmit={handleNewTraining}
          isSubmitting={isSubmitting}
        />

        {/* Inference Dialog */}
        {inferenceJob && (
          <InferenceDialog
            open={!!inferenceJob}
            onOpenChange={(open) => !open && setInferenceJob(null)}
            jobId={inferenceJob.jobId}
            modelName={inferenceJob.modelName}
          />
        )}
      </div>
    </div>
  );
};

export default MLTraining;

```

---

## frontend/src/pages/NewHome.tsx

```tsx
/**
 * NewHome - 새로운 홈 페이지
 * 
 * 구조:
 * - HeroSearchBar: 중앙 대형 검색창
 * - ContinueCard: 이어하기 카드
 * - QuickActionCards: 빠른 액션 (심층분석, 팩트체크, URL분석)
 * - RecentActivities: 최근 활동 내역 (페이지네이션)
 * - 사이드: TrendingTopics, UsageStreak
 * - 하단: RecommendedTemplates
 */

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  HeroSearchBar,
  ContinueCard,
  QuickActionCards,
  TrendingTopicsCompact,
  RecentActivities,
  RecommendedTemplates,
  UsageStreakCard,
} from '@/components/home';
import { useUsageStreak } from '@/hooks/useUsageStreak';
import { useTrendingTopics } from '@/hooks/useTrendingTopics';
import { getFavoriteTemplates, getMostUsedTemplates, type SearchTemplate } from '@/lib/api';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Sparkles, TrendingUp } from 'lucide-react';

const DEFAULT_USER_ID = 'default-user';

export function NewHome() {
  const navigate = useNavigate();
  const { stats: usageStats, isLoading: usageLoading } = useUsageStreak();
  const { topics: trending, personalizedTopics: recommended, isLoading: trendingLoading } = useTrendingTopics();

  const [templates, setTemplates] = useState<SearchTemplate[]>([]);
  const [templatesLoading, setTemplatesLoading] = useState(false);
  
  // 트렌딩 토픽이 없으면 개인화 토픽 사용
  const displayTopics = trending.length > 0 ? trending : recommended;

  // 트렌드 클릭
  const handleTrendingClick = (keyword: string) => {
    navigate('/search', { state: { query: keyword } });
  };


  useEffect(() => {
    let cancelled = false;
    const loadTemplates = async () => {
      setTemplatesLoading(true);
      try {
        const [favorites, mostUsed] = await Promise.all([
          getFavoriteTemplates(DEFAULT_USER_ID).catch(() => []),
          getMostUsedTemplates(DEFAULT_USER_ID, 10).catch(() => []),
        ]);

        if (cancelled) return;

        const merged = new Map<number, any>();
        [...favorites, ...mostUsed].forEach((t: any) => merged.set(t.id, t));
        setTemplates(Array.from(merged.values()));
      } finally {
        if (!cancelled) setTemplatesLoading(false);
      }
    };
    loadTemplates();
    return () => {
      cancelled = true;
    };
  }, []);

  return (
    <div className="min-h-[calc(100vh-8rem)] bg-gradient-to-b from-background to-muted/20">
      {/* Hero Section - 검색창 */}
      <section className="pt-12 pb-8 px-4">
        <div className="max-w-4xl mx-auto text-center space-y-6">
          {/* 환영 메시지 */}
          <div className="space-y-2">
            <h1 className="text-3xl md:text-4xl font-bold tracking-tight">
              오늘의 뉴스, 더 깊게 분석하세요
            </h1>
            <p className="text-muted-foreground text-lg">
              AI 기반 뉴스 분석 플랫폼
            </p>
          </div>

          {/* 메인 검색창 */}
          <HeroSearchBar className="max-w-2xl mx-auto" />

          {/* 연속 사용 뱃지 */}
          {!usageLoading && usageStats.currentStreak > 0 && (
            <div className="inline-flex items-center gap-2 px-3 py-1.5 bg-primary/10 rounded-full text-sm">
              <Sparkles className="h-4 w-4 text-primary" />
              <span className="font-medium">{usageStats.currentStreak}일 연속 사용 중!</span>
            </div>
          )}
        </div>
      </section>

      {/* Main Content */}
      <section className="pb-12 px-4">
        <div className="max-w-7xl mx-auto">
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Left Column - 메인 콘텐츠 */}
            <div className="lg:col-span-2 space-y-6">
              {/* 이어하기 카드 */}
              <ContinueCard />

              {/* 빠른 액션 카드들 */}
              <QuickActionCards />

              {/* 최근 활동 내역 - 백엔드 API에서 가져옴 */}
              <RecentActivities 
                pageSize={5}
                showFilters={true}
                showHeader={true}
              />

              {/* 추천 템플릿 */}
              <RecommendedTemplates
                templates={templates}
                isLoading={templatesLoading}
                showDefaults={false}
              />
            </div>

            {/* Right Column - 사이드바 */}
            <div className="space-y-6">
              {/* 사용 현황 */}
              <UsageStreakCard />

              {/* 오늘의 트렌드 */}
              <Card>
                <CardHeader className="pb-3">
                  <CardTitle className="text-base flex items-center gap-2">
                    <TrendingUp className="h-4 w-4" />
                    {trending.length > 0 ? '오늘의 트렌드' : '내 관심 주제'}
                  </CardTitle>
                </CardHeader>
                <CardContent className="pt-0">
                  {trendingLoading ? (
                    <div className="space-y-2">
                      {[...Array(5)].map((_, i) => (
                        <div key={i} className="h-8 bg-muted animate-pulse rounded" />
                      ))}
                    </div>
                  ) : displayTopics.length > 0 ? (
                    <TrendingTopicsCompact
                      topics={displayTopics}
                      onTopicClick={handleTrendingClick}
                    />
                  ) : (
                    <div className="text-center py-4 text-muted-foreground">
                      <p className="text-sm">아직 트렌드 데이터가 없습니다</p>
                      <p className="text-xs mt-1">검색을 시작해 보세요</p>
                    </div>
                  )}
                </CardContent>
              </Card>
            </div>
          </div>
        </div>
      </section>
    </div>
  );
}

export default NewHome;

```

---

## frontend/src/pages/NotFound.tsx

```tsx
import { useLocation } from "react-router-dom";
import { useEffect } from "react";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error("404 Error: User attempted to access non-existent route:", location.pathname);
  }, [location.pathname]);

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-100">
      <div className="text-center">
        <h1 className="mb-4 text-4xl font-bold">404</h1>
        <p className="mb-4 text-xl text-gray-600">Oops! Page not found</p>
        <a href="/" className="text-blue-500 underline hover:text-blue-700">
          Return to Home
        </a>
      </div>
    </div>
  );
};

export default NotFound;

```

---

## frontend/src/pages/Operations.tsx

```tsx
import { useEffect, useState, useCallback, useRef } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { ScrollArea } from '@/components/ui/scroll-area';
import {
  RefreshCw,
  Play,
  Database,
  Activity,
  Settings2,
  Clock,
  AlertTriangle,
  CheckCircle2,
  Loader2,
  FileText,
  Trash2,
  XCircle,
} from 'lucide-react';
import { SourceCard, type SourceInfo } from '@/components/admin/SourceCard';
import { JobStatusBadge } from '@/components/admin/JobStatusBadge';
import { LiveCounter } from '@/components/admin/LiveCounter';
import { LiveStream } from '@/components/admin/LiveStream';
import { useDashboardEvents } from '@/hooks/useDashboardEvents';
import {
  listCollectionJobs,
  getCollectionStats,
  startCollectionForAllSources,
  cancelCollectionJob,
  cleanupOldJobs,
  type CollectionJobDTO,
  type CollectionStatsDTO,
} from '@/lib/api/collection';
import {
  listUnprocessedData,
  markDataAsProcessed,
  type CollectedDataDTO,
} from '@/lib/api/data';
import { listSources, setSourceActive } from '@/lib/api';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';

function formatDateTime(dateString: string | null): string {
  if (!dateString) return '-';
  return new Date(dateString).toLocaleString('ko-KR');
}

function formatDuration(start: string | null, end: string | null): string {
  if (!start || !end) return '-';
  const diff = new Date(end).getTime() - new Date(start).getTime();
  if (diff < 1000) return `${diff}ms`;
  if (diff < 60000) return `${(diff / 1000).toFixed(1)}초`;
  return `${(diff / 60000).toFixed(1)}분`;
}

export default function Operations() {
  const queryClient = useQueryClient();
  const [activeTab, setActiveTab] = useState('sources');
  const autoStartTriggered = useRef(false);

  // 실시간 이벤트 스트림
  const { activityLogs, status: streamStatus, clearLogs } = useDashboardEvents({
    maxActivityLogs: 30,
  });

  // 소스 목록 조회
  const { data: sourcesData, isLoading: sourcesLoading } = useQuery({
    queryKey: ['sources'],
    queryFn: () => listSources(0, 100),
    refetchInterval: 30000,
  });

  // 수집 통계 조회
  const { data: collectionStats } = useQuery({
    queryKey: ['collectionStats'],
    queryFn: getCollectionStats,
    refetchInterval: 10000,
  });

  // 작업 목록 조회
  const { data: jobsData, isLoading: jobsLoading } = useQuery({
    queryKey: ['collectionJobs'],
    queryFn: () => listCollectionJobs(0, 50),
    refetchInterval: 5000,
  });

  // 미처리 데이터 조회
  const { data: unprocessedData, isLoading: unprocessedLoading } = useQuery({
    queryKey: ['unprocessedData'],
    queryFn: () => listUnprocessedData(0, 20),
    refetchInterval: 10000,
  });

  // 전체 수집 시작
  const startAllMutation = useMutation({
    mutationFn: startCollectionForAllSources,
    onSuccess: (data) => {
      toast.success(`${data.totalJobsStarted}개 소스 수집 시작`);
      queryClient.invalidateQueries({ queryKey: ['collectionJobs'] });
    },
    onError: (e) => {
      toast.error(e instanceof Error ? e.message : '수집 시작 실패');
    },
  });

  // 소스 활성화/비활성화
  const toggleSourceMutation = useMutation({
    mutationFn: ({ id, active }: { id: number; active: boolean }) =>
      setSourceActive(id, active),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['sources'] });
    },
  });

  // 데이터 처리 완료 표시
  const markProcessedMutation = useMutation({
    mutationFn: markDataAsProcessed,
    onSuccess: () => {
      toast.success('처리 완료로 표시됨');
      queryClient.invalidateQueries({ queryKey: ['unprocessedData'] });
    },
  });

  // 오래된 작업 정리
  const cleanupMutation = useMutation({
    mutationFn: () => cleanupOldJobs(30),
    onSuccess: (message) => {
      toast.success(message);
      queryClient.invalidateQueries({ queryKey: ['collectionJobs'] });
    },
  });

  // 작업 취소
  const cancelJobMutation = useMutation({
    mutationFn: cancelCollectionJob,
    onSuccess: () => {
      toast.success('작업이 취소되었습니다');
      queryClient.invalidateQueries({ queryKey: ['collectionJobs'] });
    },
    onError: (e) => {
      toast.error(e instanceof Error ? e.message : '작업 취소 실패');
    },
  });

  // 초기 로드 시 자동으로 전체 수집 시작
  useEffect(() => {
    // 이미 자동 시작이 트리거되었으면 무시
    if (autoStartTriggered.current) return;
    
    // 소스 데이터가 로드되지 않았거나 작업 데이터가 로드되지 않았으면 대기
    if (!sourcesData || !jobsData) return;
    
    // 활성화된 소스가 있는지 확인
    const activeSources = sourcesData.content.filter(s => s.active);
    if (activeSources.length === 0) return;
    
    // 이미 실행 중인 작업이 있으면 시작하지 않음
    const runningJobs = jobsData.content.filter(j => j.status === 'RUNNING' || j.status === 'PENDING');
    if (runningJobs.length > 0) {
      autoStartTriggered.current = true; // 이미 작업이 진행 중이면 플래그 설정
      return;
    }
    
    // 자동 시작 트리거
    autoStartTriggered.current = true;
    startAllMutation.mutate();
  }, [sourcesData, jobsData, startAllMutation]);

  const handleCancelJob = useCallback((jobId: number) => {
    cancelJobMutation.mutate(jobId);
  }, [cancelJobMutation]);

  const handleToggleSource = useCallback(async (id: number, active: boolean) => {
    await toggleSourceMutation.mutateAsync({ id, active });
  }, [toggleSourceMutation]);

  // 소스 데이터를 SourceInfo 형식으로 변환
  const sources: SourceInfo[] = (sourcesData?.content || []).map((s) => ({
    id: s.id,
    name: s.name,
    url: s.url,
    sourceType: s.sourceType,
    active: s.active,
    lastCollectedAt: s.lastCollectedAt,
    lastError: s.lastError,
    itemsCollectedToday: s.itemsCollectedToday,
    totalItemsCollected: s.totalItemsCollected,
  }));

  const runningJobs = jobsData?.content.filter((j) => j.status === 'RUNNING') || [];
  const isAnyRunning = runningJobs.length > 0;

  return (
    <div className="container py-6 space-y-6">
      {/* Header */}
      <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <Settings2 className="h-6 w-6 text-primary" />
            운영 관리
          </h1>
          <p className="text-muted-foreground text-sm mt-1">
            데이터 수집 및 처리 상태를 모니터링하고 제어합니다
          </p>
        </div>
        <div className="flex gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={() => cleanupMutation.mutate()}
            disabled={cleanupMutation.isPending}
          >
            <Trash2 className="h-4 w-4 mr-2" />
            오래된 작업 정리
          </Button>
          <Button
            size="sm"
            onClick={() => startAllMutation.mutate()}
            disabled={startAllMutation.isPending || isAnyRunning}
          >
            {startAllMutation.isPending || isAnyRunning ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <Play className="h-4 w-4 mr-2" />
            )}
            전체 수집 시작
          </Button>
        </div>
      </div>

      {/* Stats Cards */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <LiveCounter
          value={collectionStats?.totalSources ?? 0}
          label="전체 소스"
          icon={<Database className="h-4 w-4" />}
          subtitle={`${collectionStats?.activeSources ?? 0}개 활성`}
          showChange={false}
        />
        <LiveCounter
          value={collectionStats?.totalItemsCollected ?? 0}
          label="총 수집량"
          icon={<FileText className="h-4 w-4" />}
          showChange={false}
        />
        <LiveCounter
          value={collectionStats?.itemsCollectedToday ?? 0}
          label="오늘 수집"
          icon={<Activity className="h-4 w-4" />}
          showChange={false}
        />
        <LiveCounter
          value={unprocessedData?.totalElements ?? 0}
          label="대기 중"
          icon={<Clock className="h-4 w-4" />}
          subtitle="처리 대기열"
          showChange={false}
        />
      </div>

      {/* Main Content */}
      <div className="grid gap-6 lg:grid-cols-3">
        {/* Left: Tabs Content */}
        <div className="lg:col-span-2">
          <Tabs value={activeTab} onValueChange={setActiveTab}>
            <TabsList className="grid w-full grid-cols-3">
              <TabsTrigger value="sources">
                소스 관리
                <Badge variant="secondary" className="ml-2">
                  {sources.length}
                </Badge>
              </TabsTrigger>
              <TabsTrigger value="jobs">
                작업 내역
                {isAnyRunning && (
                  <Badge className="ml-2 bg-blue-500">
                    {runningJobs.length}
                  </Badge>
                )}
              </TabsTrigger>
              <TabsTrigger value="queue">
                대기열
                {(unprocessedData?.totalElements ?? 0) > 0 && (
                  <Badge variant="secondary" className="ml-2">
                    {unprocessedData?.totalElements}
                  </Badge>
                )}
              </TabsTrigger>
            </TabsList>

            {/* Sources Tab */}
            <TabsContent value="sources" className="mt-4">
              {sourcesLoading ? (
                <div className="flex items-center justify-center py-12">
                  <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
                </div>
              ) : sources.length === 0 ? (
                <div className="text-center py-12 text-muted-foreground">
                  등록된 소스가 없습니다
                </div>
              ) : (
                <div className="grid gap-4 md:grid-cols-2">
                  {sources.map((source) => (
                    <SourceCard
                      key={source.id}
                      source={source}
                      isCollecting={runningJobs.some((j) => j.sourceId === source.id)}
                      onToggleActive={handleToggleSource}
                      onCollectionComplete={() =>
                        queryClient.invalidateQueries({ queryKey: ['collectionJobs'] })
                      }
                    />
                  ))}
                </div>
              )}
            </TabsContent>

            {/* Jobs Tab */}
            <TabsContent value="jobs" className="mt-4">
              <ScrollArea className="h-[500px]">
                {jobsLoading ? (
                  <div className="flex items-center justify-center py-12">
                    <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
                  </div>
                ) : (jobsData?.content.length ?? 0) === 0 ? (
                  <div className="text-center py-12 text-muted-foreground">
                    수집 작업 내역이 없습니다
                  </div>
                ) : (
                  <div className="space-y-2">
                    {jobsData?.content.map((job) => (
                      <JobRow 
                        key={job.id} 
                        job={job} 
                        sources={sources} 
                        onCancel={handleCancelJob}
                        isCancelling={cancelJobMutation.isPending}
                      />
                    ))}
                  </div>
                )}
              </ScrollArea>
            </TabsContent>

            {/* Queue Tab */}
            <TabsContent value="queue" className="mt-4">
              <ScrollArea className="h-[500px]">
                {unprocessedLoading ? (
                  <div className="flex items-center justify-center py-12">
                    <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
                  </div>
                ) : (unprocessedData?.content.length ?? 0) === 0 ? (
                  <div className="text-center py-12 text-muted-foreground">
                    처리 대기 중인 데이터가 없습니다
                  </div>
                ) : (
                  <div className="space-y-2">
                    {unprocessedData?.content.map((data) => (
                      <QueueItem
                        key={data.id}
                        data={data}
                        onMarkProcessed={() => markProcessedMutation.mutate(data.id)}
                        isProcessing={markProcessedMutation.isPending}
                      />
                    ))}
                  </div>
                )}
              </ScrollArea>
            </TabsContent>
          </Tabs>
        </div>

        {/* Right: Live Stream */}
        <div className="lg:col-span-1">
          <LiveStream
            logs={activityLogs}
            status={streamStatus}
            maxVisible={20}
            title="실시간 활동"
            onClear={clearLogs}
            className="h-[600px]"
          />
        </div>
      </div>
    </div>
  );
}

// Job Row Component
function JobRow({ 
  job, 
  sources,
  onCancel,
  isCancelling,
}: { 
  job: CollectionJobDTO; 
  sources: SourceInfo[];
  onCancel: (id: number) => void;
  isCancelling: boolean;
}) {
  const source = sources.find((s) => s.id === job.sourceId);
  const canCancel = job.status === 'RUNNING' || job.status === 'PENDING';
  
  return (
    <div className="flex items-center justify-between p-3 rounded-lg border bg-card">
      <div className="flex items-center gap-3">
        <JobStatusBadge status={job.status} size="sm" />
        <div>
          <p className="text-sm font-medium">{source?.name ?? `소스 #${job.sourceId}`}</p>
          <p className="text-xs text-muted-foreground">
            {formatDateTime(job.startedAt)}
            {job.completedAt && ` (${formatDuration(job.startedAt, job.completedAt)})`}
          </p>
        </div>
      </div>
      <div className="flex items-center gap-2">
        <div className="text-right">
          {job.itemsCollected > 0 && (
            <p className="text-sm font-medium">{job.itemsCollected}건</p>
          )}
          {job.errorMessage && (
            <p className="text-xs text-red-600 max-w-[200px] truncate" title={job.errorMessage}>
              {job.errorMessage}
            </p>
          )}
        </div>
        {canCancel && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onCancel(job.id)}
            disabled={isCancelling}
            className="text-red-500 hover:text-red-700 hover:bg-red-50"
          >
            {isCancelling ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <XCircle className="h-4 w-4" />
            )}
          </Button>
        )}
      </div>
    </div>
  );
}

// Queue Item Component
function QueueItem({
  data,
  onMarkProcessed,
  isProcessing,
}: {
  data: CollectedDataDTO;
  onMarkProcessed: () => void;
  isProcessing: boolean;
}) {
  return (
    <div className="p-3 rounded-lg border bg-card">
      <div className="flex items-start justify-between gap-3">
        <div className="flex-1 min-w-0">
          <h4 className="text-sm font-medium line-clamp-1">{data.title || '제목 없음'}</h4>
          <p className="text-xs text-muted-foreground mt-1 line-clamp-2">
            {data.content?.substring(0, 150) || '내용 없음'}
          </p>
          <div className="flex items-center gap-2 mt-2 text-xs text-muted-foreground">
            <Clock className="h-3 w-3" />
            {formatDateTime(data.collectedAt)}
          </div>
        </div>
        <Button
          variant="outline"
          size="sm"
          onClick={onMarkProcessed}
          disabled={isProcessing}
        >
          {isProcessing ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <CheckCircle2 className="h-4 w-4" />
          )}
        </Button>
      </div>
    </div>
  );
}

```

---

## frontend/src/pages/ParallelSearch.tsx

```tsx
import { useState, useCallback, useRef, useEffect, useMemo } from "react";
import { Link, useLocation } from "react-router-dom";
import { useQuery } from "@tanstack/react-query";
import {
  Loader2,
  AlertCircle,
  Database,
  Globe,
  Brain,
  CheckCircle2,
  Clock,
  ExternalLink,
  RefreshCw,
  Zap,
  Shield,
  ChevronDown,
  ChevronUp,
  FolderOpen,
  Link as LinkIcon,
  X,
  Bot,
  Sparkles,
  Save,
  BookmarkPlus,
  Maximize2,
  FileText,
  Printer,
} from "lucide-react";
import { ExportButton } from "@/components/ExportButton";
import { ReportExportButton } from "@/components/ReportExportButton";
import { AnalysisExportMenu } from "@/components/AnalysisExportMenu";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { useToast } from "@/hooks/use-toast";
import { AnalysisBadges, type AnalysisData } from "@/components/AnalysisBadges";
import { EnhancedMarkdownRenderer } from "@/components/EnhancedMarkdownRenderer";
import { useUrlCollection } from "@/hooks/useUrlCollection";
import { useAutoSaveSearch } from "@/hooks/useSearchHistory";
import { SearchInputWithSuggestions } from "@/components/SearchInputWithSuggestions";
import { AdvancedFilters, defaultFilters, type SearchFilters } from "@/components/AdvancedFilters";
import { useLiveRegion } from "@/hooks/useAccessibility";
import {
  openUnifiedSearchStream,
  checkUnifiedSearchHealth,
  startUnifiedSearchJob,
  openUnifiedSearchJobStream,
  getUnifiedSearchJobStatus,
  saveSearchHistorySync,
  type UnifiedSearchResult,
  type UnifiedSearchEvent,
  type UnifiedSearchJob,
} from "@/lib/api";

// Source configuration with icons and colors
const SOURCE_CONFIG = {
  database: {
    label: "저장된 뉴스",
    icon: Database,
    color: "text-blue-600",
    bgColor: "bg-blue-100 dark:bg-blue-900/30",
    borderColor: "border-l-blue-500",
  },
  web: {
    label: "웹 검색",
    icon: Globe,
    color: "text-green-600",
    bgColor: "bg-green-100 dark:bg-green-900/30",
    borderColor: "border-l-green-500",
  },
  ai: {
    label: "AI 분석",
    icon: Brain,
    color: "text-purple-600",
    bgColor: "bg-purple-100 dark:bg-purple-900/30",
    borderColor: "border-l-purple-500",
  },
} as const;

type SourceType = keyof typeof SOURCE_CONFIG;

interface SourceStatus {
  status: "idle" | "connecting" | "searching" | "complete" | "error";
  message?: string;
  count: number;
}

interface SearchResultCardProps {
  result: UnifiedSearchResult;
  onSaveUrl?: (result: UnifiedSearchResult) => void;
  isUrlSaved?: boolean;
}

const SearchResultCard = ({ result, onSaveUrl, isUrlSaved = false }: SearchResultCardProps) => {
  const config = SOURCE_CONFIG[result.source];
  const SourceIcon = config.icon;

  // Convert result to AnalysisData format
  const analysisData: AnalysisData = {
    analyzed: result.analyzed,
    analysisStatus: result.analysisStatus as AnalysisData["analysisStatus"],
    reliabilityScore: result.reliabilityScore,
    reliabilityGrade: result.reliabilityGrade as AnalysisData["reliabilityGrade"],
    reliabilityColor: result.reliabilityColor as AnalysisData["reliabilityColor"],
    sentimentLabel: result.sentimentLabel as AnalysisData["sentimentLabel"],
    sentimentScore: result.sentimentScore,
    biasLabel: result.biasLabel,
    biasScore: result.biasScore,
    factcheckStatus: result.factcheckStatus as AnalysisData["factcheckStatus"],
    misinfoRisk: result.misinfoRisk as AnalysisData["misinfoRisk"],
    riskTags: result.riskTags,
    topics: result.topics,
    hasDiscussion: result.hasDiscussion,
    totalCommentCount: result.totalCommentCount,
    discussionSentiment: result.discussionSentiment,
  };

  const hasAnalysis = result.source === "database" && (result.analyzed || result.analysisStatus === "pending");

  return (
    <Card className={`${config.bgColor} border-l-4 ${config.borderColor} transition-all hover:shadow-md`}>
      <CardContent className="p-4">
        <div className="flex items-start justify-between gap-4">
          <div className="flex-1 min-w-0">
            <div className="flex items-center gap-2 mb-2">
              <Badge variant="outline" className={`${config.color} flex items-center gap-1`}>
                <SourceIcon className="h-3 w-3" />
                {result.sourceLabel || config.label}
              </Badge>
              {result.publishedAt && (
                <span className="text-xs text-muted-foreground flex items-center gap-1">
                  <Clock className="h-3 w-3" />
                  {new Date(result.publishedAt).toLocaleDateString("ko-KR")}
                </span>
              )}
            </div>
            {result.title && (
              <h4 className="font-semibold text-sm mb-1 line-clamp-2">{result.title}</h4>
            )}
            {result.snippet && (
              <p className="text-sm text-muted-foreground line-clamp-3 mb-2">{result.snippet}</p>
            )}
            {/* Analysis Badges - only for database results */}
            {hasAnalysis && (
              <div className="mt-2 pt-2 border-t border-border/50">
                <AnalysisBadges 
                  data={analysisData} 
                  size="sm" 
                  loading={result.analysisStatus === "pending"}
                />
              </div>
            )}
            {/* Topics */}
            {result.topics && result.topics.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-2">
                {result.topics.slice(0, 3).map((topic) => (
                  <Badge key={topic} variant="secondary" className="text-xs">
                    {topic}
                  </Badge>
                ))}
              </div>
            )}
          </div>
          <div className="flex flex-col gap-2">
            {result.url && (
              <>
                <a
                  href={result.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="shrink-0 p-2 rounded-md hover:bg-muted transition-colors"
                  title="원문 보기"
                >
                  <ExternalLink className="h-4 w-4" />
                </a>
                {onSaveUrl && (
                  <button
                    onClick={() => onSaveUrl(result)}
                    disabled={isUrlSaved}
                    className={`shrink-0 p-2 rounded-md transition-colors ${
                      isUrlSaved 
                        ? "text-green-600 cursor-default" 
                        : "hover:bg-muted text-muted-foreground hover:text-foreground"
                    }`}
                    title={isUrlSaved ? "컬렉션에 저장됨" : "컬렉션에 저장"}
                  >
                    {isUrlSaved ? (
                      <CheckCircle2 className="h-4 w-4" />
                    ) : (
                      <BookmarkPlus className="h-4 w-4" />
                    )}
                  </button>
                )}
              </>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

interface AIStreamCardProps {
  content: string;
  isComplete: boolean;
  onSave?: () => void;
  isSaved?: boolean;
  evidence?: UnifiedSearchResult[];
  jobId?: string;
  query?: string;
}

const AIStreamCard = ({ content, isComplete, onSave, isSaved = false, evidence = [], jobId, query = '' }: AIStreamCardProps) => {
  const [isExpanded, setIsExpanded] = useState(true);
  const [isFullViewOpen, setIsFullViewOpen] = useState(false);
  const [showFullContent, setShowFullContent] = useState(false);

  if (!content) return null;

  // Filter evidence to only include non-AI results with URLs
  const validEvidence = evidence.filter(r => r.source !== 'ai' && r.url);

  // Check if content is long (more than ~500 characters indicates substantial content)
  const isLongContent = content.length > 500;

  return (
    <Card className="bg-purple-100 dark:bg-purple-900/30 border-l-4 border-l-purple-500">
      <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
        <CardHeader className="pb-2">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Brain className="h-5 w-5 text-purple-600" />
              <CardTitle className="text-lg">AI 실시간 분석</CardTitle>
              {!isComplete && (
                <Loader2 className="h-4 w-4 animate-spin text-purple-600" />
              )}
              {isComplete && (
                <CheckCircle2 className="h-4 w-4 text-green-600" />
              )}
            </div>
            <div className="flex items-center gap-2">
              {/* Export Menu */}
              {isComplete && content && (
                <AnalysisExportMenu
                  content={content}
                  query={query}
                  jobId={jobId}
                  size="sm"
                  variant="outline"
                />
              )}
              {/* Full View Button */}
              {isComplete && (
                <Dialog open={isFullViewOpen} onOpenChange={setIsFullViewOpen}>
                  <DialogTrigger asChild>
                    <Button variant="outline" size="sm" className="gap-1">
                      <Maximize2 className="h-4 w-4" />
                      전체보기
                    </Button>
                  </DialogTrigger>
                  <DialogContent className="max-w-5xl max-h-[90vh] overflow-hidden flex flex-col">
                    <DialogHeader className="flex-shrink-0">
                      <div className="flex items-center justify-between">
                        <DialogTitle className="flex items-center gap-2">
                          <Brain className="h-5 w-5 text-purple-600" />
                          AI 분석 보고서
                        </DialogTitle>
                        <div className="flex items-center gap-2 mr-8">
                          <AnalysisExportMenu
                            content={content}
                            query={query}
                            jobId={jobId}
                            size="sm"
                            variant="default"
                          />
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => window.print()}
                            className="gap-1"
                          >
                            <Printer className="h-4 w-4" />
                            인쇄
                          </Button>
                        </div>
                      </div>
                      <DialogDescription>
                        "{query}" 검색에 대한 AI 분석 결과입니다. 내보내기 버튼으로 PDF, Markdown, HTML 형식으로 저장할 수 있습니다.
                      </DialogDescription>
                    </DialogHeader>
                    <div className="flex-1 overflow-y-auto space-y-6 pr-2 mt-4">
                      {/* AI Analysis Content */}
                      <div className="print:break-inside-avoid">
                        <h3 className="font-semibold mb-3 flex items-center gap-2 text-purple-700 dark:text-purple-300">
                          <FileText className="h-4 w-4" />
                          분석 내용
                        </h3>
                        <div className="bg-white/70 dark:bg-black/30 p-6 rounded-xl border shadow-sm">
                          <EnhancedMarkdownRenderer content={content} isStreaming={false} variant="report" />
                        </div>
                      </div>
                      
                      {/* Evidence / Source URLs */}
                      {validEvidence.length > 0 && (
                        <div className="print:break-inside-avoid">
                          <h3 className="font-semibold mb-3 flex items-center gap-2 text-blue-700 dark:text-blue-300">
                            <Globe className="h-4 w-4" />
                            참조 소스 ({validEvidence.length}개)
                          </h3>
                          <ScrollArea className="h-[300px] print:h-auto">
                            <div className="space-y-3 pr-4">
                              {validEvidence.map((item, index) => {
                                const sourceConfig = SOURCE_CONFIG[item.source];
                                const SourceIcon = sourceConfig?.icon || Globe;
                                return (
                                  <div
                                    key={item.id || index}
                                    className={`p-3 rounded-lg border-l-4 ${sourceConfig?.borderColor || 'border-l-gray-400'} ${sourceConfig?.bgColor || 'bg-gray-100 dark:bg-gray-800'}`}
                                  >
                                    <div className="flex items-start justify-between gap-2">
                                      <div className="flex-1 min-w-0">
                                        <div className="flex items-center gap-2 mb-1">
                                          <Badge variant="outline" className={`${sourceConfig?.color || 'text-gray-600'} text-xs`}>
                                            <SourceIcon className="h-3 w-3 mr-1" />
                                            {item.sourceLabel || sourceConfig?.label || item.source}
                                          </Badge>
                                          {item.publishedAt && (
                                            <span className="text-xs text-muted-foreground">
                                              {new Date(item.publishedAt).toLocaleDateString('ko-KR')}
                                            </span>
                                          )}
                                        </div>
                                        {item.title && (
                                          <h4 className="font-medium text-sm line-clamp-2 mb-1">{item.title}</h4>
                                        )}
                                        {item.snippet && (
                                          <p className="text-xs text-muted-foreground line-clamp-2">{item.snippet}</p>
                                        )}
                                      </div>
                                      {item.url && (
                                        <a
                                          href={item.url}
                                          target="_blank"
                                          rel="noopener noreferrer"
                                          className="shrink-0 p-2 rounded-md hover:bg-muted transition-colors print:hidden"
                                          title="원문 보기"
                                        >
                                          <ExternalLink className="h-4 w-4" />
                                        </a>
                                      )}
                                    </div>
                                  </div>
                                );
                              })}
                            </div>
                          </ScrollArea>
                        </div>
                      )}
                      
                      {validEvidence.length === 0 && (
                        <div className="text-center py-6 text-muted-foreground">
                          <Globe className="h-8 w-8 mx-auto mb-2 opacity-50" />
                          <p>참조된 소스가 없습니다.</p>
                        </div>
                      )}
                    </div>
                  </DialogContent>
                </Dialog>
              )}
              {isComplete && onSave && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={onSave}
                  disabled={isSaved}
                  className={isSaved ? "text-green-600 border-green-600" : ""}
                >
                  {isSaved ? (
                    <>
                      <CheckCircle2 className="h-4 w-4 mr-1" />
                      저장됨
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-1" />
                      분석 저장
                    </>
                  )}
                </Button>
              )}
              <CollapsibleTrigger asChild>
                <Button variant="ghost" size="sm">
                  {isExpanded ? <ChevronUp className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />}
                </Button>
              </CollapsibleTrigger>
            </div>
          </div>
        </CardHeader>
        <CollapsibleContent>
          <CardContent>
            <div className="bg-white/50 dark:bg-black/20 p-4 rounded-lg">
              {/* Show full content or truncated based on state */}
              {isLongContent && !showFullContent && isComplete ? (
                <>
                  <div className="max-h-[400px] overflow-hidden relative">
                    <EnhancedMarkdownRenderer content={content} isStreaming={false} variant="compact" />
                    {/* Gradient fade at bottom */}
                    <div className="absolute bottom-0 left-0 right-0 h-20 bg-gradient-to-t from-white/90 dark:from-black/40 to-transparent pointer-events-none" />
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setShowFullContent(true)}
                    className="w-full mt-2 text-purple-600 hover:text-purple-700 hover:bg-purple-100"
                  >
                    <ChevronDown className="h-4 w-4 mr-1" />
                    전체 내용 펼치기
                  </Button>
                </>
              ) : (
                <>
                  <EnhancedMarkdownRenderer content={content} isStreaming={!isComplete} />
                  {isLongContent && showFullContent && isComplete && (
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => setShowFullContent(false)}
                      className="w-full mt-2 text-purple-600 hover:text-purple-700 hover:bg-purple-100"
                    >
                      <ChevronUp className="h-4 w-4 mr-1" />
                      접기
                    </Button>
                  )}
                </>
              )}
            </div>
            
            {/* Evidence summary in main view when complete */}
            {isComplete && validEvidence.length > 0 && (
              <div className="mt-4 pt-4 border-t border-purple-200 dark:border-purple-800">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm font-medium text-purple-700 dark:text-purple-300 flex items-center gap-1">
                    <Globe className="h-4 w-4" />
                    참조 소스 ({validEvidence.length}개)
                  </span>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setIsFullViewOpen(true)}
                    className="text-xs text-purple-600"
                  >
                    모두 보기
                  </Button>
                </div>
                <div className="flex flex-wrap gap-2">
                  {validEvidence.slice(0, 5).map((item, index) => (
                    <a
                      key={item.id || index}
                      href={item.url}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-white/70 dark:bg-black/30 text-xs hover:bg-white dark:hover:bg-black/50 transition-colors"
                      title={item.title || item.url}
                    >
                      <ExternalLink className="h-3 w-3" />
                      <span className="max-w-[150px] truncate">
                        {item.sourceLabel || item.title || new URL(item.url).hostname}
                      </span>
                    </a>
                  ))}
                  {validEvidence.length > 5 && (
                    <span className="inline-flex items-center px-2 py-1 text-xs text-muted-foreground">
                      +{validEvidence.length - 5}개 더
                    </span>
                  )}
                </div>
              </div>
            )}
          </CardContent>
        </CollapsibleContent>
      </Collapsible>
    </Card>
  );
};

interface SourceStatusIndicatorProps {
  source: SourceType;
  status: SourceStatus;
}

const SourceStatusIndicator = ({ source, status }: SourceStatusIndicatorProps) => {
  const config = SOURCE_CONFIG[source];
  const SourceIcon = config.icon;

  return (
    <div className={`flex items-center gap-3 p-3 rounded-lg ${config.bgColor}`}>
      <div className={`p-2 rounded-full bg-white dark:bg-gray-800`}>
        <SourceIcon className={`h-5 w-5 ${config.color}`} />
      </div>
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2">
          <span className="font-medium text-sm">{config.label}</span>
          {status.status === "connecting" && (
            <Loader2 className="h-3 w-3 animate-spin text-yellow-600" />
          )}
          {status.status === "searching" && (
            <Loader2 className="h-3 w-3 animate-spin text-muted-foreground" />
          )}
          {status.status === "complete" && (
            <CheckCircle2 className="h-3 w-3 text-green-600" />
          )}
          {status.status === "error" && (
            <AlertCircle className="h-3 w-3 text-red-500" />
          )}
        </div>
        <p className="text-xs text-muted-foreground truncate">
          {status.status === "idle" && "대기 중"}
          {status.status === "connecting" && "연결 중..."}
          {status.status === "searching" && (status.message || "검색 중...")}
          {status.status === "complete" && `${status.count}개 결과`}
          {status.status === "error" && (status.message || "오류 발생")}
        </p>
      </div>
      <Badge variant="secondary" className="tabular-nums">
        {status.count}
      </Badge>
    </div>
  );
};

// Interface for priority URLs passed from UrlCollections page
interface PriorityUrl {
  id: string;
  url: string;
  name: string;
}

// Quick action cards for the home page
const QuickActions = () => (
  <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
    <Link to="/deep-search">
      <Card className="p-4 hover:shadow-md transition-all cursor-pointer border-purple-200 dark:border-purple-800 hover:border-purple-400">
        <div className="flex flex-col items-center text-center gap-2">
          <div className="p-3 rounded-full bg-purple-100 dark:bg-purple-900/30">
            <Sparkles className="h-6 w-6 text-purple-600" />
          </div>
          <span className="font-medium text-sm">Deep AI Search</span>
          <span className="text-xs text-muted-foreground">심층 AI 분석</span>
        </div>
      </Card>
    </Link>
    <Link to="/fact-check">
      <Card className="p-4 hover:shadow-md transition-all cursor-pointer border-green-200 dark:border-green-800 hover:border-green-400">
        <div className="flex flex-col items-center text-center gap-2">
          <div className="p-3 rounded-full bg-green-100 dark:bg-green-900/30">
            <Shield className="h-6 w-6 text-green-600" />
          </div>
          <span className="font-medium text-sm">팩트체크</span>
          <span className="text-xs text-muted-foreground">신뢰도 검증</span>
        </div>
      </Card>
    </Link>
    <Link to="/ai-agent">
      <Card className="p-4 hover:shadow-md transition-all cursor-pointer border-blue-200 dark:border-blue-800 hover:border-blue-400">
        <div className="flex flex-col items-center text-center gap-2">
          <div className="p-3 rounded-full bg-blue-100 dark:bg-blue-900/30">
            <Bot className="h-6 w-6 text-blue-600" />
          </div>
          <span className="font-medium text-sm">브라우저 에이전트</span>
          <span className="text-xs text-muted-foreground">자동 수집</span>
        </div>
      </Card>
    </Link>
    <Link to="/url-collections">
      <Card className="p-4 hover:shadow-md transition-all cursor-pointer border-orange-200 dark:border-orange-800 hover:border-orange-400">
        <div className="flex flex-col items-center text-center gap-2">
          <div className="p-3 rounded-full bg-orange-100 dark:bg-orange-900/30">
            <FolderOpen className="h-6 w-6 text-orange-600" />
          </div>
          <span className="font-medium text-sm">URL 컬렉션</span>
          <span className="text-xs text-muted-foreground">소스 관리</span>
        </div>
      </Card>
    </Link>
  </div>
);

const ParallelSearch = () => {
  const { toast } = useToast();
  const location = useLocation();
  const { addUrl, addFolder, collection, urlExists } = useUrlCollection();
  const { saveUnifiedSearch, saveFailedSearch } = useAutoSaveSearch();
  
  // Accessibility: Live region for screen reader announcements
  const { announce, LiveRegion } = useLiveRegion();
  
  const [query, setQuery] = useState("");
  const [filters, setFilters] = useState<SearchFilters>(defaultFilters);
  const [isSearching, setIsSearching] = useState(false);
  const [activeTab, setActiveTab] = useState<"all" | SourceType>("all");
  
  // Job-based search state
  const [currentJobId, setCurrentJobId] = useState<string | null>(null);
  const [jobStatus, setJobStatus] = useState<string>("idle");
  
  // Track search start time for duration calculation
  const [searchStartTime, setSearchStartTime] = useState<number | null>(null);
  
  // Priority URLs from URL Collections page
  const [priorityUrls, setPriorityUrls] = useState<PriorityUrl[]>([]);
  
  // Connection status state for initial SSE feedback
  const [connectionStatus, setConnectionStatus] = useState<"idle" | "connecting" | "connected" | "error">("idle");
  
  // Results state
  const [results, setResults] = useState<UnifiedSearchResult[]>([]);
  const [aiContent, setAiContent] = useState("");
  const [aiComplete, setAiComplete] = useState(false);
  
  // Saved analysis state
  const [isAnalysisSaved, setIsAnalysisSaved] = useState(false);
  
  // Track URLs already added to collection during this session
  const addedUrlsRef = useRef<Set<string>>(new Set());
  
  // Source status
  const [sourceStatus, setSourceStatus] = useState<Record<SourceType, SourceStatus>>({
    database: { status: "idle", count: 0 },
    web: { status: "idle", count: 0 },
    ai: { status: "idle", count: 0 },
  });
  
  const eventSourceRef = useRef<EventSource | null>(null);
  
  // Load priority URLs from location state or sessionStorage
  useEffect(() => {
    const locationState = location.state as { priorityUrls?: PriorityUrl[] } | null;
    if (locationState?.priorityUrls && locationState.priorityUrls.length > 0) {
      setPriorityUrls(locationState.priorityUrls);
      // Save to sessionStorage for persistence across page refreshes
      sessionStorage.setItem("parallelSearch_priorityUrls", JSON.stringify(locationState.priorityUrls));
      // Clear the location state to prevent re-adding on refresh
      window.history.replaceState({}, document.title);
    } else {
      // Try to load from sessionStorage
      const stored = sessionStorage.getItem("parallelSearch_priorityUrls");
      if (stored) {
        try {
          const parsed = JSON.parse(stored) as PriorityUrl[];
          setPriorityUrls(parsed);
        } catch {
          // Ignore parse errors
        }
      }
    }
  }, [location.state]);

  // Load query from location state (e.g., from Search History page)
  useEffect(() => {
    const locationState = location.state as { 
      query?: string; 
      fromHistory?: boolean; 
      historyId?: number;
      parentSearchId?: number;
      deriveFrom?: number;
      depthLevel?: number;
    } | null;
    
    if (locationState?.query && !isSearching && !currentJobId) {
      // Set the query
      setQuery(locationState.query);
      
      if (locationState.fromHistory) {
        toast({
          title: "검색 기록에서 연결됨",
          description: `"${locationState.query}" 검색어로 통합 검색을 시작할 수 있습니다.`,
        });
        // Clear the location state to prevent showing toast again
        window.history.replaceState({}, document.title);
      }
      
      if (locationState.deriveFrom) {
        toast({
          title: "파생 검색",
          description: "이전 검색에서 파생된 통합 검색을 시작합니다.",
        });
        // Clear the location state
        window.history.replaceState({}, document.title);
      }
    }
  }, [location.state, isSearching, currentJobId, toast]);
  
  // Restore jobId from URL query params or sessionStorage on mount
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const jobIdFromUrl = urlParams.get("jobId");
    const storedJobId = sessionStorage.getItem("parallelSearch_currentJobId");
    const storedQuery = sessionStorage.getItem("parallelSearch_query");
    
    const jobIdToRestore = jobIdFromUrl || storedJobId;
    
    if (jobIdToRestore) {
      // Restore job state
      setCurrentJobId(jobIdToRestore);
      if (storedQuery) {
        setQuery(storedQuery);
      }
      
      // Check job status and reconnect if still active
      getUnifiedSearchJobStatus(jobIdToRestore)
        .then((job) => {
          setQuery(job.query);
          setFilters(prev => ({ ...prev, timeWindow: job.window || prev.timeWindow }));
          setJobStatus(job.status);
          
          if (job.status === "PENDING" || job.status === "IN_PROGRESS") {
            // Reconnect to SSE stream
            reconnectToJob(jobIdToRestore);
          } else if (job.status === "COMPLETED") {
            toast({
              title: "검색 완료됨",
              description: "이전 검색이 이미 완료되었습니다. 새 검색을 시작하세요.",
            });
          } else if (job.status === "FAILED") {
            toast({
              title: "검색 실패",
              description: "이전 검색이 실패했습니다. 새 검색을 시작하세요.",
              variant: "destructive",
            });
          }
        })
        .catch(() => {
          // Job not found, clear stored state
          sessionStorage.removeItem("parallelSearch_currentJobId");
          sessionStorage.removeItem("parallelSearch_query");
          setCurrentJobId(null);
        });
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  
  // Function to reconnect to an existing job
  const reconnectToJob = useCallback(async (jobId: string) => {
    setIsSearching(true);
    setConnectionStatus("connecting");
    
    // Set all sources to "searching" state
    setSourceStatus({
      database: { status: "searching", message: "재연결 중...", count: 0 },
      web: { status: "searching", message: "재연결 중...", count: 0 },
      ai: { status: "searching", message: "재연결 중...", count: 0 },
    });
    
    try {
      const es = await openUnifiedSearchJobStream(jobId);
      eventSourceRef.current = es;
      
      setupEventHandlers(es, jobId);
      
      toast({
        title: "재연결됨",
        description: "검색 스트림에 다시 연결되었습니다.",
      });
    } catch (error) {
      console.error("Failed to reconnect to job:", error);
      setIsSearching(false);
      setConnectionStatus("error");
      toast({
        title: "재연결 실패",
        description: "검색 스트림에 다시 연결할 수 없습니다.",
        variant: "destructive",
      });
    }
  }, [toast]);
  
  // Remove a priority URL
  const removePriorityUrl = useCallback((id: string) => {
    setPriorityUrls((prev) => {
      const updated = prev.filter((u) => u.id !== id);
      if (updated.length > 0) {
        sessionStorage.setItem("parallelSearch_priorityUrls", JSON.stringify(updated));
      } else {
        sessionStorage.removeItem("parallelSearch_priorityUrls");
      }
      return updated;
    });
  }, []);
  
  // Clear all priority URLs
  const clearPriorityUrls = useCallback(() => {
    setPriorityUrls([]);
    sessionStorage.removeItem("parallelSearch_priorityUrls");
    toast({
      title: "초기화됨",
      description: "우선순위 URL이 모두 제거되었습니다.",
    });
  }, [toast]);

  // Health check
  const { data: healthData } = useQuery({
    queryKey: ["unifiedSearch", "health"],
    queryFn: checkUnifiedSearchHealth,
    staleTime: 60_000,
    retry: 0,
  });

  const isHealthy = healthData?.status === "available";

  // Auto-save unified search results when job completes
  useEffect(() => {
    if (jobStatus === "COMPLETED" && results.length > 0 && query.trim()) {
      const durationMs = searchStartTime ? Date.now() - searchStartTime : undefined;
      
      // Build AI summary object if available
      const aiSummary = aiContent ? { content: aiContent, complete: aiComplete } : undefined;
      
      saveUnifiedSearch(
        query.trim(),
        results.map((r) => ({
          id: r.id,
          source: r.source,
          title: r.title,
          snippet: r.snippet,
          url: r.url,
          publishedAt: r.publishedAt,
          reliabilityScore: r.reliabilityScore,
          sentimentLabel: r.sentimentLabel,
        })),
        aiSummary,
        durationMs,
        filters.timeWindow,
      );
    }
  }, [jobStatus, results, query, aiContent, aiComplete, filters.timeWindow, searchStartTime, saveUnifiedSearch]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
    };
  }, []);

  const resetState = useCallback(() => {
    setResults([]);
    setAiContent("");
    setAiComplete(false);
    setConnectionStatus("idle");
    setCurrentJobId(null);
    setJobStatus("idle");
    setIsAnalysisSaved(false);
    addedUrlsRef.current.clear();
    setSourceStatus({
      database: { status: "idle", count: 0 },
      web: { status: "idle", count: 0 },
      ai: { status: "idle", count: 0 },
    });
    // Clear stored job info
    sessionStorage.removeItem("parallelSearch_currentJobId");
    sessionStorage.removeItem("parallelSearch_query");
    // Update URL to remove jobId
    const url = new URL(window.location.href);
    url.searchParams.delete("jobId");
    window.history.replaceState({}, document.title, url.pathname);
  }, []);

  // Auto-save new URLs to collection
  const autoSaveUrl = useCallback((result: UnifiedSearchResult) => {
    if (!result.url || addedUrlsRef.current.has(result.url)) {
      return; // Skip if no URL or already added in this session
    }
    
    // Check if URL already exists in collection
    if (urlExists(result.url)) {
      return; // Skip if already exists
    }
    
    // Find or create "Auto-saved" folder
    let autoSavedFolderId = 'root';
    const autoSavedFolder = collection.root.children.find(
      (item) => item.type === 'folder' && item.name === '자동 저장됨'
    );
    
    if (!autoSavedFolder) {
      autoSavedFolderId = addFolder('root', '자동 저장됨', '검색 결과에서 자동으로 저장된 URL');
    } else {
      autoSavedFolderId = autoSavedFolder.id;
    }
    
    // Add URL to collection
    addUrl(
      autoSavedFolderId,
      result.url,
      result.title || undefined,
      result.snippet || undefined,
      result.topics || undefined
    );
    
    // Mark as added in this session
    addedUrlsRef.current.add(result.url);
    
    // Show toast notification
    toast({
      title: "URL 저장됨",
      description: `"${result.title || result.url}"이(가) 컬렉션에 추가되었습니다.`,
    });
  }, [addUrl, addFolder, urlExists, collection.root.children, toast]);

  // Save AI analysis result
  const handleSaveAnalysis = useCallback(async () => {
    if (!aiContent || !query) return;
    
    try {
      // Save to backend using search history API
      await saveSearchHistorySync({
        externalId: currentJobId || `analysis-${Date.now()}`,
        searchType: 'UNIFIED',
        query,
        resultCount: results.length,
        results: results.map(r => ({
          url: r.url,
          title: r.title,
          snippet: r.snippet,
          source: r.source,
          topics: r.topics,
        })),
        aiSummary: {
          content: aiContent,
          timestamp: new Date().toISOString(),
        },
        metadata: {
          savedManually: true,
          savedAt: new Date().toISOString(),
        },
        success: true,
      });
      
      setIsAnalysisSaved(true);
      toast({
        title: "분석 저장됨",
        description: `"${query}" 분석 결과가 저장되었습니다.`,
      });
    } catch (e) {
      console.error('Failed to save analysis:', e);
      toast({
        title: "저장 실패",
        description: "분석 결과를 저장하는 데 실패했습니다.",
        variant: "destructive",
      });
    }
  }, [aiContent, query, currentJobId, results, toast]);

  // Manual URL save handler for individual results
  const handleManualSaveUrl = useCallback((result: UnifiedSearchResult) => {
    if (!result.url) return;
    
    // Check if already saved
    if (urlExists(result.url) || addedUrlsRef.current.has(result.url)) {
      toast({
        title: "이미 저장됨",
        description: "이 URL은 이미 컬렉션에 저장되어 있습니다.",
      });
      return;
    }
    
    // Find or create "수동 저장" folder
    let manualFolderId = 'root';
    const manualFolder = collection.root.children.find(
      (item) => item.type === 'folder' && item.name === '수동 저장됨'
    );
    
    if (!manualFolder) {
      manualFolderId = addFolder('root', '수동 저장됨', '검색 결과에서 수동으로 저장한 URL');
    } else {
      manualFolderId = manualFolder.id;
    }
    
    // Add URL to collection
    addUrl(
      manualFolderId,
      result.url,
      result.title || undefined,
      result.snippet || undefined,
      result.topics || undefined
    );
    
    // Mark as added
    addedUrlsRef.current.add(result.url);
    
    toast({
      title: "URL 저장됨",
      description: `"${result.title || result.url}"이(가) 컬렉션에 추가되었습니다.`,
    });
  }, [addUrl, addFolder, urlExists, collection.root.children, toast]);

  // Check if a URL is saved in this session or collection
  const isUrlSaved = useCallback((url: string): boolean => {
    return urlExists(url) || addedUrlsRef.current.has(url);
  }, [urlExists]);

  // Setup event handlers for SSE stream
  const setupEventHandlers = useCallback((es: EventSource, jobId: string) => {
    // Handle job_status event (initial status on connection)
    es.addEventListener("job_status", (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        setConnectionStatus("connected");
        setJobStatus(data.status);
        if (data.query) setQuery(data.query);
        if (data.window) setFilters(prev => ({ ...prev, timeWindow: data.window }));
        
        // Set all sources to "searching" state if job is active
        if (data.status === "PENDING" || data.status === "IN_PROGRESS") {
          setSourceStatus({
            database: { status: "searching", message: "검색 중...", count: 0 },
            web: { status: "searching", message: "검색 중...", count: 0 },
            ai: { status: "searching", message: "분석 중...", count: 0 },
          });
        }
      } catch (e) {
        console.error("Failed to parse job_status event:", e);
      }
    });

    // Handle status event (source status updates)
    es.addEventListener("status", (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        const source = data.source as SourceType;
        setSourceStatus((prev) => ({
          ...prev,
          [source]: {
            status: "searching",
            message: data.message,
            count: prev[source].count,
          },
        }));
      } catch (e) {
        console.error("Failed to parse status event:", e);
      }
    });

    // Handle result event
    es.addEventListener("result", (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        if (data.result) {
          const newResult = data.result as UnifiedSearchResult;
          setResults((prev) => [...prev, newResult]);
          const source = data.source as SourceType;
          setSourceStatus((prev) => ({
            ...prev,
            [source]: {
              ...prev[source],
              count: prev[source].count + 1,
            },
          }));
          
          // Auto-save new URLs from web and database sources
                          if (source !== 'ai' && newResult.url) {
                            autoSaveUrl(newResult);
                          }
        }
      } catch (e) {
        console.error("Failed to parse result event:", e);
      }
    });

    // Handle ai_chunk event
    es.addEventListener("ai_chunk", (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        if (data.message) {
          setAiContent((prev) => prev + data.message);
        }
      } catch (e) {
        console.error("Failed to parse ai_chunk event:", e);
      }
    });

    // Handle source_complete event
    es.addEventListener("source_complete", (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        const source = data.source as SourceType;
        setSourceStatus((prev) => ({
          ...prev,
          [source]: {
            status: "complete",
            message: data.message,
            count: data.totalCount ?? prev[source].count,
          },
        }));
        if (source === "ai") {
          setAiComplete(true);
        }
      } catch (e) {
        console.error("Failed to parse source_complete event:", e);
      }
    });

    // Handle source_error event
    es.addEventListener("source_error", (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        const source = data.source as SourceType;
        setSourceStatus((prev) => ({
          ...prev,
          [source]: {
            status: "error",
            message: data.message,
            count: prev[source].count,
          },
        }));
      } catch (e) {
        console.error("Failed to parse source_error event:", e);
      }
    });

    // Handle done event (all sources completed)
    es.addEventListener("done", (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        setIsSearching(false);
        setJobStatus("COMPLETED");
        es.close();
        eventSourceRef.current = null;
        
        // Clear stored job since it's complete
        sessionStorage.removeItem("parallelSearch_currentJobId");
        
        // Announce completion for screen readers
        const resultCount = data.totalResults || results.length;
        announce(`검색 완료. ${resultCount}개의 결과를 찾았습니다.`, "polite");
        
        toast({
          title: "검색 완료",
          description: `${resultCount}개의 결과를 찾았습니다.`,
        });
      } catch (e) {
        console.error("Failed to parse done event:", e);
        setIsSearching(false);
      }
    });

    // Handle job_error event
    es.addEventListener("job_error", (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        setIsSearching(false);
        setJobStatus("FAILED");
        setConnectionStatus("error");
        es.close();
        eventSourceRef.current = null;
        
        sessionStorage.removeItem("parallelSearch_currentJobId");
        
        // Announce error for screen readers
        announce(`검색 오류가 발생했습니다. ${data.error || "다시 시도해주세요."}`, "assertive");
        
        toast({
          title: "검색 오류",
          description: data.error || "검색 중 오류가 발생했습니다.",
          variant: "destructive",
        });
      } catch (e) {
        console.error("Failed to parse job_error event:", e);
      }
    });

    // Handle error event
    es.addEventListener("error", () => {
      setIsSearching(false);
      setConnectionStatus("error");
      es.close();
      eventSourceRef.current = null;
      toast({
        title: "연결 오류",
        description: "검색 스트림 연결이 끊어졌습니다.",
        variant: "destructive",
      });
    });

    // Handle heartbeat (keep connection status as connected)
    es.addEventListener("heartbeat", () => {
      setConnectionStatus("connected");
    });

    // Handle generic onerror
    es.onerror = () => {
      // Only handle if not already handled by specific error events
      if (eventSourceRef.current === es) {
        setIsSearching(false);
        setConnectionStatus("error");
        es.close();
        eventSourceRef.current = null;
      }
    };
  }, [toast, results.length, autoSaveUrl]);

  // Core search execution logic - can be called directly without event
  // Accepts optional searchQuery parameter to allow immediate search with new query
  const executeSearch = useCallback(async (searchQuery?: string) => {
    const effectiveQuery = searchQuery ?? query;
    if (!effectiveQuery.trim() || isSearching) return;

    // Cleanup previous search
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
    }
    
    resetState();
    setIsSearching(true);
    setConnectionStatus("connecting");
    setSearchStartTime(Date.now()); // Track start time for duration

    try {
      // Step 1: Create a new search job with priorityUrls
      const priorityUrlStrings = priorityUrls.length > 0 
        ? priorityUrls.map(p => p.url) 
        : undefined;
      
      const job = await startUnifiedSearchJob(effectiveQuery.trim(), filters.timeWindow, priorityUrlStrings);
      
      setCurrentJobId(job.jobId);
      setJobStatus(job.status);
      
      // Store job info for reconnection after page refresh
      sessionStorage.setItem("parallelSearch_currentJobId", job.jobId);
      sessionStorage.setItem("parallelSearch_query", effectiveQuery.trim());
      
      // Update URL with jobId for sharing/bookmarking
      const url = new URL(window.location.href);
      url.searchParams.set("jobId", job.jobId);
      window.history.replaceState({}, document.title, url.toString());
      
      // Step 2: Connect to SSE stream for this job
      const es = await openUnifiedSearchJobStream(job.jobId);
      eventSourceRef.current = es;
      
      // Set all sources to "searching" state immediately
      setSourceStatus({
        database: { status: "searching", message: "검색 시작...", count: 0 },
        web: { status: "searching", message: "검색 시작...", count: 0 },
        ai: { status: "searching", message: "분석 시작...", count: 0 },
      });
      
      setConnectionStatus("connected");
      
      // Announce search start for screen readers
      announce(`"${effectiveQuery}" 검색을 시작합니다. 데이터베이스, 웹, AI에서 동시에 검색 중입니다.`, "polite");
      
      toast({
        title: "검색 시작",
        description: `검색 Job이 생성되었습니다. (${job.jobId.substring(0, 8)}...)`,
      });
      
      // Setup event handlers
      setupEventHandlers(es, job.jobId);

    } catch (error) {
      console.error("Failed to start search:", error);
      setIsSearching(false);
      setConnectionStatus("error");
      
      // Auto-save failed search
      const durationMs = searchStartTime ? Date.now() - searchStartTime : undefined;
      saveFailedSearch('UNIFIED', effectiveQuery, error instanceof Error ? error.message : 'Unknown error', durationMs);
      
      toast({
        title: "오류",
        description: "검색을 시작할 수 없습니다.",
        variant: "destructive",
      });
    }
  }, [query, filters.timeWindow, isSearching, resetState, toast, setupEventHandlers, searchStartTime, saveFailedSearch]);

  // Form submit handler - wraps executeSearch with preventDefault
  const handleSearch = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    executeSearch();
  }, [executeSearch]);

  const handleCancel = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    setIsSearching(false);
    setConnectionStatus("idle");
    setJobStatus("idle");
    // Clear stored job info
    sessionStorage.removeItem("parallelSearch_currentJobId");
    toast({
      title: "취소됨",
      description: "검색이 취소되었습니다.",
    });
  }, [toast]);

  // Retry search on error
  const handleRetry = useCallback(() => {
    executeSearch();
  }, [executeSearch]);

  const filteredResults = activeTab === "all"
    ? results
    : results.filter((r) => r.source === activeTab);

  const totalResults = results.length;
  const searchProgress = Object.values(sourceStatus).filter(
    (s) => s.status === "complete" || s.status === "error"
  ).length / 3 * 100;

  // Check if we should show the home/welcome state
  const showWelcomeState = !isSearching && results.length === 0 && !aiContent;

  return (
    <div className="min-h-screen py-8">
      {/* Live Region for screen reader announcements */}
      <LiveRegion />
      
      <div className="container mx-auto px-4 max-w-6xl">
        {/* Header */}
        <header className="mb-8 text-center">
          <h1 className="text-4xl md:text-5xl font-bold mb-3 bg-gradient-to-r from-blue-600 via-purple-600 to-green-600 bg-clip-text text-transparent">
            NewsInsight
          </h1>
          <p className="text-lg text-muted-foreground mb-2">
            AI 기반 통합 뉴스 분석 플랫폼
          </p>
          <p className="text-sm text-muted-foreground flex items-center justify-center gap-2">
            <Zap className="h-4 w-4" />
            데이터베이스, 웹, AI를 동시에 검색하여 실시간으로 결과를 표시합니다.
          </p>
          {isHealthy && (
            <Badge variant="outline" className="mt-3 text-green-600 border-green-600">
              <Shield className="h-3 w-3 mr-1" />
              서비스 정상
            </Badge>
          )}
          {healthData && !isHealthy && (
            <div className="mt-4 p-3 rounded-md bg-destructive/10 text-destructive text-sm flex items-center justify-center gap-2">
              <AlertCircle className="h-4 w-4" />
              통합 검색 서비스가 현재 사용 불가능합니다.
            </div>
          )}
        </header>

        {/* Priority URLs from URL Collections */}
        {priorityUrls.length > 0 && (
          <Card className="mb-6 border-orange-200 dark:border-orange-800 bg-orange-50/50 dark:bg-orange-900/10">
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <FolderOpen className="h-5 w-5 text-orange-600" />
                  <CardTitle className="text-lg">우선순위 URL</CardTitle>
                  <Badge variant="secondary">{priorityUrls.length}개</Badge>
                </div>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={clearPriorityUrls}
                  className="text-muted-foreground hover:text-destructive"
                >
                  <X className="h-4 w-4 mr-1" />
                  모두 제거
                </Button>
              </div>
              <CardDescription>
                URL 컬렉션에서 선택한 URL입니다. 검색 시 이 URL들이 우선적으로 분석됩니다.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="flex flex-wrap gap-2">
                {priorityUrls.map((item) => {
                  // Safe URL hostname extraction
                  let displayName = item.name;
                  if (!displayName && item.url) {
                    try {
                      displayName = new URL(item.url).hostname;
                    } catch {
                      displayName = item.url;
                    }
                  }
                  if (!displayName) {
                    displayName = '알 수 없는 URL';
                  }

                  return (
                    <Badge
                      key={item.id}
                      variant="outline"
                      className="pl-2 pr-1 py-1 flex items-center gap-1 bg-white dark:bg-gray-800"
                    >
                      <LinkIcon className="h-3 w-3 text-orange-500" />
                      <span className="max-w-[200px] truncate" title={item.url || ''}>
                        {displayName}
                      </span>
                      <button
                        onClick={() => removePriorityUrl(item.id)}
                        className="ml-1 p-0.5 rounded hover:bg-muted transition-colors"
                      >
                        <X className="h-3 w-3" />
                      </button>
                    </Badge>
                  );
                })}
              </div>
            </CardContent>
          </Card>
        )}

        {/* Search Form */}
        <Card className="mb-8">
          <CardContent className="pt-6">
            <form onSubmit={handleSearch} className="space-y-4">
              <div className="flex flex-col gap-4">
                {/* 검색 입력 with 제안/자동완성 */}
                <div className="flex flex-col sm:flex-row gap-4">
                  <div className="flex-1">
                    <SearchInputWithSuggestions
                      value={query}
                      onChange={setQuery}
                      onSearch={(q) => {
                        setQuery(q);
                        executeSearch(q);
                      }}
                      placeholder="뉴스 키워드를 입력하세요... (예: AI 기술, 경제 전망, 정치 이슈)"
                      isLoading={isSearching}
                      disabled={isHealthy === false}
                      size="lg"
                      trendingKeywords={["AI", "반도체", "기후변화", "경제", "선거"]}
                    />
                  </div>
                  {isSearching && (
                    <Button type="button" variant="outline" onClick={handleCancel} className="h-12">
                      취소
                    </Button>
                  )}
                </div>
                
                {/* 고급 필터 - 컴팩트 모드 */}
                <AdvancedFilters
                  filters={filters}
                  onFiltersChange={setFilters}
                  disabled={isSearching}
                  compact
                />
              </div>
            </form>
          </CardContent>
        </Card>

        {/* Quick Actions - Show on welcome state */}
        {showWelcomeState && <QuickActions />}

        {/* Search Progress */}
        {isSearching && (
          <Card className="mb-8">
            <CardHeader className="pb-2">
              <CardTitle className="text-lg flex items-center gap-2">
                <Loader2 className="h-5 w-5 animate-spin" />
                {connectionStatus === "connecting" ? "서버에 연결 중..." : "병렬 검색 진행 중..."}
              </CardTitle>
              <CardDescription>
                {connectionStatus === "connecting" 
                  ? "검색 서버와 실시간 연결을 설정하고 있습니다..."
                  : connectionStatus === "connected"
                    ? <>3개의 소스에서 동시에 검색하고 있습니다. {currentJobId && <span className="text-xs opacity-60">(Job: {currentJobId.substring(0, 8)}...)</span>}</>
                    : "연결 대기 중..."}
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* Connection Status Indicator */}
              {connectionStatus === "connecting" && (
                <div className="flex items-center gap-2 p-3 rounded-lg bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-200 text-sm">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  <span>SSE 스트림 연결 대기 중... 첫 이벤트를 기다리고 있습니다.</span>
                </div>
              )}
              {connectionStatus === "connected" && (
                <div className="flex items-center gap-2 p-3 rounded-lg bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200 text-sm">
                  <CheckCircle2 className="h-4 w-4" />
                  <span>서버에 연결됨 - 실시간 결과가 도착하는 대로 표시됩니다.</span>
                </div>
              )}
              
              <Progress value={searchProgress} className="h-2" />
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                {(Object.keys(SOURCE_CONFIG) as SourceType[]).map((source) => (
                  <SourceStatusIndicator
                    key={source}
                    source={source}
                    status={sourceStatus[source]}
                  />
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {/* Results */}
        {(results.length > 0 || aiContent) && (
          <div className="space-y-6">
            {/* Summary Stats */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <Card>
                <CardContent className="pt-6 text-center">
                  <p className="text-3xl font-bold">{totalResults}</p>
                  <p className="text-sm text-muted-foreground">전체 결과</p>
                </CardContent>
              </Card>
              {(Object.keys(SOURCE_CONFIG) as SourceType[]).map((source) => {
                const config = SOURCE_CONFIG[source];
                const count = sourceStatus[source].count;
                return (
                  <Card key={source}>
                    <CardContent className="pt-6 text-center">
                      <p className={`text-3xl font-bold ${config.color}`}>{count}</p>
                      <p className="text-sm text-muted-foreground">{config.label}</p>
                    </CardContent>
                  </Card>
                );
              })}
            </div>

            {/* AI Analysis (if available) */}
            {aiContent && (
              <AIStreamCard 
                content={aiContent} 
                isComplete={aiComplete}
                onSave={handleSaveAnalysis}
                isSaved={isAnalysisSaved}
                evidence={results}
                jobId={currentJobId || undefined}
                query={query}
              />
            )}

            {/* Results List */}
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <div>
                    <CardTitle>검색 결과</CardTitle>
                    <CardDescription>
                      '{query}'에 대한 검색 결과입니다.
                    </CardDescription>
                  </div>
                  <div className="flex items-center gap-2">
                    <ReportExportButton
                      jobId={currentJobId || ''}
                      query={query}
                      timeWindow="7d"
                      reportType="UNIFIED_SEARCH"
                      variant="outline"
                      size="default"
                      disabled={!currentJobId || results.length === 0}
                    />
                    <ExportButton
                      data={results.map(r => ({
                        id: r.id,
                        title: r.title,
                        snippet: r.snippet,
                        content: r.content,
                        url: r.url,
                        source: r.source,
                        publishedAt: r.publishedAt,
                        reliabilityScore: r.reliabilityScore,
                        sentimentLabel: r.sentimentLabel,
                      }))}
                      options={{
                        filename: `newsinsight-search-${query.replace(/\s+/g, '-')}`,
                        title: `"${query}" 검색 결과`,
                        metadata: {
                          검색어: query,
                          총결과: results.length,
                          DB결과: sourceStatus.database.count,
                          웹결과: sourceStatus.web.count,
                          AI분석: aiContent ? '포함됨' : '없음',
                          ...(aiContent && { AI분석내용: aiContent }),
                        },
                      }}
                      disabled={results.length === 0}
                    />
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as typeof activeTab)}>
                  <TabsList className="mb-4">
                    <TabsTrigger value="all">
                      전체 ({totalResults})
                    </TabsTrigger>
                    {(Object.keys(SOURCE_CONFIG) as SourceType[]).map((source) => {
                      const config = SOURCE_CONFIG[source];
                      const Icon = config.icon;
                      return (
                        <TabsTrigger key={source} value={source} className={config.color}>
                          <Icon className="h-4 w-4 mr-1" />
                          {sourceStatus[source].count}
                        </TabsTrigger>
                      );
                    })}
                  </TabsList>
                  <TabsContent value={activeTab}>
                    <ScrollArea className="h-[600px] pr-4">
                      <div className="space-y-4">
                        {filteredResults.length > 0 ? (
                          filteredResults.map((result) => (
                            <SearchResultCard 
                              key={result.id} 
                              result={result}
                              onSaveUrl={handleManualSaveUrl}
                              isUrlSaved={result.url ? isUrlSaved(result.url) : false}
                            />
                          ))
                        ) : (
                          <div className="text-center py-8 text-muted-foreground">
                            {activeTab === "all"
                              ? "검색 결과가 없습니다."
                              : `${SOURCE_CONFIG[activeTab].label}에서 결과를 찾을 수 없습니다.`}
                          </div>
                        )}
                      </div>
                    </ScrollArea>
                  </TabsContent>
                </Tabs>
              </CardContent>
            </Card>
          </div>
        )}

        {/* Connection Error State with Retry */}
        {connectionStatus === "error" && !isSearching && results.length === 0 && (
          <Card className="mb-8 border-red-200 dark:border-red-800 bg-red-50/50 dark:bg-red-900/10">
            <CardContent className="pt-6">
              <div className="flex flex-col items-center text-center gap-4">
                <div className="p-4 rounded-full bg-red-100 dark:bg-red-900/30">
                  <AlertCircle className="h-8 w-8 text-red-600" />
                </div>
                <div>
                  <h3 className="font-semibold text-lg mb-1">연결 오류</h3>
                  <p className="text-sm text-muted-foreground mb-4">
                    검색 서버와의 연결에 실패했습니다. 네트워크 연결을 확인하거나 잠시 후 다시 시도해주세요.
                  </p>
                  <div className="flex gap-2 justify-center">
                    <Button onClick={handleRetry} variant="default" className="gap-2">
                      <RefreshCw className="h-4 w-4" />
                      다시 시도
                    </Button>
                    <Button onClick={resetState} variant="outline">
                      초기화
                    </Button>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        )}

        {/* Empty State / Welcome */}
        {showWelcomeState && (
          <div className="text-center py-12">
            <div className="inline-flex items-center justify-center gap-4 mb-6">
              <div className="p-3 rounded-full bg-blue-100 dark:bg-blue-900/30">
                <Database className="h-8 w-8 text-blue-600" />
              </div>
              <div className="p-3 rounded-full bg-green-100 dark:bg-green-900/30">
                <Globe className="h-8 w-8 text-green-600" />
              </div>
              <div className="p-3 rounded-full bg-purple-100 dark:bg-purple-900/30">
                <Brain className="h-8 w-8 text-purple-600" />
              </div>
            </div>
            <h2 className="text-xl font-semibold mb-2">통합 병렬 검색</h2>
            <p className="text-muted-foreground max-w-md mx-auto mb-6">
              검색어를 입력하면 데이터베이스, 웹, AI가 동시에 검색을 시작합니다.
              결과는 실시간으로 화면에 표시됩니다.
            </p>
            <div className="flex flex-wrap justify-center gap-4 text-sm text-muted-foreground">
              <div className="flex items-center gap-2">
                <Database className="h-4 w-4 text-blue-600" />
                저장된 뉴스 데이터
              </div>
              <div className="flex items-center gap-2">
                <Globe className="h-4 w-4 text-green-600" />
                실시간 웹 크롤링
              </div>
              <div className="flex items-center gap-2">
                <Brain className="h-4 w-4 text-purple-600" />
                AI 심층 분석
              </div>
            </div>
          </div>
        )}

        {/* Link to Deep Analysis */}
        {results.length > 0 && (
          <div className="mt-8 text-center">
            <Link to="/deep-search">
              <Button variant="outline" size="lg" className="gap-2">
                <Shield className="h-5 w-5" />
                심층 분석 및 팩트체크로 이동
              </Button>
            </Link>
          </div>
        )}
      </div>
    </div>
  );
};

export default ParallelSearch;

```

---

## frontend/src/pages/ProjectDashboard.tsx

```tsx
import React, { useState, useEffect } from 'react';
import { Link, useParams, useNavigate } from 'react-router-dom';
import {
  ArrowLeft,
  FolderOpen,
  Plus,
  Search,
  MoreVertical,
  Settings,
  Trash2,
  Users,
  FileText,
  Clock,
  Filter,
  BookmarkIcon,
  ExternalLink,
  Eye,
  RefreshCw,
  Activity,
  ChevronRight,
  Bookmark,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Skeleton } from '@/components/ui/skeleton';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Separator } from '@/components/ui/separator';
import { cn } from '@/lib/utils';
import {
  useProjects,
  PROJECT_STATUS_LABELS,
  PROJECT_CATEGORY_LABELS,
  ITEM_TYPE_LABELS,
  MEMBER_ROLE_LABELS,
  type Project,
  type ProjectItem,
  type ProjectItemType,
  type ProjectActivityLog,
  type ProjectMember,
} from '@/hooks/useProjects';

// Item type icons
const ITEM_TYPE_ICONS: Record<ProjectItemType, React.ReactNode> = {
  ARTICLE: <FileText className="h-4 w-4" />,
  SEARCH_RESULT: <Search className="h-4 w-4" />,
  NOTE: <FileText className="h-4 w-4" />,
  DOCUMENT: <FileText className="h-4 w-4" />,
  URL: <ExternalLink className="h-4 w-4" />,
  EVIDENCE: <Eye className="h-4 w-4" />,
};

// Activity type labels
const ACTIVITY_TYPE_LABELS: Record<string, string> = {
  CREATED: '생성됨',
  UPDATED: '수정됨',
  ITEM_ADDED: '항목 추가',
  ITEM_REMOVED: '항목 삭제',
  MEMBER_ADDED: '멤버 추가',
  MEMBER_REMOVED: '멤버 삭제',
  STATUS_CHANGED: '상태 변경',
};

// Item Card Component
interface ItemCardProps {
  item: ProjectItem;
  onRead: () => void;
  onBookmark: () => void;
  onDelete: () => void;
}

function ItemCard({ item, onRead, onBookmark, onDelete }: ItemCardProps) {
  return (
    <Card className={cn(
      'transition-all hover:shadow-sm',
      !item.isRead && 'border-l-4 border-l-primary'
    )}>
      <CardContent className="p-4">
        <div className="flex items-start justify-between gap-3">
          <div className="flex items-start gap-3 flex-1 min-w-0">
            <div className="p-1.5 bg-muted rounded flex-shrink-0 mt-0.5">
              {ITEM_TYPE_ICONS[item.itemType]}
            </div>
            <div className="flex-1 min-w-0">
              <div className="flex items-center gap-2 mb-1">
                <Badge variant="outline" className="text-xs">
                  {ITEM_TYPE_LABELS[item.itemType]}
                </Badge>
                {item.category && (
                  <Badge variant="secondary" className="text-xs">
                    {item.category}
                  </Badge>
                )}
              </div>
              <h4 className="font-medium text-sm truncate">{item.title}</h4>
              {item.summary && (
                <p className="text-xs text-muted-foreground line-clamp-2 mt-1">
                  {item.summary}
                </p>
              )}
              {item.sourceUrl && (
                <a
                  href={item.sourceUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-xs text-primary hover:underline mt-1 inline-flex items-center gap-1"
                  onClick={(e) => e.stopPropagation()}
                >
                  <ExternalLink className="h-3 w-3" />
                  원본 보기
                </a>
              )}
              <p className="text-xs text-muted-foreground mt-2">
                {new Date(item.createdAt).toLocaleDateString('ko-KR')}
              </p>
            </div>
          </div>
          <div className="flex items-center gap-1 flex-shrink-0">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={onBookmark}
            >
              <Bookmark className={cn(
                'h-4 w-4',
                item.isBookmarked && 'fill-current text-yellow-500'
              )} />
            </Button>
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" className="h-8 w-8">
                  <MoreVertical className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                {!item.isRead && (
                  <DropdownMenuItem onClick={onRead}>
                    <Eye className="h-4 w-4 mr-2" />
                    읽음으로 표시
                  </DropdownMenuItem>
                )}
                {item.sourceUrl && (
                  <DropdownMenuItem asChild>
                    <a href={item.sourceUrl} target="_blank" rel="noopener noreferrer">
                      <ExternalLink className="h-4 w-4 mr-2" />
                      원본 열기
                    </a>
                  </DropdownMenuItem>
                )}
                <DropdownMenuSeparator />
                <DropdownMenuItem className="text-destructive" onClick={onDelete}>
                  <Trash2 className="h-4 w-4 mr-2" />
                  삭제
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

// Activity Item Component
function ActivityItem({ activity }: { activity: ProjectActivityLog }) {
  return (
    <div className="flex items-start gap-3 py-3">
      <div className="p-1.5 bg-muted rounded-full">
        <Activity className="h-3.5 w-3.5" />
      </div>
      <div className="flex-1 min-w-0">
        <p className="text-sm">
          <span className="font-medium">{activity.userId}</span>
          {' '}
          <span className="text-muted-foreground">
            {ACTIVITY_TYPE_LABELS[activity.action] || activity.action}
          </span>
        </p>
        {activity.details && (
          <p className="text-xs text-muted-foreground mt-0.5">
            {activity.details}
          </p>
        )}
        <p className="text-xs text-muted-foreground mt-1">
          {new Date(activity.createdAt).toLocaleString('ko-KR')}
        </p>
      </div>
    </div>
  );
}

// Member Item Component
function MemberItem({ member }: { member: ProjectMember }) {
  return (
    <div className="flex items-center justify-between py-2">
      <div className="flex items-center gap-2">
        <div className="h-8 w-8 rounded-full bg-primary/10 flex items-center justify-center">
          <span className="text-sm font-medium">
            {member.userId.charAt(0).toUpperCase()}
          </span>
        </div>
        <div>
          <p className="text-sm font-medium">{member.userId}</p>
          <p className="text-xs text-muted-foreground">
            {new Date(member.joinedAt).toLocaleDateString('ko-KR')} 참여
          </p>
        </div>
      </div>
      <Badge variant="outline" className="text-xs">
        {MEMBER_ROLE_LABELS[member.role]}
      </Badge>
    </div>
  );
}

// Loading Skeleton
function DashboardSkeleton() {
  return (
    <div className="space-y-6">
      <div className="flex items-center gap-3">
        <Skeleton className="h-12 w-12 rounded-lg" />
        <div>
          <Skeleton className="h-6 w-48" />
          <Skeleton className="h-4 w-32 mt-1" />
        </div>
      </div>
      <div className="grid gap-4 md:grid-cols-3">
        <Skeleton className="h-24" />
        <Skeleton className="h-24" />
        <Skeleton className="h-24" />
      </div>
      <Skeleton className="h-64" />
    </div>
  );
}

// Main ProjectDashboard Page
const ProjectDashboard = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const projectId = id ? parseInt(id, 10) : null;

  const {
    currentProject,
    loading,
    error,
    selectProject,
    getProjectStatsAction,
    // Items
    items,
    itemsLoading,
    itemsPage,
    itemsTotalPages,
    loadItems,
    searchItems,
    markItemRead,
    toggleItemBookmark,
    deleteItem,
    // Members
    members,
    loadMembers,
    // Activities
    activities,
    loadRecentActivities,
  } = useProjects({ autoLoad: false });

  const [activeTab, setActiveTab] = useState('items');
  const [itemTypeFilter, setItemTypeFilter] = useState<ProjectItemType | 'ALL'>('ALL');
  const [searchQuery, setSearchQuery] = useState('');
  const [stats, setStats] = useState<{
    itemCount: number;
    unreadCount: number;
    memberCount: number;
  } | null>(null);
  const [deleteTarget, setDeleteTarget] = useState<ProjectItem | null>(null);

  // Load project data
  useEffect(() => {
    if (projectId) {
      selectProject(projectId);
      loadItems(projectId);
      loadMembers(projectId);
      loadRecentActivities(projectId);
      getProjectStatsAction(projectId).then(setStats);
    }
  }, [projectId, selectProject, loadItems, loadMembers, loadRecentActivities, getProjectStatsAction]);

  // Handle item filter/search
  useEffect(() => {
    if (!projectId) return;
    
    const debounce = setTimeout(() => {
      if (searchQuery.trim()) {
        searchItems(projectId, searchQuery);
      } else {
        loadItems(projectId, itemTypeFilter === 'ALL' ? undefined : itemTypeFilter);
      }
    }, 300);
    return () => clearTimeout(debounce);
  }, [searchQuery, itemTypeFilter, projectId, searchItems, loadItems]);

  // Handle item actions
  const handleMarkRead = async (itemId: number) => {
    if (projectId) {
      await markItemRead(projectId, itemId);
    }
  };

  const handleToggleBookmark = async (itemId: number) => {
    if (projectId) {
      await toggleItemBookmark(projectId, itemId);
    }
  };

  const handleDeleteItem = async () => {
    if (projectId && deleteTarget) {
      await deleteItem(projectId, deleteTarget.id);
      setDeleteTarget(null);
    }
  };

  // Handle page change
  const handlePageChange = (page: number) => {
    if (!projectId) return;
    if (searchQuery.trim()) {
      searchItems(projectId, searchQuery, page);
    } else {
      loadItems(projectId, itemTypeFilter === 'ALL' ? undefined : itemTypeFilter, page);
    }
  };

  if (!projectId) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-muted-foreground">잘못된 프로젝트 ID입니다.</p>
      </div>
    );
  }

  if (loading && !currentProject) {
    return (
      <div className="min-h-screen py-8">
        <div className="container mx-auto px-4 max-w-6xl">
          <DashboardSkeleton />
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen py-8">
        <div className="container mx-auto px-4 max-w-6xl">
          <Card className="border-destructive">
            <CardContent className="py-8 text-center">
              <p className="text-destructive mb-4">{error}</p>
              <Button onClick={() => navigate('/projects')}>
                프로젝트 목록으로
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    );
  }

  if (!currentProject) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-muted-foreground">프로젝트를 찾을 수 없습니다.</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-6xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to="/projects"
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            프로젝트 목록
          </Link>
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-primary/10 rounded-lg">
                <FolderOpen className="h-6 w-6 text-primary" />
              </div>
              <div>
                <div className="flex items-center gap-2">
                  <h1 className="text-2xl font-bold">{currentProject.name}</h1>
                  <Badge variant="outline">
                    {PROJECT_CATEGORY_LABELS[currentProject.category]}
                  </Badge>
                  <Badge>
                    {PROJECT_STATUS_LABELS[currentProject.status]}
                  </Badge>
                </div>
                {currentProject.description && (
                  <p className="text-muted-foreground mt-1">
                    {currentProject.description}
                  </p>
                )}
              </div>
            </div>
            <div className="flex items-center gap-2">
              <Button variant="outline" asChild>
                <Link to={`/projects/${projectId}/settings`}>
                  <Settings className="h-4 w-4 mr-2" />
                  설정
                </Link>
              </Button>
              <Button asChild>
                <Link to={`/search?projectId=${projectId}`}>
                  <Plus className="h-4 w-4 mr-2" />
                  검색 추가
                </Link>
              </Button>
            </div>
          </div>
        </header>

        {/* Stats Cards */}
        <div className="grid gap-4 md:grid-cols-3 mb-8">
          <Card>
            <CardContent className="p-4 flex items-center gap-3">
              <div className="p-2 bg-blue-100 dark:bg-blue-900/30 rounded-lg">
                <FileText className="h-5 w-5 text-blue-600 dark:text-blue-400" />
              </div>
              <div>
                <p className="text-2xl font-bold">{stats?.itemCount || 0}</p>
                <p className="text-sm text-muted-foreground">전체 항목</p>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4 flex items-center gap-3">
              <div className="p-2 bg-orange-100 dark:bg-orange-900/30 rounded-lg">
                <Eye className="h-5 w-5 text-orange-600 dark:text-orange-400" />
              </div>
              <div>
                <p className="text-2xl font-bold">{stats?.unreadCount || 0}</p>
                <p className="text-sm text-muted-foreground">읽지 않음</p>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4 flex items-center gap-3">
              <div className="p-2 bg-green-100 dark:bg-green-900/30 rounded-lg">
                <Users className="h-5 w-5 text-green-600 dark:text-green-400" />
              </div>
              <div>
                <p className="text-2xl font-bold">{stats?.memberCount || 1}</p>
                <p className="text-sm text-muted-foreground">멤버</p>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Main Content */}
        <div className="grid gap-6 lg:grid-cols-3">
          {/* Items List (2 columns) */}
          <div className="lg:col-span-2">
            <Card>
              <CardHeader className="pb-3">
                <div className="flex items-center justify-between">
                  <CardTitle className="text-lg">수집된 항목</CardTitle>
                  <Button variant="ghost" size="sm" onClick={() => loadItems(projectId)}>
                    <RefreshCw className={cn('h-4 w-4', itemsLoading && 'animate-spin')} />
                  </Button>
                </div>
                <div className="flex flex-col sm:flex-row gap-3 mt-3">
                  <div className="relative flex-1">
                    <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                    <Input
                      placeholder="항목 검색..."
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      className="pl-9"
                    />
                  </div>
                  <Select
                    value={itemTypeFilter}
                    onValueChange={(v) => setItemTypeFilter(v as ProjectItemType | 'ALL')}
                  >
                    <SelectTrigger className="w-[140px]">
                      <Filter className="h-4 w-4 mr-2" />
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="ALL">모든 유형</SelectItem>
                      {(Object.keys(ITEM_TYPE_LABELS) as ProjectItemType[]).map((type) => (
                        <SelectItem key={type} value={type}>
                          {ITEM_TYPE_LABELS[type]}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </CardHeader>
              <CardContent>
                {itemsLoading && items.length === 0 ? (
                  <div className="space-y-3">
                    {Array.from({ length: 3 }).map((_, i) => (
                      <Skeleton key={i} className="h-24" />
                    ))}
                  </div>
                ) : items.length === 0 ? (
                  <div className="py-12 text-center">
                    <FileText className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
                    <p className="text-muted-foreground">
                      {searchQuery ? '검색 결과가 없습니다.' : '아직 수집된 항목이 없습니다.'}
                    </p>
                    {!searchQuery && (
                      <Button asChild className="mt-4">
                        <Link to={`/search?projectId=${projectId}`}>
                          <Plus className="h-4 w-4 mr-2" />
                          검색으로 항목 추가
                        </Link>
                      </Button>
                    )}
                  </div>
                ) : (
                  <div className="space-y-3">
                    {items.map((item) => (
                      <ItemCard
                        key={item.id}
                        item={item}
                        onRead={() => handleMarkRead(item.id)}
                        onBookmark={() => handleToggleBookmark(item.id)}
                        onDelete={() => setDeleteTarget(item)}
                      />
                    ))}
                  </div>
                )}

                {/* Pagination */}
                {itemsTotalPages > 1 && (
                  <div className="flex justify-center gap-2 mt-6">
                    <Button
                      variant="outline"
                      size="sm"
                      disabled={itemsPage === 0}
                      onClick={() => handlePageChange(itemsPage - 1)}
                    >
                      이전
                    </Button>
                    <span className="flex items-center px-4 text-sm text-muted-foreground">
                      {itemsPage + 1} / {itemsTotalPages}
                    </span>
                    <Button
                      variant="outline"
                      size="sm"
                      disabled={itemsPage >= itemsTotalPages - 1}
                      onClick={() => handlePageChange(itemsPage + 1)}
                    >
                      다음
                    </Button>
                  </div>
                )}
              </CardContent>
            </Card>
          </div>

          {/* Sidebar (1 column) */}
          <div className="space-y-6">
            {/* Members */}
            <Card>
              <CardHeader className="pb-3">
                <div className="flex items-center justify-between">
                  <CardTitle className="text-base">멤버</CardTitle>
                  <Button variant="ghost" size="sm" asChild>
                    <Link to={`/projects/${projectId}/settings#members`}>
                      <Settings className="h-4 w-4" />
                    </Link>
                  </Button>
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-1">
                  {members.slice(0, 5).map((member) => (
                    <MemberItem key={member.id} member={member} />
                  ))}
                  {members.length > 5 && (
                    <Button variant="link" className="w-full mt-2" asChild>
                      <Link to={`/projects/${projectId}/settings#members`}>
                        모든 멤버 보기 ({members.length})
                        <ChevronRight className="h-4 w-4 ml-1" />
                      </Link>
                    </Button>
                  )}
                  {members.length === 0 && (
                    <p className="text-sm text-muted-foreground text-center py-4">
                      멤버가 없습니다
                    </p>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Recent Activity */}
            <Card>
              <CardHeader className="pb-3">
                <CardTitle className="text-base">최근 활동</CardTitle>
              </CardHeader>
              <CardContent>
                <ScrollArea className="h-64">
                  <div className="divide-y">
                    {activities.slice(0, 10).map((activity) => (
                      <ActivityItem key={activity.id} activity={activity} />
                    ))}
                    {activities.length === 0 && (
                      <p className="text-sm text-muted-foreground text-center py-8">
                        아직 활동이 없습니다
                      </p>
                    )}
                  </div>
                </ScrollArea>
              </CardContent>
            </Card>
          </div>
        </div>

        {/* Delete Confirmation Dialog */}
        <AlertDialog open={!!deleteTarget} onOpenChange={() => setDeleteTarget(null)}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>항목 삭제</AlertDialogTitle>
              <AlertDialogDescription>
                "{deleteTarget?.title}" 항목을 삭제하시겠습니까?
                이 작업은 되돌릴 수 없습니다.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>취소</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleDeleteItem}
                className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
              >
                삭제
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </div>
  );
};

export default ProjectDashboard;

```

---

## frontend/src/pages/ProjectSettings.tsx

```tsx
import React, { useState, useEffect } from 'react';
import { Link, useParams, useNavigate, useLocation } from 'react-router-dom';
import {
  ArrowLeft,
  FolderOpen,
  Settings,
  Trash2,
  Users,
  UserPlus,
  Shield,
  Bell,
  Archive,
  Save,
  Clock,
  Play,
  Pause,
  CheckCircle,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Skeleton } from '@/components/ui/skeleton';
import { Separator } from '@/components/ui/separator';
import { Switch } from '@/components/ui/switch';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { cn } from '@/lib/utils';
import { useToast } from '@/hooks/use-toast';
import {
  useProjects,
  PROJECT_STATUS_LABELS,
  PROJECT_CATEGORY_LABELS,
  PROJECT_VISIBILITY_LABELS,
  MEMBER_ROLE_LABELS,
  type Project,
  type ProjectStatus,
  type ProjectCategory,
  type ProjectVisibility,
  type ProjectMember,
  type MemberRole,
} from '@/hooks/useProjects';

// Status icons
const STATUS_ICONS: Record<ProjectStatus, React.ReactNode> = {
  ACTIVE: <Play className="h-4 w-4 text-green-500" />,
  PAUSED: <Pause className="h-4 w-4 text-yellow-500" />,
  COMPLETED: <CheckCircle className="h-4 w-4 text-blue-500" />,
  ARCHIVED: <Archive className="h-4 w-4 text-gray-500" />,
};

// Invite Member Dialog
interface InviteMemberDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSubmit: (userId: string, role: MemberRole) => Promise<void>;
}

function InviteMemberDialog({ open, onOpenChange, onSubmit }: InviteMemberDialogProps) {
  const [userId, setUserId] = useState('');
  const [role, setRole] = useState<MemberRole>('VIEWER');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!userId.trim()) return;

    setIsSubmitting(true);
    try {
      await onSubmit(userId.trim(), role);
      setUserId('');
      setRole('VIEWER');
      onOpenChange(false);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>멤버 초대</DialogTitle>
          <DialogDescription>
            프로젝트에 새 멤버를 초대합니다.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="userId">사용자 ID</Label>
              <Input
                id="userId"
                value={userId}
                onChange={(e) => setUserId(e.target.value)}
                placeholder="초대할 사용자 ID 입력"
                required
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="role">역할</Label>
              <Select value={role} onValueChange={(v) => setRole(v as MemberRole)}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="ADMIN">관리자</SelectItem>
                  <SelectItem value="EDITOR">편집자</SelectItem>
                  <SelectItem value="VIEWER">뷰어</SelectItem>
                </SelectContent>
              </Select>
              <p className="text-xs text-muted-foreground">
                {role === 'ADMIN' && '모든 권한을 가집니다.'}
                {role === 'EDITOR' && '항목을 추가/수정할 수 있습니다.'}
                {role === 'VIEWER' && '항목을 조회만 할 수 있습니다.'}
              </p>
            </div>
          </div>
          <DialogFooter>
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              취소
            </Button>
            <Button type="submit" disabled={!userId.trim() || isSubmitting}>
              {isSubmitting ? '초대 중...' : '초대하기'}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

// Member Row Component
interface MemberRowProps {
  member: ProjectMember;
  isOwner: boolean;
  canManage: boolean;
  onUpdateRole: (role: MemberRole) => void;
  onRemove: () => void;
}

function MemberRow({ member, isOwner, canManage, onUpdateRole, onRemove }: MemberRowProps) {
  return (
    <div className="flex items-center justify-between py-3 px-4 bg-muted/30 rounded-lg">
      <div className="flex items-center gap-3">
        <div className="h-10 w-10 rounded-full bg-primary/10 flex items-center justify-center">
          <span className="text-lg font-medium">
            {member.userId.charAt(0).toUpperCase()}
          </span>
        </div>
        <div>
          <p className="font-medium">{member.userId}</p>
          <p className="text-sm text-muted-foreground">
            {new Date(member.joinedAt).toLocaleDateString('ko-KR')} 참여
          </p>
        </div>
      </div>
      <div className="flex items-center gap-2">
        {isOwner ? (
          <Badge>소유자</Badge>
        ) : canManage ? (
          <>
            <Select
              value={member.role}
              onValueChange={(v) => onUpdateRole(v as MemberRole)}
            >
              <SelectTrigger className="w-[120px]">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="ADMIN">관리자</SelectItem>
                <SelectItem value="EDITOR">편집자</SelectItem>
                <SelectItem value="VIEWER">뷰어</SelectItem>
              </SelectContent>
            </Select>
            <Button variant="ghost" size="icon" onClick={onRemove}>
              <Trash2 className="h-4 w-4 text-destructive" />
            </Button>
          </>
        ) : (
          <Badge variant="outline">{MEMBER_ROLE_LABELS[member.role]}</Badge>
        )}
      </div>
    </div>
  );
}

// Main ProjectSettings Page
const ProjectSettings = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const location = useLocation();
  const { toast } = useToast();
  const projectId = id ? parseInt(id, 10) : null;

  // Get initial tab from URL hash
  const initialTab = location.hash.replace('#', '') || 'general';

  const {
    currentProject,
    loading,
    error,
    selectProject,
    updateProjectAction,
    deleteProjectAction,
    // Members
    members,
    loadMembers,
    inviteMember,
    removeMember,
    updateMemberRole,
  } = useProjects({ autoLoad: false });

  const [activeTab, setActiveTab] = useState(initialTab);
  const [isSaving, setIsSaving] = useState(false);
  const [inviteDialogOpen, setInviteDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [removeMemberTarget, setRemoveMemberTarget] = useState<ProjectMember | null>(null);

  // Form state
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    category: 'RESEARCH' as ProjectCategory,
    visibility: 'PRIVATE' as ProjectVisibility,
    status: 'ACTIVE' as ProjectStatus,
  });

  // Load project data
  useEffect(() => {
    if (projectId) {
      selectProject(projectId);
      loadMembers(projectId);
    }
  }, [projectId, selectProject, loadMembers]);

  // Initialize form when project loads
  useEffect(() => {
    if (currentProject) {
      setFormData({
        name: currentProject.name,
        description: currentProject.description || '',
        category: currentProject.category,
        visibility: currentProject.visibility,
        status: currentProject.status,
      });
    }
  }, [currentProject]);

  // Handle tab change
  const handleTabChange = (tab: string) => {
    setActiveTab(tab);
    window.history.replaceState(null, '', `#${tab}`);
  };

  // Handle save
  const handleSave = async () => {
    if (!projectId) return;

    setIsSaving(true);
    try {
      await updateProjectAction(projectId, {
        name: formData.name,
        description: formData.description || undefined,
        category: formData.category,
        visibility: formData.visibility,
        status: formData.status,
      });
    } finally {
      setIsSaving(false);
    }
  };

  // Handle delete
  const handleDelete = async () => {
    if (!projectId) return;

    const success = await deleteProjectAction(projectId);
    if (success) {
      navigate('/projects');
    }
  };

  // Handle invite member
  const handleInviteMember = async (userId: string, role: MemberRole) => {
    if (!projectId) return;
    await inviteMember(projectId, userId, role);
  };

  // Handle update member role
  const handleUpdateMemberRole = async (memberUserId: string, role: MemberRole) => {
    if (!projectId) return;
    await updateMemberRole(projectId, memberUserId, role);
  };

  // Handle remove member
  const handleRemoveMember = async () => {
    if (!projectId || !removeMemberTarget) return;
    await removeMember(projectId, removeMemberTarget.userId);
    setRemoveMemberTarget(null);
  };

  // Check if current user is owner (simplified - in real app, check against actual user)
  const isOwner = currentProject?.ownerId === 'anonymous'; // Simplified check
  const canManageMembers = isOwner || members.some(m => m.userId === 'anonymous' && m.role === 'ADMIN');

  if (!projectId) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-muted-foreground">잘못된 프로젝트 ID입니다.</p>
      </div>
    );
  }

  if (loading && !currentProject) {
    return (
      <div className="min-h-screen py-8">
        <div className="container mx-auto px-4 max-w-4xl">
          <Skeleton className="h-8 w-32 mb-4" />
          <Skeleton className="h-12 w-64 mb-8" />
          <Skeleton className="h-96" />
        </div>
      </div>
    );
  }

  if (error || !currentProject) {
    return (
      <div className="min-h-screen py-8">
        <div className="container mx-auto px-4 max-w-4xl">
          <Card className="border-destructive">
            <CardContent className="py-8 text-center">
              <p className="text-destructive mb-4">{error || '프로젝트를 찾을 수 없습니다.'}</p>
              <Button onClick={() => navigate('/projects')}>
                프로젝트 목록으로
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-4xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to={`/projects/${projectId}`}
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            프로젝트로 돌아가기
          </Link>
          <div className="flex items-center gap-3">
            <div className="p-2 bg-primary/10 rounded-lg">
              <Settings className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h1 className="text-2xl font-bold">프로젝트 설정</h1>
              <p className="text-muted-foreground">{currentProject.name}</p>
            </div>
          </div>
        </header>

        {/* Settings Tabs */}
        <Tabs value={activeTab} onValueChange={handleTabChange}>
          <TabsList className="mb-6">
            <TabsTrigger value="general">
              <FolderOpen className="h-4 w-4 mr-2" />
              일반
            </TabsTrigger>
            <TabsTrigger value="members">
              <Users className="h-4 w-4 mr-2" />
              멤버
            </TabsTrigger>
            <TabsTrigger value="danger">
              <Shield className="h-4 w-4 mr-2" />
              위험 구역
            </TabsTrigger>
          </TabsList>

          {/* General Settings */}
          <TabsContent value="general">
            <Card>
              <CardHeader>
                <CardTitle>기본 정보</CardTitle>
                <CardDescription>
                  프로젝트의 기본 정보를 수정합니다.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-6">
                <div className="grid gap-2">
                  <Label htmlFor="name">프로젝트 이름</Label>
                  <Input
                    id="name"
                    value={formData.name}
                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  />
                </div>

                <div className="grid gap-2">
                  <Label htmlFor="description">설명</Label>
                  <Textarea
                    id="description"
                    value={formData.description}
                    onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                    rows={3}
                  />
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div className="grid gap-2">
                    <Label>카테고리</Label>
                    <Select
                      value={formData.category}
                      onValueChange={(v) => setFormData({ ...formData, category: v as ProjectCategory })}
                    >
                      <SelectTrigger>
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        {(Object.keys(PROJECT_CATEGORY_LABELS) as ProjectCategory[]).map((cat) => (
                          <SelectItem key={cat} value={cat}>
                            {PROJECT_CATEGORY_LABELS[cat]}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  <div className="grid gap-2">
                    <Label>공개 범위</Label>
                    <Select
                      value={formData.visibility}
                      onValueChange={(v) => setFormData({ ...formData, visibility: v as ProjectVisibility })}
                    >
                      <SelectTrigger>
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        {(Object.keys(PROJECT_VISIBILITY_LABELS) as ProjectVisibility[]).map((vis) => (
                          <SelectItem key={vis} value={vis}>
                            {PROJECT_VISIBILITY_LABELS[vis]}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                </div>

                <div className="grid gap-2">
                  <Label>상태</Label>
                  <div className="flex flex-wrap gap-2">
                    {(Object.keys(PROJECT_STATUS_LABELS) as ProjectStatus[]).map((status) => (
                      <Button
                        key={status}
                        type="button"
                        variant={formData.status === status ? 'default' : 'outline'}
                        size="sm"
                        onClick={() => setFormData({ ...formData, status })}
                        className="gap-2"
                      >
                        {STATUS_ICONS[status]}
                        {PROJECT_STATUS_LABELS[status]}
                      </Button>
                    ))}
                  </div>
                </div>

                <Separator />

                <div className="flex justify-end">
                  <Button onClick={handleSave} disabled={isSaving}>
                    <Save className="h-4 w-4 mr-2" />
                    {isSaving ? '저장 중...' : '변경사항 저장'}
                  </Button>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* Members Settings */}
          <TabsContent value="members">
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <div>
                    <CardTitle>프로젝트 멤버</CardTitle>
                    <CardDescription>
                      프로젝트에 참여하는 멤버를 관리합니다.
                    </CardDescription>
                  </div>
                  {canManageMembers && (
                    <Button onClick={() => setInviteDialogOpen(true)}>
                      <UserPlus className="h-4 w-4 mr-2" />
                      멤버 초대
                    </Button>
                  )}
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-3">
                  {members.length === 0 ? (
                    <p className="text-center text-muted-foreground py-8">
                      아직 멤버가 없습니다.
                    </p>
                  ) : (
                    members.map((member) => (
                      <MemberRow
                        key={member.id}
                        member={member}
                        isOwner={member.role === 'OWNER' || member.userId === currentProject.ownerId}
                        canManage={canManageMembers && member.userId !== currentProject.ownerId}
                        onUpdateRole={(role) => handleUpdateMemberRole(member.userId, role)}
                        onRemove={() => setRemoveMemberTarget(member)}
                      />
                    ))
                  )}
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* Danger Zone */}
          <TabsContent value="danger">
            <Card className="border-destructive">
              <CardHeader>
                <CardTitle className="text-destructive">위험 구역</CardTitle>
                <CardDescription>
                  아래 작업은 되돌릴 수 없습니다. 신중하게 진행해주세요.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-6">
                <div className="flex items-center justify-between p-4 border border-destructive/50 rounded-lg">
                  <div>
                    <h4 className="font-medium">프로젝트 보관</h4>
                    <p className="text-sm text-muted-foreground">
                      프로젝트를 보관 상태로 변경합니다. 나중에 복원할 수 있습니다.
                    </p>
                  </div>
                  <Button
                    variant="outline"
                    onClick={() => {
                      setFormData({ ...formData, status: 'ARCHIVED' });
                      handleSave();
                    }}
                    disabled={formData.status === 'ARCHIVED'}
                  >
                    <Archive className="h-4 w-4 mr-2" />
                    보관하기
                  </Button>
                </div>

                <div className="flex items-center justify-between p-4 border border-destructive rounded-lg bg-destructive/5">
                  <div>
                    <h4 className="font-medium text-destructive">프로젝트 삭제</h4>
                    <p className="text-sm text-muted-foreground">
                      프로젝트와 모든 항목이 영구적으로 삭제됩니다.
                    </p>
                  </div>
                  <Button
                    variant="destructive"
                    onClick={() => setDeleteDialogOpen(true)}
                  >
                    <Trash2 className="h-4 w-4 mr-2" />
                    삭제하기
                  </Button>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>

        {/* Invite Member Dialog */}
        <InviteMemberDialog
          open={inviteDialogOpen}
          onOpenChange={setInviteDialogOpen}
          onSubmit={handleInviteMember}
        />

        {/* Remove Member Confirmation */}
        <AlertDialog open={!!removeMemberTarget} onOpenChange={() => setRemoveMemberTarget(null)}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>멤버 제거</AlertDialogTitle>
              <AlertDialogDescription>
                "{removeMemberTarget?.userId}" 멤버를 프로젝트에서 제거하시겠습니까?
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>취소</AlertDialogCancel>
              <AlertDialogAction onClick={handleRemoveMember}>
                제거
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        {/* Delete Project Confirmation */}
        <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>프로젝트 삭제</AlertDialogTitle>
              <AlertDialogDescription>
                "{currentProject.name}" 프로젝트를 삭제하시겠습니까?
                이 작업은 되돌릴 수 없으며, 프로젝트의 모든 항목이 함께 삭제됩니다.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>취소</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleDelete}
                className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
              >
                삭제
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </div>
  );
};

export default ProjectSettings;

```

---

## frontend/src/pages/Projects.tsx

```tsx
import React, { useState, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import {
  ArrowLeft,
  FolderOpen,
  Plus,
  Search,
  MoreVertical,
  Settings,
  Trash2,
  Users,
  FileText,
  Clock,
  Filter,
  Grid3X3,
  List,
  RefreshCw,
  FolderPlus,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Skeleton } from '@/components/ui/skeleton';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { cn } from '@/lib/utils';
import {
  useProjects,
  PROJECT_STATUS_LABELS,
  PROJECT_CATEGORY_LABELS,
  PROJECT_VISIBILITY_LABELS,
  type Project,
  type ProjectStatus,
  type ProjectCategory,
  type ProjectVisibility,
} from '@/hooks/useProjects';

// Status badge color mapping
const STATUS_COLORS: Record<ProjectStatus, string> = {
  ACTIVE: 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400',
  PAUSED: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-400',
  COMPLETED: 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-400',
  ARCHIVED: 'bg-gray-100 text-gray-800 dark:bg-gray-900/30 dark:text-gray-400',
};

// Category icons
const CATEGORY_ICONS: Record<ProjectCategory, React.ReactNode> = {
  RESEARCH: <FileText className="h-4 w-4" />,
  MONITORING: <Clock className="h-4 w-4" />,
  FACT_CHECK: <Search className="h-4 w-4" />,
  TREND_ANALYSIS: <Grid3X3 className="h-4 w-4" />,
  CUSTOM: <FolderOpen className="h-4 w-4" />,
};

// Create Project Dialog
interface CreateProjectDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSubmit: (data: {
    name: string;
    description?: string;
    category: ProjectCategory;
    visibility: ProjectVisibility;
  }) => Promise<void>;
}

function CreateProjectDialog({ open, onOpenChange, onSubmit }: CreateProjectDialogProps) {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [category, setCategory] = useState<ProjectCategory>('RESEARCH');
  const [visibility, setVisibility] = useState<ProjectVisibility>('PRIVATE');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) return;

    setIsSubmitting(true);
    try {
      await onSubmit({
        name: name.trim(),
        description: description.trim() || undefined,
        category,
        visibility,
      });
      // Reset form
      setName('');
      setDescription('');
      setCategory('RESEARCH');
      setVisibility('PRIVATE');
      onOpenChange(false);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>새 프로젝트 만들기</DialogTitle>
          <DialogDescription>
            검색 결과와 분석 자료를 체계적으로 관리할 프로젝트를 만듭니다.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="name">프로젝트 이름 *</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="예: 2024년 대선 관련 팩트체크"
                required
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="description">설명</Label>
              <Textarea
                id="description"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="프로젝트에 대한 간단한 설명을 입력하세요."
                rows={3}
              />
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="grid gap-2">
                <Label htmlFor="category">카테고리</Label>
                <Select value={category} onValueChange={(v) => setCategory(v as ProjectCategory)}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {(Object.keys(PROJECT_CATEGORY_LABELS) as ProjectCategory[]).map((cat) => (
                      <SelectItem key={cat} value={cat}>
                        <span className="flex items-center gap-2">
                          {CATEGORY_ICONS[cat]}
                          {PROJECT_CATEGORY_LABELS[cat]}
                        </span>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              <div className="grid gap-2">
                <Label htmlFor="visibility">공개 범위</Label>
                <Select value={visibility} onValueChange={(v) => setVisibility(v as ProjectVisibility)}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {(Object.keys(PROJECT_VISIBILITY_LABELS) as ProjectVisibility[]).map((vis) => (
                      <SelectItem key={vis} value={vis}>
                        {PROJECT_VISIBILITY_LABELS[vis]}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              취소
            </Button>
            <Button type="submit" disabled={!name.trim() || isSubmitting}>
              {isSubmitting ? '생성 중...' : '프로젝트 만들기'}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

// Project Card Component
interface ProjectCardProps {
  project: Project;
  viewMode: 'grid' | 'list';
  onSelect: (project: Project) => void;
  onEdit: (project: Project) => void;
  onDelete: (project: Project) => void;
}

function ProjectCard({ project, viewMode, onSelect, onEdit, onDelete }: ProjectCardProps) {
  const isGrid = viewMode === 'grid';

  return (
    <Card
      className={cn(
        'cursor-pointer transition-all hover:shadow-md hover:border-primary/50',
        isGrid ? '' : 'flex items-center'
      )}
      onClick={() => onSelect(project)}
    >
      <CardHeader className={cn(isGrid ? '' : 'flex-1 py-4')}>
        <div className="flex items-start justify-between">
          <div className="flex items-center gap-2">
            <div className="p-1.5 bg-primary/10 rounded">
              {CATEGORY_ICONS[project.category]}
            </div>
            <div>
              <CardTitle className="text-base">{project.name}</CardTitle>
              {project.description && (
                <CardDescription className="line-clamp-1 mt-1">
                  {project.description}
                </CardDescription>
              )}
            </div>
          </div>
          <DropdownMenu>
            <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>
              <Button variant="ghost" size="icon" className="h-8 w-8">
                <MoreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={(e) => { e.stopPropagation(); onEdit(project); }}>
                <Settings className="h-4 w-4 mr-2" />
                설정
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem
                className="text-destructive"
                onClick={(e) => { e.stopPropagation(); onDelete(project); }}
              >
                <Trash2 className="h-4 w-4 mr-2" />
                삭제
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </CardHeader>
      {isGrid && (
        <CardContent className="pt-0">
          <div className="flex items-center justify-between text-sm">
            <div className="flex items-center gap-3 text-muted-foreground">
              <span className="flex items-center gap-1">
                <FileText className="h-3.5 w-3.5" />
                {project.itemCount || 0}
              </span>
              <span className="flex items-center gap-1">
                <Users className="h-3.5 w-3.5" />
                {project.memberCount || 1}
              </span>
            </div>
            <Badge className={cn('text-xs', STATUS_COLORS[project.status])}>
              {PROJECT_STATUS_LABELS[project.status]}
            </Badge>
          </div>
          <p className="text-xs text-muted-foreground mt-2">
            {new Date(project.updatedAt || project.createdAt).toLocaleDateString('ko-KR')} 업데이트
          </p>
        </CardContent>
      )}
      {!isGrid && (
        <div className="flex items-center gap-4 px-6 py-4">
          <div className="flex items-center gap-3 text-sm text-muted-foreground">
            <span className="flex items-center gap-1">
              <FileText className="h-3.5 w-3.5" />
              {project.itemCount || 0}
            </span>
            <span className="flex items-center gap-1">
              <Users className="h-3.5 w-3.5" />
              {project.memberCount || 1}
            </span>
          </div>
          <Badge className={cn('text-xs', STATUS_COLORS[project.status])}>
            {PROJECT_STATUS_LABELS[project.status]}
          </Badge>
          <span className="text-xs text-muted-foreground">
            {new Date(project.updatedAt || project.createdAt).toLocaleDateString('ko-KR')}
          </span>
        </div>
      )}
    </Card>
  );
}

// Loading Skeleton
function ProjectCardSkeleton({ viewMode }: { viewMode: 'grid' | 'list' }) {
  if (viewMode === 'list') {
    return (
      <Card className="flex items-center">
        <CardHeader className="flex-1 py-4">
          <div className="flex items-center gap-2">
            <Skeleton className="h-8 w-8 rounded" />
            <div>
              <Skeleton className="h-4 w-40" />
              <Skeleton className="h-3 w-60 mt-1" />
            </div>
          </div>
        </CardHeader>
        <div className="flex items-center gap-4 px-6 py-4">
          <Skeleton className="h-4 w-16" />
          <Skeleton className="h-5 w-12 rounded-full" />
          <Skeleton className="h-3 w-20" />
        </div>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center gap-2">
          <Skeleton className="h-8 w-8 rounded" />
          <div className="flex-1">
            <Skeleton className="h-4 w-32" />
            <Skeleton className="h-3 w-48 mt-1" />
          </div>
        </div>
      </CardHeader>
      <CardContent className="pt-0">
        <div className="flex items-center justify-between">
          <Skeleton className="h-4 w-20" />
          <Skeleton className="h-5 w-12 rounded-full" />
        </div>
        <Skeleton className="h-3 w-24 mt-2" />
      </CardContent>
    </Card>
  );
}

// Main Projects Page
const Projects = () => {
  const navigate = useNavigate();
  const {
    projects,
    loading,
    error,
    totalElements,
    currentPage,
    totalPages,
    loadProjects,
    searchProjectsAction,
    createProjectAction,
    deleteProjectAction,
    refresh,
  } = useProjects({ autoLoad: true });

  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<ProjectStatus | 'ALL'>('ALL');
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState<Project | null>(null);

  // Handle search
  useEffect(() => {
    const debounce = setTimeout(() => {
      if (searchQuery.trim()) {
        searchProjectsAction(searchQuery);
      } else {
        loadProjects(0, statusFilter === 'ALL' ? undefined : statusFilter);
      }
    }, 300);
    return () => clearTimeout(debounce);
  }, [searchQuery, statusFilter, searchProjectsAction, loadProjects]);

  // Handle status filter change
  const handleStatusFilterChange = (value: string) => {
    setStatusFilter(value as ProjectStatus | 'ALL');
    setSearchQuery('');
  };

  // Handle create project
  const handleCreateProject = async (data: {
    name: string;
    description?: string;
    category: ProjectCategory;
    visibility: ProjectVisibility;
  }) => {
    await createProjectAction({
      ...data,
      ownerId: 'anonymous', // Will be set by hook
    });
  };

  // Handle select project
  const handleSelectProject = (project: Project) => {
    navigate(`/projects/${project.id}`);
  };

  // Handle edit project
  const handleEditProject = (project: Project) => {
    navigate(`/projects/${project.id}/settings`);
  };

  // Handle delete project
  const handleDeleteProject = async () => {
    if (deleteTarget) {
      await deleteProjectAction(deleteTarget.id);
      setDeleteTarget(null);
    }
  };

  // Handle page change
  const handlePageChange = (page: number) => {
    if (searchQuery.trim()) {
      searchProjectsAction(searchQuery, page);
    } else {
      loadProjects(page, statusFilter === 'ALL' ? undefined : statusFilter);
    }
  };

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-6xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to="/"
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            홈으로 돌아가기
          </Link>
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-primary/10 rounded-lg">
                <FolderOpen className="h-6 w-6 text-primary" />
              </div>
              <div>
                <h1 className="text-3xl font-bold">프로젝트</h1>
                <p className="text-muted-foreground">
                  {totalElements}개의 프로젝트
                </p>
              </div>
            </div>
            <Button onClick={() => setCreateDialogOpen(true)}>
              <Plus className="h-4 w-4 mr-2" />
              새 프로젝트
            </Button>
          </div>
        </header>

        {/* Toolbar */}
        <div className="flex flex-col sm:flex-row gap-4 mb-6">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="프로젝트 검색..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-9"
            />
          </div>
          <div className="flex items-center gap-2">
            <Select value={statusFilter} onValueChange={handleStatusFilterChange}>
              <SelectTrigger className="w-[140px]">
                <Filter className="h-4 w-4 mr-2" />
                <SelectValue placeholder="상태" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="ALL">모든 상태</SelectItem>
                {(Object.keys(PROJECT_STATUS_LABELS) as ProjectStatus[]).map((status) => (
                  <SelectItem key={status} value={status}>
                    {PROJECT_STATUS_LABELS[status]}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <div className="flex items-center border rounded-md">
              <Button
                variant={viewMode === 'grid' ? 'secondary' : 'ghost'}
                size="icon"
                className="h-9 w-9 rounded-r-none"
                onClick={() => setViewMode('grid')}
              >
                <Grid3X3 className="h-4 w-4" />
              </Button>
              <Button
                variant={viewMode === 'list' ? 'secondary' : 'ghost'}
                size="icon"
                className="h-9 w-9 rounded-l-none"
                onClick={() => setViewMode('list')}
              >
                <List className="h-4 w-4" />
              </Button>
            </div>
            <Button variant="outline" size="icon" onClick={refresh}>
              <RefreshCw className={cn('h-4 w-4', loading && 'animate-spin')} />
            </Button>
          </div>
        </div>

        {/* Error State */}
        {error && (
          <Card className="mb-6 border-destructive">
            <CardContent className="py-4">
              <p className="text-destructive">{error}</p>
              <Button variant="outline" size="sm" onClick={refresh} className="mt-2">
                다시 시도
              </Button>
            </CardContent>
          </Card>
        )}

        {/* Projects Grid/List */}
        {loading && projects.length === 0 ? (
          <div className={cn(
            viewMode === 'grid' 
              ? 'grid gap-4 sm:grid-cols-2 lg:grid-cols-3' 
              : 'space-y-3'
          )}>
            {Array.from({ length: 6 }).map((_, i) => (
              <ProjectCardSkeleton key={i} viewMode={viewMode} />
            ))}
          </div>
        ) : projects.length === 0 ? (
          <Card className="border-dashed">
            <CardContent className="py-16 text-center">
              <div className="flex justify-center mb-6">
                <div className="p-4 bg-muted rounded-full">
                  <FolderPlus className="h-12 w-12 text-muted-foreground" />
                </div>
              </div>
              <h2 className="text-xl font-semibold mb-2">
                {searchQuery ? '검색 결과가 없습니다' : '프로젝트가 없습니다'}
              </h2>
              <p className="text-muted-foreground mb-6">
                {searchQuery
                  ? '다른 검색어로 다시 시도해보세요.'
                  : '첫 번째 프로젝트를 만들어 검색 결과와 분석 자료를 체계적으로 관리해보세요.'}
              </p>
              {!searchQuery && (
                <Button onClick={() => setCreateDialogOpen(true)}>
                  <Plus className="h-4 w-4 mr-2" />
                  첫 프로젝트 만들기
                </Button>
              )}
            </CardContent>
          </Card>
        ) : (
          <div className={cn(
            viewMode === 'grid'
              ? 'grid gap-4 sm:grid-cols-2 lg:grid-cols-3'
              : 'space-y-3'
          )}>
            {projects.map((project) => (
              <ProjectCard
                key={project.id}
                project={project}
                viewMode={viewMode}
                onSelect={handleSelectProject}
                onEdit={handleEditProject}
                onDelete={setDeleteTarget}
              />
            ))}
          </div>
        )}

        {/* Pagination */}
        {totalPages > 1 && (
          <div className="flex justify-center gap-2 mt-8">
            <Button
              variant="outline"
              size="sm"
              disabled={currentPage === 0}
              onClick={() => handlePageChange(currentPage - 1)}
            >
              이전
            </Button>
            <span className="flex items-center px-4 text-sm text-muted-foreground">
              {currentPage + 1} / {totalPages}
            </span>
            <Button
              variant="outline"
              size="sm"
              disabled={currentPage >= totalPages - 1}
              onClick={() => handlePageChange(currentPage + 1)}
            >
              다음
            </Button>
          </div>
        )}

        {/* Quick Actions */}
        <div className="mt-8 grid gap-4 md:grid-cols-2">
          <Card>
            <CardHeader>
              <CardTitle className="text-base">검색 기록</CardTitle>
              <CardDescription>
                지금까지 수행한 검색 내역을 확인하고 프로젝트에 추가할 수 있습니다.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Link to="/history">
                <Button variant="outline" className="w-full">
                  검색 기록 보기
                </Button>
              </Link>
            </CardContent>
          </Card>
          <Card>
            <CardHeader>
              <CardTitle className="text-base">URL 컬렉션</CardTitle>
              <CardDescription>
                수집한 URL을 프로젝트별로 정리하고 관리할 수 있습니다.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Link to="/url-collections">
                <Button variant="outline" className="w-full">
                  URL 컬렉션 보기
                </Button>
              </Link>
            </CardContent>
          </Card>
        </div>

        {/* Create Project Dialog */}
        <CreateProjectDialog
          open={createDialogOpen}
          onOpenChange={setCreateDialogOpen}
          onSubmit={handleCreateProject}
        />

        {/* Delete Confirmation Dialog */}
        <AlertDialog open={!!deleteTarget} onOpenChange={() => setDeleteTarget(null)}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>프로젝트 삭제</AlertDialogTitle>
              <AlertDialogDescription>
                "{deleteTarget?.name}" 프로젝트를 삭제하시겠습니까?
                이 작업은 되돌릴 수 없으며, 프로젝트의 모든 항목이 함께 삭제됩니다.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>취소</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleDeleteProject}
                className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
              >
                삭제
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </div>
  );
};

export default Projects;

```

---

## frontend/src/pages/Register.tsx

```tsx
/**
 * Register - 회원가입 페이지
 * 
 * 일반 사용자를 위한 회원가입 페이지
 * - 사용자명, 이메일, 비밀번호 입력
 * - 실시간 유효성 검사
 * - 가입 성공 시 자동 로그인 및 홈으로 이동
 */

import { useState, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useForm } from 'react-hook-form';
import { Eye, EyeOff, User, Mail, Lock, CheckCircle, XCircle, Loader2 } from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { useToast } from '@/components/ui/use-toast';
import { publicAuthApi } from '@/lib/publicAuthApi';
import { useAuth } from '@/contexts/AuthContext';

interface RegisterFormData {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
}

export default function Register() {
  const navigate = useNavigate();
  const { toast } = useToast();
  const { isAuthenticated, login } = useAuth();
  
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // 중복 확인 상태
  const [usernameStatus, setUsernameStatus] = useState<'idle' | 'checking' | 'available' | 'taken'>('idle');
  const [emailStatus, setEmailStatus] = useState<'idle' | 'checking' | 'available' | 'taken'>('idle');
  
  const {
    register,
    handleSubmit,
    watch,
    formState: { errors },
    setError,
  } = useForm<RegisterFormData>({
    mode: 'onChange',
  });
  
  const watchUsername = watch('username');
  const watchEmail = watch('email');
  const watchPassword = watch('password');
  
  // 이미 로그인된 경우 홈으로 리다이렉트
  useEffect(() => {
    if (isAuthenticated) {
      navigate('/');
    }
  }, [isAuthenticated, navigate]);
  
  // 사용자명 중복 확인 (debounced)
  useEffect(() => {
    if (!watchUsername || watchUsername.length < 3) {
      setUsernameStatus('idle');
      return;
    }
    
    const timer = setTimeout(async () => {
      setUsernameStatus('checking');
      try {
        const result = await publicAuthApi.checkUsername(watchUsername);
        setUsernameStatus(result.available ? 'available' : 'taken');
      } catch {
        setUsernameStatus('idle');
      }
    }, 500);
    
    return () => clearTimeout(timer);
  }, [watchUsername]);
  
  // 이메일 중복 확인 (debounced)
  useEffect(() => {
    if (!watchEmail || !watchEmail.includes('@')) {
      setEmailStatus('idle');
      return;
    }
    
    const timer = setTimeout(async () => {
      setEmailStatus('checking');
      try {
        const result = await publicAuthApi.checkEmail(watchEmail);
        setEmailStatus(result.available ? 'available' : 'taken');
      } catch {
        setEmailStatus('idle');
      }
    }, 500);
    
    return () => clearTimeout(timer);
  }, [watchEmail]);
  
  const onSubmit = async (data: RegisterFormData) => {
    // 추가 유효성 검사
    if (usernameStatus === 'taken') {
      setError('username', { message: '이미 사용 중인 사용자명입니다' });
      return;
    }
    if (emailStatus === 'taken') {
      setError('email', { message: '이미 사용 중인 이메일입니다' });
      return;
    }
    
    setIsSubmitting(true);
    
    try {
      // 회원가입 API 호출 (성공 시 토큰 반환)
      const token = await publicAuthApi.register({
        username: data.username,
        email: data.email,
        password: data.password,
      });
      
      // 토큰 저장 및 로그인 처리
      localStorage.setItem('access_token', token.access_token);
      document.cookie = `access_token=${token.access_token}; path=/; SameSite=Lax`;
      
      toast({
        title: '회원가입 완료',
        description: `환영합니다, ${data.username}님!`,
      });
      
      // 홈으로 이동 (새로고침하여 AuthContext 초기화)
      window.location.href = '/';
      
    } catch (error: any) {
      const message = error.response?.data?.detail || '회원가입에 실패했습니다. 다시 시도해주세요.';
      toast({
        variant: 'destructive',
        title: '회원가입 실패',
        description: message,
      });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  const renderStatusIcon = (status: 'idle' | 'checking' | 'available' | 'taken') => {
    switch (status) {
      case 'checking':
        return <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />;
      case 'available':
        return <CheckCircle className="h-4 w-4 text-green-500" />;
      case 'taken':
        return <XCircle className="h-4 w-4 text-red-500" />;
      default:
        return null;
    }
  };
  
  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-b from-background to-muted/20 px-4 py-8">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1 text-center">
          <div className="flex justify-center mb-4">
            <img 
              src="/initial_logo-v0.1.png" 
              alt="NewsInsight" 
              className="h-12 w-12"
            />
          </div>
          <CardTitle className="text-2xl font-bold">회원가입</CardTitle>
          <CardDescription>
            NewsInsight 계정을 만들어 검색 기록과 분석 결과를 저장하세요
          </CardDescription>
        </CardHeader>
        
        <form onSubmit={handleSubmit(onSubmit)}>
          <CardContent className="space-y-4">
            {/* 사용자명 */}
            <div className="space-y-2">
              <Label htmlFor="username">사용자명</Label>
              <div className="relative">
                <User className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  id="username"
                  placeholder="사용자명 (3자 이상)"
                  className="pl-10 pr-10"
                  {...register('username', {
                    required: '사용자명을 입력해주세요',
                    minLength: { value: 3, message: '사용자명은 3자 이상이어야 합니다' },
                    maxLength: { value: 50, message: '사용자명은 50자 이하여야 합니다' },
                    pattern: {
                      value: /^[a-zA-Z0-9_-]+$/,
                      message: '영문, 숫자, 밑줄, 하이픈만 사용 가능합니다',
                    },
                  })}
                />
                <div className="absolute right-3 top-1/2 -translate-y-1/2">
                  {renderStatusIcon(usernameStatus)}
                </div>
              </div>
              {errors.username && (
                <p className="text-sm text-red-500">{errors.username.message}</p>
              )}
              {usernameStatus === 'taken' && !errors.username && (
                <p className="text-sm text-red-500">이미 사용 중인 사용자명입니다</p>
              )}
              {usernameStatus === 'available' && (
                <p className="text-sm text-green-500">사용 가능한 사용자명입니다</p>
              )}
            </div>
            
            {/* 이메일 */}
            <div className="space-y-2">
              <Label htmlFor="email">이메일</Label>
              <div className="relative">
                <Mail className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  id="email"
                  type="email"
                  placeholder="example@email.com"
                  className="pl-10 pr-10"
                  {...register('email', {
                    required: '이메일을 입력해주세요',
                    pattern: {
                      value: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
                      message: '유효한 이메일 주소를 입력해주세요',
                    },
                  })}
                />
                <div className="absolute right-3 top-1/2 -translate-y-1/2">
                  {renderStatusIcon(emailStatus)}
                </div>
              </div>
              {errors.email && (
                <p className="text-sm text-red-500">{errors.email.message}</p>
              )}
              {emailStatus === 'taken' && !errors.email && (
                <p className="text-sm text-red-500">이미 사용 중인 이메일입니다</p>
              )}
              {emailStatus === 'available' && (
                <p className="text-sm text-green-500">사용 가능한 이메일입니다</p>
              )}
            </div>
            
            {/* 비밀번호 */}
            <div className="space-y-2">
              <Label htmlFor="password">비밀번호</Label>
              <div className="relative">
                <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  id="password"
                  type={showPassword ? 'text' : 'password'}
                  placeholder="비밀번호 (8자 이상)"
                  className="pl-10 pr-10"
                  {...register('password', {
                    required: '비밀번호를 입력해주세요',
                    minLength: { value: 8, message: '비밀번호는 8자 이상이어야 합니다' },
                  })}
                />
                <button
                  type="button"
                  className="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
                  onClick={() => setShowPassword(!showPassword)}
                >
                  {showPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                </button>
              </div>
              {errors.password && (
                <p className="text-sm text-red-500">{errors.password.message}</p>
              )}
            </div>
            
            {/* 비밀번호 확인 */}
            <div className="space-y-2">
              <Label htmlFor="confirmPassword">비밀번호 확인</Label>
              <div className="relative">
                <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  id="confirmPassword"
                  type={showConfirmPassword ? 'text' : 'password'}
                  placeholder="비밀번호 재입력"
                  className="pl-10 pr-10"
                  {...register('confirmPassword', {
                    required: '비밀번호를 다시 입력해주세요',
                    validate: (value) =>
                      value === watchPassword || '비밀번호가 일치하지 않습니다',
                  })}
                />
                <button
                  type="button"
                  className="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
                  onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                >
                  {showConfirmPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                </button>
              </div>
              {errors.confirmPassword && (
                <p className="text-sm text-red-500">{errors.confirmPassword.message}</p>
              )}
            </div>
          </CardContent>
          
          <CardFooter className="flex flex-col gap-4">
            <Button
              type="submit"
              className="w-full"
              disabled={isSubmitting || usernameStatus === 'taken' || emailStatus === 'taken'}
            >
              {isSubmitting ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  가입 중...
                </>
              ) : (
                '가입하기'
              )}
            </Button>
            
            <div className="text-center text-sm text-muted-foreground">
              이미 계정이 있으신가요?{' '}
              <Link to="/login" className="text-primary hover:underline font-medium">
                로그인
              </Link>
            </div>
            
            <div className="text-center text-xs text-muted-foreground">
              가입 없이{' '}
              <Link to="/" className="text-primary hover:underline">
                익명으로 사용하기
              </Link>
            </div>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
}

```

---

## frontend/src/pages/SearchHistory.tsx

```tsx
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { SearchHistoryPanel } from '@/components/SearchHistoryPanel';
import { DeriveSearchDialog } from '@/components/DeriveSearchDialog';
import type { SearchHistoryRecord, SearchHistoryType } from '@/lib/api';
import { getDiscoveredUrls } from '@/lib/api';

/**
 * Search History Page
 * 
 * A dedicated page for viewing and managing search history.
 * Users can filter by search type, bookmark important searches,
 * and navigate back to re-run or derive new searches.
 */
export default function SearchHistory() {
  const navigate = useNavigate();
  
  // Dialog state
  const [deriveDialogOpen, setDeriveDialogOpen] = useState(false);
  const [selectedRecord, setSelectedRecord] = useState<SearchHistoryRecord | null>(null);
  
  // Discovered URLs state
  const [discoveredUrls, setDiscoveredUrls] = useState<string[]>([]);
  const [urlsLoading, setUrlsLoading] = useState(false);
  const [urlsError, setUrlsError] = useState<string | null>(null);
  const [showDiscoveredUrls, setShowDiscoveredUrls] = useState(false);
  const [urlsDays, setUrlsDays] = useState(7);

  // Load discovered URLs
  useEffect(() => {
    if (showDiscoveredUrls) {
      setUrlsLoading(true);
      setUrlsError(null);
      getDiscoveredUrls(urlsDays, 100)
        .then(setDiscoveredUrls)
        .catch((err) => {
          console.error('Failed to load discovered URLs:', err);
          setDiscoveredUrls([]);
          setUrlsError('URL 목록을 불러오는데 실패했습니다.');
        })
        .finally(() => setUrlsLoading(false));
    }
  }, [showDiscoveredUrls, urlsDays]);

  // Navigate to the appropriate page based on search type
  const getSearchPagePath = (searchType: SearchHistoryType): string => {
    switch (searchType) {
      case 'UNIFIED':
        return '/search';
      case 'DEEP_SEARCH':
        return '/deep-search';
      case 'FACT_CHECK':
        return '/fact-check';
      case 'BROWSER_AGENT':
        return '/ai-agent';
      default:
        return '/';
    }
  };

  // Handle selecting a search to view/re-run
  const handleSelectSearch = (search: SearchHistoryRecord) => {
    const path = getSearchPagePath(search.searchType);
    // Navigate to the search page with the query as state
    navigate(path, { 
      state: { 
        query: search.query,
        fromHistory: true,
        historyId: search.id 
      } 
    });
  };

  // Handle deriving a new search from an existing one - opens dialog
  const handleDeriveSearch = (search: SearchHistoryRecord) => {
    setSelectedRecord(search);
    setDeriveDialogOpen(true);
  };

  return (
    <div className="container mx-auto px-4 py-6 max-w-4xl">
      <div className="mb-6">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-gray-100 mb-2">
          검색 기록
        </h1>
        <p className="text-gray-600 dark:text-gray-400">
          이전 검색 기록을 확인하고 재검색하거나 파생 검색을 수행할 수 있습니다.
        </p>
      </div>

      {/* Discovered URLs Section */}
      <div className="mb-4">
        <button
          onClick={() => setShowDiscoveredUrls(!showDiscoveredUrls)}
          className="flex items-center gap-2 text-sm text-blue-600 dark:text-blue-400 hover:underline"
        >
          <svg
            className={`w-4 h-4 transition-transform ${showDiscoveredUrls ? 'rotate-90' : ''}`}
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
          발견된 URL 목록 보기
        </button>
        
        {showDiscoveredUrls && (
          <div className="mt-3 bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="font-medium text-gray-900 dark:text-gray-100">
                최근 발견된 URL ({discoveredUrls.length}건)
              </h3>
              <div className="flex items-center gap-2">
                <label className="text-xs text-gray-500">기간:</label>
                <select
                  value={urlsDays}
                  onChange={(e) => setUrlsDays(Number(e.target.value))}
                  className="text-xs border border-gray-300 dark:border-gray-600 rounded px-2 py-1 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100"
                >
                  <option value={1}>1일</option>
                  <option value={7}>7일</option>
                  <option value={14}>14일</option>
                  <option value={30}>30일</option>
                </select>
              </div>
            </div>
            
            {urlsLoading ? (
              <div className="flex items-center justify-center py-4">
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-500"></div>
              </div>
            ) : urlsError ? (
              <div className="flex items-center gap-2 py-4 px-3 bg-red-50 dark:bg-red-900/20 rounded text-sm text-red-600 dark:text-red-400">
                <svg className="w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span>{urlsError}</span>
                <button
                  onClick={() => {
                    setUrlsError(null);
                    setUrlsLoading(true);
                    getDiscoveredUrls(urlsDays, 100)
                      .then(setDiscoveredUrls)
                      .catch((err) => {
                        console.error('Failed to load discovered URLs:', err);
                        setDiscoveredUrls([]);
                        setUrlsError('URL 목록을 불러오는데 실패했습니다.');
                      })
                      .finally(() => setUrlsLoading(false));
                  }}
                  className="ml-auto text-blue-600 dark:text-blue-400 hover:underline text-xs"
                >
                  다시 시도
                </button>
              </div>
            ) : discoveredUrls.length === 0 ? (
              <p className="text-sm text-gray-500 dark:text-gray-400 text-center py-4">
                해당 기간에 발견된 URL이 없습니다.
              </p>
            ) : (
              <div className="max-h-64 overflow-y-auto space-y-1">
                {discoveredUrls.map((url, index) => (
                  <div
                    key={index}
                    className="flex items-center gap-2 py-1 px-2 hover:bg-gray-50 dark:hover:bg-gray-800 rounded text-sm"
                  >
                    <svg className="w-3 h-3 text-gray-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                    </svg>
                    <a
                      href={url}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-blue-600 dark:text-blue-400 hover:underline truncate flex-1"
                      title={url}
                    >
                      {url}
                    </a>
                    <button
                      onClick={() => navigator.clipboard.writeText(url)}
                      className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                      title="URL 복사"
                    >
                      <svg className="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                      </svg>
                    </button>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
      </div>

      <div className="bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 shadow-sm p-4 min-h-[600px]">
        <SearchHistoryPanel
          onSelectSearch={handleSelectSearch}
          onDeriveSearch={handleDeriveSearch}
          className="h-full"
        />
      </div>
      
      {/* Derive Search Dialog */}
      {selectedRecord && (
        <DeriveSearchDialog
          open={deriveDialogOpen}
          onOpenChange={setDeriveDialogOpen}
          searchRecord={selectedRecord}
        />
      )}
    </div>
  );
}

```

---

## frontend/src/pages/Settings.tsx

```tsx
import React, { useState, useEffect, useCallback } from 'react';
import { Link } from 'react-router-dom';
import {
  ArrowLeft,
  Settings as SettingsIcon,
  RefreshCw,
  CheckCircle2,
  XCircle,
  AlertCircle,
  Loader2,
  Server,
  Zap,
  ExternalLink,
  Eye,
  Key,
  Save,
  Sparkles,
  Bot,
  Search,
  EyeOff,
  BarChart3,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/contexts/AuthContext';
import { UserLlmSettings } from '@/components/settings/UserLlmSettings';
import {
  // API Gateway
  checkApiGatewayHealth,
  // AI Provider Models
  fetchProviderModels,
  getStaticModels,
  type LLMProviderType as ApiLLMProviderType,
  type ProviderModel,
} from '@/lib/api';

// ============================================
// AI/LLM Settings Types
// ============================================

type LLMProviderType = 'openai' | 'anthropic' | 'google' | 'openrouter' | 'ollama' | 'azure' | 'custom';

interface AISettings {
  llmProvider: LLMProviderType;
  // OpenAI
  openaiApiKey: string;
  openaiModel: string;
  // Anthropic
  anthropicApiKey: string;
  anthropicModel: string;
  // Google (Gemini)
  googleApiKey: string;
  googleModel: string;
  // OpenRouter
  openrouterApiKey: string;
  openrouterModel: string;
  // Ollama (로컬)
  ollamaBaseUrl: string;
  ollamaModel: string;
  // Azure OpenAI
  azureApiKey: string;
  azureEndpoint: string;
  azureDeploymentName: string;
  azureApiVersion: string;
  // Custom REST API
  customBaseUrl: string;
  customApiKey: string;
  customModel: string;
  customHeaders: string; // JSON 문자열
  // Search APIs
  braveApiKey: string;
  tavilyApiKey: string;
  perplexityApiKey: string;
}

const defaultAISettings: AISettings = {
  llmProvider: 'openai',
  // OpenAI
  openaiApiKey: '',
  openaiModel: 'gpt-4o',
  // Anthropic
  anthropicApiKey: '',
  anthropicModel: 'claude-3-5-sonnet-20241022',
  // Google
  googleApiKey: '',
  googleModel: 'gemini-1.5-pro',
  // OpenRouter
  openrouterApiKey: '',
  openrouterModel: 'openai/gpt-4o',
  // Ollama
  ollamaBaseUrl: 'http://localhost:11434',
  ollamaModel: 'llama3.1',
  // Azure
  azureApiKey: '',
  azureEndpoint: '',
  azureDeploymentName: '',
  azureApiVersion: '2024-02-15-preview',
  // Custom
  customBaseUrl: '',
  customApiKey: '',
  customModel: '',
  customHeaders: '{}',
  // Search
  braveApiKey: '',
  tavilyApiKey: '',
  perplexityApiKey: '',
};

// Provider 메타데이터
const LLM_PROVIDERS: { value: LLMProviderType; label: string; description: string; color: string }[] = [
  { value: 'openai', label: 'OpenAI', description: 'GPT-4, GPT-3.5', color: 'bg-green-500' },
  { value: 'anthropic', label: 'Anthropic', description: 'Claude 3.5', color: 'bg-orange-500' },
  { value: 'google', label: 'Google AI', description: 'Gemini 1.5', color: 'bg-blue-500' },
  { value: 'openrouter', label: 'OpenRouter', description: '다양한 모델', color: 'bg-purple-500' },
  { value: 'ollama', label: 'Ollama', description: '로컬 LLM', color: 'bg-gray-500' },
  { value: 'azure', label: 'Azure OpenAI', description: 'Azure 호스팅', color: 'bg-cyan-500' },
  { value: 'custom', label: 'Custom API', description: '커스텀 엔드포인트', color: 'bg-pink-500' },
];

const LLM_MODELS: Record<LLMProviderType, { value: string; label: string }[]> = {
  openai: [
    { value: 'gpt-4o', label: 'GPT-4o (추천)' },
    { value: 'gpt-4o-mini', label: 'GPT-4o Mini (빠름)' },
    { value: 'gpt-4.1', label: 'GPT-4.1' },
    { value: 'gpt-4.1-mini', label: 'GPT-4.1 Mini' },
    { value: 'gpt-4-turbo', label: 'GPT-4 Turbo' },
    { value: 'gpt-3.5-turbo', label: 'GPT-3.5 Turbo (저렴)' },
    { value: 'o1', label: 'o1 (추론)' },
    { value: 'o1-preview', label: 'o1-preview (추론)' },
    { value: 'o1-mini', label: 'o1-mini (추론, 빠름)' },
    { value: 'o3-mini', label: 'o3-mini (최신 추론)' },
  ],
  anthropic: [
    { value: 'claude-sonnet-4-20250514', label: 'Claude Sonnet 4 (최신)' },
    { value: 'claude-3-5-sonnet-20241022', label: 'Claude 3.5 Sonnet (추천)' },
    { value: 'claude-3-5-haiku-20241022', label: 'Claude 3.5 Haiku (빠름)' },
    { value: 'claude-3-opus-20240229', label: 'Claude 3 Opus (강력)' },
  ],
  google: [
    { value: 'gemini-2.5-flash-preview-05-20', label: 'Gemini 2.5 Flash (최신)' },
    { value: 'gemini-2.5-pro-preview-05-06', label: 'Gemini 2.5 Pro (최신)' },
    { value: 'gemini-2.0-flash', label: 'Gemini 2.0 Flash' },
    { value: 'gemini-2.0-flash-lite', label: 'Gemini 2.0 Flash Lite (빠름)' },
    { value: 'gemini-1.5-pro', label: 'Gemini 1.5 Pro' },
    { value: 'gemini-1.5-flash', label: 'Gemini 1.5 Flash' },
  ],
  openrouter: [
    { value: 'openai/gpt-4o', label: 'GPT-4o (OpenAI)' },
    { value: 'openai/gpt-4.1', label: 'GPT-4.1 (OpenAI)' },
    { value: 'anthropic/claude-sonnet-4', label: 'Claude Sonnet 4 (Anthropic)' },
    { value: 'anthropic/claude-3.5-sonnet', label: 'Claude 3.5 Sonnet' },
    { value: 'google/gemini-2.5-flash-preview', label: 'Gemini 2.5 Flash (Google)' },
    { value: 'google/gemini-2.0-flash-001', label: 'Gemini 2.0 Flash (Google)' },
    { value: 'google/gemini-pro-1.5', label: 'Gemini 1.5 Pro' },
    { value: 'meta-llama/llama-3.3-70b-instruct', label: 'Llama 3.3 70B' },
    { value: 'meta-llama/llama-3.1-405b-instruct', label: 'Llama 3.1 405B' },
    { value: 'deepseek/deepseek-r1', label: 'DeepSeek R1 (추론)' },
    { value: 'deepseek/deepseek-chat', label: 'DeepSeek Chat' },
    { value: 'qwen/qwen-2.5-72b-instruct', label: 'Qwen 2.5 72B' },
  ],
  ollama: [
    { value: 'llama3.3', label: 'Llama 3.3 (최신)' },
    { value: 'llama3.2', label: 'Llama 3.2' },
    { value: 'llama3.1', label: 'Llama 3.1' },
    { value: 'llama3.1:70b', label: 'Llama 3.1 70B' },
    { value: 'mistral', label: 'Mistral' },
    { value: 'mixtral', label: 'Mixtral' },
    { value: 'codellama', label: 'Code Llama' },
    { value: 'qwen2.5', label: 'Qwen 2.5' },
    { value: 'deepseek-r1', label: 'DeepSeek R1' },
    { value: 'gemma2', label: 'Gemma 2' },
  ],
  azure: [
    { value: 'gpt-4o', label: 'GPT-4o' },
    { value: 'gpt-4-turbo', label: 'GPT-4 Turbo' },
    { value: 'gpt-35-turbo', label: 'GPT-3.5 Turbo' },
  ],
  custom: [
    { value: 'default', label: '기본 모델' },
  ],
};

// ============================================
// Settings Page Component
// ============================================

// Helper function to check if user has admin role
const isAdminRole = (role?: string): boolean => {
  return role === 'admin';
};

const Settings = () => {
  const { toast } = useToast();
  const { user } = useAuth();
  const isAdmin = isAdminRole(user?.role);
  const [activeTab, setActiveTab] = useState('user-llm');
  
  // AI Settings state
  const [aiSettings, setAISettings] = useState<AISettings>(() => {
    const saved = localStorage.getItem('newsinsight-ai-settings');
    if (saved) {
      try {
        return { ...defaultAISettings, ...JSON.parse(saved) };
      } catch {
        // ignore
      }
    }
    return defaultAISettings;
  });
  const [isSavingAI, setIsSavingAI] = useState(false);
  const [showApiKeys, setShowApiKeys] = useState<Record<string, boolean>>({});
  const [aiSettingsChanged, setAISettingsChanged] = useState(false);
  const [isTestingProvider, setIsTestingProvider] = useState(false);
  const [providerTestResult, setProviderTestResult] = useState<{
    status: 'success' | 'failed';
    message: string;
    latency_ms?: number;
  } | null>(null);
  
  // Dynamic model lists per provider
  const [dynamicModels, setDynamicModels] = useState<Record<LLMProviderType, ProviderModel[]>>({
    openai: [],
    anthropic: [],
    google: [],
    openrouter: [],
    ollama: [],
    azure: [],
    custom: [],
  });
  const [isLoadingModels, setIsLoadingModels] = useState<Record<LLMProviderType, boolean>>({
    openai: false,
    anthropic: false,
    google: false,
    openrouter: false,
    ollama: false,
    azure: false,
    custom: false,
  });
  const [modelSource, setModelSource] = useState<Record<LLMProviderType, 'api' | 'static'>>({
    openai: 'static',
    anthropic: 'static',
    google: 'static',
    openrouter: 'static',
    ollama: 'static',
    azure: 'static',
    custom: 'static',
  });
  const [modelLoadError, setModelLoadError] = useState<Record<LLMProviderType, string | null>>({
    openai: null,
    anthropic: null,
    google: null,
    openrouter: null,
    ollama: null,
    azure: null,
    custom: null,
  });

  // Fetch models for a provider
  const loadModelsForProvider = useCallback(async (provider: LLMProviderType, showToast = false) => {
    setIsLoadingModels(prev => ({ ...prev, [provider]: true }));
    setModelLoadError(prev => ({ ...prev, [provider]: null }));
    try {
      // Get API key and base URL from current settings
      let apiKey: string | undefined;
      let baseUrl: string | undefined;
      
      switch (provider) {
        case 'openai':
          apiKey = aiSettings.openaiApiKey || undefined;
          break;
        case 'anthropic':
          apiKey = aiSettings.anthropicApiKey || undefined;
          break;
        case 'google':
          apiKey = aiSettings.googleApiKey || undefined;
          break;
        case 'openrouter':
          apiKey = aiSettings.openrouterApiKey || undefined;
          break;
        case 'ollama':
          baseUrl = aiSettings.ollamaBaseUrl || undefined;
          break;
        case 'custom':
          baseUrl = aiSettings.customBaseUrl || undefined;
          apiKey = aiSettings.customApiKey || undefined;
          break;
      }
      
      const response = await fetchProviderModels(provider as ApiLLMProviderType, apiKey, baseUrl);
      
      // Ensure models is an array before setting
      const models = Array.isArray(response?.models) ? response.models : [];
      if (models.length > 0) {
        setDynamicModels(prev => ({ ...prev, [provider]: models }));
        setModelSource(prev => ({ ...prev, [provider]: response.source || 'api' }));
        if (showToast && response.source === 'api') {
          toast({
            title: '모델 목록 로드 완료',
            description: `${models.length}개의 ${provider} 모델을 API에서 가져왔습니다.`,
          });
        }
      } else {
        // Fallback to static
        setDynamicModels(prev => ({ ...prev, [provider]: getStaticModels(provider as ApiLLMProviderType) }));
        setModelSource(prev => ({ ...prev, [provider]: 'static' }));
        if (response.error) {
          setModelLoadError(prev => ({ ...prev, [provider]: response.error || null }));
        }
      }
    } catch (e) {
      console.error(`Failed to load models for ${provider}:`, e);
      const errorMessage = e instanceof Error ? e.message : '알 수 없는 오류';
      setModelLoadError(prev => ({ ...prev, [provider]: errorMessage }));
      // Fallback to static models
      setDynamicModels(prev => ({ ...prev, [provider]: getStaticModels(provider as ApiLLMProviderType) }));
      setModelSource(prev => ({ ...prev, [provider]: 'static' }));
    } finally {
      setIsLoadingModels(prev => ({ ...prev, [provider]: false }));
    }
  }, [aiSettings.openaiApiKey, aiSettings.anthropicApiKey, aiSettings.googleApiKey, aiSettings.openrouterApiKey, aiSettings.ollamaBaseUrl, aiSettings.customBaseUrl, aiSettings.customApiKey, toast]);

  // Load models when provider changes or on mount
  useEffect(() => {
    if (activeTab === 'ai-settings') {
      // Load models for current provider
      loadModelsForProvider(aiSettings.llmProvider);
    }
  }, [activeTab, aiSettings.llmProvider, loadModelsForProvider]);

  // Auto-refresh models when API key changes (with debounce)
  useEffect(() => {
    if (activeTab !== 'ai-settings') return;
    
    const timeoutId = setTimeout(() => {
      // Only refresh if the API key looks valid (has some length)
      if (aiSettings.openaiApiKey && aiSettings.openaiApiKey.length > 10) {
        loadModelsForProvider('openai');
      }
    }, 1000); // 1 second debounce
    
    return () => clearTimeout(timeoutId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [aiSettings.openaiApiKey, activeTab]);

  useEffect(() => {
    if (activeTab !== 'ai-settings') return;
    
    const timeoutId = setTimeout(() => {
      if (aiSettings.googleApiKey && aiSettings.googleApiKey.length > 10) {
        loadModelsForProvider('google');
      }
    }, 1000);
    
    return () => clearTimeout(timeoutId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [aiSettings.googleApiKey, activeTab]);

  useEffect(() => {
    if (activeTab !== 'ai-settings') return;
    
    const timeoutId = setTimeout(() => {
      if (aiSettings.openrouterApiKey && aiSettings.openrouterApiKey.length > 10) {
        loadModelsForProvider('openrouter');
      }
    }, 1000);
    
    return () => clearTimeout(timeoutId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [aiSettings.openrouterApiKey, activeTab]);

  useEffect(() => {
    if (activeTab !== 'ai-settings') return;
    
    const timeoutId = setTimeout(() => {
      if (aiSettings.ollamaBaseUrl && aiSettings.ollamaBaseUrl.length > 5) {
        loadModelsForProvider('ollama');
      }
    }, 1000);
    
    return () => clearTimeout(timeoutId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [aiSettings.ollamaBaseUrl, activeTab]);

  useEffect(() => {
    if (activeTab !== 'ai-settings') return;
    
    const timeoutId = setTimeout(() => {
      if (aiSettings.customBaseUrl && aiSettings.customBaseUrl.length > 5) {
        loadModelsForProvider('custom');
      }
    }, 1000);
    
    return () => clearTimeout(timeoutId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [aiSettings.customBaseUrl, activeTab]);

  // Get models for display (dynamic if available, otherwise static fallback from LLM_MODELS)
  const getModelsForProvider = (provider: LLMProviderType): { value: string; label: string }[] => {
    const dynamic = dynamicModels[provider];
    if (dynamic && Array.isArray(dynamic) && dynamic.length > 0) {
      return dynamic.map(m => ({
        value: m?.id || '',
        label: m?.name || m?.id || 'Unknown',
      })).filter(m => m.value); // Filter out empty values
    }
    // Fallback to static LLM_MODELS
    const staticModels = LLM_MODELS[provider];
    return Array.isArray(staticModels) ? staticModels : [];
  };

  // Update AI setting
  const updateAISetting = <K extends keyof AISettings>(key: K, value: AISettings[K]) => {
    setAISettings(prev => ({ ...prev, [key]: value }));
    setAISettingsChanged(true);
  };

  // Save AI settings
  const saveAISettings = async () => {
    setIsSavingAI(true);
    try {
      // Save to localStorage
      localStorage.setItem('newsinsight-ai-settings', JSON.stringify(aiSettings));
      
      // Build settings payload for backend
      // Keys are mapped to environment variable format for autonomous-crawler
      const settingsPayload: Record<string, string> = {
        'LLM_PROVIDER': aiSettings.llmProvider,
        // OpenAI
        'LLM_OPENAI_API_KEY': aiSettings.openaiApiKey,
        'LLM_OPENAI_MODEL': aiSettings.openaiModel,
        // Anthropic
        'LLM_ANTHROPIC_API_KEY': aiSettings.anthropicApiKey,
        'LLM_ANTHROPIC_MODEL': aiSettings.anthropicModel,
        // Google
        'LLM_GOOGLE_API_KEY': aiSettings.googleApiKey,
        'LLM_GOOGLE_MODEL': aiSettings.googleModel,
        // OpenRouter
        'LLM_OPENROUTER_API_KEY': aiSettings.openrouterApiKey,
        'LLM_OPENROUTER_MODEL': aiSettings.openrouterModel,
        // Ollama
        'LLM_OLLAMA_BASE_URL': aiSettings.ollamaBaseUrl,
        'LLM_OLLAMA_MODEL': aiSettings.ollamaModel,
        // Azure
        'LLM_AZURE_API_KEY': aiSettings.azureApiKey,
        'LLM_AZURE_ENDPOINT': aiSettings.azureEndpoint,
        'LLM_AZURE_DEPLOYMENT_NAME': aiSettings.azureDeploymentName,
        'LLM_AZURE_API_VERSION': aiSettings.azureApiVersion,
        // Custom
        'LLM_CUSTOM_BASE_URL': aiSettings.customBaseUrl,
        'LLM_CUSTOM_API_KEY': aiSettings.customApiKey,
        'LLM_CUSTOM_MODEL': aiSettings.customModel,
        'LLM_CUSTOM_HEADERS': aiSettings.customHeaders,
        // Search
        'SEARCH_BRAVE_API_KEY': aiSettings.braveApiKey,
        'SEARCH_TAVILY_API_KEY': aiSettings.tavilyApiKey,
        'SEARCH_PERPLEXITY_API_KEY': aiSettings.perplexityApiKey,
      };
      
      // Save to backend (Consul) via API
      const response = await fetch('/api/v1/config/ai-settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(settingsPayload),
      });
      
      if (!response.ok) {
        throw new Error('Failed to save settings to server');
      }
      
      setAISettingsChanged(false);
      toast({
        title: '설정 저장됨',
        description: 'AI/LLM 설정이 저장되었습니다. 크롤러 서비스를 재시작하면 새 설정이 적용됩니다.',
      });
    } catch (e) {
      console.error('Failed to save AI settings:', e);
      // Still save to localStorage even if API fails
      localStorage.setItem('newsinsight-ai-settings', JSON.stringify(aiSettings));
      toast({
        title: '로컬 저장 완료',
        description: '서버 저장에 실패했지만 로컬에 저장되었습니다.',
        variant: 'default',
      });
      setAISettingsChanged(false);
    } finally {
      setIsSavingAI(false);
    }
  };

  // Test LLM Provider connection
  const testProviderConnection = async () => {
    setIsTestingProvider(true);
    setProviderTestResult(null);

    try {
      // Get current model based on selected provider
      let model = '';
      switch (aiSettings.llmProvider) {
        case 'openai':
          model = aiSettings.openaiModel;
          break;
        case 'anthropic':
          model = aiSettings.anthropicModel;
          break;
        case 'google':
          model = aiSettings.googleModel;
          break;
        case 'openrouter':
          model = aiSettings.openrouterModel;
          break;
        case 'ollama':
          model = aiSettings.ollamaModel;
          break;
        case 'azure':
          model = aiSettings.azureDeploymentName;
          break;
        case 'custom':
          model = aiSettings.customModel;
          break;
      }

      const response = await fetch(
        `/api/v1/crawler/providers/test?provider=${aiSettings.llmProvider}&model=${encodeURIComponent(model)}`,
        { method: 'POST' }
      );

      const result = await response.json();

      setProviderTestResult({
        status: result.status === 'success' ? 'success' : 'failed',
        message: result.message || (result.status === 'success' ? '연결 성공' : '연결 실패'),
        latency_ms: result.latency_ms,
      });

      toast({
        title: result.status === 'success' ? '연결 성공' : '연결 실패',
        description: result.message,
        variant: result.status === 'success' ? 'default' : 'destructive',
      });
    } catch (e) {
      console.error('Provider test failed:', e);
      setProviderTestResult({
        status: 'failed',
        message: e instanceof Error ? e.message : '연결 테스트 실패',
      });
      toast({
        title: '테스트 실패',
        description: '연결 테스트 중 오류가 발생했습니다.',
        variant: 'destructive',
      });
    } finally {
      setIsTestingProvider(false);
    }
  };

  // Toggle API key visibility
  const toggleKeyVisibility = (key: string) => {
    setShowApiKeys(prev => ({ ...prev, [key]: !prev[key] }));
  };

  // ML Add-ons state (kept for local storage reset in system tab)
  const [addonEnabled, setAddonEnabled] = useState<Record<string, boolean>>(() => {
    const saved = localStorage.getItem('newsinsight-ml-addons-enabled');
    if (saved) {
      try {
        return JSON.parse(saved);
      } catch {
        // ignore
      }
    }
    return { sentiment: true, factcheck: true, bias: true };
  });

  // API Gateway state
  const [gatewayHealth, setGatewayHealth] = useState<{
    status: string;
    services?: Record<string, { status: string; instances?: number }>;
  } | null>(null);
  const [isLoadingGateway, setIsLoadingGateway] = useState(false);

  const refreshGatewayHealth = useCallback(async () => {
    setIsLoadingGateway(true);
    try {
      const health = await checkApiGatewayHealth();
      setGatewayHealth(health);
    } catch (e) {
      console.error('Failed to check API Gateway health:', e);
      setGatewayHealth({ status: 'unhealthy' });
    } finally {
      setIsLoadingGateway(false);
    }
  }, []);

  // Load gateway health when system tab is active
  useEffect(() => {
    if (activeTab === 'system') {
      refreshGatewayHealth();
    }
  }, [activeTab, refreshGatewayHealth]);

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-5xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to="/"
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            메인으로 돌아가기
          </Link>
          <div className="flex items-center justify-between flex-wrap gap-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-primary/10 rounded-lg">
                <SettingsIcon className="h-6 w-6 text-primary" />
              </div>
              <div>
                <h1 className="text-3xl font-bold">설정</h1>
                <p className="text-muted-foreground">
                  NewsInsight 시스템 설정을 관리합니다.
                </p>
              </div>
            </div>
          </div>
        </header>

        {/* Tabs */}
        <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
          <TabsList className={`grid w-full ${isAdmin ? 'grid-cols-3 lg:w-[600px]' : 'grid-cols-2 lg:w-[400px]'}`}>
            <TabsTrigger value="user-llm" className="gap-2">
              <Bot className="h-4 w-4" />
              내 LLM 설정
            </TabsTrigger>
            {isAdmin && (
              <TabsTrigger value="ai-settings" className="gap-2">
                <Sparkles className="h-4 w-4" />
                고급 AI 설정
              </TabsTrigger>
            )}
            <TabsTrigger value="system" className="gap-2">
              <Server className="h-4 w-4" />
              시스템
            </TabsTrigger>
          </TabsList>

          {/* User LLM Settings Tab (DB-based with admin defaults) */}
          <TabsContent value="user-llm" className="space-y-6">
            <Alert>
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>
                <strong>개인 LLM 설정:</strong> 여기서 설정한 값은 데이터베이스에 저장되며, 
                관리자가 설정한 전역 기본값보다 우선 적용됩니다.
                개인 설정이 없으면 자동으로 관리자 전역 설정이 사용됩니다.
              </AlertDescription>
            </Alert>
            
            {user?.id ? (
              <UserLlmSettings userId={user.id} />
            ) : (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>
                  로그인이 필요합니다. LLM 설정을 관리하려면 먼저 로그인해주세요.
                </AlertDescription>
              </Alert>
            )}
          </TabsContent>

          {/* AI/LLM Settings Tab - Admin Only */}
          {isAdmin && (
          <TabsContent value="ai-settings" className="space-y-6">
            {/* LLM Provider Card */}
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <div>
                    <CardTitle className="flex items-center gap-2">
                      <Bot className="h-5 w-5" />
                      LLM 제공자 설정
                    </CardTitle>
                    <CardDescription>
                      자동 확장 크롤링 및 AI 분석에 사용할 LLM 제공자를 설정합니다.
                    </CardDescription>
                  </div>
                  <div className="flex gap-2">
                    <Button
                      variant="outline"
                      onClick={testProviderConnection}
                      disabled={isTestingProvider}
                    >
                      {isTestingProvider ? (
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      ) : (
                        <Zap className="h-4 w-4 mr-2" />
                      )}
                      연결 테스트
                    </Button>
                    <Button
                      onClick={saveAISettings}
                      disabled={isSavingAI || !aiSettingsChanged}
                    >
                      {isSavingAI ? (
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      ) : (
                        <Save className="h-4 w-4 mr-2" />
                      )}
                      저장
                    </Button>
                  </div>
                </div>
                {/* Test Result */}
                {providerTestResult && (
                  <Alert
                    variant={providerTestResult.status === 'success' ? 'default' : 'destructive'}
                    className="mt-4"
                  >
                    {providerTestResult.status === 'success' ? (
                      <CheckCircle2 className="h-4 w-4" />
                    ) : (
                      <XCircle className="h-4 w-4" />
                    )}
                    <AlertDescription className="flex items-center justify-between">
                      <span>{providerTestResult.message}</span>
                      {providerTestResult.latency_ms && (
                        <Badge variant="secondary" className="ml-2">
                          {providerTestResult.latency_ms}ms
                        </Badge>
                      )}
                    </AlertDescription>
                  </Alert>
                )}
              </CardHeader>
              <CardContent className="space-y-6">
                {/* Provider Selection */}
                <div className="space-y-2">
                  <Label>LLM 제공자</Label>
                  <Select
                    value={aiSettings.llmProvider}
                    onValueChange={(value: LLMProviderType) => updateAISetting('llmProvider', value)}
                  >
                    <SelectTrigger className="w-full md:w-[400px]">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      {LLM_PROVIDERS.map((provider) => (
                        <SelectItem key={provider.value} value={provider.value}>
                          <div className="flex items-center gap-2">
                            <span className={`h-2 w-2 rounded-full ${provider.color}`} />
                            <span className="font-medium">{provider.label}</span>
                            <span className="text-xs text-muted-foreground">{provider.description}</span>
                          </div>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <Separator />

                {/* OpenAI Settings */}
                <div className={`space-y-4 ${aiSettings.llmProvider !== 'openai' ? 'opacity-50' : ''}`}>
                  <h4 className="text-sm font-medium flex items-center gap-2">
                    <span className="h-2 w-2 rounded-full bg-green-500" />
                    OpenAI 설정
                    {aiSettings.llmProvider === 'openai' && (
                      <Badge variant="secondary" className="text-xs">현재 사용중</Badge>
                    )}
                  </h4>
                  <div className="grid gap-4 md:grid-cols-2">
                    <div className="space-y-2">
                      <Label htmlFor="openai-key">API 키</Label>
                      <div className="flex gap-2">
                        <Input
                          id="openai-key"
                          type={showApiKeys['openai'] ? 'text' : 'password'}
                          value={aiSettings.openaiApiKey}
                          onChange={(e) => updateAISetting('openaiApiKey', e.target.value)}
                          placeholder="sk-..."
                          className="font-mono text-sm"
                        />
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          onClick={() => toggleKeyVisibility('openai')}
                        >
                          {showApiKeys['openai'] ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                        </Button>
                      </div>
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="openai-model" className="flex items-center gap-2">
                        모델
                        {modelSource.openai === 'api' && (
                          <Badge variant="outline" className="text-xs">API</Badge>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          className="h-5 w-5"
                          onClick={() => loadModelsForProvider('openai', true)}
                          disabled={isLoadingModels.openai}
                        >
                          <RefreshCw className={`h-3 w-3 ${isLoadingModels.openai ? 'animate-spin' : ''}`} />
                        </Button>
                      </Label>
                      <Select
                        value={aiSettings.openaiModel}
                        onValueChange={(value) => updateAISetting('openaiModel', value)}
                      >
                        <SelectTrigger id="openai-model">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {getModelsForProvider('openai').map((model) => (
                            <SelectItem key={model.value} value={model.value}>
                              {model.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      {modelLoadError.openai && (
                        <p className="text-xs text-destructive mt-1">{modelLoadError.openai}</p>
                      )}
                    </div>
                  </div>
                </div>

                {/* Anthropic Settings */}
                <div className={`space-y-4 ${aiSettings.llmProvider !== 'anthropic' ? 'opacity-50' : ''}`}>
                  <h4 className="text-sm font-medium flex items-center gap-2">
                    <span className="h-2 w-2 rounded-full bg-orange-500" />
                    Anthropic 설정
                    {aiSettings.llmProvider === 'anthropic' && (
                      <Badge variant="secondary" className="text-xs">현재 사용중</Badge>
                    )}
                  </h4>
                  <div className="grid gap-4 md:grid-cols-2">
                    <div className="space-y-2">
                      <Label htmlFor="anthropic-key">API 키</Label>
                      <div className="flex gap-2">
                        <Input
                          id="anthropic-key"
                          type={showApiKeys['anthropic'] ? 'text' : 'password'}
                          value={aiSettings.anthropicApiKey}
                          onChange={(e) => updateAISetting('anthropicApiKey', e.target.value)}
                          placeholder="sk-ant-..."
                          className="font-mono text-sm"
                        />
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          onClick={() => toggleKeyVisibility('anthropic')}
                        >
                          {showApiKeys['anthropic'] ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                        </Button>
                      </div>
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="anthropic-model" className="flex items-center gap-2">
                        모델
                        {modelSource.anthropic === 'api' && (
                          <Badge variant="outline" className="text-xs">API</Badge>
                        )}
                      </Label>
                      <Select
                        value={aiSettings.anthropicModel}
                        onValueChange={(value) => updateAISetting('anthropicModel', value)}
                      >
                        <SelectTrigger id="anthropic-model">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {getModelsForProvider('anthropic').map((model) => (
                            <SelectItem key={model.value} value={model.value}>
                              {model.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                </div>

                {/* Google AI Settings */}
                <div className={`space-y-4 ${aiSettings.llmProvider !== 'google' ? 'opacity-50' : ''}`}>
                  <h4 className="text-sm font-medium flex items-center gap-2">
                    <span className="h-2 w-2 rounded-full bg-blue-500" />
                    Google AI 설정
                    {aiSettings.llmProvider === 'google' && (
                      <Badge variant="secondary" className="text-xs">현재 사용중</Badge>
                    )}
                  </h4>
                  <div className="grid gap-4 md:grid-cols-2">
                    <div className="space-y-2">
                      <Label htmlFor="google-key">API 키</Label>
                      <div className="flex gap-2">
                        <Input
                          id="google-key"
                          type={showApiKeys['google'] ? 'text' : 'password'}
                          value={aiSettings.googleApiKey}
                          onChange={(e) => updateAISetting('googleApiKey', e.target.value)}
                          placeholder="AIza..."
                          className="font-mono text-sm"
                        />
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          onClick={() => toggleKeyVisibility('google')}
                        >
                          {showApiKeys['google'] ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                        </Button>
                      </div>
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="google-model" className="flex items-center gap-2">
                        모델
                        {modelSource.google === 'api' && (
                          <Badge variant="outline" className="text-xs">API</Badge>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          className="h-5 w-5"
                          onClick={() => loadModelsForProvider('google', true)}
                          disabled={isLoadingModels.google}
                        >
                          <RefreshCw className={`h-3 w-3 ${isLoadingModels.google ? 'animate-spin' : ''}`} />
                        </Button>
                      </Label>
                      <Select
                        value={aiSettings.googleModel}
                        onValueChange={(value) => updateAISetting('googleModel', value)}
                      >
                        <SelectTrigger id="google-model">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {getModelsForProvider('google').map((model) => (
                            <SelectItem key={model.value} value={model.value}>
                              {model.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      {modelLoadError.google && (
                        <p className="text-xs text-destructive mt-1">{modelLoadError.google}</p>
                      )}
                    </div>
                  </div>
                </div>

                {/* OpenRouter Settings */}
                <div className={`space-y-4 ${aiSettings.llmProvider !== 'openrouter' ? 'opacity-50' : ''}`}>
                  <h4 className="text-sm font-medium flex items-center gap-2">
                    <span className="h-2 w-2 rounded-full bg-purple-500" />
                    OpenRouter 설정
                    {aiSettings.llmProvider === 'openrouter' && (
                      <Badge variant="secondary" className="text-xs">현재 사용중</Badge>
                    )}
                    <a href="https://openrouter.ai/" target="_blank" rel="noopener noreferrer" className="text-xs text-primary hover:underline">
                      <ExternalLink className="h-3 w-3 inline" /> 사이트
                    </a>
                  </h4>
                  <div className="grid gap-4 md:grid-cols-2">
                    <div className="space-y-2">
                      <Label htmlFor="openrouter-key">API 키</Label>
                      <div className="flex gap-2">
                        <Input
                          id="openrouter-key"
                          type={showApiKeys['openrouter'] ? 'text' : 'password'}
                          value={aiSettings.openrouterApiKey}
                          onChange={(e) => updateAISetting('openrouterApiKey', e.target.value)}
                          placeholder="sk-or-..."
                          className="font-mono text-sm"
                        />
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          onClick={() => toggleKeyVisibility('openrouter')}
                        >
                          {showApiKeys['openrouter'] ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                        </Button>
                      </div>
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="openrouter-model" className="flex items-center gap-2">
                        모델
                        {modelSource.openrouter === 'api' && (
                          <Badge variant="outline" className="text-xs">API</Badge>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          className="h-5 w-5"
                          onClick={() => loadModelsForProvider('openrouter', true)}
                          disabled={isLoadingModels.openrouter}
                        >
                          <RefreshCw className={`h-3 w-3 ${isLoadingModels.openrouter ? 'animate-spin' : ''}`} />
                        </Button>
                      </Label>
                      <Select
                        value={aiSettings.openrouterModel}
                        onValueChange={(value) => updateAISetting('openrouterModel', value)}
                      >
                        <SelectTrigger id="openrouter-model">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {getModelsForProvider('openrouter').map((model) => (
                            <SelectItem key={model.value} value={model.value}>
                              {model.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      {modelLoadError.openrouter && (
                        <p className="text-xs text-destructive mt-1">{modelLoadError.openrouter}</p>
                      )}
                    </div>
                  </div>
                </div>

                {/* Ollama Settings */}
                <div className={`space-y-4 ${aiSettings.llmProvider !== 'ollama' ? 'opacity-50' : ''}`}>
                  <h4 className="text-sm font-medium flex items-center gap-2">
                    <span className="h-2 w-2 rounded-full bg-gray-500" />
                    Ollama 설정 (로컬 LLM)
                    {aiSettings.llmProvider === 'ollama' && (
                      <Badge variant="secondary" className="text-xs">현재 사용중</Badge>
                    )}
                  </h4>
                  <div className="grid gap-4 md:grid-cols-2">
                    <div className="space-y-2">
                      <Label htmlFor="ollama-url">Ollama URL</Label>
                      <Input
                        id="ollama-url"
                        value={aiSettings.ollamaBaseUrl}
                        onChange={(e) => updateAISetting('ollamaBaseUrl', e.target.value)}
                        placeholder="http://localhost:11434"
                        className="font-mono text-sm"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="ollama-model" className="flex items-center gap-2">
                        모델
                        {modelSource.ollama === 'api' && (
                          <Badge variant="outline" className="text-xs">API</Badge>
                        )}
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          className="h-5 w-5"
                          onClick={() => loadModelsForProvider('ollama', true)}
                          disabled={isLoadingModels.ollama}
                        >
                          <RefreshCw className={`h-3 w-3 ${isLoadingModels.ollama ? 'animate-spin' : ''}`} />
                        </Button>
                      </Label>
                      <Select
                        value={aiSettings.ollamaModel}
                        onValueChange={(value) => updateAISetting('ollamaModel', value)}
                      >
                        <SelectTrigger id="ollama-model">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {getModelsForProvider('ollama').map((model) => (
                            <SelectItem key={model.value} value={model.value}>
                              {model.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      {modelLoadError.ollama && (
                        <p className="text-xs text-destructive mt-1">{modelLoadError.ollama}</p>
                      )}
                    </div>
                  </div>
                </div>

                {/* Azure OpenAI Settings */}
                <div className={`space-y-4 ${aiSettings.llmProvider !== 'azure' ? 'opacity-50' : ''}`}>
                  <h4 className="text-sm font-medium flex items-center gap-2">
                    <span className="h-2 w-2 rounded-full bg-cyan-500" />
                    Azure OpenAI 설정
                    {aiSettings.llmProvider === 'azure' && (
                      <Badge variant="secondary" className="text-xs">현재 사용중</Badge>
                    )}
                  </h4>
                  <div className="grid gap-4 md:grid-cols-2">
                    <div className="space-y-2">
                      <Label htmlFor="azure-key">API 키</Label>
                      <div className="flex gap-2">
                        <Input
                          id="azure-key"
                          type={showApiKeys['azure'] ? 'text' : 'password'}
                          value={aiSettings.azureApiKey}
                          onChange={(e) => updateAISetting('azureApiKey', e.target.value)}
                          placeholder="Azure API Key"
                          className="font-mono text-sm"
                        />
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          onClick={() => toggleKeyVisibility('azure')}
                        >
                          {showApiKeys['azure'] ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                        </Button>
                      </div>
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="azure-endpoint">엔드포인트</Label>
                      <Input
                        id="azure-endpoint"
                        value={aiSettings.azureEndpoint}
                        onChange={(e) => updateAISetting('azureEndpoint', e.target.value)}
                        placeholder="https://your-resource.openai.azure.com/"
                        className="font-mono text-sm"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="azure-deployment">배포 이름</Label>
                      <Input
                        id="azure-deployment"
                        value={aiSettings.azureDeploymentName}
                        onChange={(e) => updateAISetting('azureDeploymentName', e.target.value)}
                        placeholder="gpt-4o-deployment"
                        className="font-mono text-sm"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="azure-version">API 버전</Label>
                      <Input
                        id="azure-version"
                        value={aiSettings.azureApiVersion}
                        onChange={(e) => updateAISetting('azureApiVersion', e.target.value)}
                        placeholder="2024-02-15-preview"
                        className="font-mono text-sm"
                      />
                    </div>
                  </div>
                </div>

                {/* Custom REST API Settings */}
                <div className={`space-y-4 ${aiSettings.llmProvider !== 'custom' ? 'opacity-50' : ''}`}>
                  <h4 className="text-sm font-medium flex items-center gap-2">
                    <span className="h-2 w-2 rounded-full bg-pink-500" />
                    커스텀 REST API 설정
                    {aiSettings.llmProvider === 'custom' && (
                      <Badge variant="secondary" className="text-xs">현재 사용중</Badge>
                    )}
                  </h4>
                  <Alert className="mb-4">
                    <AlertCircle className="h-4 w-4" />
                    <AlertDescription className="text-xs">
                      OpenAI 호환 API 형식을 지원합니다. (예: LiteLLM, vLLM, LocalAI 등)
                    </AlertDescription>
                  </Alert>
                  <div className="grid gap-4 md:grid-cols-2">
                    <div className="space-y-2">
                      <Label htmlFor="custom-url">Base URL</Label>
                      <Input
                        id="custom-url"
                        value={aiSettings.customBaseUrl}
                        onChange={(e) => updateAISetting('customBaseUrl', e.target.value)}
                        placeholder="https://your-api.example.com/v1"
                        className="font-mono text-sm"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="custom-key">API 키 (선택)</Label>
                      <div className="flex gap-2">
                        <Input
                          id="custom-key"
                          type={showApiKeys['custom'] ? 'text' : 'password'}
                          value={aiSettings.customApiKey}
                          onChange={(e) => updateAISetting('customApiKey', e.target.value)}
                          placeholder="your-api-key"
                          className="font-mono text-sm"
                        />
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          onClick={() => toggleKeyVisibility('custom')}
                        >
                          {showApiKeys['custom'] ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                        </Button>
                      </div>
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="custom-model">모델 이름</Label>
                      <Input
                        id="custom-model"
                        value={aiSettings.customModel}
                        onChange={(e) => updateAISetting('customModel', e.target.value)}
                        placeholder="your-model-name"
                        className="font-mono text-sm"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="custom-headers">추가 헤더 (JSON)</Label>
                      <Input
                        id="custom-headers"
                        value={aiSettings.customHeaders}
                        onChange={(e) => updateAISetting('customHeaders', e.target.value)}
                        placeholder='{"X-Custom-Header": "value"}'
                        className="font-mono text-sm"
                      />
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* Search API Settings Card */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Search className="h-5 w-5" />
                  검색 API 설정
                </CardTitle>
                <CardDescription>
                  웹 검색에 사용할 API 키를 설정합니다. 여러 제공자를 설정하면 병렬 검색이 가능합니다.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* Brave Search */}
                <div className="space-y-2">
                  <Label htmlFor="brave-key" className="flex items-center gap-2">
                    Brave Search API
                    <a href="https://brave.com/search/api/" target="_blank" rel="noopener noreferrer" className="text-xs text-primary hover:underline">
                      <ExternalLink className="h-3 w-3 inline" /> API 키 발급
                    </a>
                  </Label>
                  <div className="flex gap-2">
                    <Input
                      id="brave-key"
                      type={showApiKeys['brave'] ? 'text' : 'password'}
                      value={aiSettings.braveApiKey}
                      onChange={(e) => updateAISetting('braveApiKey', e.target.value)}
                      placeholder="BSA..."
                      className="font-mono text-sm"
                    />
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      onClick={() => toggleKeyVisibility('brave')}
                    >
                      {showApiKeys['brave'] ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                    </Button>
                  </div>
                </div>

                {/* Tavily Search */}
                <div className="space-y-2">
                  <Label htmlFor="tavily-key" className="flex items-center gap-2">
                    Tavily Search API
                    <a href="https://tavily.com/" target="_blank" rel="noopener noreferrer" className="text-xs text-primary hover:underline">
                      <ExternalLink className="h-3 w-3 inline" /> API 키 발급
                    </a>
                  </Label>
                  <div className="flex gap-2">
                    <Input
                      id="tavily-key"
                      type={showApiKeys['tavily'] ? 'text' : 'password'}
                      value={aiSettings.tavilyApiKey}
                      onChange={(e) => updateAISetting('tavilyApiKey', e.target.value)}
                      placeholder="tvly-..."
                      className="font-mono text-sm"
                    />
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      onClick={() => toggleKeyVisibility('tavily')}
                    >
                      {showApiKeys['tavily'] ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                    </Button>
                  </div>
                </div>

                {/* Perplexity */}
                <div className="space-y-2">
                  <Label htmlFor="perplexity-key" className="flex items-center gap-2">
                    Perplexity API
                    <a href="https://docs.perplexity.ai/" target="_blank" rel="noopener noreferrer" className="text-xs text-primary hover:underline">
                      <ExternalLink className="h-3 w-3 inline" /> API 키 발급
                    </a>
                  </Label>
                  <div className="flex gap-2">
                    <Input
                      id="perplexity-key"
                      type={showApiKeys['perplexity'] ? 'text' : 'password'}
                      value={aiSettings.perplexityApiKey}
                      onChange={(e) => updateAISetting('perplexityApiKey', e.target.value)}
                      placeholder="pplx-..."
                      className="font-mono text-sm"
                    />
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      onClick={() => toggleKeyVisibility('perplexity')}
                    >
                      {showApiKeys['perplexity'] ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* API Key Info */}
            <Alert>
              <Key className="h-4 w-4" />
              <AlertDescription>
                <strong>API 키 보안:</strong> API 키는 로컬 저장소와 서버(Consul)에 저장됩니다.
                <br />
                <span className="text-muted-foreground">
                  자동 확장 크롤링 기능을 사용하려면 최소 하나의 LLM API 키가 필요합니다.
                </span>
              </AlertDescription>
            </Alert>
          </TabsContent>
          )}



          {/* System Tab */}
          <TabsContent value="system" className="space-y-6">
            {/* API Gateway Health - Admin Only */}
            {isAdmin && (
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <div>
                    <CardTitle className="flex items-center gap-2">
                      <Server className="h-5 w-5" />
                      API Gateway 상태
                    </CardTitle>
                    <CardDescription>
                      백엔드 서비스 연결 상태를 확인합니다.
                    </CardDescription>
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={refreshGatewayHealth}
                    disabled={isLoadingGateway}
                  >
                    <RefreshCw className={`h-4 w-4 mr-2 ${isLoadingGateway ? 'animate-spin' : ''}`} />
                    새로고침
                  </Button>
                </div>
              </CardHeader>
              <CardContent>
                {isLoadingGateway && !gatewayHealth ? (
                  <div className="flex items-center gap-2 text-muted-foreground">
                    <Loader2 className="h-4 w-4 animate-spin" />
                    <span>상태 확인 중...</span>
                  </div>
                ) : gatewayHealth ? (
                  <div className="space-y-3">
                    <div className="flex items-center gap-2">
                      <div className={`h-3 w-3 rounded-full ${
                        gatewayHealth.status === 'UP' || gatewayHealth.status === 'healthy' ? 'bg-green-500' : 'bg-red-500'
                      }`} />
                      <span className="text-sm font-medium">
                        {gatewayHealth.status === 'UP' || gatewayHealth.status === 'healthy' ? '정상 작동' : '오프라인'}
                      </span>
                    </div>
                    {gatewayHealth.services && Object.keys(gatewayHealth.services).length > 0 && (
                      <div className="grid gap-2 mt-3">
                        {Object.entries(gatewayHealth.services).map(([name, info]) => (
                          <div key={name} className="flex items-center justify-between p-2 bg-muted/30 rounded">
                            <span className="text-sm">{name}</span>
                            <Badge variant={info.status === 'UP' ? 'default' : 'destructive'}>
                              {info.status}
                              {info.instances !== undefined && ` (${info.instances})`}
                            </Badge>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                ) : (
                  <Alert variant="destructive">
                    <AlertCircle className="h-4 w-4" />
                    <AlertDescription>
                      API Gateway에 연결할 수 없습니다.
                    </AlertDescription>
                  </Alert>
                )}
              </CardContent>
            </Card>
            )}

            {/* System Info - Limited for non-admin */}
            <Card>
              <CardHeader>
                <CardTitle>시스템 정보</CardTitle>
                <CardDescription>
                  NewsInsight 시스템 구성 정보입니다.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid gap-4 md:grid-cols-2">
                  <div className="space-y-1">
                    <Label className="text-muted-foreground">프론트엔드 버전</Label>
                    <p className="font-mono text-sm">1.0.0</p>
                  </div>
                  {isAdmin && (
                  <>
                  <div className="space-y-1">
                    <Label className="text-muted-foreground">API Gateway</Label>
                    <p className="font-mono text-sm">localhost:8000</p>
                  </div>
                  <div className="space-y-1">
                    <Label className="text-muted-foreground">Collector Service</Label>
                    <p className="font-mono text-sm">lb://collector-service</p>
                  </div>
                  <div className="space-y-1">
                    <Label className="text-muted-foreground">Browser-Use API</Label>
                    <p className="font-mono text-sm">lb://browser-use-api</p>
                  </div>
                  </>
                  )}
                </div>

                {isAdmin && (
                <>
                <Separator />

                <div className="space-y-2">
                  <Label className="text-muted-foreground">외부 링크</Label>
                  <div className="flex flex-wrap gap-2">
                    <Button variant="outline" size="sm" asChild>
                      <a href="https://github.com/your-repo/newsinsight" target="_blank" rel="noopener noreferrer">
                        <ExternalLink className="h-4 w-4 mr-2" />
                        GitHub
                      </a>
                    </Button>
                    <Button variant="outline" size="sm" asChild>
                      <a href="/admin/sources" target="_blank" rel="noopener noreferrer">
                        <BarChart3 className="h-4 w-4 mr-2" />
                        데이터 소스 관리
                      </a>
                    </Button>
                  </div>
                </div>
                </>
                )}
              </CardContent>
            </Card>

            {/* Storage */}
            <Card>
              <CardHeader>
                <CardTitle>로컬 저장소</CardTitle>
                <CardDescription>
                  브라우저에 저장된 데이터를 관리합니다.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-sm font-medium">URL 컬렉션</p>
                      <p className="text-xs text-muted-foreground">저장된 URL 및 폴더 구조</p>
                    </div>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => {
                        if (confirm('URL 컬렉션 데이터를 삭제하시겠습니까?')) {
                          localStorage.removeItem('newsinsight-url-collection');
                          toast({ title: '삭제됨', description: 'URL 컬렉션이 초기화되었습니다.' });
                        }
                      }}
                    >
                      초기화
                    </Button>
                  </div>
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-sm font-medium">검색 템플릿</p>
                      <p className="text-xs text-muted-foreground">저장된 SmartSearch 템플릿</p>
                    </div>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => {
                        if (confirm('검색 템플릿 데이터를 삭제하시겠습니까?')) {
                          localStorage.removeItem('smartSearch_templates');
                          toast({ title: '삭제됨', description: '검색 템플릿이 초기화되었습니다.' });
                        }
                      }}
                    >
                      초기화
                    </Button>
                  </div>
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-sm font-medium">ML Add-on 설정</p>
                      <p className="text-xs text-muted-foreground">Add-on 활성화 상태</p>
                    </div>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => {
                        if (confirm('ML Add-on 설정을 초기화하시겠습니까?')) {
                          localStorage.removeItem('newsinsight-ml-addons-enabled');
                          setAddonEnabled({ sentiment: true, factcheck: true, bias: true });
                          toast({ title: '초기화됨', description: 'ML Add-on 설정이 초기화되었습니다.' });
                        }
                      }}
                    >
                      초기화
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
};

export default Settings;

```

---

## frontend/src/pages/SmartSearch.tsx

```tsx
/**
 * SmartSearch - 통합 검색 페이지
 * 
 * 4가지 검색 모드를 탭으로 통합:
 * 1. 통합 검색 (Parallel Search) - 빠른 뉴스 검색
 * 2. Deep Search - AI 심층 분석
 * 3. 팩트체크 - 주장 검증
 * 4. URL 분석 - URL에서 주장 추출 및 검증
 * 
 * 각 탭에서 결과를 카드로 표시하고, 선택한 결과들을 "검색 템플릿"으로 저장 가능
 */

import { useState, useCallback, useRef, useEffect, useMemo, createElement } from "react";
import { useLocation, useSearchParams, useNavigate } from "react-router-dom";
import {
  Search,
  Brain,
  Shield,
  Loader2,
  Pin,
  Bookmark,
  ChevronRight,
  ChevronDown,
  Sparkles,
  ExternalLink,
  CheckCircle2,
  Clock,
  X,
  FolderOpen,
  FolderPlus,
  Zap,
  Database,
  Globe,
  ThumbsUp,
  ThumbsDown,
  Minus,
  AlertCircle,
  HelpCircle,
  AlertTriangle,
  Scale,
  XCircle,
  Plus,
  Play,
  Trash2,
  Star,
  Link as LinkIcon,
  FileText,
  Eye,
  ChevronsUpDown,
  Check,
  Newspaper,
  Users,
  GraduationCap,
  History,
  RefreshCw,
} from "lucide-react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Progress } from "@/components/ui/progress";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import { MarkdownRenderer } from "@/components/MarkdownRenderer";
import { FactCheckChatbot, type FactCheckChatbotRef } from "@/components/FactCheckChatbot";
import { UnifiedExportMenu } from "@/components/UnifiedExportMenu";
import { useProjects, type Project, type ProjectItemType, ITEM_TYPE_LABELS } from "@/hooks/useProjects";
import { useToast } from "@/hooks/use-toast";
import { AdvancedFilters, defaultFilters, type SearchFilters } from "@/components/AdvancedFilters";
import {
  startUnifiedSearchJob,
  openUnifiedSearchJobStream,
  startDeepSearch,
  getDeepSearchStatus,
  getDeepSearchResult,
  listDeepSearchJobs,
  createSearchTemplate,
  getAllTemplatesByUser,
  deleteSearchTemplate,
  recordTemplateUsage,
  toggleTemplateFavorite,
  getFavoriteTemplates,
  getMostUsedTemplates,
  getRecentlyUsedTemplates,
  searchTemplatesByName,
  extractClaimsFromUrl,
  getSearchHistoryByExternalId,
  type UnifiedSearchResult,
  type Evidence,
  type DeepSearchResult,
  type DeepSearchJob,
  type SearchTemplate as ApiSearchTemplate,
} from "@/lib/api";
import { useDeepSearchSSE } from "@/hooks/useDeepSearchSSE";
import { useBackgroundTasks } from "@/contexts/BackgroundTaskContext";
import { PriorityUrlEditor, type PriorityUrl } from "@/components/PriorityUrlEditor";

// ============================================
// Types
// ============================================

type SearchMode = "unified" | "deep" | "factcheck" | "urlanalysis";

type TemplateMode = "unified" | "deep" | "factcheck";
type TemplateItemType = "unified" | "evidence" | "factcheck";

const toTemplateMode = (mode: SearchMode): TemplateMode => {
  return mode === "urlanalysis" ? "factcheck" : mode;
};

const isTemplateItem = (item: SelectedItem): item is SelectedItem & { type: TemplateItemType } => {
  return item.type !== "urlclaim";
};

interface SelectedItem {
  id: string;
  type: "unified" | "evidence" | "factcheck" | "urlclaim";
  title: string;
  url?: string;
  snippet?: string;
  source?: string;
  stance?: string;
  verificationStatus?: string;
  addedAt: string;
}

interface SearchTemplate {
  id: number;
  name: string;
  query: string;
  mode: SearchMode;
  items: SelectedItem[];
  favorite?: boolean;
  useCount?: number;
  createdAt: string;
}

interface VerificationResult {
  claimId: string;
  originalClaim: string;
  status: "VERIFIED" | "PARTIALLY_VERIFIED" | "UNVERIFIED" | "DISPUTED" | "FALSE";
  confidenceScore: number;
  supportingEvidence: Array<{ sourceName: string; url: string; excerpt: string }>;
  contradictingEvidence: Array<{ sourceName: string; url: string; excerpt: string }>;
  verificationSummary: string;
}

// ============================================
// Constants
// ============================================

const MODE_CONFIG = {
  unified: {
    label: "통합 검색",
    description: "DB + 웹 + AI를 동시에 검색",
    icon: Search,
    color: "text-blue-600",
    bgColor: "bg-blue-50 dark:bg-blue-900/20",
    borderColor: "border-blue-500",
  },
  deep: {
    label: "심층 보고서",
    description: "AI 기반 심층 분석 보고서 생성",
    icon: Brain,
    color: "text-purple-600",
    bgColor: "bg-purple-50 dark:bg-purple-900/20",
    borderColor: "border-purple-500",
  },
  factcheck: {
    label: "팩트체크",
    description: "주장의 진위 검증",
    icon: Shield,
    color: "text-green-600",
    bgColor: "bg-green-50 dark:bg-green-900/20",
    borderColor: "border-green-500",
  },
  urlanalysis: {
    label: "URL 분석",
    description: "URL에서 주장 추출 및 검증",
    icon: LinkIcon,
    color: "text-orange-600",
    bgColor: "bg-orange-50 dark:bg-orange-900/20",
    borderColor: "border-orange-500",
  },
} as const;

const SOURCE_CONFIG = {
  database: { label: "DB", icon: Database, color: "text-blue-600", bgColor: "bg-blue-100 dark:bg-blue-900/30" },
  web: { label: "웹", icon: Globe, color: "text-green-600", bgColor: "bg-green-100 dark:bg-green-900/30" },
  ai: { label: "AI", icon: Brain, color: "text-purple-600", bgColor: "bg-purple-100 dark:bg-purple-900/30" },
} as const;

const STANCE_CONFIG = {
  pro: { label: "긍정", icon: ThumbsUp, color: "text-teal-600", bgColor: "bg-teal-100 dark:bg-teal-900/30" },
  con: { label: "부정", icon: ThumbsDown, color: "text-red-600", bgColor: "bg-red-100 dark:bg-red-900/30" },
  neutral: { label: "중립", icon: Minus, color: "text-gray-600", bgColor: "bg-gray-100 dark:bg-gray-800" },
} as const;

const SOURCE_CATEGORY_CONFIG = {
  news: { label: "뉴스", icon: Newspaper, color: "text-blue-600", bgColor: "bg-blue-100 dark:bg-blue-900/30" },
  community: { label: "커뮤니티", icon: Users, color: "text-orange-600", bgColor: "bg-orange-100 dark:bg-orange-900/30" },
  blog: { label: "블로그", icon: FileText, color: "text-purple-600", bgColor: "bg-purple-100 dark:bg-purple-900/30" },
  official: { label: "공식", icon: Shield, color: "text-green-600", bgColor: "bg-green-100 dark:bg-green-900/30" },
  academic: { label: "학술", icon: GraduationCap, color: "text-indigo-600", bgColor: "bg-indigo-100 dark:bg-indigo-900/30" },
} as const;

const VERIFICATION_CONFIG = {
  VERIFIED: { label: "검증됨", icon: CheckCircle2, color: "text-green-600", bgColor: "bg-green-100 dark:bg-green-900/30" },
  PARTIALLY_VERIFIED: { label: "부분 검증", icon: AlertTriangle, color: "text-yellow-600", bgColor: "bg-yellow-100 dark:bg-yellow-900/30" },
  UNVERIFIED: { label: "검증 불가", icon: HelpCircle, color: "text-gray-600", bgColor: "bg-gray-100 dark:bg-gray-800" },
  DISPUTED: { label: "논쟁 중", icon: Scale, color: "text-orange-600", bgColor: "bg-orange-100 dark:bg-orange-900/30" },
  FALSE: { label: "거짓", icon: XCircle, color: "text-red-600", bgColor: "bg-red-100 dark:bg-red-900/30" },
} as const;

// Default user ID for templates (can be replaced with actual auth)
const DEFAULT_USER_ID = "default-user";

// ============================================
// Result Card Components
// ============================================

interface UnifiedResultCardProps {
  result: UnifiedSearchResult;
  isSelected: boolean;
  onSelect: () => void;
  onViewDetail: () => void;
  onAddToProject?: () => void;
  hasProject?: boolean;
}

const UnifiedResultCard = ({ result, isSelected, onSelect, onViewDetail, onAddToProject, hasProject }: UnifiedResultCardProps) => {
  const sourceConfig = SOURCE_CONFIG[result.source] || SOURCE_CONFIG.web;
  const SourceIcon = sourceConfig.icon;

  return (
    <Card className={`${sourceConfig.bgColor} border-l-4 ${isSelected ? "border-l-primary ring-2 ring-primary/30" : "border-l-transparent"} transition-all hover:shadow-md`}>
      <CardContent className="p-4">
        <div className="flex items-start gap-3">
          <div className="flex-1 min-w-0">
            <div className="flex items-center gap-2 mb-2">
              <Badge variant="outline" className={`${sourceConfig.color} flex items-center gap-1`}>
                <SourceIcon className="h-3 w-3" />
                {result.sourceLabel || sourceConfig.label}
              </Badge>
              {result.publishedAt && (
                <span className="text-xs text-muted-foreground">
                  {new Date(result.publishedAt).toLocaleDateString("ko-KR")}
                </span>
              )}
            </div>
            <h4 className="font-semibold text-sm mb-1 line-clamp-2">{result.title}</h4>
            {result.snippet && result.source === 'ai' ? (
              <div className="text-sm text-muted-foreground">
                <MarkdownRenderer content={result.snippet} isStreaming={false} />
              </div>
            ) : result.snippet ? (
              <p className="text-sm text-muted-foreground line-clamp-2">{result.snippet}</p>
            ) : null}
          </div>
          <div className="flex flex-col gap-1">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <button
                    onClick={onViewDetail}
                    className="p-2 rounded-md hover:bg-muted text-muted-foreground transition-colors"
                  >
                    <Eye className="h-4 w-4" />
                  </button>
                </TooltipTrigger>
                <TooltipContent>세부 내용 보기</TooltipContent>
              </Tooltip>
            </TooltipProvider>
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <button
                    onClick={onSelect}
                    className={`p-2 rounded-md transition-colors ${
                      isSelected
                        ? "bg-primary text-primary-foreground"
                        : "hover:bg-muted text-muted-foreground"
                    }`}
                  >
                    <Pin className="h-4 w-4" />
                  </button>
                </TooltipTrigger>
                <TooltipContent>
                  {isSelected ? "선택 해제" : "템플릿에 추가"}
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
            {hasProject && onAddToProject && (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <button
                      onClick={onAddToProject}
                      className="p-2 rounded-md hover:bg-muted text-muted-foreground hover:text-green-600 transition-colors"
                    >
                      <FolderPlus className="h-4 w-4" />
                    </button>
                  </TooltipTrigger>
                  <TooltipContent>프로젝트에 추가</TooltipContent>
                </Tooltip>
              </TooltipProvider>
            )}
            {result.url && (
              <a
                href={result.url}
                target="_blank"
                rel="noopener noreferrer"
                className="p-2 rounded-md hover:bg-muted transition-colors"
              >
                <ExternalLink className="h-4 w-4" />
              </a>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

interface EvidenceCardProps {
  evidence: Evidence;
  isSelected: boolean;
  onSelect: () => void;
  onViewDetail: () => void;
  onAddToProject?: () => void;
  hasProject?: boolean;
}

const EvidenceCard = ({ evidence, isSelected, onSelect, onViewDetail, onAddToProject, hasProject }: EvidenceCardProps) => {
  const stanceConfig = STANCE_CONFIG[evidence.stance] || STANCE_CONFIG.neutral;
  const StanceIcon = stanceConfig.icon;

  return (
    <Card className={`${stanceConfig.bgColor} border-l-4 ${isSelected ? "border-l-primary ring-2 ring-primary/30" : evidence.stance === "pro" ? "border-l-teal-500" : evidence.stance === "con" ? "border-l-red-500" : "border-l-gray-400"} transition-all hover:shadow-md`}>
      <CardContent className="p-4">
        <div className="flex items-start gap-3">
          <div className="flex-1 min-w-0">
            <div className="flex items-center gap-2 mb-2">
              <Badge variant="outline" className={`${stanceConfig.color} flex items-center gap-1`}>
                <StanceIcon className="h-3 w-3" />
                {stanceConfig.label}
              </Badge>
              {evidence.source && (
                <span className="text-xs text-muted-foreground truncate">{evidence.source}</span>
              )}
            </div>
            {evidence.title && (
              <h4 className="font-semibold text-sm mb-1 line-clamp-2">{evidence.title}</h4>
            )}
            <p className="text-sm text-muted-foreground line-clamp-3">{evidence.snippet}</p>
          </div>
          <div className="flex flex-col gap-1">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <button
                    onClick={onViewDetail}
                    className="p-2 rounded-md hover:bg-muted text-muted-foreground transition-colors"
                  >
                    <Eye className="h-4 w-4" />
                  </button>
                </TooltipTrigger>
                <TooltipContent>세부 내용 보기</TooltipContent>
              </Tooltip>
            </TooltipProvider>
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <button
                    onClick={onSelect}
                    className={`p-2 rounded-md transition-colors ${
                      isSelected
                        ? "bg-primary text-primary-foreground"
                        : "hover:bg-muted text-muted-foreground"
                    }`}
                  >
                    <Pin className="h-4 w-4" />
                  </button>
                </TooltipTrigger>
                <TooltipContent>
                  {isSelected ? "선택 해제" : "템플릿에 추가"}
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
            {hasProject && onAddToProject && (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <button
                      onClick={onAddToProject}
                      className="p-2 rounded-md hover:bg-muted text-muted-foreground hover:text-green-600 transition-colors"
                    >
                      <FolderPlus className="h-4 w-4" />
                    </button>
                  </TooltipTrigger>
                  <TooltipContent>프로젝트에 추가</TooltipContent>
                </Tooltip>
              </TooltipProvider>
            )}
            {evidence.url && (
              <a
                href={evidence.url}
                target="_blank"
                rel="noopener noreferrer"
                className="p-2 rounded-md hover:bg-muted transition-colors"
              >
                <ExternalLink className="h-4 w-4" />
              </a>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

// VerificationCard component removed - now using embedded FactCheckChatbot

// ============================================
// Selection Panel
// ============================================

interface SelectionPanelProps {
  selectedItems: SelectedItem[];
  onRemove: (id: string) => void;
  onClear: () => void;
  onSaveTemplate: (name: string) => void;
}

const SelectionPanel = ({ selectedItems, onRemove, onClear, onSaveTemplate }: SelectionPanelProps) => {
  const [templateName, setTemplateName] = useState("");
  const [isExpanded, setIsExpanded] = useState(true);

  const handleSave = () => {
    if (templateName.trim()) {
      onSaveTemplate(templateName.trim());
      setTemplateName("");
    }
  };

  if (selectedItems.length === 0) return null;

  const typeColors = {
    unified: "border-l-blue-500 bg-blue-50 dark:bg-blue-900/20",
    evidence: "border-l-purple-500 bg-purple-50 dark:bg-purple-900/20",
    factcheck: "border-l-green-500 bg-green-50 dark:bg-green-900/20",
  };

  return (
    <Card className="border-dashed border-2 border-primary/30 bg-primary/5">
      <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
        <CardHeader className="pb-2">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Pin className="h-4 w-4 text-primary" />
              <CardTitle className="text-base">선택한 항목 ({selectedItems.length})</CardTitle>
            </div>
            <div className="flex items-center gap-2">
              <Button variant="ghost" size="sm" onClick={onClear}>
                전체 해제
              </Button>
              <CollapsibleTrigger asChild>
                <Button variant="ghost" size="sm">
                  {isExpanded ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
                </Button>
              </CollapsibleTrigger>
            </div>
          </div>
        </CardHeader>
        <CollapsibleContent>
          <CardContent className="space-y-4">
            <ScrollArea className="max-h-[200px]">
              <div className="space-y-2 pr-4">
                {selectedItems.map((item) => (
                  <div key={item.id} className={`border-l-4 p-3 rounded-r-lg ${typeColors[item.type]}`}>
                    <div className="flex items-start justify-between gap-2">
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1">
                          <Badge variant="outline" className="text-xs">
                            {item.type === "unified" ? "검색결과" : item.type === "evidence" ? "증거" : "검증"}
                          </Badge>
                          {item.stance && <Badge variant="secondary" className="text-xs">{item.stance}</Badge>}
                        </div>
                        <p className="text-sm font-medium line-clamp-1">{item.title}</p>
                      </div>
                      <button
                        onClick={() => onRemove(item.id)}
                        className="p-1 rounded hover:bg-destructive/10 text-destructive transition-colors"
                      >
                        <X className="h-3 w-3" />
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            </ScrollArea>
            <div className="flex gap-2 pt-2 border-t">
              <Input
                placeholder="템플릿 이름"
                value={templateName}
                onChange={(e) => setTemplateName(e.target.value)}
                className="flex-1"
                onKeyDown={(e) => e.key === "Enter" && handleSave()}
              />
              <Button onClick={handleSave} disabled={!templateName.trim()}>
                <Bookmark className="h-4 w-4 mr-1" />
                저장
              </Button>
            </div>
          </CardContent>
        </CollapsibleContent>
      </Collapsible>
    </Card>
  );
};

// ============================================
// Main Component
// ============================================

export default function SmartSearch() {
  const { toast } = useToast();
  const location = useLocation();
  const navigate = useNavigate();
  const [searchParams, setSearchParams] = useSearchParams();

  // Get initial mode from URL params (for backward compatibility redirects)
  const getInitialMode = (): SearchMode => {
    const modeParam = searchParams.get("mode");
    if (modeParam === "deep" || modeParam === "factcheck" || modeParam === "unified" || modeParam === "urlanalysis") {
      return modeParam;
    }
    return "unified";
  };

  // Project state
  const [projectSelectorOpen, setProjectSelectorOpen] = useState(false);
  const [selectedProjectId, setSelectedProjectId] = useState<number | null>(null);
  const { 
    projects, 
    loading: projectsLoading, 
    loadProjects,
    addItem: addProjectItem,
    selectProject,
    currentProject,
  } = useProjects({ userId: DEFAULT_USER_ID, autoLoad: true });

  // Background tasks for loading completed Deep Search results
  const { getTask } = useBackgroundTasks();

  // State (moved before effects that use them)
  const [activeTab, setActiveTab] = useState<SearchMode>(getInitialMode);
  const [query, setQuery] = useState(searchParams.get("q") || "");

  // Deep Search State (moved before the loading effect)
  const [deepJobId, setDeepJobId] = useState<string | null>(null);
  const [deepResults, setDeepResults] = useState<DeepSearchResult | null>(null);
  const [deepLoading, setDeepLoading] = useState(false);
  const [deepError, setDeepError] = useState<string | null>(null);
  const [deepProgress, setDeepProgress] = useState(0);
  const [showDeepHistory, setShowDeepHistory] = useState(false);
  const [deepHistoryLoading, setDeepHistoryLoading] = useState(false);
  const [deepHistoryJobs, setDeepHistoryJobs] = useState<DeepSearchJob[]>([]);

  // Get selected project object
  const selectedProject = useMemo(() => {
    if (!selectedProjectId) return null;
    return projects.find(p => p.id === selectedProjectId) || currentProject;
  }, [selectedProjectId, projects, currentProject]);

  // Read projectId from URL params on mount
  useEffect(() => {
    const projectIdParam = searchParams.get("projectId");
    if (projectIdParam) {
      const projectId = parseInt(projectIdParam, 10);
      if (!isNaN(projectId)) {
        setSelectedProjectId(projectId);
        // Load the project details
        selectProject(projectId).catch(console.error);
      }
    }
  }, [searchParams, selectProject]);

  // Load Deep Search result from URL jobId parameter or background task
  useEffect(() => {
    const jobIdParam = searchParams.get("jobId");
    if (!jobIdParam) return;

    console.log('[SmartSearch] Loading Deep Search from jobId param:', jobIdParam);
    setDeepJobId(jobIdParam);
    setActiveTab("deep");
    
    // Try to load result from background task first
    const task = getTask(jobIdParam);
    if (task && task.result) {
      console.log('[SmartSearch] Found cached result in background task:', task.result);
      setDeepResults(task.result as DeepSearchResult);
      setDeepProgress(100);
      setDeepLoading(false);
      if (task.title) {
        setQuery(task.title);
      }
      return;
    }

    // Fallback: fetch from API
    const loadFromApi = async () => {
      try {
        console.log('[SmartSearch] Fetching Deep Search result from API...');
        setDeepLoading(true);
        const result = await getDeepSearchResult(jobIdParam);
        console.log('[SmartSearch] API result:', result);
        setDeepResults(result);
        setDeepProgress(100);
        if (result.topic) {
          setQuery(result.topic);
        }
      } catch (e) {
        console.error('[SmartSearch] Failed to load Deep Search result:', e);
        setDeepError(e instanceof Error ? e.message : 'Deep Search 결과를 불러오는데 실패했습니다.');
      } finally {
        setDeepLoading(false);
      }
    };

    loadFromApi();
  }, [searchParams, getTask]); // Removed deepResults from deps to prevent re-fetching

  // Additional State
  const [selectedItems, setSelectedItems] = useState<SelectedItem[]>([]);
  const [templates, setTemplates] = useState<SearchTemplate[]>([]);
  const [showTemplates, setShowTemplates] = useState(false);
  const [templatesLoading, setTemplatesLoading] = useState(false);
  const [templateFilter, setTemplateFilter] = useState<"all" | "favorites" | "recent" | "mostUsed">("all");
  const [templateSearchQuery, setTemplateSearchQuery] = useState("");

  // Search filters state (time window, sources, etc.)
  const [filters, setFilters] = useState<SearchFilters>(defaultFilters);

  // Unified Search State
  const [unifiedResults, setUnifiedResults] = useState<UnifiedSearchResult[]>([]);
  const [unifiedLoading, setUnifiedLoading] = useState(false);
  const [unifiedError, setUnifiedError] = useState<string | null>(null);
  const unifiedEventSourceRef = useRef<EventSource | null>(null);
  const [unifiedJobId, setUnifiedJobId] = useState<string | null>(null);

  const [aiReportLoading, setAiReportLoading] = useState(false);
  const [aiReportError, setAiReportError] = useState<string | null>(null);
  const [aiReportSummary, setAiReportSummary] = useState<string | null>(null);
  const [aiReportContent, setAiReportContent] = useState<string | null>(null);

  // FactCheck State - Moved to embedded FactCheckChatbot component
  // Old states removed: claims, factCheckResults, factCheckLoading, factCheckError

  // URL Analysis State
  const [analysisUrl, setAnalysisUrl] = useState("");
  const [urlClaims, setUrlClaims] = useState<Array<{
    id: string;
    text: string;
    confidence: number;
    context?: string;
    selected: boolean;
  }>>([]);
  const [urlAnalysisLoading, setUrlAnalysisLoading] = useState(false);
  const [urlAnalysisError, setUrlAnalysisError] = useState<string | null>(null);
  const [urlPageTitle, setUrlPageTitle] = useState<string | null>(null);
  const [priorityUrls, setPriorityUrls] = useState<PriorityUrl[]>([]);

  // Detail View Dialog State
  const [detailDialogOpen, setDetailDialogOpen] = useState(false);
  const [detailItem, setDetailItem] = useState<{
    type: "unified" | "evidence" | "verification";
    data: UnifiedSearchResult | Evidence | VerificationResult;
  } | null>(null);

  // Track if we should auto-search on initial load
  const initialSearchRef = useRef(false);
  
  // Ref for the embedded FactCheckChatbot
  const factCheckChatbotRef = useRef<FactCheckChatbotRef>(null);
  
  // State for claims to be sent to the chatbot (from URL analysis transfer)
  const [pendingFactCheckClaims, setPendingFactCheckClaims] = useState<string[]>([]);

  // Accept navigation state from other pages (SearchHistory, UrlCollections, ParallelSearch, etc.)
  useEffect(() => {
    const state = location.state as {
      query?: string;
      priorityUrls?: PriorityUrl[];
      fromHistory?: boolean;
      autoSearch?: boolean;
    } | null;

    if (!state) return;

    if (typeof state.query === 'string' && state.query.trim()) {
      setQuery(state.query);
    }

    if (Array.isArray(state.priorityUrls) && state.priorityUrls.length > 0) {
      setPriorityUrls(state.priorityUrls);
    }
  }, [location.state]);

  // Deep Search SSE Hook
  const {
    status: deepSSEStatus,
    currentStatus: deepJobStatus,
    progress: sseProgress,
    result: sseResult,
    error: sseError,
  } = useDeepSearchSSE({
    jobId: deepJobId,
    topic: query,
    enabled: !!deepJobId,
    onComplete: (result) => {
      console.log('[SmartSearch] Deep Search completed with result:', result);
      setDeepResults(result);
      setDeepLoading(false);
      setDeepProgress(100);
    },
    onError: (error) => {
      console.error('[SmartSearch] Deep Search error:', error);
      setDeepError(error);
      setDeepLoading(false);
    },
    onProgress: (progress) => {
      setDeepProgress(progress);
    },
  });

  // Sync SSE result to deepResults state - always sync when sseResult changes
  useEffect(() => {
    if (sseResult) {
      console.log('[SmartSearch] Syncing sseResult to deepResults:', sseResult);
      setDeepResults(sseResult);
      // Mark as done only when job status is COMPLETED
      if (sseResult.status === 'COMPLETED') {
        setDeepLoading(false);
        setDeepProgress(100);
      }
    }
  }, [sseResult]);

  // Sync SSE error to deepError state
  useEffect(() => {
    if (sseError && !deepError) {
      console.log('[SmartSearch] Syncing sseError to deepError:', sseError);
      setDeepError(sseError);
      setDeepLoading(false);
    }
  }, [sseError, deepError]);

  // Sync SSE progress to deepProgress state
  useEffect(() => {
    if (sseProgress > 0 && sseProgress > deepProgress) {
      setDeepProgress(sseProgress);
    }
  }, [sseProgress, deepProgress]);

  // Sync SSE job status to loading state
  useEffect(() => {
    if (deepJobStatus === 'COMPLETED' || deepJobStatus === 'FAILED' || deepJobStatus === 'CANCELLED' || deepJobStatus === 'TIMEOUT') {
      setDeepLoading(false);
    } else if (deepJobStatus === 'IN_PROGRESS') {
      setDeepLoading(true);
    }
  }, [deepJobStatus]);

  // Load templates from server based on filter and search query
  useEffect(() => {
    const loadTemplates = async () => {
      setTemplatesLoading(true);
      try {
        let serverTemplates: ApiSearchTemplate[];
        
        // If there's a search query, use search API regardless of filter
        if (templateSearchQuery.trim()) {
          const searchResult = await searchTemplatesByName(templateSearchQuery.trim(), DEFAULT_USER_ID);
          serverTemplates = searchResult.content;
        } else {
          switch (templateFilter) {
            case "favorites":
              serverTemplates = await getFavoriteTemplates(DEFAULT_USER_ID);
              break;
            case "recent":
              serverTemplates = await getRecentlyUsedTemplates(DEFAULT_USER_ID, 20);
              break;
            case "mostUsed":
              serverTemplates = await getMostUsedTemplates(DEFAULT_USER_ID, 20);
              break;
            default:
              serverTemplates = await getAllTemplatesByUser(DEFAULT_USER_ID);
          }
        }
        
        // Transform API response to local format
        const transformedTemplates: SearchTemplate[] = serverTemplates.map((t) => ({
          id: t.id,
          name: t.name,
          query: t.query,
          mode: t.mode as SearchMode,
          items: t.items.map((item) => ({
            ...item,
            addedAt: item.addedAt || new Date().toISOString(),
          })) as SelectedItem[],
          favorite: t.favorite,
          useCount: t.useCount,
          createdAt: t.createdAt,
        }));
        setTemplates(transformedTemplates);
      } catch (e) {
        console.error("Failed to load templates from server:", e);
        // Fallback: try localStorage for migration (only for 'all' filter without search)
        if (templateFilter === "all" && !templateSearchQuery.trim()) {
          try {
            const saved = localStorage.getItem("smartSearch_templates");
            if (saved) {
              const localTemplates = JSON.parse(saved);
              // Migrate old localStorage templates to server
              for (const t of localTemplates) {
                try {
                  const sanitizedMode = toTemplateMode(t.mode as SearchMode);
                  const sanitizedItems = Array.isArray(t.items)
                    ? (t.items as SelectedItem[]).filter(isTemplateItem)
                    : [];

                  await createSearchTemplate({
                    name: t.name,
                    query: t.query,
                    mode: sanitizedMode,
                    items: sanitizedItems,
                    userId: DEFAULT_USER_ID,
                  });
                } catch (migrationError) {
                  console.error("Failed to migrate template:", migrationError);
                }
              }
              // Clear localStorage after migration
              localStorage.removeItem("smartSearch_templates");
              // Reload from server
              const migrated = await getAllTemplatesByUser(DEFAULT_USER_ID);
              setTemplates(migrated.map((t) => ({
                id: t.id,
                name: t.name,
                query: t.query,
                mode: t.mode as SearchMode,
                items: t.items as SelectedItem[],
                favorite: t.favorite,
                useCount: t.useCount,
                createdAt: t.createdAt,
              })));
            }
          } catch (localError) {
            console.error("Failed to migrate local templates:", localError);
          }
        }
      } finally {
        setTemplatesLoading(false);
      }
    };
    loadTemplates();
  }, [templateFilter, templateSearchQuery]);

  // Save template to server
  const saveAsTemplate = useCallback(async (name: string) => {
    try {
      const templateMode = toTemplateMode(activeTab);
      const templateItems = selectedItems
        .filter(isTemplateItem)
        .map((item) => ({
          id: item.id,
          type: item.type,
          title: item.title,
          url: item.url,
          snippet: item.snippet,
          source: item.source,
          stance: item.stance,
          verificationStatus: item.verificationStatus,
          addedAt: item.addedAt,
        }));

      const created = await createSearchTemplate({
        name,
        query,
        mode: templateMode,
        items: templateItems,
        userId: DEFAULT_USER_ID,
      });
      
      // Add to local state
      const newTemplate: SearchTemplate = {
        id: created.id,
        name: created.name,
        query: created.query,
        mode: created.mode as SearchMode,
        items: created.items as SelectedItem[],
        favorite: created.favorite,
        useCount: created.useCount,
        createdAt: created.createdAt,
      };
      setTemplates((prev) => [...prev, newTemplate]);
      toast({ title: "템플릿 저장됨", description: `"${name}" 템플릿이 서버에 저장되었습니다.` });
    } catch (e) {
      console.error("Failed to save template:", e);
      toast({ 
        title: "저장 실패", 
        description: "템플릿 저장에 실패했습니다.",
        variant: "destructive",
      });
    }
  }, [query, activeTab, selectedItems, toast]);

  // Selection handlers
  const toggleSelection = useCallback((item: Omit<SelectedItem, "addedAt">) => {
    setSelectedItems((prev) => {
      const exists = prev.find((i) => i.id === item.id);
      if (exists) {
        return prev.filter((i) => i.id !== item.id);
      }
      return [...prev, { ...item, addedAt: new Date().toISOString() }];
    });
  }, []);

  const isSelected = useCallback((id: string) => {
    return selectedItems.some((i) => i.id === id);
  }, [selectedItems]);

  const clearSelection = useCallback(() => setSelectedItems([]), []);

  const loadTemplate = useCallback(async (template: SearchTemplate) => {
    // Record usage on server
    try {
      await recordTemplateUsage(template.id);
    } catch (e) {
      console.error("Failed to record template usage:", e);
    }
    
    setQuery(template.query);
    setActiveTab(template.mode);
    setSelectedItems(template.items);
    setShowTemplates(false);
    toast({ title: "템플릿 로드됨", description: `"${template.name}" 템플릿이 적용되었습니다.` });
  }, [toast]);

  const deleteTemplate = useCallback(async (id: number) => {
    try {
      await deleteSearchTemplate(id);
      setTemplates((prev) => prev.filter((t) => t.id !== id));
      toast({ title: "삭제됨", description: "템플릿이 삭제되었습니다." });
    } catch (e) {
      console.error("Failed to delete template:", e);
      toast({ 
        title: "삭제 실패", 
        description: "템플릿 삭제에 실패했습니다.",
        variant: "destructive",
      });
    }
  }, [toast]);

  const toggleFavorite = useCallback(async (id: number) => {
    try {
      const updated = await toggleTemplateFavorite(id);
      setTemplates((prev) => prev.map((t) => 
        t.id === id ? { ...t, favorite: updated.favorite } : t
      ));
    } catch (e) {
      console.error("Failed to toggle favorite:", e);
    }
  }, []);

  // ============================================
  // Project Functions
  // ============================================

  // Add item to selected project
  const handleAddToProject = useCallback(async (
    itemType: ProjectItemType,
    title: string,
    content?: string,
    sourceUrl?: string,
    metadata?: Record<string, unknown>
  ) => {
    if (!selectedProjectId) {
      toast({
        title: "프로젝트를 선택해주세요",
        description: "항목을 추가할 프로젝트를 먼저 선택해주세요.",
        variant: "destructive",
      });
      return;
    }

    try {
      await addProjectItem(selectedProjectId, {
        itemType,
        title,
        content,
        sourceUrl,
        metadata,
        isRead: false,
        isBookmarked: false,
      });
      toast({
        title: "프로젝트에 추가됨",
        description: `"${title.slice(0, 30)}${title.length > 30 ? '...' : ''}"이(가) 프로젝트에 추가되었습니다.`,
      });
    } catch (e) {
      console.error("Failed to add item to project:", e);
      toast({
        title: "추가 실패",
        description: e instanceof Error ? e.message : "프로젝트에 항목을 추가하는데 실패했습니다.",
        variant: "destructive",
      });
    }
  }, [selectedProjectId, addProjectItem, toast]);

  // Add unified result to project
  const handleAddUnifiedToProject = useCallback((result: UnifiedSearchResult) => {
    const itemType: ProjectItemType = result.source === 'database' ? 'ARTICLE' : 
                                      result.source === 'ai' ? 'DOCUMENT' : 'SEARCH_RESULT';
    handleAddToProject(
      itemType,
      result.title,
      result.snippet || result.content,
      result.url,
      {
        source: result.source,
        sourceLabel: result.sourceLabel,
        publishedAt: result.publishedAt,
        searchQuery: query,
      }
    );
  }, [handleAddToProject, query]);

  // Add evidence to project
  const handleAddEvidenceToProject = useCallback((evidence: Evidence) => {
    handleAddToProject(
      'EVIDENCE',
      evidence.title || evidence.snippet.slice(0, 50),
      evidence.snippet,
      evidence.url,
      {
        stance: evidence.stance,
        source: evidence.source,
        searchQuery: query,
      }
    );
  }, [handleAddToProject, query]);

  // Add verification result to project
  // handleAddVerificationToProject removed - now using embedded FactCheckChatbot

  // Handle project selection change
  const handleProjectSelect = useCallback((projectId: number | null) => {
    setSelectedProjectId(projectId);
    setProjectSelectorOpen(false);
    
    // Update URL params
    const newParams = new URLSearchParams(searchParams);
    if (projectId) {
      newParams.set("projectId", String(projectId));
    } else {
      newParams.delete("projectId");
    }
    setSearchParams(newParams, { replace: true });
  }, [searchParams, setSearchParams]);

  // ============================================
  // Search Functions
  // ============================================

  // Unified Search
  const runUnifiedSearch = useCallback(async () => {
    if (!query.trim()) return;

    setUnifiedLoading(true);
    setUnifiedError(null);
    setUnifiedResults([]);

    // Close previous connection
    if (unifiedEventSourceRef.current) {
      unifiedEventSourceRef.current.close();
    }

    try {
      // Build date parameters based on filters
      let startDate: string | undefined;
      let endDate: string | undefined;
      
      if (filters.timeWindow === "custom") {
        if (filters.customStartDate) {
          startDate = filters.customStartDate.toISOString();
        }
        if (filters.customEndDate) {
          // Set end date to end of day
          const end = new Date(filters.customEndDate);
          end.setHours(23, 59, 59, 999);
          endDate = end.toISOString();
        }
      }

      // Get priority URLs if any
      const priorityUrlStrings = priorityUrls.length > 0 
        ? priorityUrls.map(u => u.url) 
        : undefined;

      const job = await startUnifiedSearchJob(
        query, 
        filters.timeWindow,
        priorityUrlStrings,
        startDate,
        endDate
      );
      setUnifiedJobId(job.jobId);
      const es = await openUnifiedSearchJobStream(job.jobId);
      unifiedEventSourceRef.current = es;

      es.addEventListener("result", (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.result) {
            setUnifiedResults((prev) => [...prev, data.result]);
          }
        } catch (e) {
          console.error("Failed to parse result:", e);
        }
      });

      es.addEventListener("done", () => {
        setUnifiedLoading(false);
        es.close();
      });

      es.addEventListener("job_error", (event) => {
        try {
          const data = JSON.parse(event.data);
          setUnifiedError(data.error || "검색 중 오류가 발생했습니다.");
        } catch {
          setUnifiedError("검색 중 오류가 발생했습니다.");
        }
        setUnifiedLoading(false);
        es.close();
      });

      es.onerror = () => {
        setUnifiedError("연결이 끊어졌습니다.");
        setUnifiedLoading(false);
        es.close();
      };
    } catch (e) {
      setUnifiedError(e instanceof Error ? e.message : "검색 시작 실패");
      setUnifiedLoading(false);
    }
  }, [query, filters, priorityUrls]);

  // Helper: Extract summary section from markdown content
  const extractSummaryFromContent = useCallback((markdown: string | null | undefined): string | null => {
    if (!markdown) return null;
    
    // Look for "### [요약]" or "## [요약]" section
    let start = markdown.indexOf("### [요약]");
    if (start < 0) start = markdown.indexOf("## [요약]");
    if (start < 0) start = markdown.indexOf("### 요약");
    if (start < 0) start = markdown.indexOf("## 요약");
    if (start < 0) return null;

    // Find next section header
    let end = markdown.indexOf("\n### ", start + 1);
    if (end < 0) end = markdown.indexOf("\n## ", start + 1);
    if (end < 0) end = markdown.length;

    const section = markdown.substring(start, end).trim();
    return section || null;
  }, []);

  useEffect(() => {
    const loadAiReport = async () => {
      const current = detailItem?.type === "unified" ? (detailItem.data as UnifiedSearchResult) : null;
      if (!detailDialogOpen || !current || current.source !== "ai") {
        setAiReportLoading(false);
        setAiReportError(null);
        setAiReportSummary(null);
        setAiReportContent(null);
        return;
      }

      // Priority 1: Use SSE content if available (immediate, no network call)
      // SSE result should have full content in 'content' field
      const sseContent = current.content || null;
      const sseSnippet = current.snippet || null;
      
      // Debug: Log what we have from SSE
      console.debug("[AI Report] SSE data:", {
        hasContent: !!sseContent,
        contentLength: sseContent?.length,
        hasSnippet: !!sseSnippet,
        snippetLength: sseSnippet?.length,
        contentPreview: sseContent?.substring(0, 100),
      });
      
      // If SSE content is available, use it immediately (best case - no network needed)
      if (sseContent && sseContent.length > 500) {
        // SSE has full content (longer than typical snippet)
        setAiReportLoading(false);
        setAiReportError(null);
        setAiReportContent(sseContent);
        setAiReportSummary(extractSummaryFromContent(sseContent));
        console.debug("[AI Report] Using SSE full content");
        return;
      }
      
      // If no jobId, use whatever SSE data we have
      if (!unifiedJobId) {
        setAiReportLoading(false);
        setAiReportError(null);
        const content = sseContent || sseSnippet;
        setAiReportContent(content);
        setAiReportSummary(extractSummaryFromContent(content));
        return;
      }

      // Set initial content from SSE while loading DB data
      const initialContent = sseContent || sseSnippet;
      setAiReportContent(initialContent);
      setAiReportSummary(extractSummaryFromContent(initialContent));
      
      // Try to fetch from DB for full content
      setAiReportLoading(true);
      setAiReportError(null);
      
      // Helper to fetch from DB
      const fetchFromDb = async (): Promise<{ content: string | null; summary: string | null }> => {
        const record = await getSearchHistoryByExternalId(unifiedJobId);
        const aiSummary = record.aiSummary || {};
        const dbSummary = typeof (aiSummary as Record<string, unknown>).summary === "string" 
          ? (aiSummary as Record<string, unknown>).summary as string 
          : null;
        const dbContent = typeof (aiSummary as Record<string, unknown>).content === "string" 
          ? (aiSummary as Record<string, unknown>).content as string 
          : null;
        return { content: dbContent, summary: dbSummary };
      };
      
      try {
        let { content: dbContent, summary: dbSummary } = await fetchFromDb();
        
        // Debug: Log DB result
        console.debug("[AI Report] DB fetch result:", {
          hasDbContent: !!dbContent,
          dbContentLength: dbContent?.length,
          hasDbSummary: !!dbSummary,
        });
        
        // If DB doesn't have content yet, wait and retry once
        // (AI report might still be saving to DB)
        if (!dbContent && unifiedJobId) {
          console.debug("[AI Report] DB content not found, retrying after delay...");
          await new Promise(resolve => setTimeout(resolve, 1500));
          const retry = await fetchFromDb();
          dbContent = retry.content;
          dbSummary = retry.summary;
          console.debug("[AI Report] Retry result:", {
            hasDbContent: !!dbContent,
            dbContentLength: dbContent?.length,
          });
        }

        // Use DB content if available (most reliable), otherwise keep SSE content
        const finalContent = dbContent || sseContent || sseSnippet;
        const finalSummary = dbSummary || extractSummaryFromContent(finalContent);
        
        setAiReportContent(finalContent);
        setAiReportSummary(finalSummary);
        
        console.debug("[AI Report] Final content source:", dbContent ? "DB" : sseContent ? "SSE content" : "SSE snippet");
      } catch (e) {
        // DB fetch failed - keep using SSE content (already set above)
        console.warn("[AI Report] Failed to load from DB, using SSE content:", e);
        // Don't show error to user if we have SSE content
        if (!sseContent && !sseSnippet) {
          setAiReportError(e instanceof Error ? e.message : "AI 보고서를 불러오는데 실패했습니다");
        }
      } finally {
        setAiReportLoading(false);
      }
    };

    void loadAiReport();
  }, [detailDialogOpen, detailItem, unifiedJobId, extractSummaryFromContent]);

  // Deep Search
  const runDeepSearch = useCallback(async () => {
    if (!query.trim()) return;

    setDeepLoading(true);
    setDeepError(null);
    setDeepResults(null);
    setDeepProgress(0);

    try {
      const job = await startDeepSearch({ topic: query });
      setDeepJobId(job.jobId);
    } catch (e) {
      setDeepError(e instanceof Error ? e.message : "Deep Search 시작 실패");
      setDeepLoading(false);
    }
  }, [query]);

  // Load Deep Search History
  const loadDeepSearchHistory = useCallback(async () => {
    setDeepHistoryLoading(true);
    try {
      const response = await listDeepSearchJobs(0, 20);
      setDeepHistoryJobs(response.content || []);
    } catch (e) {
      console.error('Failed to load deep search history:', e);
      toast({
        title: "기록 로드 실패",
        description: e instanceof Error ? e.message : "Deep Search 기록을 불러오는데 실패했습니다.",
        variant: "destructive",
      });
    } finally {
      setDeepHistoryLoading(false);
    }
  }, [toast]);

  // Load history when panel is opened
  useEffect(() => {
    if (showDeepHistory) {
      loadDeepSearchHistory();
    }
  }, [showDeepHistory, loadDeepSearchHistory]);

  // Load a previous deep search result
  const loadDeepSearchFromHistory = useCallback(async (job: DeepSearchJob) => {
    if (job.status !== 'COMPLETED') {
      toast({
        title: "불러올 수 없음",
        description: "완료되지 않은 검색입니다.",
        variant: "destructive",
      });
      return;
    }

    setDeepLoading(true);
    setDeepError(null);
    setDeepJobId(job.jobId);
    setQuery(job.topic);
    setShowDeepHistory(false);

    try {
      const result = await getDeepSearchResult(job.jobId);
      setDeepResults(result);
      setDeepProgress(100);
    } catch (e) {
      setDeepError(e instanceof Error ? e.message : "결과를 불러오는데 실패했습니다.");
    } finally {
      setDeepLoading(false);
    }
  }, [toast]);

  // Fact Check - Now handled by embedded FactCheckChatbot component
  // Old functions removed: runFactCheck, addClaim, removeClaim, updateClaim

  // URL Analysis - Extract claims from URL
  const runUrlAnalysis = useCallback(async () => {
    if (!analysisUrl.trim()) {
      setUrlAnalysisError("URL을 입력해주세요.");
      return;
    }

    // Validate URL
    try {
      const parsed = new URL(analysisUrl);
      if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
        throw new Error("Invalid protocol");
      }
    } catch {
      setUrlAnalysisError("올바른 URL 형식을 입력해주세요.");
      return;
    }

    setUrlAnalysisLoading(true);
    setUrlAnalysisError(null);
    setUrlClaims([]);
    setUrlPageTitle(null);

    try {
      const response = await extractClaimsFromUrl({
        url: analysisUrl.trim(),
        maxClaims: 10,
        minConfidence: 0.5,
      });

      if (response.message && response.claims.length === 0) {
        setUrlAnalysisError(response.message);
        return;
      }

      if (response.pageTitle) {
        setUrlPageTitle(response.pageTitle);
      }

      if (response.claims && Array.isArray(response.claims)) {
        setUrlClaims(
          response.claims.map((claim) => ({
            id: claim.id,
            text: claim.text,
            confidence: claim.confidence || 0.7,
            context: claim.context,
            selected: true,
          }))
        );
      }
    } catch (e) {
      setUrlAnalysisError(e instanceof Error ? e.message : "URL 분석 실패");
    } finally {
      setUrlAnalysisLoading(false);
    }
  }, [analysisUrl]);

  // Toggle URL claim selection
  const toggleUrlClaimSelection = useCallback((claimId: string) => {
    setUrlClaims((prev) =>
      prev.map((claim) =>
        claim.id === claimId ? { ...claim, selected: !claim.selected } : claim
      )
    );
  }, []);

  // Select/deselect all URL claims
  const selectAllUrlClaims = useCallback((selected: boolean) => {
    setUrlClaims((prev) => prev.map((claim) => ({ ...claim, selected })));
  }, []);

  // Transfer selected URL claims to fact check chatbot
  const transferToFactCheck = useCallback(() => {
    const selectedClaims = urlClaims.filter((c) => c.selected).map((c) => c.text);
    if (selectedClaims.length === 0) {
      toast({
        title: "선택된 주장이 없습니다",
        description: "팩트체크로 전송할 주장을 선택해주세요.",
        variant: "destructive",
      });
      return;
    }
    
    // Switch to factcheck tab first
    setActiveTab("factcheck");
    
    // Use ref to send claims directly if chatbot is ready, otherwise store as pending
    if (factCheckChatbotRef.current) {
      factCheckChatbotRef.current.sendClaims(selectedClaims);
    } else {
      setPendingFactCheckClaims(selectedClaims);
    }
    
    toast({
      title: "주장이 전송되었습니다",
      description: `${selectedClaims.length}개의 주장이 팩트체크 챗봇으로 전송되었습니다.`,
    });
  }, [urlClaims, toast]);

  // Handle search based on active tab
  // Note: factcheck tab now uses embedded chatbot, so no explicit search function needed
  const handleSearch = () => {
    if (activeTab === "unified") runUnifiedSearch();
    else if (activeTab === "deep") runDeepSearch();
    else if (activeTab === "factcheck") {
      // For factcheck, send the query to the chatbot
      if (query.trim() && factCheckChatbotRef.current) {
        factCheckChatbotRef.current.sendQuery(query);
      }
    }
    else if (activeTab === "urlanalysis") runUrlAnalysis();
  };

  // Auto-search on initial load if query param exists (from home page navigation)
  useEffect(() => {
    const queryParam = searchParams.get("q");
    if (queryParam && queryParam.trim() && !initialSearchRef.current) {
      initialSearchRef.current = true;
      // Delay to ensure state is set
      const timer = setTimeout(() => {
        if (activeTab === "unified") {
          runUnifiedSearch();
        } else if (activeTab === "deep") {
          runDeepSearch();
        } else if (activeTab === "factcheck") {
          // Send query to factcheck chatbot
          if (factCheckChatbotRef.current) {
            factCheckChatbotRef.current.sendQuery(queryParam);
          }
        } else if (activeTab === "urlanalysis") {
          // Set URL and run analysis
          setAnalysisUrl(queryParam);
          // Need another delay for state to update
          setTimeout(() => {
            runUrlAnalysis();
          }, 50);
        }
      }, 100);
      return () => clearTimeout(timer);
    }
  }, [searchParams, activeTab, runUnifiedSearch, runDeepSearch, runUrlAnalysis]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (unifiedEventSourceRef.current) {
        unifiedEventSourceRef.current.close();
      }
    };
  }, []);

  return (
    <div className="container py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between flex-wrap gap-4">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <Sparkles className="h-6 w-6 text-primary" />
            검색
          </h1>
          <p className="text-muted-foreground text-sm">
            통합 검색, Deep Search, 팩트체크, URL 분석을 한 곳에서
          </p>
        </div>
        <div className="flex items-center gap-2">
          {/* Project Selector */}
          <Popover open={projectSelectorOpen} onOpenChange={setProjectSelectorOpen}>
            <PopoverTrigger asChild>
              <Button
                variant="outline"
                size="sm"
                role="combobox"
                aria-expanded={projectSelectorOpen}
                className="min-w-[180px] justify-between"
              >
                {selectedProject ? (
                  <span className="flex items-center gap-2 truncate">
                    <FolderOpen className="h-4 w-4 shrink-0 text-primary" />
                    <span className="truncate">{selectedProject.name}</span>
                  </span>
                ) : (
                  <span className="flex items-center gap-2 text-muted-foreground">
                    <FolderOpen className="h-4 w-4 shrink-0" />
                    프로젝트 선택
                  </span>
                )}
                <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-[250px] p-0" align="end">
              <Command>
                <CommandInput placeholder="프로젝트 검색..." />
                <CommandList>
                  <CommandEmpty>프로젝트를 찾을 수 없습니다.</CommandEmpty>
                  <CommandGroup>
                    <CommandItem
                      value="none"
                      onSelect={() => handleProjectSelect(null)}
                    >
                      <span className="text-muted-foreground">프로젝트 없음</span>
                      {!selectedProjectId && (
                        <Check className="ml-auto h-4 w-4" />
                      )}
                    </CommandItem>
                    {projects.map((project) => (
                      <CommandItem
                        key={project.id}
                        value={project.name}
                        onSelect={() => handleProjectSelect(project.id)}
                      >
                        <FolderOpen className="mr-2 h-4 w-4" />
                        <span className="truncate">{project.name}</span>
                        {selectedProjectId === project.id && (
                          <Check className="ml-auto h-4 w-4" />
                        )}
                      </CommandItem>
                    ))}
                  </CommandGroup>
                </CommandList>
              </Command>
            </PopoverContent>
          </Popover>

          <Sheet open={showTemplates} onOpenChange={setShowTemplates}>
            <SheetTrigger asChild>
              <Button variant="outline" size="sm">
                <FolderOpen className="h-4 w-4 mr-1" />
              템플릿 ({templates.length})
            </Button>
          </SheetTrigger>
          <SheetContent>
            <SheetHeader>
              <SheetTitle>저장된 검색 템플릿</SheetTitle>
              <SheetDescription>자주 사용하는 검색 조합을 저장하고 불러올 수 있습니다.</SheetDescription>
            </SheetHeader>
            
            {/* Template Search Input */}
            <div className="mt-4 relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="템플릿 검색..."
                value={templateSearchQuery}
                onChange={(e) => setTemplateSearchQuery(e.target.value)}
                className="pl-9 pr-8"
              />
              {templateSearchQuery && (
                <button
                  onClick={() => setTemplateSearchQuery("")}
                  className="absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground hover:text-foreground"
                >
                  <X className="h-4 w-4" />
                </button>
              )}
            </div>
            
            {/* Template Filter Tabs */}
            <div className={`flex gap-1 mt-3 mb-3 p-1 bg-muted rounded-lg ${templateSearchQuery ? "opacity-50" : ""}`}>
              <Button
                variant={templateFilter === "all" ? "secondary" : "ghost"}
                size="sm"
                className="flex-1 text-xs"
                onClick={() => setTemplateFilter("all")}
                disabled={!!templateSearchQuery}
              >
                전체
              </Button>
              <Button
                variant={templateFilter === "favorites" ? "secondary" : "ghost"}
                size="sm"
                className="flex-1 text-xs"
                onClick={() => setTemplateFilter("favorites")}
                disabled={!!templateSearchQuery}
              >
                <Star className="h-3 w-3 mr-1" />
                즐겨찾기
              </Button>
              <Button
                variant={templateFilter === "recent" ? "secondary" : "ghost"}
                size="sm"
                className="flex-1 text-xs"
                onClick={() => setTemplateFilter("recent")}
                disabled={!!templateSearchQuery}
              >
                <Clock className="h-3 w-3 mr-1" />
                최근
              </Button>
              <Button
                variant={templateFilter === "mostUsed" ? "secondary" : "ghost"}
                size="sm"
                className="flex-1 text-xs"
                onClick={() => setTemplateFilter("mostUsed")}
                disabled={!!templateSearchQuery}
              >
                <Zap className="h-3 w-3 mr-1" />
                자주 사용
              </Button>
            </div>
            
            {/* Search result indicator */}
            {templateSearchQuery && (
              <div className="text-xs text-muted-foreground mb-2">
                "{templateSearchQuery}" 검색 결과: {templates.length}건
              </div>
            )}
            
            <ScrollArea className="h-[calc(100vh-280px)]">
              <div className="space-y-2 pr-4">
                {templatesLoading ? (
                  <div className="flex items-center justify-center py-8">
                    <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
                  </div>
                ) : templates.length === 0 ? (
                  <p className="text-sm text-muted-foreground text-center py-8">
                    {templateSearchQuery 
                      ? `"${templateSearchQuery}"에 대한 검색 결과가 없습니다.`
                      : "저장된 템플릿이 없습니다."
                    }
                  </p>
                ) : (
                  templates.map((template) => (
                    <Card key={template.id} className={`p-3 ${template.favorite ? "border-yellow-400 bg-yellow-50/50 dark:bg-yellow-900/10" : ""}`}>
                      <div className="flex items-start justify-between gap-2">
                        <div className="flex-1 min-w-0">
                          <div className="flex items-center gap-1">
                            <p className="font-medium text-sm">{template.name}</p>
                            {template.favorite && (
                              <Star className="h-3 w-3 fill-yellow-400 text-yellow-400" />
                            )}
                          </div>
                          <p className="text-xs text-muted-foreground truncate">
                            {template.query} ({template.items.length}개 항목)
                          </p>
                          <div className="flex items-center gap-2 mt-1">
                            <Badge variant="outline" className="text-xs">
                              {MODE_CONFIG[template.mode].label}
                            </Badge>
                            {template.useCount != null && template.useCount > 0 && (
                              <span className="text-xs text-muted-foreground">
                                {template.useCount}회 사용
                              </span>
                            )}
                          </div>
                        </div>
                        <div className="flex gap-1">
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <Button 
                                  variant="ghost" 
                                  size="sm"
                                  onClick={() => toggleFavorite(template.id)}
                                  className={template.favorite ? "text-yellow-500" : "text-muted-foreground"}
                                >
                                  <Star className={`h-4 w-4 ${template.favorite ? "fill-current" : ""}`} />
                                </Button>
                              </TooltipTrigger>
                              <TooltipContent>
                                {template.favorite ? "즐겨찾기 해제" : "즐겨찾기"}
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                          <Button variant="ghost" size="sm" onClick={() => loadTemplate(template)}>
                            불러오기
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => deleteTemplate(template.id)}
                            className="text-destructive hover:text-destructive"
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </div>
                    </Card>
                  ))
                )}
              </div>
            </ScrollArea>
          </SheetContent>
        </Sheet>
        </div>
      </div>

      {/* Selection Panel */}
      <SelectionPanel
        selectedItems={selectedItems}
        onRemove={(id) => setSelectedItems((prev) => prev.filter((i) => i.id !== id))}
        onClear={clearSelection}
        onSaveTemplate={saveAsTemplate}
      />

      {/* Search Input - Conditional based on mode */}
      {activeTab === "urlanalysis" ? (
        <div className="flex gap-2">
          <div className="relative flex-1">
            <LinkIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="분석할 URL을 입력하세요... (예: https://example.com/article)"
              value={analysisUrl}
              onChange={(e) => setAnalysisUrl(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleSearch()}
              className="pl-10"
            />
          </div>
          <Button onClick={handleSearch} disabled={urlAnalysisLoading}>
            {urlAnalysisLoading ? (
              <Loader2 className="h-4 w-4 animate-spin mr-1" />
            ) : (
              <Play className="h-4 w-4 mr-1" />
            )}
            분석
          </Button>
        </div>
      ) : (
        <div className="space-y-3">
          <div className="flex gap-2">
            <Input
              placeholder="검색어를 입력하세요..."
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleSearch()}
              className="flex-1"
            />
            <Button onClick={handleSearch} disabled={unifiedLoading || deepLoading}>
              {(unifiedLoading || deepLoading) ? (
                <Loader2 className="h-4 w-4 animate-spin mr-1" />
              ) : (
                <Play className="h-4 w-4 mr-1" />
              )}
              검색
            </Button>
          </div>
          
          {/* Date range and filters - shown for unified/deep search */}
          {(activeTab === "unified" || activeTab === "deep") && (
            <AdvancedFilters
              filters={filters}
              onFiltersChange={setFilters}
              disabled={unifiedLoading || deepLoading}
              compact={true}
            />
          )}
        </div>
      )}

      {/* Tabs */}
      <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as SearchMode)}>
        <TabsList className="grid w-full grid-cols-4">
          {(Object.keys(MODE_CONFIG) as SearchMode[]).map((mode) => {
            const config = MODE_CONFIG[mode];
            const Icon = config.icon;
            const count = mode === "unified" 
              ? unifiedResults.length 
              : mode === "deep" 
                ? (deepResults?.evidence?.length || 0) 
                : mode === "urlanalysis"
                  ? urlClaims.length
                  : 0; // factcheck tab uses embedded chatbot, no count needed
            return (
              <TabsTrigger key={mode} value={mode} className="flex items-center gap-2">
                <Icon className="h-4 w-4" />
                <span className="hidden sm:inline">{config.label}</span>
                {count > 0 && <Badge variant="secondary" className="ml-1">{count}</Badge>}
              </TabsTrigger>
            );
          })}
        </TabsList>

        {/* Unified Search Tab */}
        <TabsContent value="unified" className="space-y-4">
          <Card className={`${MODE_CONFIG.unified.bgColor} border-none`}>
            <CardContent className="py-3">
              <div className="flex items-center gap-2 text-sm">
                <Search className={`h-4 w-4 ${MODE_CONFIG.unified.color}`} />
                <span className="text-muted-foreground">데이터베이스, 웹, AI를 동시에 검색합니다.</span>
                {unifiedLoading && <Loader2 className="h-4 w-4 animate-spin ml-auto" />}
                
                {/* Export buttons */}
                {unifiedResults.length > 0 && !unifiedLoading && (
                  <div className="ml-auto flex items-center gap-2">
                    <UnifiedExportMenu
                      jobId={unifiedJobId || undefined}
                      query={query}
                      reportType="UNIFIED_SEARCH"
                      aiContent={unifiedResults.find(r => r.source === 'ai')?.content || unifiedResults.find(r => r.source === 'ai')?.snippet || undefined}
                      data={unifiedResults.map(r => ({
                        id: r.id,
                        title: r.title,
                        url: r.url,
                        snippet: r.snippet,
                        content: r.content,
                        source: r.source,
                        sourceLabel: r.sourceLabel,
                        publishedAt: r.publishedAt,
                        reliabilityScore: r.reliabilityScore,
                        sentimentLabel: r.sentimentLabel,
                        biasLabel: r.biasLabel,
                        factcheckStatus: r.factcheckStatus,
                      }))}
                      exportOptions={{ filename: `NewsInsight_통합검색_${query}`, title: query }}
                      size="sm"
                      variant="outline"
                    />
                  </div>
                )}
              </div>
            </CardContent>
          </Card>

          {unifiedError && (
            <div className="p-4 rounded-lg bg-destructive/10 text-destructive flex items-center gap-2">
              <AlertCircle className="h-4 w-4" />
              {unifiedError}
            </div>
          )}

          <ScrollArea className="h-[500px]">
            <div className="space-y-3 pr-4">
              {unifiedResults.map((result) => (
                <UnifiedResultCard
                  key={result.id}
                  result={result}
                  isSelected={isSelected(result.id)}
                  onSelect={() =>
                    toggleSelection({
                      id: result.id,
                      type: "unified",
                      title: result.title,
                      url: result.url,
                      snippet: result.snippet,
                      source: result.source,
                    })
                  }
                  onViewDetail={() => {
                    setDetailItem({ type: "unified", data: result });
                    setDetailDialogOpen(true);
                  }}
                  hasProject={!!selectedProjectId}
                  onAddToProject={() => handleAddUnifiedToProject(result)}
                />
              ))}
              {!unifiedLoading && unifiedResults.length === 0 && !unifiedError && (
                <div className="text-center py-12 text-muted-foreground">
                  <Search className="h-12 w-12 mx-auto mb-4 opacity-30" />
                  <p>검색어를 입력하고 검색 버튼을 눌러주세요.</p>
                </div>
              )}
            </div>
          </ScrollArea>
        </TabsContent>

        {/* Deep Search Tab - 심층 보고서 */}
        <TabsContent value="deep" className="space-y-4">
          {/* History toggle and info bar */}
          <Card className={`${MODE_CONFIG.deep.bgColor} border-none`}>
            <CardContent className="py-3">
              <div className="flex items-center gap-2 text-sm">
                <Brain className={`h-4 w-4 ${MODE_CONFIG.deep.color}`} />
                <span className="text-muted-foreground">AI가 주제에 대한 심층 분석 보고서를 생성합니다.</span>
                
                {/* History toggle button */}
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setShowDeepHistory(!showDeepHistory)}
                  className="ml-auto gap-1"
                >
                  <History className="h-4 w-4" />
                  기록
                </Button>
                
                {deepLoading && (
                  <div className="flex items-center gap-2">
                    <Progress value={deepProgress} className="w-24 h-2" />
                    <span className="text-xs">{deepProgress}%</span>
                  </div>
                )}
                
                {/* Export buttons for Deep Search */}
                {deepResults && !deepLoading && deepJobId && (
                  <div className="flex items-center gap-2">
                    <UnifiedExportMenu
                      jobId={deepJobId}
                      query={query || deepResults.topic}
                      reportType="DEEP_SEARCH"
                      data={(deepResults.evidence || []).map(e => ({
                        id: String(e.id),
                        title: e.title || e.snippet.slice(0, 50),
                        url: e.url,
                        snippet: e.snippet,
                        content: e.snippet,
                        source: e.source || 'web',
                        stance: e.stance,
                      }))}
                      exportOptions={{ filename: `NewsInsight_심층보고서_${query || deepResults.topic}`, title: query || deepResults.topic }}
                      size="sm"
                      variant="outline"
                    />
                  </div>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Deep Search History Panel */}
          {showDeepHistory && (
            <Card>
              <CardHeader className="pb-3">
                <div className="flex items-center justify-between">
                  <CardTitle className="text-base flex items-center gap-2">
                    <History className="h-4 w-4" />
                    Deep Search 기록
                  </CardTitle>
                  <div className="flex items-center gap-2">
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={loadDeepSearchHistory}
                      disabled={deepHistoryLoading}
                    >
                      <RefreshCw className={`h-4 w-4 ${deepHistoryLoading ? 'animate-spin' : ''}`} />
                    </Button>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => setShowDeepHistory(false)}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                {deepHistoryLoading && deepHistoryJobs.length === 0 ? (
                  <div className="flex items-center justify-center py-8">
                    <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
                  </div>
                ) : deepHistoryJobs.length === 0 ? (
                  <div className="text-center py-8 text-muted-foreground text-sm">
                    아직 Deep Search 기록이 없습니다.
                  </div>
                ) : (
                  <ScrollArea className="max-h-[300px]">
                    <div className="space-y-2">
                      {deepHistoryJobs.map((job) => {
                        const statusConfig: Record<string, { label: string; color: string }> = {
                          COMPLETED: { label: "완료", color: "bg-green-500" },
                          IN_PROGRESS: { label: "진행 중", color: "bg-blue-500" },
                          PENDING: { label: "대기", color: "bg-yellow-500" },
                          FAILED: { label: "실패", color: "bg-red-500" },
                          CANCELLED: { label: "취소", color: "bg-gray-500" },
                          TIMEOUT: { label: "시간 초과", color: "bg-orange-500" },
                        };
                        const status = statusConfig[job.status] || { label: job.status, color: "bg-gray-500" };
                        
                        return (
                          <div
                            key={job.jobId}
                            className={`flex items-center justify-between p-3 rounded-lg border transition-colors ${
                              job.status === 'COMPLETED' ? 'hover:bg-muted/50 cursor-pointer' : 'opacity-60'
                            }`}
                            onClick={() => job.status === 'COMPLETED' && loadDeepSearchFromHistory(job)}
                          >
                            <div className="flex-1 min-w-0 mr-4">
                              <div className="flex items-center gap-2 mb-1">
                                <Badge className={`${status.color} text-white text-xs`}>
                                  {status.label}
                                </Badge>
                                {job.evidenceCount !== undefined && job.evidenceCount > 0 && (
                                  <Badge variant="outline" className="text-xs">
                                    {job.evidenceCount}개 증거
                                  </Badge>
                                )}
                              </div>
                              <h4 className="font-medium text-sm truncate">{job.topic}</h4>
                              <p className="text-xs text-muted-foreground">
                                {new Date(job.createdAt).toLocaleString('ko-KR')}
                                {job.completedAt && ` · 완료: ${new Date(job.completedAt).toLocaleTimeString('ko-KR')}`}
                              </p>
                              {job.errorMessage && (
                                <p className="text-xs text-destructive mt-1 truncate">
                                  {job.errorMessage}
                                </p>
                              )}
                            </div>
                            {job.status === 'COMPLETED' && (
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  loadDeepSearchFromHistory(job);
                                }}
                              >
                                <Eye className="h-4 w-4" />
                              </Button>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  </ScrollArea>
                )}
              </CardContent>
            </Card>
          )}

          {deepError && (
            <div className="p-4 rounded-lg bg-destructive/10 text-destructive flex items-center gap-2">
              <AlertCircle className="h-4 w-4" />
              {deepError}
            </div>
          )}

          {/* 심층 보고서 결과 */}
          {deepResults && (
            <ScrollArea className="h-[500px]">
              <div className="space-y-4 pr-4">
                {/* 핵심 요약 */}
                <Card className="border-l-4 border-l-purple-500">
                  <CardHeader className="pb-2">
                    <div className="flex items-center gap-2">
                      <Sparkles className="h-5 w-5 text-purple-600" />
                      <CardTitle className="text-lg">핵심 요약</CardTitle>
                    </div>
                  </CardHeader>
                  <CardContent>
                    <p className="text-sm text-muted-foreground leading-relaxed">
                      <strong>'{deepResults.topic}'</strong>에 대해 {deepResults.evidence?.length || 0}개의 출처를 분석했습니다.
                      {deepResults.evidence && deepResults.evidence.length > 0 && (
                        <> 다양한 관점의 자료를 수집하여 주제에 대한 종합적인 이해를 제공합니다.</>
                      )}
                    </p>
                  </CardContent>
                </Card>

                {/* 분석 개요 */}
                <Card>
                  <CardHeader className="pb-2">
                    <CardTitle className="text-base flex items-center gap-2">
                      <Database className="h-4 w-4" />
                      분석 개요
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="grid grid-cols-3 gap-4 text-center">
                      <div className="p-3 rounded-lg bg-muted/50">
                        <p className="text-2xl font-bold text-primary">{deepResults.evidence?.length || 0}</p>
                        <p className="text-xs text-muted-foreground">총 수집 자료</p>
                      </div>
                      <div className="p-3 rounded-lg bg-muted/50">
                        <p className="text-2xl font-bold text-green-600">
                          {new Set(deepResults.evidence?.map(e => e.source).filter(Boolean)).size || 0}
                        </p>
                        <p className="text-xs text-muted-foreground">참조 출처</p>
                      </div>
                      <div className="p-3 rounded-lg bg-muted/50">
                        <p className="text-2xl font-bold text-blue-600">
                          {deepResults.evidence?.filter(e => e.title).length || 0}
                        </p>
                        <p className="text-xs text-muted-foreground">기사/문서</p>
                      </div>
                    </div>
                  </CardContent>
                </Card>

                {/* 주요 발견사항 */}
                {deepResults.evidence && deepResults.evidence.length > 0 && (
                  <Card>
                    <CardHeader className="pb-2">
                      <CardTitle className="text-base flex items-center gap-2">
                        <FileText className="h-4 w-4" />
                        주요 발견사항
                      </CardTitle>
                      <CardDescription>수집된 자료에서 추출한 핵심 정보</CardDescription>
                    </CardHeader>
                    <CardContent className="space-y-3">
                      {deepResults.evidence.slice(0, 5).map((evidence, index) => (
                        <div 
                          key={evidence.id} 
                          className="p-3 rounded-lg bg-muted/30 border-l-2 border-l-purple-400 hover:bg-muted/50 transition-colors"
                        >
                          <div className="flex items-start justify-between gap-2">
                            <div className="flex-1 min-w-0">
                              <div className="flex items-center gap-2 mb-1 flex-wrap">
                                <span className="text-xs font-medium text-purple-600">#{index + 1}</span>
                                {evidence.sourceCategory && SOURCE_CATEGORY_CONFIG[evidence.sourceCategory] && (
                                  <Badge variant="secondary" className={`text-xs ${SOURCE_CATEGORY_CONFIG[evidence.sourceCategory].color}`}>
                                    {createElement(SOURCE_CATEGORY_CONFIG[evidence.sourceCategory].icon, { className: "h-3 w-3 mr-1" })}
                                    {SOURCE_CATEGORY_CONFIG[evidence.sourceCategory].label}
                                  </Badge>
                                )}
                                {evidence.source && (
                                  <Badge variant="outline" className="text-xs">
                                    {evidence.source}
                                  </Badge>
                                )}
                              </div>
                              {evidence.title && (
                                <h4 className="font-medium text-sm mb-1 line-clamp-1">{evidence.title}</h4>
                              )}
                              <p className="text-sm text-muted-foreground line-clamp-2">{evidence.snippet}</p>
                            </div>
                            <div className="flex gap-1">
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <button
                                      onClick={() => {
                                        setDetailItem({ type: "evidence", data: evidence });
                                        setDetailDialogOpen(true);
                                      }}
                                      className="p-1.5 rounded hover:bg-muted"
                                    >
                                      <Eye className="h-4 w-4 text-muted-foreground" />
                                    </button>
                                  </TooltipTrigger>
                                  <TooltipContent>상세 보기</TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                              {evidence.url && (
                                <a
                                  href={evidence.url}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="p-1.5 rounded hover:bg-muted"
                                >
                                  <ExternalLink className="h-4 w-4 text-muted-foreground" />
                                </a>
                              )}
                            </div>
                          </div>
                        </div>
                      ))}
                      {deepResults.evidence.length > 5 && (
                        <p className="text-xs text-muted-foreground text-center pt-2">
                          외 {deepResults.evidence.length - 5}개의 자료가 더 있습니다. PDF 보고서로 내보내기하여 전체 내용을 확인하세요.
                        </p>
                      )}
                    </CardContent>
                  </Card>
                )}

                {/* 출처 목록 */}
                {deepResults.evidence && deepResults.evidence.length > 0 && (
                  <Card>
                    <CardHeader className="pb-2">
                      <CardTitle className="text-base flex items-center gap-2">
                        <Globe className="h-4 w-4" />
                        참조 출처
                      </CardTitle>
                    </CardHeader>
                    <CardContent>
                      <div className="space-y-2">
                        {Array.from(new Set(deepResults.evidence.map(e => e.source).filter(Boolean))).slice(0, 8).map((source, index) => (
                          <div key={index} className="flex items-center gap-2 text-sm">
                            <CheckCircle2 className="h-3 w-3 text-green-500" />
                            <span className="text-muted-foreground">{source}</span>
                            <Badge variant="secondary" className="text-xs ml-auto">
                              {deepResults.evidence?.filter(e => e.source === source).length}건
                            </Badge>
                          </div>
                        ))}
                      </div>
                    </CardContent>
                  </Card>
                )}

                {/* 결론 */}
                <Card className="border-l-4 border-l-green-500">
                  <CardHeader className="pb-2">
                    <CardTitle className="text-base flex items-center gap-2">
                      <CheckCircle2 className="h-4 w-4 text-green-600" />
                      결론
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <p className="text-sm text-muted-foreground leading-relaxed">
                      '{deepResults.topic}'에 대한 심층 분석 결과, {deepResults.evidence?.length || 0}개의 관련 자료를 수집했습니다.
                      {deepResults.evidence && deepResults.evidence.length > 0 ? (
                        <> 수집된 자료들은 다양한 출처에서 제공되었으며, 주제에 대한 폭넓은 관점을 제공합니다. 
                        보다 자세한 내용은 PDF 보고서로 내보내기하여 확인하실 수 있습니다.</>
                      ) : (
                        <> 추가적인 검색어나 다른 관점에서의 분석을 시도해보시기 바랍니다.</>
                      )}
                    </p>
                  </CardContent>
                </Card>
              </div>
            </ScrollArea>
          )}

          {/* 초기 상태 */}
          {!deepLoading && !deepJobId && !deepResults && !deepError && (
            <div className="text-center py-12 text-muted-foreground">
              <Brain className="h-12 w-12 mx-auto mb-4 opacity-30" />
              <p>검색어를 입력하고 심층 보고서를 생성해보세요.</p>
              <p className="text-xs mt-1">AI가 주제에 대한 심층 분석을 수행하며 2-5분 정도 소요됩니다.</p>
            </div>
          )}
          {!deepLoading && deepResults && deepResults.evidence?.length === 0 && (
            <div className="text-center py-12 text-muted-foreground">
              <Brain className="h-12 w-12 mx-auto mb-4 opacity-30" />
              <p>분석 결과가 없습니다.</p>
              <p className="text-xs mt-1">다른 검색어로 다시 시도해보세요.</p>
            </div>
          )}
        </TabsContent>

        {/* Fact Check Tab - Using Embedded Chatbot */}
        <TabsContent value="factcheck" className="space-y-4">
          <Card className={`${MODE_CONFIG.factcheck.bgColor} border-none`}>
            <CardContent className="py-3">
              <div className="flex items-center gap-2 text-sm">
                <Shield className={`h-4 w-4 ${MODE_CONFIG.factcheck.color}`} />
                <span className="text-muted-foreground">
                  AI 챗봇과 대화하며 주장이나 뉴스의 사실 여부를 검증합니다.
                </span>
              </div>
            </CardContent>
          </Card>

          {/* Embedded FactCheck Chatbot */}
          <FactCheckChatbot
            ref={factCheckChatbotRef}
            compact={true}
            hideHeader={false}
            heightClass="h-[500px]"
            initialClaims={pendingFactCheckClaims.length > 0 ? pendingFactCheckClaims : undefined}
          />
        </TabsContent>

        {/* URL Analysis Tab */}
        <TabsContent value="urlanalysis" className="space-y-4">
          <Card className={`${MODE_CONFIG.urlanalysis.bgColor} border-none`}>
            <CardContent className="py-3">
              <div className="flex items-center gap-2 text-sm">
                <LinkIcon className={`h-4 w-4 ${MODE_CONFIG.urlanalysis.color}`} />
                <span className="text-muted-foreground">
                  뉴스 기사나 웹 페이지의 URL을 입력하면 AI가 검증 가능한 주장을 추출합니다.
                </span>
              </div>
            </CardContent>
          </Card>

          {urlAnalysisError && (
            <div className="p-4 rounded-lg bg-destructive/10 text-destructive flex items-center gap-2">
              <AlertCircle className="h-4 w-4" />
              {urlAnalysisError}
            </div>
          )}

          {/* URL Analysis Results */}
          {urlPageTitle && (
            <Card>
              <CardHeader className="pb-2">
                <div className="flex items-center gap-2">
                  <Globe className="h-4 w-4 text-muted-foreground" />
                  <CardTitle className="text-base">{urlPageTitle}</CardTitle>
                </div>
                <CardDescription className="truncate">{analysisUrl}</CardDescription>
              </CardHeader>
            </Card>
          )}

          {urlClaims.length > 0 && (
            <Card>
              <CardHeader className="pb-2">
                <div className="flex items-center justify-between">
                  <CardTitle className="text-base">추출된 주장 ({urlClaims.length})</CardTitle>
                  <div className="flex gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => selectAllUrlClaims(true)}
                    >
                      전체 선택
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => selectAllUrlClaims(false)}
                    >
                      전체 해제
                    </Button>
                    <Button
                      size="sm"
                      onClick={transferToFactCheck}
                      disabled={!urlClaims.some((c) => c.selected)}
                    >
                      <Shield className="h-4 w-4 mr-1" />
                      팩트체크로 전송
                    </Button>
                  </div>
                </div>
                <CardDescription>
                  팩트체크할 주장을 선택하세요. 선택한 주장은 팩트체크 탭으로 전송됩니다.
                </CardDescription>
              </CardHeader>
              <CardContent>
                <ScrollArea className="h-[400px]">
                  <div className="space-y-3 pr-4">
                    {urlClaims.map((claim) => (
                      <Card
                        key={claim.id}
                        className={`cursor-pointer transition-all hover:shadow-md ${
                          claim.selected
                            ? "border-primary ring-2 ring-primary/30"
                            : "border-transparent"
                        }`}
                        onClick={() => toggleUrlClaimSelection(claim.id)}
                      >
                        <CardContent className="p-4">
                          <div className="flex items-start gap-3">
                            <Checkbox
                              checked={claim.selected}
                              onCheckedChange={() => toggleUrlClaimSelection(claim.id)}
                              onClick={(e) => e.stopPropagation()}
                            />
                            <div className="flex-1 min-w-0">
                              <div className="flex items-center gap-2 mb-1">
                                <Badge
                                  variant="outline"
                                  className={
                                    claim.confidence >= 0.8
                                      ? "text-green-600 border-green-300"
                                      : claim.confidence >= 0.5
                                        ? "text-yellow-600 border-yellow-300"
                                        : "text-orange-600 border-orange-300"
                                  }
                                >
                                  신뢰도 {Math.round(claim.confidence * 100)}%
                                </Badge>
                              </div>
                              <p className="text-sm font-medium">{claim.text}</p>
                              {claim.context && (
                                <p className="text-xs text-muted-foreground mt-1 line-clamp-2">
                                  {claim.context}
                                </p>
                              )}
                            </div>
                            <TooltipProvider>
                              <Tooltip>
                                <TooltipTrigger asChild>
                                  <button
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      toggleSelection({
                                        id: `urlclaim_${claim.id}`,
                                        type: "urlclaim",
                                        title: claim.text.slice(0, 50) + (claim.text.length > 50 ? "..." : ""),
                                        snippet: claim.text,
                                        url: analysisUrl,
                                      });
                                    }}
                                    className={`p-2 rounded-md transition-colors ${
                                      isSelected(`urlclaim_${claim.id}`)
                                        ? "bg-primary text-primary-foreground"
                                        : "hover:bg-muted text-muted-foreground"
                                    }`}
                                  >
                                    <Pin className="h-4 w-4" />
                                  </button>
                                </TooltipTrigger>
                                <TooltipContent>
                                  {isSelected(`urlclaim_${claim.id}`) ? "선택 해제" : "템플릿에 추가"}
                                </TooltipContent>
                              </Tooltip>
                            </TooltipProvider>
                          </div>
                        </CardContent>
                      </Card>
                    ))}
                  </div>
                </ScrollArea>
              </CardContent>
            </Card>
          )}

          {!urlAnalysisLoading && urlClaims.length === 0 && !urlAnalysisError && (
            <div className="text-center py-12 text-muted-foreground">
              <LinkIcon className="h-12 w-12 mx-auto mb-4 opacity-30" />
              <p>분석할 URL을 입력하고 분석 버튼을 눌러주세요.</p>
              <p className="text-xs mt-1">
                AI가 웹 페이지를 분석하여 검증 가능한 주장을 추출합니다.
              </p>
            </div>
          )}

          {urlAnalysisLoading && (
            <div className="text-center py-12">
              <Loader2 className="h-12 w-12 mx-auto mb-4 animate-spin text-muted-foreground" />
              <p className="text-muted-foreground">URL을 분석하고 있습니다...</p>
              <p className="text-xs text-muted-foreground mt-1">
                페이지 크기에 따라 시간이 소요될 수 있습니다.
              </p>
            </div>
          )}

          {/* Priority URLs for reference */}
          <PriorityUrlEditor
            storageKey="smartsearch-priority-urls"
            urls={priorityUrls}
            onUrlsChange={setPriorityUrls}
            disabled={urlAnalysisLoading}
            title="참고 URL"
            description="팩트체크 시 우선적으로 참고할 신뢰 URL을 추가하세요."
            defaultCollapsed={true}
          />
        </TabsContent>
      </Tabs>

      {/* Tip Banner */}
      <div className="flex items-center gap-2 p-3 rounded-lg bg-muted/50 text-sm">
        <Zap className="h-4 w-4 text-yellow-500 shrink-0" />
        <span className="text-muted-foreground">
          <strong>Tip:</strong> 각 결과 카드의 <Pin className="h-3 w-3 inline mx-1" /> 버튼을 눌러 항목을 선택하고, 
          상단의 "선택한 항목" 패널에서 템플릿으로 저장할 수 있습니다.
        </span>
      </div>

      {/* Detail View Dialog */}
      <Dialog open={detailDialogOpen} onOpenChange={setDetailDialogOpen}>
        <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
          {detailItem?.type === "unified" && (() => {
            const result = detailItem.data as UnifiedSearchResult;
            const sourceConfig = SOURCE_CONFIG[result.source] || SOURCE_CONFIG.web;
            const SourceIcon = sourceConfig.icon;
            return (
              <>
                <DialogHeader>
                  <div className="flex items-center gap-2 mb-2">
                    <Badge variant="outline" className={`${sourceConfig.color} flex items-center gap-1`}>
                      <SourceIcon className="h-3 w-3" />
                      {result.sourceLabel || sourceConfig.label}
                    </Badge>
                    {result.publishedAt && (
                      <span className="text-xs text-muted-foreground">
                        {new Date(result.publishedAt).toLocaleDateString("ko-KR")}
                      </span>
                    )}
                  </div>
                  <DialogTitle className="text-lg">{result.title}</DialogTitle>
                  {result.url && (
                    <DialogDescription className="break-all">
                      <a href={result.url} target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline flex items-center gap-1">
                        {result.url}
                        <ExternalLink className="h-3 w-3" />
                      </a>
                    </DialogDescription>
                  )}
                </DialogHeader>
                <div className="mt-4 space-y-4">
                  {result.source === "ai" ? (
                    <div>
                      {/* Summary Section */}
                      <div className="flex items-center gap-2 mb-2">
                        <h4 className="font-medium text-sm">요약</h4>
                        {aiReportLoading && (
                          <span className="text-xs text-muted-foreground animate-pulse">
                            (DB에서 불러오는 중...)
                          </span>
                        )}
                      </div>
                      <div className="bg-muted/30 rounded-lg p-3">
                        {aiReportSummary ? (
                          <MarkdownRenderer content={aiReportSummary} isStreaming={false} />
                        ) : aiReportLoading ? (
                          <div className="flex items-center gap-2 text-sm text-muted-foreground">
                            <div className="h-4 w-4 border-2 border-muted-foreground/30 border-t-muted-foreground rounded-full animate-spin" />
                            불러오는 중...
                          </div>
                        ) : (
                          <p className="text-sm text-muted-foreground">요약 섹션이 없습니다.</p>
                        )}
                      </div>

                      {/* Full Content Section */}
                      <h4 className="font-medium text-sm mt-4 mb-2">전체 내용</h4>
                      <div className="bg-white/70 dark:bg-black/30 rounded-lg border p-4 max-h-[50vh] overflow-y-auto">
                        {aiReportError && (
                          <p className="text-sm text-amber-600 dark:text-amber-400 mb-2 flex items-center gap-1">
                            <span className="shrink-0">!</span> 
                            DB 조회 실패 - SSE 데이터를 표시합니다
                          </p>
                        )}
                        {aiReportContent ? (
                          <MarkdownRenderer content={aiReportContent} isStreaming={false} />
                        ) : aiReportLoading ? (
                          <div className="flex items-center gap-2 text-sm text-muted-foreground">
                            <div className="h-4 w-4 border-2 border-muted-foreground/30 border-t-muted-foreground rounded-full animate-spin" />
                            불러오는 중...
                          </div>
                        ) : (
                          <p className="text-sm text-muted-foreground">내용이 없습니다.</p>
                        )}
                      </div>
                    </div>
                  ) : result.content ? (
                    <div>
                      <h4 className="font-medium text-sm mb-2">전체 내용</h4>
                      <div className="bg-white/70 dark:bg-black/30 rounded-lg border p-4 max-h-[50vh] overflow-y-auto">
                        <MarkdownRenderer content={result.content} isStreaming={false} />
                      </div>
                    </div>
                  ) : result.snippet ? (
                    <div>
                      <h4 className="font-medium text-sm mb-2">내용</h4>
                      <div className="bg-muted/30 rounded-lg p-3">
                        <p className="text-sm text-muted-foreground whitespace-pre-wrap">{result.snippet}</p>
                      </div>
                    </div>
                  ) : null}
                  {(() => {
                    const author = (result as unknown as { author?: unknown })?.author;
                    if (typeof author !== "string" || !author) return null;
                    return (
                      <div>
                        <h4 className="font-medium text-sm mb-1">작성자</h4>
                        <p className="text-sm text-muted-foreground">{author}</p>
                      </div>
                    );
                  })()}
                </div>
              </>
            );
          })()}
          
          {detailItem?.type === "evidence" && (() => {
            const evidence = detailItem.data as Evidence;
            const stanceConfig = STANCE_CONFIG[evidence.stance] || STANCE_CONFIG.neutral;
            const StanceIcon = stanceConfig.icon;
            return (
              <>
                <DialogHeader>
                  <div className="flex items-center gap-2 mb-2">
                    <Badge variant="outline" className={`${stanceConfig.color} flex items-center gap-1`}>
                      <StanceIcon className="h-3 w-3" />
                      {stanceConfig.label}
                    </Badge>
                    {evidence.source && (
                      <span className="text-xs text-muted-foreground">{evidence.source}</span>
                    )}
                  </div>
                  <DialogTitle className="text-lg">{evidence.title || "증거 자료"}</DialogTitle>
                  {evidence.url && (
                    <DialogDescription className="break-all">
                      <a href={evidence.url} target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline flex items-center gap-1">
                        {evidence.url}
                        <ExternalLink className="h-3 w-3" />
                      </a>
                    </DialogDescription>
                  )}
                </DialogHeader>
                <div className="mt-4 space-y-4">
                  <div>
                    <h4 className="font-medium text-sm mb-2">전체 내용</h4>
                    <p className="text-sm text-muted-foreground whitespace-pre-wrap">{evidence.snippet}</p>
                  </div>
                  {(() => {
                    const relevance = (evidence as unknown as { relevance?: unknown })?.relevance;
                    if (typeof relevance !== "number") return null;
                    return (
                      <div>
                        <h4 className="font-medium text-sm mb-1">관련도</h4>
                        <Progress value={relevance * 100} className="h-2" />
                        <span className="text-xs text-muted-foreground">{Math.round(relevance * 100)}%</span>
                      </div>
                    );
                  })()}
                </div>
              </>
            );
          })()}
          
          {detailItem?.type === "verification" && (() => {
            const result = detailItem.data as VerificationResult;
            const config = VERIFICATION_CONFIG[result.status] || VERIFICATION_CONFIG.UNVERIFIED;
            const StatusIcon = config.icon;
            return (
              <>
                <DialogHeader>
                  <div className="flex items-center gap-2 mb-2">
                    <Badge className={`${config.bgColor} ${config.color} border-none`}>
                      <StatusIcon className="h-3 w-3 mr-1" />
                      {config.label}
                    </Badge>
                    <span className="text-xs text-muted-foreground">
                      신뢰도: {Math.round(result.confidenceScore * 100)}%
                    </span>
                  </div>
                  <DialogTitle className="text-lg">팩트체크 결과</DialogTitle>
                </DialogHeader>
                <div className="mt-4 space-y-4">
                  <div>
                    <h4 className="font-medium text-sm mb-2">원본 주장</h4>
                    <p className="text-sm p-3 bg-muted rounded-lg">{result.originalClaim}</p>
                  </div>
                  <div>
                    <h4 className="font-medium text-sm mb-2">검증 요약</h4>
                    <p className="text-sm text-muted-foreground">{result.verificationSummary}</p>
                  </div>
                  {result.supportingEvidence.length > 0 && (
                    <div>
                      <h4 className="font-medium text-sm mb-2 text-green-600">지지 근거 ({result.supportingEvidence.length})</h4>
                      <div className="space-y-2">
                        {result.supportingEvidence.map((e, i) => (
                          <div key={i} className="text-sm p-3 bg-green-50 dark:bg-green-900/20 rounded-lg border-l-2 border-green-400">
                            <p className="font-medium text-xs text-green-700 mb-1">{e.sourceName}</p>
                            <p className="text-muted-foreground">{e.excerpt}</p>
                            {e.url && (
                              <a href={e.url} target="_blank" rel="noopener noreferrer" className="text-xs text-blue-600 hover:underline mt-1 inline-flex items-center gap-1">
                                출처 보기 <ExternalLink className="h-3 w-3" />
                              </a>
                            )}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  {result.contradictingEvidence.length > 0 && (
                    <div>
                      <h4 className="font-medium text-sm mb-2 text-red-600">반박 근거 ({result.contradictingEvidence.length})</h4>
                      <div className="space-y-2">
                        {result.contradictingEvidence.map((e, i) => (
                          <div key={i} className="text-sm p-3 bg-red-50 dark:bg-red-900/20 rounded-lg border-l-2 border-red-400">
                            <p className="font-medium text-xs text-red-700 mb-1">{e.sourceName}</p>
                            <p className="text-muted-foreground">{e.excerpt}</p>
                            {e.url && (
                              <a href={e.url} target="_blank" rel="noopener noreferrer" className="text-xs text-blue-600 hover:underline mt-1 inline-flex items-center gap-1">
                                출처 보기 <ExternalLink className="h-3 w-3" />
                              </a>
                            )}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </>
            );
          })()}
        </DialogContent>
      </Dialog>
    </div>
  );
}

```

---

## frontend/src/pages/ToolsHub.tsx

```tsx
/**
 * ToolsHub - 도구 허브 페이지
 * 
 * 모든 분석 도구를 한눈에 보여주고 빠르게 접근할 수 있게 합니다.
 * - 스마트 검색
 * - ML Add-ons (편향성, 감정 분석)
 * - 브라우저 에이전트
 * - AI Jobs
 */

import { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  Search,
  Cpu,
  Bot,
  Brain,
  ArrowRight,
  Zap,
  Shield,
  BarChart3,
  Globe,
  Sparkles,
  Activity,
  CheckCircle2,
  XCircle,
  Loader2,
} from 'lucide-react';
import {
  checkAllMLAddonsHealth,
  checkBrowserUseHealth,
  type MLAddonHealth,
  type BrowserHealthResponse,
} from '@/lib/api';

interface ToolCardProps {
  to: string;
  icon: React.ReactNode;
  title: string;
  description: string;
  features: string[];
  badge?: string;
  badgeVariant?: 'default' | 'secondary' | 'outline';
  status?: 'healthy' | 'unhealthy' | 'loading' | 'partial';
  statusText?: string;
}

function ToolCard({ to, icon, title, description, features, badge, badgeVariant = 'secondary', status, statusText }: ToolCardProps) {
  const getStatusIndicator = () => {
    if (!status) return null;
    
    switch (status) {
      case 'healthy':
        return (
          <div className="flex items-center gap-1.5 text-xs text-green-600 dark:text-green-400">
            <CheckCircle2 className="h-3.5 w-3.5" />
            <span>{statusText || '정상'}</span>
          </div>
        );
      case 'unhealthy':
        return (
          <div className="flex items-center gap-1.5 text-xs text-red-500">
            <XCircle className="h-3.5 w-3.5" />
            <span>{statusText || '오프라인'}</span>
          </div>
        );
      case 'partial':
        return (
          <div className="flex items-center gap-1.5 text-xs text-yellow-600 dark:text-yellow-400">
            <Activity className="h-3.5 w-3.5" />
            <span>{statusText || '일부 정상'}</span>
          </div>
        );
      case 'loading':
        return (
          <div className="flex items-center gap-1.5 text-xs text-muted-foreground">
            <Loader2 className="h-3.5 w-3.5 animate-spin" />
            <span>확인 중...</span>
          </div>
        );
    }
  };

  return (
    <Link to={to} className="block group">
      <Card className="h-full transition-all hover:shadow-lg hover:border-primary/50 group-hover:bg-accent/30">
        <CardHeader>
          <div className="flex items-start justify-between">
            <div className="p-3 rounded-lg bg-primary/10 text-primary">
              {icon}
            </div>
            <div className="flex flex-col items-end gap-1">
              {badge && (
                <Badge variant={badgeVariant}>{badge}</Badge>
              )}
              {getStatusIndicator()}
            </div>
          </div>
          <CardTitle className="text-lg mt-4 flex items-center gap-2">
            {title}
            <ArrowRight className="h-4 w-4 opacity-0 -translate-x-2 transition-all group-hover:opacity-100 group-hover:translate-x-0" />
          </CardTitle>
          <CardDescription>{description}</CardDescription>
        </CardHeader>
        <CardContent>
          <ul className="space-y-2">
            {features.map((feature, idx) => (
              <li key={idx} className="flex items-center gap-2 text-sm text-muted-foreground">
                <div className="h-1.5 w-1.5 rounded-full bg-primary" />
                {feature}
              </li>
            ))}
          </ul>
        </CardContent>
      </Card>
    </Link>
  );
}

export function ToolsHub() {
  // Status states
  const [mlAddonStatus, setMlAddonStatus] = useState<{
    loading: boolean;
    healthyCount: number;
    totalCount: number;
  }>({ loading: true, healthyCount: 0, totalCount: 3 });
  
  const [browserStatus, setBrowserStatus] = useState<{
    loading: boolean;
    healthy: boolean;
    activeJobs: number;
  }>({ loading: true, healthy: false, activeJobs: 0 });

  // Fetch status on mount
  useEffect(() => {
    const fetchStatuses = async () => {
      // Fetch ML Add-on status
      try {
        const mlHealth = await checkAllMLAddonsHealth();
        const healthyCount = Object.values(mlHealth).filter(
          (h): h is MLAddonHealth => h?.status === 'healthy'
        ).length;
        setMlAddonStatus({
          loading: false,
          healthyCount,
          totalCount: 3,
        });
      } catch {
        setMlAddonStatus(prev => ({ ...prev, loading: false }));
      }

      // Fetch Browser-Use status
      try {
        const browserHealth = await checkBrowserUseHealth();
        setBrowserStatus({
          loading: false,
          healthy: browserHealth?.status === 'healthy',
          activeJobs: browserHealth?.active_jobs || 0,
        });
      } catch {
        setBrowserStatus(prev => ({ ...prev, loading: false }));
      }
    };

    fetchStatuses();
  }, []);

  // Determine ML Add-on status for display
  const getMlAddonDisplayStatus = (): { status: ToolCardProps['status']; text: string } => {
    if (mlAddonStatus.loading) {
      return { status: 'loading', text: '' };
    }
    if (mlAddonStatus.healthyCount === mlAddonStatus.totalCount) {
      return { status: 'healthy', text: `${mlAddonStatus.healthyCount}/${mlAddonStatus.totalCount} 정상` };
    }
    if (mlAddonStatus.healthyCount > 0) {
      return { status: 'partial', text: `${mlAddonStatus.healthyCount}/${mlAddonStatus.totalCount} 정상` };
    }
    return { status: 'unhealthy', text: '오프라인' };
  };

  // Determine Browser status for display
  const getBrowserDisplayStatus = (): { status: ToolCardProps['status']; text: string } => {
    if (browserStatus.loading) {
      return { status: 'loading', text: '' };
    }
    if (browserStatus.healthy) {
      return { 
        status: 'healthy', 
        text: browserStatus.activeJobs > 0 
          ? `${browserStatus.activeJobs}개 작업 실행중` 
          : '정상' 
      };
    }
    return { status: 'unhealthy', text: '오프라인' };
  };

  const mlStatus = getMlAddonDisplayStatus();
  const browserStatusDisplay = getBrowserDisplayStatus();

  const tools: ToolCardProps[] = [
    {
      to: '/search',
      icon: <Search className="h-6 w-6" />,
      title: '스마트 검색',
      description: '통합 뉴스 검색 및 분석 허브',
      features: [
        '빠른 검색 / 심층 분석 / 팩트체크 모드',
        '멀티소스 뉴스 통합 검색',
        'AI 기반 요약 및 분석',
      ],
      badge: '핵심 기능',
      badgeVariant: 'default',
    },
    {
      to: '/ml-addons',
      icon: <Cpu className="h-6 w-6" />,
      title: 'ML Add-ons',
      description: '고급 ML 분석 도구',
      features: [
        '뉴스 편향성 분석',
        '감정/논조 분석',
        '주제 클러스터링',
      ],
      badge: 'AI',
      status: mlStatus.status,
      statusText: mlStatus.text,
    },
    {
      to: '/ai-agent',
      icon: <Bot className="h-6 w-6" />,
      title: '브라우저 에이전트',
      description: 'AI 웹 자동화 도구',
      features: [
        '자연어로 웹 탐색 명령',
        '자동 데이터 수집',
        '스크린샷 기반 분석',
      ],
      badge: 'Beta',
      status: browserStatusDisplay.status,
      statusText: browserStatusDisplay.text,
    },
    {
      to: '/ai-jobs',
      icon: <Brain className="h-6 w-6" />,
      title: 'AI Jobs',
      description: 'AI 작업 관리 및 모니터링',
      features: [
        '배치 분석 작업 관리',
        '작업 스케줄링',
        '결과 히스토리 조회',
      ],
    },
    {
      to: '/ml-results',
      icon: <Sparkles className="h-6 w-6" />,
      title: 'ML 분석 결과',
      description: 'ML 분석 결과 확인 및 조회',
      features: [
        '기사별 분석 결과 확인',
        '전체 분석 이력 조회',
        '상세 결과 JSON 보기',
      ],
      badge: 'New',
    },
  ];

  return (
    <div className="container py-8 px-4 max-w-7xl mx-auto">
      {/* Header */}
      <div className="mb-8">
        <h1 className="text-3xl font-bold tracking-tight mb-2">도구</h1>
        <p className="text-muted-foreground text-lg">
          AI 기반 뉴스 분석을 위한 다양한 도구를 활용하세요
        </p>
      </div>

      {/* Quick Actions */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
        <Link to="/search?mode=deep">
          <Button variant="outline" className="w-full h-auto py-4 flex flex-col gap-2">
            <Zap className="h-5 w-5 text-amber-500" />
            <span className="text-sm font-medium">심층 분석</span>
          </Button>
        </Link>
        <Link to="/search?mode=factcheck">
          <Button variant="outline" className="w-full h-auto py-4 flex flex-col gap-2">
            <Shield className="h-5 w-5 text-green-500" />
            <span className="text-sm font-medium">팩트체크</span>
          </Button>
        </Link>
        <Link to="/ml-addons">
          <Button variant="outline" className="w-full h-auto py-4 flex flex-col gap-2">
            <BarChart3 className="h-5 w-5 text-blue-500" />
            <span className="text-sm font-medium">편향성 분석</span>
          </Button>
        </Link>
        <Link to="/ai-agent">
          <Button variant="outline" className="w-full h-auto py-4 flex flex-col gap-2">
            <Globe className="h-5 w-5 text-purple-500" />
            <span className="text-sm font-medium">URL 분석</span>
          </Button>
        </Link>
      </div>

      {/* Tool Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {tools.map((tool) => (
          <ToolCard key={tool.to} {...tool} />
        ))}
      </div>

      {/* Tip Section */}
      <Card className="mt-8 bg-primary/5 border-primary/20">
        <CardContent className="py-6">
          <div className="flex items-start gap-4">
            <div className="p-2 rounded-lg bg-primary/10">
              <Sparkles className="h-5 w-5 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold mb-1">Pro Tip</h3>
              <p className="text-sm text-muted-foreground">
                <kbd className="px-1.5 py-0.5 rounded bg-background text-xs mr-1">Ctrl+K</kbd>를 눌러
                어디서든 빠르게 검색하고 도구에 접근할 수 있습니다.
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

export default ToolsHub;

```

---

## frontend/src/pages/UrlCollections.tsx

```tsx
import React, { useState, useCallback, useMemo } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import {
  FolderPlus,
  Plus,
  Download,
  Upload,
  Search,
  Trash2,
  Copy,
  ArrowLeft,
  Play,
  Shield,
  CheckSquare,
  Square,
  RefreshCw,
  FileJson,
  Clipboard,
  AlertCircle,
  Info,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from '@/components/ui/alert-dialog';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';
import { UrlTree } from '@/components/UrlTree';
import { useUrlCollection, type UrlItem } from '@/hooks/useUrlCollection';

// ============================================
// Add Folder Dialog
// ============================================

interface AddFolderDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onAdd: (name: string, description?: string) => void;
}

const AddFolderDialog: React.FC<AddFolderDialogProps> = ({ open, onOpenChange, onAdd }) => {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (name.trim()) {
      onAdd(name.trim(), description.trim() || undefined);
      setName('');
      setDescription('');
      onOpenChange(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>새 폴더 추가</DialogTitle>
            <DialogDescription>
              URL을 그룹화할 새 폴더를 만듭니다.
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="folder-name">폴더 이름 *</Label>
              <Input
                id="folder-name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="예: 경제 뉴스"
                autoFocus
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="folder-desc">설명 (선택)</Label>
              <Input
                id="folder-desc"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="폴더에 대한 설명"
              />
            </div>
          </div>
          <DialogFooter>
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              취소
            </Button>
            <Button type="submit" disabled={!name.trim()}>
              추가
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

// ============================================
// Add URL Dialog
// ============================================

interface AddUrlDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onAdd: (url: string, name?: string, description?: string, tags?: string[]) => void;
}

const AddUrlDialog: React.FC<AddUrlDialogProps> = ({ open, onOpenChange, onAdd }) => {
  const [url, setUrl] = useState('');
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [tags, setTags] = useState('');
  const [bulkMode, setBulkMode] = useState(false);
  const [bulkUrls, setBulkUrls] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (bulkMode) {
      // Parse multiple URLs (one per line)
      const urls = bulkUrls
        .split('\n')
        .map(line => line.trim())
        .filter(line => line && (line.startsWith('http://') || line.startsWith('https://')));
      
      if (urls.length > 0) {
        for (const u of urls) {
          onAdd(u);
        }
        setBulkUrls('');
        onOpenChange(false);
      }
    } else {
      if (url.trim()) {
        const tagList = tags.split(',').map(t => t.trim()).filter(Boolean);
        onAdd(url.trim(), name.trim() || undefined, description.trim() || undefined, tagList.length > 0 ? tagList : undefined);
        setUrl('');
        setName('');
        setDescription('');
        setTags('');
        onOpenChange(false);
      }
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-lg">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>URL 추가</DialogTitle>
            <DialogDescription>
              분석할 웹 페이지 URL을 추가합니다.
            </DialogDescription>
          </DialogHeader>
          
          <div className="flex gap-2 py-4">
            <Button
              type="button"
              variant={bulkMode ? 'outline' : 'default'}
              size="sm"
              onClick={() => setBulkMode(false)}
            >
              단일 URL
            </Button>
            <Button
              type="button"
              variant={bulkMode ? 'default' : 'outline'}
              size="sm"
              onClick={() => setBulkMode(true)}
            >
              여러 URL 한번에
            </Button>
          </div>

          {bulkMode ? (
            <div className="space-y-4 py-2">
              <div className="space-y-2">
                <Label>URL 목록 (한 줄에 하나씩)</Label>
                <Textarea
                  value={bulkUrls}
                  onChange={(e) => setBulkUrls(e.target.value)}
                  placeholder={`https://example.com/article1\nhttps://example.com/article2\nhttps://example.com/article3`}
                  className="min-h-[200px] font-mono text-sm"
                  autoFocus
                />
                <p className="text-xs text-muted-foreground">
                  {bulkUrls.split('\n').filter(line => line.trim().startsWith('http')).length}개의 유효한 URL
                </p>
              </div>
            </div>
          ) : (
            <div className="space-y-4 py-2">
              <div className="space-y-2">
                <Label htmlFor="url">URL *</Label>
                <Input
                  id="url"
                  type="url"
                  value={url}
                  onChange={(e) => setUrl(e.target.value)}
                  placeholder="https://example.com/article"
                  autoFocus
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="url-name">이름 (선택)</Label>
                <Input
                  id="url-name"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="자동으로 도메인에서 추출됩니다"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="url-desc">설명 (선택)</Label>
                <Input
                  id="url-desc"
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  placeholder="이 URL에 대한 메모"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="url-tags">태그 (선택, 쉼표로 구분)</Label>
                <Input
                  id="url-tags"
                  value={tags}
                  onChange={(e) => setTags(e.target.value)}
                  placeholder="경제, 정치, 국제"
                />
              </div>
            </div>
          )}

          <DialogFooter>
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              취소
            </Button>
            <Button type="submit">
              추가
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

// ============================================
// Import/Export Dialog
// ============================================

interface ImportExportDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  mode: 'import' | 'export';
  exportData?: string;
  onImport: (json: string) => boolean;
}

const ImportExportDialog: React.FC<ImportExportDialogProps> = ({
  open,
  onOpenChange,
  mode,
  exportData,
  onImport,
}) => {
  const { toast } = useToast();
  const [jsonInput, setJsonInput] = useState('');
  const [error, setError] = useState<string | null>(null);

  const handleImport = () => {
    setError(null);
    const success = onImport(jsonInput);
    if (success) {
      toast({ title: '가져오기 완료', description: 'URL 컬렉션을 가져왔습니다.' });
      setJsonInput('');
      onOpenChange(false);
    } else {
      setError('유효하지 않은 JSON 형식입니다.');
    }
  };

  const handleCopy = () => {
    if (exportData) {
      navigator.clipboard.writeText(exportData);
      toast({ title: '복사됨', description: 'JSON이 클립보드에 복사되었습니다.' });
    }
  };

  const handlePaste = async () => {
    try {
      const text = await navigator.clipboard.readText();
      setJsonInput(text);
    } catch (e) {
      toast({ title: '오류', description: '클립보드에서 읽기에 실패했습니다.', variant: 'destructive' });
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-2xl">
        <DialogHeader>
          <DialogTitle>
            {mode === 'export' ? 'JSON 내보내기' : 'JSON 가져오기'}
          </DialogTitle>
          <DialogDescription>
            {mode === 'export'
              ? 'URL 컬렉션을 JSON으로 복사하여 다른 곳에서 공유할 수 있습니다.'
              : 'JSON 형식의 URL 컬렉션을 붙여넣어 가져옵니다.'}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {mode === 'export' ? (
            <>
              <Textarea
                value={exportData}
                readOnly
                className="min-h-[300px] font-mono text-xs"
              />
              <Button onClick={handleCopy} className="w-full">
                <Copy className="h-4 w-4 mr-2" />
                클립보드에 복사
              </Button>
            </>
          ) : (
            <>
              <div className="flex justify-end">
                <Button type="button" variant="outline" size="sm" onClick={handlePaste}>
                  <Clipboard className="h-4 w-4 mr-2" />
                  붙여넣기
                </Button>
              </div>
              <Textarea
                value={jsonInput}
                onChange={(e) => {
                  setJsonInput(e.target.value);
                  setError(null);
                }}
                placeholder={`다음 형식 중 하나를 붙여넣으세요:

1. URL 배열:
["https://example.com/1", "https://example.com/2"]

2. URL 객체 배열:
{"urls": [{"url": "https://...", "name": "제목"}]}

3. 전체 컬렉션 (내보내기한 JSON)`}
                className="min-h-[300px] font-mono text-xs"
              />
              {error && (
                <Alert variant="destructive">
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
              )}
            </>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            닫기
          </Button>
          {mode === 'import' && (
            <Button onClick={handleImport} disabled={!jsonInput.trim()}>
              <Upload className="h-4 w-4 mr-2" />
              가져오기
            </Button>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

// ============================================
// Main Page Component
// ============================================

const UrlCollections = () => {
  const { toast } = useToast();
  const navigate = useNavigate();

  const {
    collection,
    selectedItems,
    selectedCount,
    addFolder,
    addUrl,
    updateItem,
    deleteItem,
    moveItem,
    toggleFolder,
    toggleSelection,
    selectAllInFolder,
    clearSelection,
    getSelectedUrls,
    exportToJson,
    exportSelectedToJson,
    importFromJson,
    resetCollection,
  } = useUrlCollection();

  // Dialog states
  const [showAddFolder, setShowAddFolder] = useState(false);
  const [showAddUrl, setShowAddUrl] = useState(false);
  const [showImport, setShowImport] = useState(false);
  const [showExport, setShowExport] = useState(false);
  const [showExportSelected, setShowExportSelected] = useState(false);
  const [addParentId, setAddParentId] = useState('root');

  // Handlers
  const handleAddFolder = useCallback((parentId: string) => {
    setAddParentId(parentId);
    setShowAddFolder(true);
  }, []);

  const handleAddUrl = useCallback((parentId: string) => {
    setAddParentId(parentId);
    setShowAddUrl(true);
  }, []);

  const handleDeleteSelected = useCallback(() => {
    const selectedUrls = getSelectedUrls();
    for (const url of selectedUrls) {
      deleteItem(url.id);
    }
    for (const folderId of selectedItems.folders) {
      deleteItem(folderId);
    }
    toast({
      title: '삭제 완료',
      description: `${selectedCount}개 항목이 삭제되었습니다.`,
    });
  }, [deleteItem, getSelectedUrls, selectedItems.folders, selectedCount, toast]);

  const handleAnalyzeSelected = useCallback((mode: 'search' | 'factcheck') => {
    const selectedUrls = getSelectedUrls();
    if (selectedUrls.length === 0) {
      toast({
        title: '선택된 URL 없음',
        description: '분석할 URL을 선택해주세요.',
        variant: 'destructive',
      });
      return;
    }

    // Store selected URLs in sessionStorage for the analysis page
    sessionStorage.setItem('analysis-urls', JSON.stringify(selectedUrls.map(u => u.url)));
    
    // Navigate to the analysis page with proper PriorityUrl objects
    navigate(mode === 'search' ? '/search' : '/fact-check', {
      state: {
        priorityUrls: selectedUrls.map((u) => ({
          id: u.id,
          url: u.url,
          name: u.name,
        })),
      },
    });
  }, [getSelectedUrls, navigate, toast]);

  // Stats
  const stats = useMemo(() => {
    let totalUrls = 0;
    let totalFolders = 0;

    const count = (items: typeof collection.root.children) => {
      for (const item of items) {
        if (item.type === 'url') {
          totalUrls++;
        } else {
          totalFolders++;
          count(item.children);
        }
      }
    };

    count(collection.root.children);
    return { totalUrls, totalFolders };
  }, [collection.root.children]);

  return (
    <div className="min-h-screen py-8">
      <div className="container mx-auto px-4 max-w-5xl">
        {/* Header */}
        <header className="mb-8">
          <Link
            to="/"
            className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-4"
          >
            <ArrowLeft className="h-4 w-4" />
            메인으로 돌아가기
          </Link>
          <div className="flex items-center justify-between flex-wrap gap-4">
            <div>
              <h1 className="text-3xl md:text-4xl font-bold mb-2">
                URL 컬렉션
              </h1>
              <p className="text-muted-foreground">
                분석할 URL을 폴더별로 관리하고 선택하여 우선 분석할 수 있습니다.
              </p>
            </div>
            <div className="flex items-center gap-2 text-sm text-muted-foreground">
              <Badge variant="outline">{stats.totalFolders} 폴더</Badge>
              <Badge variant="outline">{stats.totalUrls} URL</Badge>
            </div>
          </div>
        </header>

        {/* Action Bar */}
        <Card className="mb-6">
          <CardContent className="py-4">
            <div className="flex flex-wrap items-center gap-2">
              {/* Add buttons */}
              <Button variant="outline" size="sm" onClick={() => handleAddFolder('root')}>
                <FolderPlus className="h-4 w-4 mr-2" />
                폴더 추가
              </Button>
              <Button variant="outline" size="sm" onClick={() => handleAddUrl('root')}>
                <Plus className="h-4 w-4 mr-2" />
                URL 추가
              </Button>

              <Separator orientation="vertical" className="h-6" />

              {/* Import/Export */}
              <Button variant="outline" size="sm" onClick={() => setShowImport(true)}>
                <Upload className="h-4 w-4 mr-2" />
                가져오기
              </Button>
              <Button variant="outline" size="sm" onClick={() => setShowExport(true)}>
                <Download className="h-4 w-4 mr-2" />
                내보내기
              </Button>

              <div className="flex-1" />

              {/* Selection actions */}
              {selectedCount > 0 && (
                <>
                  <Badge variant="secondary" className="mr-2">
                    {selectedCount}개 선택됨
                  </Badge>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setShowExportSelected(true)}
                  >
                    <FileJson className="h-4 w-4 mr-2" />
                    선택 항목 JSON
                  </Button>
                  <AlertDialog>
                    <AlertDialogTrigger asChild>
                      <Button variant="outline" size="sm" className="text-destructive">
                        <Trash2 className="h-4 w-4 mr-2" />
                        삭제
                      </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>선택 항목 삭제</AlertDialogTitle>
                        <AlertDialogDescription>
                          {selectedCount}개의 선택된 항목을 삭제하시겠습니까?
                          이 작업은 취소할 수 없습니다.
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel>취소</AlertDialogCancel>
                        <AlertDialogAction onClick={handleDeleteSelected}>
                          삭제
                        </AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
                  <Button size="sm" variant="outline" onClick={clearSelection}>
                    선택 해제
                  </Button>
                </>
              )}
            </div>
          </CardContent>
        </Card>

        {/* Analysis Action */}
        {selectedCount > 0 && (
          <Card className="mb-6 bg-primary/5 border-primary/20">
            <CardContent className="py-4">
              <div className="flex flex-wrap items-center justify-between gap-4">
                <div>
                  <h3 className="font-medium">선택된 URL 분석</h3>
                  <p className="text-sm text-muted-foreground">
                    {getSelectedUrls().length}개의 URL을 우선 분석합니다.
                  </p>
                </div>
                <div className="flex gap-2">
                  <Button onClick={() => handleAnalyzeSelected('search')}>
                    <Search className="h-4 w-4 mr-2" />
                    통합 검색으로 분석
                  </Button>
                  <Button variant="outline" onClick={() => handleAnalyzeSelected('factcheck')}>
                    <Shield className="h-4 w-4 mr-2" />
                    팩트체크로 분석
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        )}

        {/* URL Tree */}
        <Card>
          <CardHeader className="pb-2">
            <div className="flex items-center justify-between">
              <CardTitle>URL 목록</CardTitle>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => selectAllInFolder('root')}
              >
                <CheckSquare className="h-4 w-4 mr-2" />
                전체 선택
              </Button>
            </div>
          </CardHeader>
          <CardContent>
            <ScrollArea className="h-[500px] pr-4">
              <UrlTree
                root={collection.root}
                selectedItems={selectedItems}
                onToggleFolder={toggleFolder}
                onToggleSelection={toggleSelection}
                onDelete={deleteItem}
                onUpdate={updateItem}
                onAddFolder={handleAddFolder}
                onAddUrl={handleAddUrl}
                onSelectAll={selectAllInFolder}
                onMoveItem={moveItem}
              />
            </ScrollArea>
          </CardContent>
        </Card>

        {/* Help Text */}
        <Alert className="mt-6">
          <Info className="h-4 w-4" />
          <AlertDescription>
            <strong>사용법:</strong> 폴더와 URL을 추가하고, 체크박스로 분석할 항목을 선택하세요.
            드래그 앤 드롭으로 항목을 이동할 수 있습니다.
            JSON 내보내기/가져오기로 컬렉션을 공유할 수 있습니다.
            더블클릭으로 이름을 변경할 수 있습니다.
          </AlertDescription>
        </Alert>

        {/* Reset Button */}
        <div className="mt-4 text-center">
          <AlertDialog>
            <AlertDialogTrigger asChild>
              <Button variant="ghost" size="sm" className="text-muted-foreground">
                <RefreshCw className="h-4 w-4 mr-2" />
                컬렉션 초기화
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>컬렉션 초기화</AlertDialogTitle>
                <AlertDialogDescription>
                  모든 폴더와 URL을 삭제하고 초기 상태로 되돌립니다.
                  이 작업은 취소할 수 없습니다.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>취소</AlertDialogCancel>
                <AlertDialogAction onClick={resetCollection}>
                  초기화
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        </div>
      </div>

      {/* Dialogs */}
      <AddFolderDialog
        open={showAddFolder}
        onOpenChange={setShowAddFolder}
        onAdd={(name, desc) => addFolder(addParentId, name, desc)}
      />

      <AddUrlDialog
        open={showAddUrl}
        onOpenChange={setShowAddUrl}
        onAdd={(url, name, desc, tags) => addUrl(addParentId, url, name, desc, tags)}
      />

      <ImportExportDialog
        open={showImport}
        onOpenChange={setShowImport}
        mode="import"
        onImport={importFromJson}
      />

      <ImportExportDialog
        open={showExport}
        onOpenChange={setShowExport}
        mode="export"
        exportData={exportToJson()}
        onImport={() => false}
      />

      <ImportExportDialog
        open={showExportSelected}
        onOpenChange={setShowExportSelected}
        mode="export"
        exportData={exportSelectedToJson()}
        onImport={() => false}
      />
    </div>
  );
};

export default UrlCollections;

```

---

## frontend/src/pages/WorkspaceHub.tsx

```tsx
/**
 * WorkspaceHub - 내 작업 허브 페이지
 * 
 * 사용자의 모든 작업을 한눈에 보여줍니다.
 * - 검색 기록 (백엔드 API 연동)
 * - URL 컬렉션
 * - 최근 분석 결과
 */

import { Link } from 'react-router-dom';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { Skeleton } from '@/components/ui/skeleton';
import {
  FolderOpen,
  History,
  Globe,
  Clock,
  ArrowRight,
  FileText,
  Star,
  TrendingUp,
  Calendar,
  AlertCircle,
} from 'lucide-react';
import { useContinueWork } from '@/hooks/useContinueWork';
import { useUsageStreak } from '@/hooks/useUsageStreak';
import { useEffect, useState } from 'react';
import { getSearchStatistics, listSearchHistory, getBookmarkedSearches } from '@/lib/api';
import { formatDistanceToNow } from 'date-fns';
import { ko } from 'date-fns/locale';

interface QuickAccessCardProps {
  to: string;
  icon: React.ReactNode;
  title: string;
  description: string;
  count?: number;
  lastUpdated?: Date;
  isLoading?: boolean;
}

function QuickAccessCard({ to, icon, title, description, count, lastUpdated, isLoading }: QuickAccessCardProps) {
  return (
    <Link to={to} className="block group">
      <Card className="h-full transition-all hover:shadow-md hover:border-primary/50">
        <CardHeader className="pb-2">
          <div className="flex items-center justify-between">
            <div className="p-2 rounded-lg bg-muted text-muted-foreground group-hover:bg-primary/10 group-hover:text-primary transition-colors">
              {icon}
            </div>
            <ArrowRight className="h-4 w-4 text-muted-foreground opacity-0 -translate-x-2 transition-all group-hover:opacity-100 group-hover:translate-x-0" />
          </div>
        </CardHeader>
        <CardContent>
          <h3 className="font-semibold mb-1">{title}</h3>
          <p className="text-sm text-muted-foreground mb-3">{description}</p>
          <div className="flex items-center justify-between text-xs text-muted-foreground">
            {isLoading ? (
              <Skeleton className="h-4 w-16" />
            ) : (
              count !== undefined && <span>{count}개 항목</span>
            )}
            {lastUpdated && (
              <span className="flex items-center gap-1">
                <Clock className="h-3 w-3" />
                {formatDistanceToNow(lastUpdated, { addSuffix: true, locale: ko })}
              </span>
            )}
          </div>
        </CardContent>
      </Card>
    </Link>
  );
}

interface WorkspaceStats {
  searchHistoryCount: number;
  bookmarkedCount: number;
  recentSearchDate?: Date;
  isLoading: boolean;
  error: string | null;
}

export function WorkspaceHub() {
  const { recentWorks } = useContinueWork();
  const { streak, weeklyStats, totalSearches } = useUsageStreak();
  
  const [stats, setStats] = useState<WorkspaceStats>({
    searchHistoryCount: 0,
    bookmarkedCount: 0,
    isLoading: true,
    error: null,
  });

  // 백엔드에서 실제 통계 로드
  useEffect(() => {
    const loadStats = async () => {
      try {
        const [historyResponse, bookmarkedResponse] = await Promise.all([
          listSearchHistory(0, 1), // 총 개수만 확인
          getBookmarkedSearches(0, 1),
        ]);
        
        // 가장 최근 검색 날짜
        let recentDate: Date | undefined;
        if (historyResponse.content.length > 0) {
          recentDate = new Date(historyResponse.content[0].createdAt);
        }
        
        setStats({
          searchHistoryCount: historyResponse.totalElements || 0,
          bookmarkedCount: bookmarkedResponse.totalElements || 0,
          recentSearchDate: recentDate,
          isLoading: false,
          error: null,
        });
      } catch (error) {
        console.error('Failed to load workspace stats:', error);
        setStats(prev => ({
          ...prev,
          isLoading: false,
          error: '통계를 불러오는데 실패했습니다',
        }));
      }
    };
    
    loadStats();
  }, []);

  return (
    <div className="container py-8 px-4 max-w-7xl mx-auto">
      {/* Header */}
      <div className="mb-8 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-3xl font-bold tracking-tight mb-2">내 작업</h1>
          <p className="text-muted-foreground">
            검색 기록, 저장된 분석을 관리하세요
          </p>
        </div>
        <div className="flex gap-2">
          <Link to="/search">
            <Button>
              새 검색 시작
            </Button>
          </Link>
        </div>
      </div>

      {/* Stats Overview - 백엔드 데이터 기반 */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center gap-3">
              <div className="p-2 rounded-lg bg-green-500/10">
                <History className="h-5 w-5 text-green-500" />
              </div>
              <div>
                {stats.isLoading ? (
                  <Skeleton className="h-8 w-12" />
                ) : (
                  <p className="text-2xl font-bold">{stats.searchHistoryCount}</p>
                )}
                <p className="text-xs text-muted-foreground">검색 기록</p>
              </div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center gap-3">
              <div className="p-2 rounded-lg bg-yellow-500/10">
                <Star className="h-5 w-5 text-yellow-500" />
              </div>
              <div>
                {stats.isLoading ? (
                  <Skeleton className="h-8 w-12" />
                ) : (
                  <p className="text-2xl font-bold">{stats.bookmarkedCount}</p>
                )}
                <p className="text-xs text-muted-foreground">북마크</p>
              </div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center gap-3">
              <div className="p-2 rounded-lg bg-purple-500/10">
                <Globe className="h-5 w-5 text-purple-500" />
              </div>
              <div>
                <p className="text-2xl font-bold">{totalSearches}</p>
                <p className="text-xs text-muted-foreground">이번 주 검색</p>
              </div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center gap-3">
              <div className="p-2 rounded-lg bg-blue-500/10">
                <TrendingUp className="h-5 w-5 text-blue-500" />
              </div>
              <div>
                <p className="text-2xl font-bold">{streak}일</p>
                <p className="text-xs text-muted-foreground">연속 사용</p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Error Message */}
      {stats.error && (
        <Card className="mb-6 border-amber-500/50 bg-amber-50 dark:bg-amber-950/20">
          <CardContent className="py-4">
            <div className="flex items-center gap-2 text-amber-600 dark:text-amber-400">
              <AlertCircle className="h-4 w-4" />
              <span className="text-sm">{stats.error}</span>
            </div>
          </CardContent>
        </Card>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Content */}
        <div className="lg:col-span-2 space-y-6">
          {/* Quick Access */}
          <div>
            <h2 className="text-lg font-semibold mb-4">빠른 접근</h2>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <QuickAccessCard
                to="/history"
                icon={<History className="h-5 w-5" />}
                title="검색 기록"
                description="최근 검색 내역"
                count={stats.searchHistoryCount}
                lastUpdated={stats.recentSearchDate}
                isLoading={stats.isLoading}
              />
              <QuickAccessCard
                to="/url-collections"
                icon={<Globe className="h-5 w-5" />}
                title="URL 컬렉션"
                description="저장된 URL 원천"
              />
              <QuickAccessCard
                to="/ai-jobs"
                icon={<FileText className="h-5 w-5" />}
                title="AI 분석 작업"
                description="AI 분석 작업 히스토리"
              />
              <QuickAccessCard
                to="/projects"
                icon={<FolderOpen className="h-5 w-5" />}
                title="프로젝트"
                description="분석 프로젝트 (준비 중)"
              />
            </div>
          </div>

          {/* Recent Activity */}
          <Card>
            <CardHeader>
              <CardTitle className="text-base">최근 활동</CardTitle>
              <CardDescription>최근에 작업한 내역</CardDescription>
            </CardHeader>
            <CardContent>
              {recentWorks.length > 0 ? (
                <div className="space-y-3">
                  {recentWorks.slice(0, 5).map((work, idx) => (
                    <Link
                      key={idx}
                      to={work.continueUrl}
                      className="flex items-center gap-3 p-3 rounded-lg hover:bg-accent transition-colors"
                    >
                      <div className="p-2 rounded bg-muted">
                        {(work.type === 'unified_search' || work.type === 'deep_search') && <History className="h-4 w-4" />}
                        {work.type === 'fact_check' && <FileText className="h-4 w-4" />}
                        {work.type === 'browser_agent' && <Globe className="h-4 w-4" />}
                        {work.type === 'url_analysis' && <FolderOpen className="h-4 w-4" />}
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="text-sm font-medium truncate">{work.title}</p>
                        <p className="text-xs text-muted-foreground">
                          {formatDistanceToNow(new Date(work.lastUpdated), { addSuffix: true, locale: ko })}
                        </p>
                      </div>
                      <Badge variant="outline" className="text-xs">
                        {work.type === 'unified_search' && '검색'}
                        {work.type === 'deep_search' && '심층분석'}
                        {work.type === 'fact_check' && '팩트체크'}
                        {work.type === 'browser_agent' && 'AI 에이전트'}
                        {work.type === 'url_analysis' && 'URL 분석'}
                      </Badge>
                    </Link>
                  ))}
                </div>
              ) : (
                <div className="text-center py-8 text-muted-foreground">
                  <History className="h-8 w-8 mx-auto mb-2 opacity-50" />
                  <p>아직 활동 내역이 없습니다</p>
                  <Link to="/search">
                    <Button variant="link" className="mt-2">
                      첫 검색 시작하기
                    </Button>
                  </Link>
                </div>
              )}
            </CardContent>
          </Card>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Usage Stats */}
          <Card>
            <CardHeader>
              <CardTitle className="text-base flex items-center gap-2">
                <TrendingUp className="h-4 w-4" />
                사용 현황
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <div className="flex justify-between text-sm mb-1">
                  <span>연속 사용</span>
                  <span className="font-medium">{streak}일</span>
                </div>
                <Progress value={Math.min(streak * 10, 100)} className="h-2" />
              </div>
              <div>
                <div className="flex justify-between text-sm mb-1">
                  <span>이번 주 검색</span>
                  <span className="font-medium">{totalSearches}회</span>
                </div>
              </div>
              
              {/* Weekly Activity */}
              <div>
                <p className="text-sm text-muted-foreground mb-2">주간 활동</p>
                <div className="flex gap-1">
                  {['월', '화', '수', '목', '금', '토', '일'].map((day, idx) => {
                    const stat = weeklyStats[idx];
                    const intensity = stat?.count ? Math.min(stat.count / 5, 1) : 0;
                    return (
                      <div
                        key={day}
                        className="flex-1 flex flex-col items-center gap-1"
                      >
                        <div
                          className="w-full h-6 rounded"
                          style={{
                            backgroundColor: intensity > 0
                              ? `rgba(34, 197, 94, ${0.2 + intensity * 0.8})`
                              : 'rgb(229, 231, 235)',
                          }}
                        />
                        <span className="text-[10px] text-muted-foreground">{day}</span>
                      </div>
                    );
                  })}
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Bookmarks */}
          <Card>
            <CardHeader>
              <CardTitle className="text-base flex items-center gap-2">
                <Star className="h-4 w-4" />
                북마크
              </CardTitle>
            </CardHeader>
            <CardContent>
              {stats.isLoading ? (
                <div className="space-y-2">
                  <Skeleton className="h-4 w-full" />
                  <Skeleton className="h-4 w-3/4" />
                </div>
              ) : stats.bookmarkedCount > 0 ? (
                <div className="text-center py-2">
                  <p className="text-sm text-muted-foreground mb-2">
                    {stats.bookmarkedCount}개의 북마크
                  </p>
                  <Link to="/history?bookmarked=true">
                    <Button variant="outline" size="sm">
                      북마크 보기
                    </Button>
                  </Link>
                </div>
              ) : (
                <div className="text-center py-4 text-muted-foreground">
                  <Star className="h-6 w-6 mx-auto mb-2 opacity-50" />
                  <p className="text-sm">북마크한 검색이 없습니다</p>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="text-base flex items-center gap-2">
                <Calendar className="h-4 w-4" />
                빠른 작업
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-2">
              <Link to="/search" className="block">
                <Button variant="outline" className="w-full justify-start">
                  <History className="h-4 w-4 mr-2" />
                  새 검색 시작
                </Button>
              </Link>
              <Link to="/smart-search" className="block">
                <Button variant="outline" className="w-full justify-start">
                  <FileText className="h-4 w-4 mr-2" />
                  스마트 검색
                </Button>
              </Link>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}

export default WorkspaceHub;

```

---

## frontend/src/pages/admin/AdminAuditLogs.tsx

```tsx
import { useEffect, useState } from 'react';
import { auditApi } from '@/lib/adminApi';
import type { AuditLog } from '@/types/admin';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from '@/components/ui/badge';
import { Input } from "@/components/ui/input";
import { Button } from '@/components/ui/button';
import { Search, Filter, Download } from 'lucide-react';
import { format } from 'date-fns';
import { ko } from 'date-fns/locale';

export default function AdminAuditLogs() {
  const [logs, setLogs] = useState<AuditLog[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [filters, setFilters] = useState({
    userId: '',
    action: '',
    resourceType: '',
    page: 1,
    pageSize: 50
  });

  useEffect(() => {
    loadLogs();
  }, [filters.page]);

  const loadLogs = async () => {
    setIsLoading(true);
    try {
      const data = await auditApi.list(filters);
      setLogs(data);
    } catch (error) {
      console.error('Failed to load audit logs:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleSearch = () => {
    setFilters(prev => ({ ...prev, page: 1 }));
    loadLogs();
  };

  const getActionBadge = (action: string) => {
    const variants: Record<string, "default" | "secondary" | "destructive" | "outline"> = {
      'login': 'secondary',
      'logout': 'outline',
      'create': 'default',
      'update': 'default', // blue-ish usually
      'delete': 'destructive',
      'execute': 'default',
      'deploy': 'default',
      'rollback': 'destructive'
    };
    
    return <Badge variant={variants[action] || 'outline'}>{action}</Badge>;
  };

  return (
    <div className="space-y-6 container mx-auto p-4">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold tracking-tight">감사 로그</h1>
        <Button variant="outline">
          <Download className="w-4 h-4 mr-2" />
          CSV 내보내기
        </Button>
      </div>

      <Card>
        <CardHeader>
          <div className="flex flex-col md:flex-row gap-4">
            <div className="flex-1 flex gap-2">
              <div className="relative flex-1">
                <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                <Input 
                  placeholder="사용자 ID 검색..." 
                  className="pl-8"
                  value={filters.userId}
                  onChange={(e) => setFilters(prev => ({ ...prev, userId: e.target.value }))}
                />
              </div>
              <div className="relative flex-1">
                <Filter className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                <Input 
                  placeholder="리소스 타입..." 
                  className="pl-8"
                  value={filters.resourceType}
                  onChange={(e) => setFilters(prev => ({ ...prev, resourceType: e.target.value }))}
                />
              </div>
              <Button onClick={handleSearch}>검색</Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <div className="rounded-md border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>시간</TableHead>
                  <TableHead>사용자</TableHead>
                  <TableHead>액션</TableHead>
                  <TableHead>리소스</TableHead>
                  <TableHead>환경</TableHead>
                  <TableHead>상태</TableHead>
                  <TableHead>IP</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={7} className="text-center h-24">
                      <div className="flex justify-center items-center">
                        <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary" />
                      </div>
                    </TableCell>
                  </TableRow>
                ) : logs.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={7} className="text-center h-24 text-muted-foreground">
                      로그 데이터가 없습니다.
                    </TableCell>
                  </TableRow>
                ) : (
                  logs.map((log) => (
                    <TableRow key={log.id}>
                      <TableCell className="font-mono text-xs">
                        {format(new Date(log.timestamp), 'yyyy-MM-dd HH:mm:ss')}
                      </TableCell>
                      <TableCell>
                        <div className="flex flex-col">
                          <span className="font-medium">{log.username}</span>
                          <span className="text-xs text-muted-foreground">{log.user_id}</span>
                        </div>
                      </TableCell>
                      <TableCell>{getActionBadge(log.action)}</TableCell>
                      <TableCell>
                        <div className="flex flex-col">
                          <span className="font-medium">{log.resource_type}</span>
                          <span className="text-xs text-muted-foreground truncate max-w-[150px]">
                            {log.resource_name || log.resource_id}
                          </span>
                        </div>
                      </TableCell>
                      <TableCell>{log.environment_name || '-'}</TableCell>
                      <TableCell>
                        <Badge variant={log.success ? 'outline' : 'destructive'} className={log.success ? 'text-green-600 border-green-200 bg-green-50' : ''}>
                          {log.success ? '성공' : '실패'}
                        </Badge>
                      </TableCell>
                      <TableCell className="text-xs text-muted-foreground">{log.ip_address}</TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
          
          <div className="flex items-center justify-end space-x-2 py-4">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setFilters(prev => ({ ...prev, page: Math.max(1, prev.page - 1) }))}
              disabled={filters.page <= 1 || isLoading}
            >
              이전
            </Button>
            <div className="text-sm font-medium">Page {filters.page}</div>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setFilters(prev => ({ ...prev, page: prev.page + 1 }))}
              disabled={logs.length < filters.pageSize || isLoading}
            >
              다음
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

```

---

## frontend/src/pages/admin/AdminConfigExport.tsx

```tsx
import { useState, useRef, useCallback } from 'react';
import {
  Download,
  Upload,
  FileJson,
  Loader2,
  CheckCircle2,
  XCircle,
  AlertTriangle,
  RefreshCw,
  Eye,
  Copy,
  ShieldAlert,
  FileUp,
  Bot,
  Cpu,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Switch } from '@/components/ui/switch';
import { Separator } from '@/components/ui/separator';
import { Textarea } from '@/components/ui/textarea';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/contexts/AuthContext';
import {
  exportSystemConfig,
  importSystemConfig,
  validateSystemConfig,
  getConfigTemplate,
} from '@/lib/api';
import type {
  SystemConfigExport,
  SystemConfigImport,
  ConfigImportResult,
} from '@/types/api';

export default function AdminConfigExport() {
  const { toast } = useToast();
  const { user } = useAuth();
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Export state
  const [isExporting, setIsExporting] = useState(false);
  const [exportData, setExportData] = useState<SystemConfigExport | null>(null);
  const [includeLlm, setIncludeLlm] = useState(true);
  const [includeMl, setIncludeMl] = useState(true);

  // Import state
  const [isImporting, setIsImporting] = useState(false);
  const [isValidating, setIsValidating] = useState(false);
  const [importDialogOpen, setImportDialogOpen] = useState(false);
  const [importData, setImportData] = useState<SystemConfigImport | null>(null);
  const [importJson, setImportJson] = useState('');
  const [importResult, setImportResult] = useState<ConfigImportResult | null>(null);
  const [importOptions, setImportOptions] = useState({
    overwriteExisting: true,
    skipLlmProviders: false,
    skipMlAddons: false,
  });

  // Preview dialog
  const [previewDialogOpen, setPreviewDialogOpen] = useState(false);

  const isAdmin = user?.role === 'admin';

  // Export configuration
  const handleExport = useCallback(async () => {
    setIsExporting(true);
    try {
      const data = await exportSystemConfig(includeLlm, includeMl);
      setExportData(data);
      toast({
        title: 'Export 완료',
        description: `LLM: ${data.llmProviders.length}개, ML: ${data.mlAddons.length}개 설정이 준비되었습니다.`,
      });
    } catch (error) {
      console.error('Export failed:', error);
      toast({
        title: 'Export 실패',
        description: '설정을 내보내는데 실패했습니다.',
        variant: 'destructive',
      });
    } finally {
      setIsExporting(false);
    }
  }, [includeLlm, includeMl, toast]);

  // Download as file
  const handleDownload = useCallback(() => {
    if (!exportData) return;

    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
      type: 'application/json',
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `newsinsight-config-${new Date().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    toast({
      title: '다운로드 완료',
      description: '설정 파일이 다운로드되었습니다.',
    });
  }, [exportData, toast]);

  // Copy to clipboard
  const handleCopyToClipboard = useCallback(() => {
    if (!exportData) return;

    navigator.clipboard.writeText(JSON.stringify(exportData, null, 2));
    toast({
      title: '복사 완료',
      description: '설정이 클립보드에 복사되었습니다.',
    });
  }, [exportData, toast]);

  // File input change
  const handleFileSelect = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const text = event.target?.result as string;
        const parsed = JSON.parse(text) as SystemConfigImport;
        setImportData(parsed);
        setImportJson(text);
        setImportDialogOpen(true);
        setImportResult(null);
      } catch (error) {
        toast({
          title: '파일 파싱 실패',
          description: '유효한 JSON 파일이 아닙니다.',
          variant: 'destructive',
        });
      }
    };
    reader.readAsText(file);

    // Reset file input
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  }, [toast]);

  // Validate import config
  const handleValidate = useCallback(async () => {
    if (!importData) return;

    setIsValidating(true);
    try {
      const result = await validateSystemConfig(importData);
      setImportResult(result);
      toast({
        title: result.success ? '검증 성공' : '검증 실패',
        description: result.message,
        variant: result.success ? 'default' : 'destructive',
      });
    } catch (error) {
      console.error('Validation failed:', error);
      toast({
        title: '검증 실패',
        description: '설정 검증 중 오류가 발생했습니다.',
        variant: 'destructive',
      });
    } finally {
      setIsValidating(false);
    }
  }, [importData, toast]);

  // Import configuration
  const handleImport = useCallback(async () => {
    if (!importData) return;

    setIsImporting(true);
    try {
      const result = await importSystemConfig(importData, importOptions);
      setImportResult(result);

      if (result.success) {
        toast({
          title: 'Import 완료',
          description: result.message,
        });
        setImportDialogOpen(false);
      } else {
        toast({
          title: 'Import 부분 실패',
          description: result.message,
          variant: 'destructive',
        });
      }
    } catch (error) {
      console.error('Import failed:', error);
      toast({
        title: 'Import 실패',
        description: '설정을 가져오는데 실패했습니다.',
        variant: 'destructive',
      });
    } finally {
      setIsImporting(false);
    }
  }, [importData, importOptions, toast]);

  // Load template
  const handleLoadTemplate = useCallback(async () => {
    try {
      const template = await getConfigTemplate();
      setImportData(template);
      setImportJson(JSON.stringify(template, null, 2));
      setImportDialogOpen(true);
      setImportResult(null);
      toast({
        title: '템플릿 로드',
        description: '예시 템플릿이 로드되었습니다. API Key를 실제 값으로 교체하세요.',
      });
    } catch (error) {
      console.error('Failed to load template:', error);
      toast({
        title: '템플릿 로드 실패',
        description: '템플릿을 불러오는데 실패했습니다.',
        variant: 'destructive',
      });
    }
  }, [toast]);

  // Access denied for non-admins
  if (!isAdmin) {
    return (
      <div className="flex flex-col items-center justify-center h-64 space-y-4">
        <ShieldAlert className="w-16 h-16 text-muted-foreground" />
        <h2 className="text-xl font-semibold">접근 권한이 없습니다</h2>
        <p className="text-muted-foreground text-center">
          설정 Export/Import는 관리자만 사용할 수 있습니다.
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6 container mx-auto p-4">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">설정 Export/Import</h1>
          <p className="text-muted-foreground mt-1">
            LLM Provider, ML Addon 등 시스템 설정을 JSON으로 일괄 관리합니다.
          </p>
        </div>
      </div>

      <Alert>
        <FileJson className="w-4 h-4" />
        <AlertDescription>
          설정을 JSON 파일로 내보내거나 가져와서 백업/복원, 환경 간 설정 이전에 활용하세요.
          <strong className="ml-1">API Key는 마스킹되어 Export됩니다.</strong>
        </AlertDescription>
      </Alert>

      <div className="grid gap-6 md:grid-cols-2">
        {/* Export Card */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Download className="w-5 h-5" />
              설정 Export
            </CardTitle>
            <CardDescription>
              현재 시스템 설정을 JSON으로 내보냅니다.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Bot className="w-4 h-4 text-muted-foreground" />
                  <Label>LLM Provider 설정 포함</Label>
                </div>
                <Switch
                  checked={includeLlm}
                  onCheckedChange={setIncludeLlm}
                />
              </div>
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Cpu className="w-4 h-4 text-muted-foreground" />
                  <Label>ML Addon 설정 포함</Label>
                </div>
                <Switch
                  checked={includeMl}
                  onCheckedChange={setIncludeMl}
                />
              </div>
            </div>

            <Separator />

            <div className="flex gap-2">
              <Button
                onClick={handleExport}
                disabled={isExporting || (!includeLlm && !includeMl)}
                className="flex-1"
              >
                {isExporting ? (
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                ) : (
                  <RefreshCw className="w-4 h-4 mr-2" />
                )}
                설정 불러오기
              </Button>
            </div>

            {exportData && (
              <div className="space-y-3 pt-2">
                <div className="flex items-center gap-2 text-sm text-muted-foreground">
                  <CheckCircle2 className="w-4 h-4 text-green-500" />
                  <span>
                    LLM: {exportData.llmProviders.length}개, ML: {exportData.mlAddons.length}개
                  </span>
                </div>

                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setPreviewDialogOpen(true)}
                  >
                    <Eye className="w-4 h-4 mr-2" />
                    미리보기
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleCopyToClipboard}
                  >
                    <Copy className="w-4 h-4 mr-2" />
                    복사
                  </Button>
                  <Button
                    size="sm"
                    onClick={handleDownload}
                  >
                    <Download className="w-4 h-4 mr-2" />
                    다운로드
                  </Button>
                </div>
              </div>
            )}
          </CardContent>
        </Card>

        {/* Import Card */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Upload className="w-5 h-5" />
              설정 Import
            </CardTitle>
            <CardDescription>
              JSON 파일에서 설정을 가져옵니다.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Alert variant="destructive" className="bg-yellow-500/10 border-yellow-500/50">
              <AlertTriangle className="w-4 h-4 text-yellow-500" />
              <AlertTitle className="text-yellow-600">주의</AlertTitle>
              <AlertDescription className="text-yellow-600">
                Import 시 기존 설정이 덮어쓰여질 수 있습니다.
                <br />
                API Key는 반드시 실제 값으로 교체해야 합니다.
              </AlertDescription>
            </Alert>

            <input
              ref={fileInputRef}
              type="file"
              accept=".json,application/json"
              onChange={handleFileSelect}
              className="hidden"
            />

            <div className="flex gap-2">
              <Button
                variant="outline"
                onClick={() => fileInputRef.current?.click()}
                className="flex-1"
              >
                <FileUp className="w-4 h-4 mr-2" />
                파일 선택
              </Button>
              <Button
                variant="secondary"
                onClick={handleLoadTemplate}
              >
                <FileJson className="w-4 h-4 mr-2" />
                템플릿
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Preview Dialog */}
      <Dialog open={previewDialogOpen} onOpenChange={setPreviewDialogOpen}>
        <DialogContent className="max-w-4xl max-h-[80vh] overflow-hidden flex flex-col">
          <DialogHeader>
            <DialogTitle>Export 미리보기</DialogTitle>
            <DialogDescription>
              내보낼 설정의 JSON 내용입니다.
            </DialogDescription>
          </DialogHeader>
          <div className="flex-1 overflow-auto">
            <pre className="bg-muted p-4 rounded-lg text-xs overflow-auto max-h-[50vh]">
              {exportData ? JSON.stringify(exportData, null, 2) : ''}
            </pre>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setPreviewDialogOpen(false)}>
              닫기
            </Button>
            <Button onClick={handleDownload}>
              <Download className="w-4 h-4 mr-2" />
              다운로드
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Import Dialog */}
      <Dialog open={importDialogOpen} onOpenChange={setImportDialogOpen}>
        <DialogContent className="max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
          <DialogHeader>
            <DialogTitle>설정 Import</DialogTitle>
            <DialogDescription>
              가져올 설정을 확인하고 옵션을 선택하세요.
            </DialogDescription>
          </DialogHeader>

          <div className="flex-1 overflow-auto space-y-4">
            {/* Import Summary */}
            {importData && (
              <div className="grid gap-4 md:grid-cols-2">
                <Card>
                  <CardHeader className="py-3">
                    <CardTitle className="text-sm flex items-center gap-2">
                      <Bot className="w-4 h-4" />
                      LLM Provider ({importData.llmProviders.length}개)
                    </CardTitle>
                  </CardHeader>
                  <CardContent className="py-2">
                    <div className="space-y-1">
                      {importData.llmProviders.map((p, i) => (
                        <div key={i} className="flex items-center justify-between text-sm">
                          <span>{p.providerType}</span>
                          <Badge variant={p.apiKey ? 'default' : 'secondary'}>
                            {p.apiKey ? 'API Key 있음' : 'API Key 없음'}
                          </Badge>
                        </div>
                      ))}
                      {importData.llmProviders.length === 0 && (
                        <span className="text-muted-foreground text-sm">없음</span>
                      )}
                    </div>
                  </CardContent>
                </Card>

                <Card>
                  <CardHeader className="py-3">
                    <CardTitle className="text-sm flex items-center gap-2">
                      <Cpu className="w-4 h-4" />
                      ML Addon ({importData.mlAddons.length}개)
                    </CardTitle>
                  </CardHeader>
                  <CardContent className="py-2">
                    <div className="space-y-1">
                      {importData.mlAddons.map((a, i) => (
                        <div key={i} className="flex items-center justify-between text-sm">
                          <span>{a.name}</span>
                          <code className="text-xs bg-muted px-1 rounded">{a.addon_key}</code>
                        </div>
                      ))}
                      {importData.mlAddons.length === 0 && (
                        <span className="text-muted-foreground text-sm">없음</span>
                      )}
                    </div>
                  </CardContent>
                </Card>
              </div>
            )}

            {/* Import Options */}
            <Card>
              <CardHeader className="py-3">
                <CardTitle className="text-sm">Import 옵션</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="flex items-center justify-between">
                  <Label>기존 설정 덮어쓰기</Label>
                  <Switch
                    checked={importOptions.overwriteExisting}
                    onCheckedChange={(v) =>
                      setImportOptions((prev) => ({ ...prev, overwriteExisting: v }))
                    }
                  />
                </div>
                <div className="flex items-center justify-between">
                  <Label>LLM Provider 건너뛰기</Label>
                  <Switch
                    checked={importOptions.skipLlmProviders}
                    onCheckedChange={(v) =>
                      setImportOptions((prev) => ({ ...prev, skipLlmProviders: v }))
                    }
                  />
                </div>
                <div className="flex items-center justify-between">
                  <Label>ML Addon 건너뛰기</Label>
                  <Switch
                    checked={importOptions.skipMlAddons}
                    onCheckedChange={(v) =>
                      setImportOptions((prev) => ({ ...prev, skipMlAddons: v }))
                    }
                  />
                </div>
              </CardContent>
            </Card>

            {/* JSON Editor */}
            <Accordion type="single" collapsible>
              <AccordionItem value="json">
                <AccordionTrigger>JSON 편집</AccordionTrigger>
                <AccordionContent>
                  <Textarea
                    value={importJson}
                    onChange={(e) => {
                      setImportJson(e.target.value);
                      try {
                        setImportData(JSON.parse(e.target.value));
                      } catch {
                        // Invalid JSON, ignore
                      }
                    }}
                    className="font-mono text-xs h-64"
                    placeholder="JSON 설정을 붙여넣으세요..."
                  />
                </AccordionContent>
              </AccordionItem>
            </Accordion>

            {/* Import Result */}
            {importResult && (
              <Alert variant={importResult.success ? 'default' : 'destructive'}>
                {importResult.success ? (
                  <CheckCircle2 className="w-4 h-4" />
                ) : (
                  <XCircle className="w-4 h-4" />
                )}
                <AlertTitle>{importResult.success ? '성공' : '실패'}</AlertTitle>
                <AlertDescription>
                  <p>{importResult.message}</p>
                  <div className="mt-2 text-sm">
                    <p>LLM: {importResult.llmProvidersImported}개 성공, {importResult.llmProvidersFailed}개 실패</p>
                    <p>ML: {importResult.mlAddonsImported}개 성공, {importResult.mlAddonsFailed}개 실패</p>
                  </div>
                  {importResult.warnings.length > 0 && (
                    <div className="mt-2">
                      <p className="font-medium">경고:</p>
                      <ul className="list-disc list-inside text-sm">
                        {importResult.warnings.map((w, i) => (
                          <li key={i}>{w}</li>
                        ))}
                      </ul>
                    </div>
                  )}
                  {importResult.errors.length > 0 && (
                    <div className="mt-2">
                      <p className="font-medium">오류:</p>
                      <ul className="list-disc list-inside text-sm">
                        {importResult.errors.map((e, i) => (
                          <li key={i}>{e}</li>
                        ))}
                      </ul>
                    </div>
                  )}
                </AlertDescription>
              </Alert>
            )}
          </div>

          <DialogFooter className="gap-2">
            <Button variant="outline" onClick={() => setImportDialogOpen(false)}>
              취소
            </Button>
            <Button
              variant="secondary"
              onClick={handleValidate}
              disabled={isValidating || !importData}
            >
              {isValidating ? (
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              ) : (
                <Eye className="w-4 h-4 mr-2" />
              )}
              검증
            </Button>
            <Button
              onClick={handleImport}
              disabled={isImporting || !importData}
            >
              {isImporting ? (
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              ) : (
                <Upload className="w-4 h-4 mr-2" />
              )}
              Import 실행
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

```

---

## frontend/src/pages/admin/AdminDashboard.tsx

```tsx
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  LayoutDashboard,
  Server,
  Users,
  FileText,
  Settings,
  Brain,
  Activity,
  Database,
  Shield,
  TrendingUp,
  AlertTriangle,
  CheckCircle2,
  XCircle,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { useAuth } from '@/contexts/AuthContext';
import { MCPHealthStatus } from '@/components/dashboard/MCPHealthStatus';
import { getMlAddonStatus, type MlAddonStatusSummary } from '@/lib/api/ml';
import { environmentsApi } from '@/lib/adminApi';
import type { Environment } from '@/types/admin';

export default function AdminDashboard() {
  const navigate = useNavigate();
  const { user } = useAuth();
  const [mlStatus, setMlStatus] = useState<MlAddonStatusSummary | null>(null);
  const [environments, setEnvironments] = useState<Environment[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadDashboardData();
  }, []);

  const loadDashboardData = async () => {
    setIsLoading(true);
    try {
      const [mlData, envData] = await Promise.all([
        getMlAddonStatus().catch(() => null),
        environmentsApi.list(true).catch(() => []),
      ]);
      setMlStatus(mlData);
      setEnvironments(envData);
    } catch (error) {
      console.error('Failed to load dashboard data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const quickLinks = [
    {
      title: 'ML 학습 관리',
      description: 'Kaggle 데이터셋 학습 및 모델 훈련',
      icon: Brain,
      path: '/ml-training',
      color: 'text-purple-500',
      bgColor: 'bg-purple-50',
      available: true,
    },
    {
      title: 'ML Add-ons',
      description: '배포된 ML 모델 관리 및 모니터링',
      icon: Activity,
      path: '/ml-addons',
      color: 'text-blue-500',
      bgColor: 'bg-blue-50',
      available: true,
    },
    {
      title: '환경 관리',
      description: 'Docker 컨테이너 및 서비스 제어',
      icon: Server,
      path: '/admin/environments',
      color: 'text-green-500',
      bgColor: 'bg-green-50',
      available: user?.role === 'operator' || user?.role === 'admin',
    },
    {
      title: '스크립트 실행',
      description: '운영 스크립트 및 작업 관리',
      icon: FileText,
      path: '/admin/scripts',
      color: 'text-orange-500',
      bgColor: 'bg-orange-50',
      available: user?.role === 'operator' || user?.role === 'admin',
    },
    {
      title: '사용자 관리',
      description: '관리자 계정 및 권한 관리',
      icon: Users,
      path: '/admin/users',
      color: 'text-red-500',
      bgColor: 'bg-red-50',
      available: user?.role === 'admin',
    },
    {
      title: 'LLM 프로바이더',
      description: 'AI 모델 제공자 설정',
      icon: Settings,
      path: '/admin/llm-providers',
      color: 'text-indigo-500',
      bgColor: 'bg-indigo-50',
      available: user?.role === 'admin',
    },
    {
      title: '감사 로그',
      description: '시스템 활동 및 변경 이력',
      icon: Shield,
      path: '/admin/audit-logs',
      color: 'text-gray-500',
      bgColor: 'bg-gray-50',
      available: user?.role === 'admin',
    },
    {
      title: '데이터 소스',
      description: '크롤링 소스 및 URL 관리',
      icon: Database,
      path: '/admin/sources',
      color: 'text-teal-500',
      bgColor: 'bg-teal-50',
      available: true,
    },
  ];

  const availableLinks = quickLinks.filter((link) => link.available);

  return (
    <div className="container mx-auto p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold flex items-center gap-2">
            <LayoutDashboard className="h-8 w-8" />
            관리자 대시보드
          </h1>
          <p className="text-muted-foreground mt-1">
            시스템 상태 모니터링 및 관리 기능
          </p>
        </div>
        <Badge variant="outline" className="text-sm">
          {user?.role === 'admin' ? '최고 관리자' : user?.role === 'operator' ? '운영자' : '뷰어'}
        </Badge>
      </div>

      {/* Status Overview */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        {/* ML Add-ons Status */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">ML Add-ons</CardTitle>
            <Brain className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            {isLoading ? (
              <div className="text-2xl font-bold">...</div>
            ) : mlStatus ? (
              <>
                <div className="text-2xl font-bold">
                  {mlStatus.enabledAddons} / {mlStatus.totalAddons}
                </div>
                <p className="text-xs text-muted-foreground">
                  활성화됨 · 성공률 {(mlStatus.successRate * 100).toFixed(1)}%
                </p>
                <div className="flex gap-2 mt-2">
                  <Badge variant="outline" className="text-xs">
                    <CheckCircle2 className="h-3 w-3 mr-1 text-green-500" />
                    {mlStatus.healthyAddons}
                  </Badge>
                  {mlStatus.unhealthyAddons > 0 && (
                    <Badge variant="outline" className="text-xs">
                      <XCircle className="h-3 w-3 mr-1 text-red-500" />
                      {mlStatus.unhealthyAddons}
                    </Badge>
                  )}
                </div>
              </>
            ) : (
              <div className="text-sm text-muted-foreground">데이터 없음</div>
            )}
          </CardContent>
        </Card>

        {/* Environments Status */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">활성 환경</CardTitle>
            <Server className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{environments.length}</div>
            <p className="text-xs text-muted-foreground">
              Docker 환경 실행 중
            </p>
          </CardContent>
        </Card>

        {/* Today's Executions */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">오늘 실행</CardTitle>
            <TrendingUp className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            {isLoading ? (
              <div className="text-2xl font-bold">...</div>
            ) : mlStatus ? (
              <>
                <div className="text-2xl font-bold">
                  {mlStatus.totalExecutionsToday.toLocaleString()}
                </div>
                <p className="text-xs text-muted-foreground">
                  평균 {mlStatus.avgLatencyMs.toFixed(0)}ms
                </p>
              </>
            ) : (
              <div className="text-sm text-muted-foreground">데이터 없음</div>
            )}
          </CardContent>
        </Card>

        {/* System Health */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">시스템 상태</CardTitle>
            <Activity className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <CheckCircle2 className="h-6 w-6 text-green-500" />
              <span className="text-2xl font-bold">정상</span>
            </div>
            <p className="text-xs text-muted-foreground">
              모든 서비스 운영 중
            </p>
          </CardContent>
        </Card>
      </div>

      {/* MCP Health Status */}
      <MCPHealthStatus className="w-full" />

      {/* Quick Access Links */}
      <div>
        <h2 className="text-xl font-semibold mb-4">빠른 접근</h2>
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
          {availableLinks.map((link) => (
            <Card
              key={link.path}
              className="cursor-pointer hover:shadow-lg transition-shadow"
              onClick={() => navigate(link.path)}
            >
              <CardHeader>
                <div className={`w-12 h-12 rounded-lg ${link.bgColor} flex items-center justify-center mb-2`}>
                  <link.icon className={`h-6 w-6 ${link.color}`} />
                </div>
                <CardTitle className="text-base">{link.title}</CardTitle>
                <CardDescription className="text-sm">
                  {link.description}
                </CardDescription>
              </CardHeader>
            </Card>
          ))}
        </div>
      </div>

      {/* Recent Activity / Alerts */}
      {mlStatus && mlStatus.unhealthyAddons > 0 && (
        <Card className="border-orange-200 bg-orange-50">
          <CardHeader>
            <CardTitle className="flex items-center gap-2 text-orange-700">
              <AlertTriangle className="h-5 w-5" />
              주의 필요
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-orange-700">
              {mlStatus.unhealthyAddons}개의 ML Add-on이 비정상 상태입니다. 
              <Button
                variant="link"
                className="p-0 h-auto text-orange-700 underline ml-1"
                onClick={() => navigate('/ml-addons')}
              >
                확인하기
              </Button>
            </p>
          </CardContent>
        </Card>
      )}
    </div>
  );
}

```

---

## frontend/src/pages/admin/AdminEnvironments.tsx

```tsx
import { useEffect, useState } from 'react';
import { useSearchParams } from 'react-router-dom';
import {
  Server,
  Play,
  Square,
  RotateCcw,
  Trash2,
  RefreshCw,
  CheckCircle,
  XCircle,
  AlertTriangle,
  Terminal,
  ShieldAlert,
} from 'lucide-react';
import { environmentsApi } from '@/lib/adminApi';
import { useAuth } from '@/contexts/AuthContext';
import type { Environment, EnvironmentStatus, ContainerInfo } from '@/types/admin';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Badge } from '@/components/ui/badge';

export default function AdminEnvironments() {
  const [searchParams, setSearchParams] = useSearchParams();
  const [environments, setEnvironments] = useState<Environment[]>([]);
  const [selectedEnv, setSelectedEnv] = useState<Environment | null>(null);
  const [status, setStatus] = useState<EnvironmentStatus | null>(null);
  const [logs, setLogs] = useState<string>('');
  const [selectedService, setSelectedService] = useState<string>('');
  const [isLoading, setIsLoading] = useState(true);
  const [isActionLoading, setIsActionLoading] = useState(false);
  const [actionOutput, setActionOutput] = useState<string>('');
  
  // Role-based access control
  const { user } = useAuth();
  const isOperator = user?.role === 'operator' || user?.role === 'admin';
  const isAdmin = user?.role === 'admin';

  useEffect(() => {
    loadEnvironments();
  }, []);

  useEffect(() => {
    const selectedId = searchParams.get('selected');
    if (selectedId && environments.length > 0) {
      const env = environments.find((e) => e.id === selectedId);
      if (env) {
        setSelectedEnv(env);
        loadStatus(env.id);
      }
    }
  }, [searchParams, environments]);

  const loadEnvironments = async () => {
    try {
      const envs = await environmentsApi.list();
      setEnvironments(envs);
      
      if (envs.length > 0 && !searchParams.get('selected')) {
        setSelectedEnv(envs[0]);
        loadStatus(envs[0].id);
      }
    } catch (error) {
      console.error('Failed to load environments:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const loadStatus = async (envId: string) => {
    try {
      const statusData = await environmentsApi.getStatus(envId);
      setStatus(statusData);
    } catch (error) {
      console.error('Failed to load status:', error);
      setStatus(null);
    }
  };

  const selectEnvironment = (env: Environment) => {
    setSelectedEnv(env);
    setSearchParams({ selected: env.id });
    setLogs('');
    setActionOutput('');
    loadStatus(env.id);
  };

  const handleAction = async (
    action: 'up' | 'down' | 'restart' | 'cleanup',
    service?: string
  ) => {
    if (!selectedEnv) return;

    // Confirm dangerous actions
    if (action === 'cleanup') {
      if (!confirm('⚠️ 전체 정리를 진행하면 데이터베이스 볼륨도 삭제됩니다. 계속하시겠습니까?')) {
        return;
      }
    }

    setIsActionLoading(true);
    setActionOutput('');

    try {
      // Note: The return types from adminApi might need adjustment based on backend response
      // Assuming void or simple object response for now
      switch (action) {
        case 'up':
          await environmentsApi.up(selectedEnv.id, true);
          break;
        case 'down':
          await environmentsApi.down(selectedEnv.id, false);
          break;
        case 'restart':
          await environmentsApi.restart(selectedEnv.id, service);
          break;
        case 'cleanup':
          await environmentsApi.down(selectedEnv.id, true);
          break;
      }
      setActionOutput(`Action ${action} completed successfully`);
      await loadStatus(selectedEnv.id);
    } catch (error) {
      setActionOutput(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsActionLoading(false);
    }
  };

  const loadServiceLogs = async (service: string) => {
    if (!selectedEnv) return;
    setSelectedService(service);
    
    try {
      const result = await environmentsApi.logs(selectedEnv.id, service, 200);
      setLogs(result.logs);
    } catch (error) {
      setLogs(`Error loading logs: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  const getStatusIcon = (container: ContainerInfo) => {
    if (container.status === 'up') {
      return <CheckCircle className="w-4 h-4 text-green-500" />;
    } else if (container.status === 'down') {
      return <XCircle className="w-4 h-4 text-red-500" />;
    }
    return <AlertTriangle className="w-4 h-4 text-yellow-500" />;
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
      </div>
    );
  }

  // 권한이 없는 경우 접근 불가 UI
  if (!isOperator) {
    return (
      <div className="flex flex-col items-center justify-center h-64 space-y-4">
        <ShieldAlert className="w-16 h-16 text-muted-foreground" />
        <h2 className="text-xl font-semibold">접근 권한이 없습니다</h2>
        <p className="text-muted-foreground text-center">
          환경 관리 기능은 Operator 또는 Admin 권한이 필요합니다.
          <br />
          현재 역할: {user?.role || '없음'}
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6 container mx-auto p-4">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold tracking-tight">환경 관리</h1>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
        {/* Environment List */}
        <div className="lg:col-span-1 space-y-2">
          {environments.map((env) => (
            <Button
              key={env.id}
              variant={selectedEnv?.id === env.id ? "default" : "outline"}
              className="w-full justify-start h-auto py-3 px-4"
              onClick={() => selectEnvironment(env)}
            >
              <div className="flex items-center gap-3 w-full">
                <Server className="w-5 h-5 shrink-0" />
                <div className="text-left overflow-hidden">
                  <p className="font-medium truncate">{env.name}</p>
                  <p className="text-xs opacity-70 truncate">{env.env_type}</p>
                </div>
              </div>
            </Button>
          ))}
        </div>

        {/* Environment Details */}
        <div className="lg:col-span-3 space-y-6">
          {selectedEnv ? (
            <>
              {/* Actions */}
              <Card>
                <CardHeader>
                  <CardTitle>{selectedEnv.name} 환경</CardTitle>
                  <CardDescription>{selectedEnv.description || selectedEnv.compose_file}</CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="flex flex-wrap gap-3 mb-4">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => handleAction('up')}
                      disabled={!isOperator || isActionLoading}
                      className="bg-green-600/10 hover:bg-green-600/20 text-green-600 border-green-200"
                    >
                      <Play className="w-4 h-4 mr-2" />
                      시작
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => handleAction('down')}
                      disabled={!isOperator || isActionLoading}
                      className="bg-yellow-600/10 hover:bg-yellow-600/20 text-yellow-600 border-yellow-200"
                    >
                      <Square className="w-4 h-4 mr-2" />
                      중지
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => handleAction('restart')}
                      disabled={!isOperator || isActionLoading}
                      className="bg-blue-600/10 hover:bg-blue-600/20 text-blue-600 border-blue-200"
                    >
                      <RotateCcw className="w-4 h-4 mr-2" />
                      재시작
                    </Button>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => handleAction('cleanup')}
                      disabled={!isAdmin || isActionLoading}
                    >
                      <Trash2 className="w-4 h-4 mr-2" />
                      전체 정리
                    </Button>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => loadStatus(selectedEnv.id)}
                      disabled={isActionLoading}
                    >
                      <RefreshCw className={`w-4 h-4 mr-2 ${isActionLoading ? 'animate-spin' : ''}`} />
                      새로고침
                    </Button>
                  </div>

                  {actionOutput && (
                    <div className="mt-4 p-4 bg-muted rounded-md text-sm font-mono overflow-x-auto max-h-48">
                      {actionOutput}
                    </div>
                  )}
                </CardContent>
              </Card>

              {/* Container Status */}
              <Card>
                <CardHeader className="pb-3">
                  <CardTitle className="text-lg font-medium">
                    컨테이너 상태
                    {status && (
                      <span className="ml-2 text-sm font-normal text-muted-foreground">
                        ({status.running_containers}/{status.total_containers} 실행 중)
                      </span>
                    )}
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="divide-y">
                    {status?.containers && status.containers.length > 0 ? (
                      status.containers.map((container) => (
                        <div
                          key={container.name}
                          className="flex items-center justify-between py-3"
                        >
                          <div className="flex items-center gap-3">
                            {getStatusIcon(container)}
                            <div>
                              <p className="text-sm font-medium">
                                {container.name}
                              </p>
                              <p className="text-xs text-muted-foreground">{container.image}</p>
                            </div>
                          </div>
                          <div className="flex items-center gap-2">
                            <Badge variant={container.status === 'up' ? 'default' : 'secondary'} className={
                                container.status === 'up' ? 'bg-green-500/10 text-green-600 hover:bg-green-500/20' : 
                                container.status === 'down' ? 'bg-red-500/10 text-red-600 hover:bg-red-500/20' : ''
                            }>
                              {container.status}
                            </Badge>
                            <Button
                              variant="ghost"
                              size="icon"
                              onClick={() => loadServiceLogs(container.name.replace('newsinsight-', ''))}
                              title="로그 보기"
                              className="h-8 w-8"
                            >
                              <Terminal className="w-4 h-4" />
                            </Button>
                          </div>
                        </div>
                      ))
                    ) : (
                      <div className="py-8 text-center text-muted-foreground">
                        컨테이너 정보가 없습니다
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>

              {/* Logs */}
              {logs && (
                <Card>
                  <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                    <CardTitle className="text-base font-medium">
                      로그: {selectedService}
                    </CardTitle>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => setLogs('')}
                    >
                      닫기
                    </Button>
                  </CardHeader>
                  <CardContent>
                    <ScrollArea className="h-96 w-full rounded-md border bg-muted p-4">
                      <pre className="text-xs font-mono whitespace-pre-wrap">
                        {logs}
                      </pre>
                    </ScrollArea>
                  </CardContent>
                </Card>
              )}
            </>
          ) : (
            <Card className="h-64 flex items-center justify-center text-muted-foreground">
              환경을 선택해주세요
            </Card>
          )}
        </div>
      </div>
    </div>
  );
}

```

---

## frontend/src/pages/admin/AdminLlmProviders.tsx

```tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
  Bot,
  CheckCircle2,
  XCircle,
  Loader2,
  Zap,
  Save,
  Eye,
  EyeOff,
  Trash2,
  RefreshCw,
  Shield,
  Plus,
  ShieldAlert,
  Power,
  PowerOff,
  Wand2,
} from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Input } from '@/components/ui/input';
import { Switch } from '@/components/ui/switch';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Separator } from '@/components/ui/separator';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/contexts/AuthContext';
import {
  getGlobalLlmSettings,
  saveGlobalLlmSetting,
  deleteGlobalLlmSetting,
  testGlobalLlmConnection,
  toggleGlobalLlmSetting,
  getLlmProviderTypes,
  testNewLlmConnection,
} from '@/lib/api';
import type {
  LlmProviderType,
  LlmProviderSettings,
  LlmProviderSettingsRequest,
  LlmProviderTypeInfo,
  LlmTestResult,
} from '@/types/api';
import { APIKeyWizard } from '@/components/APIKeyWizard';

const DEFAULT_MODELS: Record<LlmProviderType, string[]> = {
  // OpenAI - 2025년 12월 최신 (GPT-5 시리즈 출시)
  OPENAI: [
    'gpt-5', 'gpt-5-mini', 'gpt-5-nano',           // Frontier 모델
    'gpt-4.1', 'gpt-4.1-mini',                      // 고급 모델
    'o3', 'o3-mini', 'o3-pro', 'o4-mini',          // 추론 모델
    'gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo',        // 기존 모델
  ],
  // Anthropic Claude - 2025년 12월 최신 (Claude 4 시리즈)
  ANTHROPIC: [
    'claude-sonnet-4-20250514',                    // 추천, 성능-가격 최적
    'claude-opus-4-20250514',                      // 가장 강력
    'claude-haiku-4-20250514',                     // 경량, 빠른 응답
    'claude-3-5-sonnet-20241022',                  // 이전 버전 호환
    'claude-3-5-haiku-20241022',
  ],
  // Google Gemini - 2025년 12월 최신 (Gemini 3 시리즈)
  GOOGLE: [
    'gemini-3-pro-preview',                        // 최고 지능, 멀티모달
    'gemini-3-flash-preview',                      // Pro 수준, Flash 속도
    'gemini-2.5-pro',                              // 씽킹 모델, 복잡 추론
    'gemini-2.5-flash',                            // 최고 가격-성능비
    'gemini-2.5-flash-lite',                       // 비용 최적화
    'gemini-2.0-flash',                            // 워크홀스
  ],
  // OpenRouter - 다양한 공급자 모델 통합 (무료 모델 포함)
  OPENROUTER: [
    // 무료 모델 (Free)
    'google/gemini-2.0-flash-exp:free',
    'google/gemini-exp-1206:free',
    'meta-llama/llama-3.2-3b-instruct:free',
    'meta-llama/llama-3.1-8b-instruct:free',
    'microsoft/phi-3-mini-128k-instruct:free',
    'mistralai/mistral-7b-instruct:free',
    'openchat/openchat-7b:free',
    'huggingfaceh4/zephyr-7b-beta:free',
    'qwen/qwen-2-7b-instruct:free',
    'nousresearch/hermes-3-llama-3.1-405b:free',
    // 유료 모델
    'openai/gpt-5', 'openai/gpt-4o',
    'anthropic/claude-sonnet-4', 'anthropic/claude-3.5-haiku',
    'google/gemini-2.5-pro', 'google/gemini-3-pro',
    'meta-llama/llama-3.1-405b-instruct',
    'mistralai/mistral-large-2411',
    'qwen/qwen-max',
    'deepseek/deepseek-r1',
  ],
  // Ollama - 로컬 실행 모델
  OLLAMA: [
    'llama3.2',                                    // Meta Llama 3.2
    'mistral',                                     // Mistral AI
    'neural-chat',                                 // Intel
    'deepseek-r1',                                 // DeepSeek R1
    'smollm2',                                     // 경량 모델
    'mixtral', 'codellama',
  ],
  // Azure OpenAI - 배포된 모델만 사용 가능
  AZURE_OPENAI: [
    'gpt-5', 'gpt-4o', 'gpt-4-turbo', 'gpt-35-turbo',
  ],
  // Together AI - DeepSeek 및 오픈소스 모델
  TOGETHER_AI: [
    'deepseek-ai/DeepSeek-R1-Distill-Llama-70B',  // 추론 능력 70B
    'deepseek-ai/DeepSeek-V3',                    // DeepSeek V3
    'meta-llama/Llama-3.1-405B-Instruct-Turbo',
    'mistralai/Mixtral-8x22B-Instruct-v0.1',
  ],
  CUSTOM: ['default'],
};

/**
 * 관리자 전용 글로벌 LLM Provider 설정 페이지
 */
export default function AdminLlmProviders() {
  const { toast } = useToast();
  const { user } = useAuth();

  // State
  const [providerTypes, setProviderTypes] = useState<LlmProviderTypeInfo[]>([]);
  const [settings, setSettings] = useState<LlmProviderSettings[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [showApiKeys, setShowApiKeys] = useState<Record<string, boolean>>({});
  const [testResults, setTestResults] = useState<Record<string, LlmTestResult>>({});
  const [testingProvider, setTestingProvider] = useState<string | null>(null);

  // Edit dialog state
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [editingProvider, setEditingProvider] = useState<LlmProviderType | null>(null);
  const [isNewProvider, setIsNewProvider] = useState(false);
  const [editForm, setEditForm] = useState<LlmProviderSettingsRequest>({
    providerType: 'OPENAI',
    apiKey: '',
    defaultModel: '',
    baseUrl: '',
    enabled: true,
  });

  // API Key Wizard state
  const [apiKeyWizardOpen, setApiKeyWizardOpen] = useState(false);

  // Role check
  const isAdmin = user?.role === 'admin';

  // Load data
  const loadData = useCallback(async () => {
    setIsLoading(true);
    try {
      const [types, globalSettings] = await Promise.all([
        getLlmProviderTypes(),
        getGlobalLlmSettings(),
      ]);
      setProviderTypes(types);
      setSettings(globalSettings);
    } catch (error) {
      console.error('Failed to load LLM settings:', error);
      toast({
        title: '데이터 로드 실패',
        description: 'LLM 설정을 불러오는데 실패했습니다.',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  useEffect(() => {
    loadData();
  }, [loadData]);

  // Open edit dialog
  const openEditDialog = (providerType: LlmProviderType | null) => {
    if (providerType) {
      const existing = settings.find(s => s.providerType === providerType);
      if (existing) {
        setEditForm({
          providerType: existing.providerType,
          apiKey: existing.apiKeyMasked || '',
          defaultModel: existing.defaultModel || '',
          baseUrl: existing.baseUrl || '',
          enabled: existing.enabled,
        });
        setIsNewProvider(false);
      }
      setEditingProvider(providerType);
    } else {
      // New provider
      setEditForm({
        providerType: 'OPENAI',
        apiKey: '',
        defaultModel: '',
        baseUrl: '',
        enabled: true,
      });
      setIsNewProvider(true);
      setEditingProvider(null);
    }
    setEditDialogOpen(true);
  };

  // Save provider settings
  const handleSave = async () => {
    if (!editForm.apiKey?.trim()) {
      toast({
        title: 'API 키 필요',
        description: 'API 키를 입력해주세요.',
        variant: 'destructive',
      });
      return;
    }

    setIsSaving(true);
    try {
      await saveGlobalLlmSetting(editForm);
      toast({
        title: '저장 완료',
        description: `${editForm.providerType} 설정이 저장되었습니다.`,
      });
      setEditDialogOpen(false);
      loadData();
    } catch (error) {
      console.error('Failed to save LLM setting:', error);
      toast({
        title: '저장 실패',
        description: '설정을 저장하는데 실패했습니다.',
        variant: 'destructive',
      });
    } finally {
      setIsSaving(false);
    }
  };

  // Delete provider
  const handleDelete = async (providerType: LlmProviderType) => {
    if (!confirm(`${providerType} 설정을 삭제하시겠습니까?`)) return;

    try {
      await deleteGlobalLlmSetting(providerType);
      toast({
        title: '삭제 완료',
        description: `${providerType} 설정이 삭제되었습니다.`,
      });
      loadData();
    } catch (error) {
      console.error('Failed to delete LLM setting:', error);
      toast({
        title: '삭제 실패',
        description: '설정을 삭제하는데 실패했습니다.',
        variant: 'destructive',
      });
    }
  };

  // Toggle enabled
  const handleToggle = async (setting: LlmProviderSettings) => {
    try {
      await toggleGlobalLlmSetting(setting.providerType, !setting.enabled);
      toast({
        title: setting.enabled ? '비활성화됨' : '활성화됨',
        description: `${setting.providerType}이(가) ${setting.enabled ? '비활성화' : '활성화'}되었습니다.`,
      });
      loadData();
    } catch (error) {
      console.error('Failed to toggle LLM setting:', error);
      toast({
        title: '변경 실패',
        description: '설정을 변경하는데 실패했습니다.',
        variant: 'destructive',
      });
    }
  };

  // Test connection
  const handleTestConnection = async (setting: LlmProviderSettings) => {
    setTestingProvider(setting.providerType);
    setTestResults(prev => ({ ...prev, [setting.providerType]: undefined as any }));

    try {
      const result = await testGlobalLlmConnection(setting.providerType);
      setTestResults(prev => ({ ...prev, [setting.providerType]: result }));
    } catch (error) {
      console.error('Failed to test connection:', error);
      setTestResults(prev => ({
        ...prev,
        [setting.providerType]: {
          success: false,
          providerType: setting.providerType,
          message: '연결 테스트 실패',
          error: error instanceof Error ? error.message : '알 수 없는 오류',
        },
      }));
    } finally {
      setTestingProvider(null);
    }
  };

  // Test new connection before save
  const handleTestNewConnection = async () => {
    if (!editForm.apiKey?.trim()) {
      toast({
        title: 'API 키 필요',
        description: 'API 키를 입력해주세요.',
        variant: 'destructive',
      });
      return;
    }

    setTestingProvider('new');
    try {
      const result = await testNewLlmConnection(editForm);
      if (result.success) {
        toast({
          title: '연결 성공',
          description: result.message || '연결 테스트에 성공했습니다.',
        });
      } else {
        toast({
          title: '연결 실패',
          description: result.error || result.message || '연결 테스트에 실패했습니다.',
          variant: 'destructive',
        });
      }
    } catch (error) {
      console.error('Failed to test new connection:', error);
      toast({
        title: '테스트 실패',
        description: '연결 테스트 중 오류가 발생했습니다.',
        variant: 'destructive',
      });
    } finally {
      setTestingProvider(null);
    }
  };

  // Toggle API key visibility
  const toggleApiKeyVisibility = (providerType: string) => {
    setShowApiKeys(prev => ({ ...prev, [providerType]: !prev[providerType] }));
  };

  // Mask API key
  const maskApiKey = (key: string | undefined): string => {
    if (!key) return '(설정되지 않음)';
    if (key.length <= 8) return '••••••••';
    return key.slice(0, 4) + '••••••••' + key.slice(-4);
  };

  // Handle API Key Wizard success - reload settings after auto-provisioning
  const handleApiKeyWizardSuccess = useCallback((provider: string, keyMasked: string) => {
    toast({
      title: 'API 키 자동 발급 완료',
      description: `${provider} API 키가 성공적으로 발급되고 저장되었습니다: ${keyMasked}`,
    });
    // Reload settings to reflect the new API key
    loadData();
  }, [toast, loadData]);

  // Access denied for non-admins
  if (!isAdmin) {
    return (
      <div className="flex flex-col items-center justify-center h-64 space-y-4">
        <ShieldAlert className="w-16 h-16 text-muted-foreground" />
        <h2 className="text-xl font-semibold">접근 권한이 없습니다</h2>
        <p className="text-muted-foreground text-center">
          글로벌 LLM 설정은 관리자만 접근할 수 있습니다.
        </p>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="w-8 h-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  const configuredProviders = settings.map(s => s.providerType);
  const availableNewProviders = providerTypes.filter(
    t => !configuredProviders.includes(t.value)
  );

  return (
    <div className="space-y-6 container mx-auto p-4">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">LLM Provider 설정</h1>
          <p className="text-muted-foreground mt-1">
            시스템 전체에서 사용되는 LLM 공급자 설정을 관리합니다.
          </p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={() => setApiKeyWizardOpen(true)}>
            <Wand2 className="w-4 h-4 mr-2" />
            API 키 자동 발급
          </Button>
          <Button variant="outline" onClick={loadData}>
            <RefreshCw className="w-4 h-4 mr-2" />
            새로고침
          </Button>
          {availableNewProviders.length > 0 && (
            <Button onClick={() => openEditDialog(null)}>
              <Plus className="w-4 h-4 mr-2" />
              Provider 추가
            </Button>
          )}
        </div>
      </div>

      <Alert>
        <Shield className="w-4 h-4" />
        <AlertDescription>
          여기서 설정한 LLM Provider는 시스템 전체 기본값으로 사용됩니다.
          개별 사용자는 자신의 설정으로 이를 덮어쓸 수 있습니다.
        </AlertDescription>
      </Alert>

      {/* Provider List */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Bot className="w-5 h-5" />
            설정된 Provider
          </CardTitle>
          <CardDescription>
            {settings.length}개의 LLM Provider가 설정되어 있습니다.
          </CardDescription>
        </CardHeader>
        <CardContent>
          {settings.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              <Bot className="w-12 h-12 mx-auto mb-4 opacity-20" />
              <p>설정된 LLM Provider가 없습니다.</p>
              <p className="text-sm mt-1">위의 "Provider 추가" 버튼을 클릭하여 추가하세요.</p>
            </div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Provider</TableHead>
                  <TableHead>모델</TableHead>
                  <TableHead>API 키</TableHead>
                  <TableHead>상태</TableHead>
                  <TableHead className="text-right">작업</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {settings.map((setting) => {
                  const typeInfo = providerTypes.find(t => t.value === setting.providerType);
                  const testResult = testResults[setting.providerType];
                  
                  return (
                    <TableRow key={setting.id}>
                      <TableCell>
                        <div className="flex items-center gap-2">
                          <span className="font-medium">{typeInfo?.displayName || setting.providerType}</span>
                          {setting.enabled ? (
                            <Badge variant="default" className="bg-green-500">활성</Badge>
                          ) : (
                            <Badge variant="secondary">비활성</Badge>
                          )}
                        </div>
                        {typeInfo?.description && (
                          <p className="text-xs text-muted-foreground mt-1">{typeInfo.description}</p>
                        )}
                      </TableCell>
                      <TableCell>
                        <code className="text-sm bg-muted px-1 py-0.5 rounded">
                          {setting.defaultModel || '(기본값)'}
                        </code>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2">
                          <code className="text-sm">
                            {showApiKeys[setting.providerType]
                              ? setting.apiKeyMasked
                              : maskApiKey(setting.apiKeyMasked)}
                          </code>
                          <Button
                            variant="ghost"
                            size="icon"
                            className="h-6 w-6"
                            onClick={() => toggleApiKeyVisibility(setting.providerType)}
                          >
                            {showApiKeys[setting.providerType] ? (
                              <EyeOff className="h-3 w-3" />
                            ) : (
                              <Eye className="h-3 w-3" />
                            )}
                          </Button>
                        </div>
                      </TableCell>
                      <TableCell>
                        {testResult ? (
                          testResult.success ? (
                            <div className="flex items-center gap-1 text-green-600">
                              <CheckCircle2 className="w-4 h-4" />
                              <span className="text-sm">연결됨</span>
                            </div>
                          ) : (
                            <div className="flex items-center gap-1 text-red-600">
                              <XCircle className="w-4 h-4" />
                              <span className="text-sm" title={testResult.error}>실패</span>
                            </div>
                          )
                        ) : (
                          <span className="text-muted-foreground text-sm">-</span>
                        )}
                      </TableCell>
                      <TableCell className="text-right">
                        <div className="flex justify-end gap-2">
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleTestConnection(setting)}
                            disabled={testingProvider === setting.providerType}
                          >
                            {testingProvider === setting.providerType ? (
                              <Loader2 className="w-4 h-4 animate-spin" />
                            ) : (
                              <Zap className="w-4 h-4" />
                            )}
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleToggle(setting)}
                          >
                            {setting.enabled ? (
                              <PowerOff className="w-4 h-4" />
                            ) : (
                              <Power className="w-4 h-4" />
                            )}
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => openEditDialog(setting.providerType)}
                          >
                            <Save className="w-4 h-4" />
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            className="text-red-600 hover:text-red-700"
                            onClick={() => handleDelete(setting.providerType)}
                          >
                            <Trash2 className="w-4 h-4" />
                          </Button>
                        </div>
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>

      {/* Edit Dialog */}
      <Dialog open={editDialogOpen} onOpenChange={setEditDialogOpen}>
        <DialogContent className="sm:max-w-[500px]">
          <DialogHeader>
            <DialogTitle>
              {isNewProvider ? 'LLM Provider 추가' : `${editingProvider} 설정 편집`}
            </DialogTitle>
            <DialogDescription>
              API 키와 기본 모델을 설정하세요. 테스트 버튼으로 연결을 확인할 수 있습니다.
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4 py-4">
            {/* Provider Type (only for new) */}
            {isNewProvider && (
              <div className="space-y-2">
                <Label>Provider 타입</Label>
                <Select
                  value={editForm.providerType}
                  onValueChange={(value: LlmProviderType) =>
                    setEditForm(prev => ({
                      ...prev,
                      providerType: value,
                      defaultModel: DEFAULT_MODELS[value]?.[0] || '',
                    }))
                  }
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {availableNewProviders.map((type) => (
                      <SelectItem key={type.value} value={type.value}>
                        {type.displayName}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            )}

            {/* API Key */}
            <div className="space-y-2">
              <Label>API 키</Label>
              <Input
                type="password"
                value={editForm.apiKey}
                onChange={(e) => setEditForm(prev => ({ ...prev, apiKey: e.target.value }))}
                placeholder="sk-..."
              />
            </div>

            {/* Default Model */}
            <div className="space-y-2">
              <Label>기본 모델</Label>
              <Select
                value={editForm.defaultModel}
                onValueChange={(value) => setEditForm(prev => ({ ...prev, defaultModel: value }))}
              >
                <SelectTrigger>
                  <SelectValue placeholder="모델 선택" />
                </SelectTrigger>
                <SelectContent>
                  {DEFAULT_MODELS[editForm.providerType]?.map((model) => (
                    <SelectItem key={model} value={model}>
                      {model}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            {/* Base URL (for OLLAMA, CUSTOM, AZURE) */}
            {['OLLAMA', 'CUSTOM', 'AZURE_OPENAI'].includes(editForm.providerType) && (
              <div className="space-y-2">
                <Label>Base URL</Label>
                <Input
                  value={editForm.baseUrl || ''}
                  onChange={(e) => setEditForm(prev => ({ ...prev, baseUrl: e.target.value }))}
                  placeholder="http://localhost:11434"
                />
              </div>
            )}

            {/* Enabled */}
            <div className="flex items-center justify-between">
              <Label>활성화</Label>
              <Switch
                checked={editForm.enabled}
                onCheckedChange={(checked) => setEditForm(prev => ({ ...prev, enabled: checked }))}
              />
            </div>
          </div>

          <Separator />

          <DialogFooter className="gap-2">
            <Button
              variant="outline"
              onClick={handleTestNewConnection}
              disabled={testingProvider === 'new'}
            >
              {testingProvider === 'new' ? (
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              ) : (
                <Zap className="w-4 h-4 mr-2" />
              )}
              연결 테스트
            </Button>
            <Button onClick={handleSave} disabled={isSaving}>
              {isSaving ? (
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              ) : (
                <Save className="w-4 h-4 mr-2" />
              )}
              저장
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* API Key Auto-Provisioning Wizard */}
      <APIKeyWizard
        open={apiKeyWizardOpen}
        onOpenChange={setApiKeyWizardOpen}
        onSuccess={handleApiKeyWizardSuccess}
      />
    </div>
  );
}

```

---

## frontend/src/pages/admin/AdminLogin.tsx

```tsx
import { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Loader2, Shield, AlertCircle } from 'lucide-react';

export default function AdminLogin() {
  const navigate = useNavigate();
  const location = useLocation();
  const { login, isAuthenticated, isLoading: authLoading, passwordChangeRequired } = useAuth();
  
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Redirect to intended page or admin home if already authenticated
  const from = (location.state as { from?: { pathname: string } })?.from?.pathname || '/admin/environments';

  useEffect(() => {
    if (isAuthenticated && !authLoading) {
      // If password change is required, redirect to setup page
      if (passwordChangeRequired) {
        navigate('/admin/setup', { replace: true });
      } else {
        navigate(from, { replace: true });
      }
    }
  }, [isAuthenticated, authLoading, passwordChangeRequired, navigate, from]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setIsSubmitting(true);

    try {
      await login(username, password);
      // Navigation will be handled by the useEffect above
    } catch (err) {
      console.error('Login failed:', err);
      if (err instanceof Error) {
        // Check for specific error messages
        if (err.message.includes('401') || err.message.includes('Invalid')) {
          setError('잘못된 사용자 이름 또는 비밀번호입니다.');
        } else if (err.message.includes('Network') || err.message.includes('ECONNREFUSED')) {
          setError('서버에 연결할 수 없습니다. 나중에 다시 시도해주세요.');
        } else {
          setError(err.message);
        }
      } else {
        setError('로그인 중 오류가 발생했습니다.');
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  if (authLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-background to-muted p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1 text-center">
          <div className="mx-auto mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-primary/10">
            <Shield className="h-6 w-6 text-primary" />
          </div>
          <CardTitle className="text-2xl font-bold">관리자 로그인</CardTitle>
          <CardDescription>
            NewsInsight 관리자 대시보드에 로그인하세요
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            {error && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
            
            <div className="space-y-2">
              <Label htmlFor="username">사용자 이름</Label>
              <Input
                id="username"
                type="text"
                placeholder="admin"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                disabled={isSubmitting}
                autoComplete="username"
                autoFocus
                required
              />
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="password">비밀번호</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                disabled={isSubmitting}
                autoComplete="current-password"
                required
              />
            </div>
            
            <Button 
              type="submit" 
              className="w-full" 
              disabled={isSubmitting || !username || !password}
            >
              {isSubmitting ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  로그인 중...
                </>
              ) : (
                '로그인'
              )}
            </Button>
          </form>
          
          <div className="mt-6 text-center text-sm text-muted-foreground">
            <p>
              기본 계정: <code className="text-xs bg-muted px-1 py-0.5 rounded">admin</code> / <code className="text-xs bg-muted px-1 py-0.5 rounded">admin123</code>
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

```

---

## frontend/src/pages/admin/AdminScripts.tsx

```tsx
import { useEffect, useState } from 'react';
import {
  Play,
  Terminal,
  Clock,
  AlertTriangle,
  FileText,
  RotateCcw,
  XCircle,
  CheckCircle,
  MoreVertical,
  Plus,
  Pencil,
  Trash2,
} from 'lucide-react';
import { scriptsApi, environmentsApi } from '@/lib/adminApi';
import type { Script, TaskExecution, Environment } from '@/types/admin';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Textarea } from '@/components/ui/textarea';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { formatDistanceToNow } from 'date-fns';
import { ko } from 'date-fns/locale';
import { useToast } from '@/hooks/use-toast';

export default function AdminScripts() {
  const { toast } = useToast();
  const [scripts, setScripts] = useState<Script[]>([]);
  const [executions, setExecutions] = useState<TaskExecution[]>([]);
  const [environments, setEnvironments] = useState<Environment[]>([]);
  const [selectedScript, setSelectedScript] = useState<Script | null>(null);
  const [showExecuteDialog, setShowExecuteDialog] = useState(false);
  const [executionParams, setExecutionParams] = useState<Record<string, any>>({});
  const [selectedEnvId, setSelectedEnvId] = useState<string>('');
  const [isLoading, setIsLoading] = useState(true);
  
  // Create/Edit script dialog states
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [editingScript, setEditingScript] = useState<Script | null>(null);
  const [scriptForm, setScriptForm] = useState({
    name: '',
    description: '',
    command: '',
    working_directory: '',
    risk_level: 'low' as 'low' | 'medium' | 'high' | 'critical',
    allowed_environments: ['*'],
    estimated_duration: 60,
    tags: [] as string[],
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // Delete dialog states
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [deletingScript, setDeletingScript] = useState<Script | null>(null);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      const [scriptsData, executionsData, envsData] = await Promise.all([
        scriptsApi.list(),
        scriptsApi.listExecutions(undefined, undefined, 20),
        environmentsApi.list(true), // Only active environments
      ]);
      setScripts(scriptsData);
      setExecutions(executionsData);
      setEnvironments(envsData);
    } catch (error) {
      console.error('Failed to load data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleExecute = async () => {
    if (!selectedScript || !selectedEnvId) return;

    try {
      await scriptsApi.execute(selectedScript.id, selectedEnvId, executionParams);
      setShowExecuteDialog(false);
      // Refresh executions list
      const newExecutions = await scriptsApi.listExecutions(undefined, undefined, 20);
      setExecutions(newExecutions);
      
      // Reset params
      setExecutionParams({});
      setSelectedEnvId('');
      
      toast({
        title: "스크립트 실행 시작",
        description: `'${selectedScript.name}' 스크립트가 실행되었습니다.`,
      });
    } catch (error) {
      console.error('Failed to execute script:', error);
      toast({
        title: "실행 실패",
        description: error instanceof Error ? error.message : '스크립트 실행에 실패했습니다.',
        variant: "destructive",
      });
    }
  };

  // Reset form for creating new script
  const openCreateDialog = () => {
    setEditingScript(null);
    setScriptForm({
      name: '',
      description: '',
      command: '',
      working_directory: '',
      risk_level: 'low',
      allowed_environments: ['*'],
      estimated_duration: 60,
      tags: [],
    });
    setShowCreateDialog(true);
  };

  // Open edit dialog with script data
  const openEditDialog = (script: Script) => {
    setEditingScript(script);
    setScriptForm({
      name: script.name,
      description: script.description || '',
      command: script.command,
      working_directory: (script as any).working_directory || '',
      risk_level: script.risk_level as 'low' | 'medium' | 'high' | 'critical',
      allowed_environments: script.allowed_environments || ['*'],
      estimated_duration: script.estimated_duration || 60,
      tags: script.tags || [],
    });
    setShowCreateDialog(true);
  };

  // Handle create or update script
  const handleSaveScript = async () => {
    if (!scriptForm.name || !scriptForm.command) {
      toast({
        title: "입력 오류",
        description: "이름과 명령어는 필수 입력 항목입니다.",
        variant: "destructive",
      });
      return;
    }

    setIsSubmitting(true);
    try {
      if (editingScript) {
        // Update existing script
        await scriptsApi.update(editingScript.id, scriptForm);
        toast({
          title: "스크립트 수정 완료",
          description: `'${scriptForm.name}' 스크립트가 수정되었습니다.`,
        });
      } else {
        // Create new script
        await scriptsApi.create(scriptForm);
        toast({
          title: "스크립트 등록 완료",
          description: `'${scriptForm.name}' 스크립트가 등록되었습니다.`,
        });
      }
      
      setShowCreateDialog(false);
      loadData();
    } catch (error) {
      console.error('Failed to save script:', error);
      toast({
        title: editingScript ? "수정 실패" : "등록 실패",
        description: error instanceof Error ? error.message : '스크립트 저장에 실패했습니다.',
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle delete script
  const handleDeleteScript = async () => {
    if (!deletingScript) return;

    try {
      await scriptsApi.delete(deletingScript.id);
      toast({
        title: "스크립트 삭제 완료",
        description: `'${deletingScript.name}' 스크립트가 삭제되었습니다.`,
      });
      setShowDeleteDialog(false);
      setDeletingScript(null);
      loadData();
    } catch (error) {
      console.error('Failed to delete script:', error);
      toast({
        title: "삭제 실패",
        description: error instanceof Error ? error.message : '스크립트 삭제에 실패했습니다.',
        variant: "destructive",
      });
    }
  };

  const getRiskBadge = (level: string) => {
    switch (level) {
      case 'low':
        return <Badge variant="secondary" className="bg-green-100 text-green-800">Low Risk</Badge>;
      case 'medium':
        return <Badge variant="secondary" className="bg-yellow-100 text-yellow-800">Medium Risk</Badge>;
      case 'high':
        return <Badge variant="destructive">High Risk</Badge>;
      case 'critical':
        return <Badge variant="destructive" className="bg-red-900">CRITICAL</Badge>;
      default:
        return <Badge variant="outline">{level}</Badge>;
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'success':
        return <CheckCircle className="w-4 h-4 text-green-500" />;
      case 'failed':
        return <XCircle className="w-4 h-4 text-red-500" />;
      case 'running':
        return <RotateCcw className="w-4 h-4 text-blue-500 animate-spin" />;
      case 'pending':
        return <Clock className="w-4 h-4 text-gray-500" />;
      default:
        return <AlertTriangle className="w-4 h-4 text-yellow-500" />;
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
      </div>
    );
  }

  return (
    <div className="space-y-6 container mx-auto p-4">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold tracking-tight">스크립트 & 작업</h1>
        <div className="flex items-center gap-2">
          <Button onClick={openCreateDialog}>
            <Plus className="w-4 h-4 mr-2" />
            스크립트 등록
          </Button>
          <Button variant="outline" onClick={loadData}>
            <RotateCcw className="w-4 h-4 mr-2" />
            새로고침
          </Button>
        </div>
      </div>

      <Tabs defaultValue="scripts" className="w-full">
        <TabsList>
          <TabsTrigger value="scripts">스크립트 목록</TabsTrigger>
          <TabsTrigger value="executions">실행 이력</TabsTrigger>
        </TabsList>

        <TabsContent value="scripts" className="mt-4">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {scripts.map((script) => (
              <Card key={script.id} className="flex flex-col">
                <CardHeader>
                  <div className="flex justify-between items-start">
                    <CardTitle className="text-lg">{script.name}</CardTitle>
                    {getRiskBadge(script.risk_level)}
                  </div>
                  <CardDescription className="line-clamp-2 min-h-[40px]">
                    {script.description || 'No description'}
                  </CardDescription>
                </CardHeader>
                <CardContent className="flex-grow">
                  <div className="space-y-2 text-sm">
                    <div className="flex items-center gap-2 text-muted-foreground">
                      <Terminal className="w-4 h-4" />
                      <code className="bg-muted px-1 py-0.5 rounded text-xs font-mono truncate max-w-[200px]">
                        {script.command}
                      </code>
                    </div>
                    {script.estimated_duration && (
                      <div className="flex items-center gap-2 text-muted-foreground">
                        <Clock className="w-4 h-4" />
                        <span>약 {Math.ceil(script.estimated_duration / 60)}분 소요</span>
                      </div>
                    )}
                  </div>
                </CardContent>
                <CardFooter className="flex gap-2">
                  <Dialog open={showExecuteDialog && selectedScript?.id === script.id} onOpenChange={(open) => {
                    if (!open) {
                      setShowExecuteDialog(false);
                      setSelectedScript(null);
                    }
                  }}>
                    <DialogTrigger asChild>
                      <Button 
                        className="flex-1" 
                        onClick={() => {
                          setSelectedScript(script);
                          setShowExecuteDialog(true);
                          // Select first allowed environment by default
                          if (environments.length > 0) {
                            setSelectedEnvId(environments[0].id);
                          }
                        }}
                      >
                        <Play className="w-4 h-4 mr-2" />
                        실행
                      </Button>
                    </DialogTrigger>
                    <DialogContent>
                      <DialogHeader>
                        <DialogTitle>{script.name} 실행</DialogTitle>
                        <DialogDescription>
                          스크립트를 실행할 환경과 파라미터를 설정하세요.
                        </DialogDescription>
                      </DialogHeader>

                      <div className="space-y-4 py-4">
                        <div className="space-y-2">
                          <Label>환경 선택</Label>
                          <Select value={selectedEnvId} onValueChange={setSelectedEnvId}>
                            <SelectTrigger>
                              <SelectValue placeholder="환경 선택" />
                            </SelectTrigger>
                            <SelectContent>
                              {environments
                                .filter(env => script.allowed_environments.includes('*') || script.allowed_environments.includes(env.id))
                                .map(env => (
                                  <SelectItem key={env.id} value={env.id}>
                                    {env.name} ({env.env_type})
                                  </SelectItem>
                                ))
                              }
                            </SelectContent>
                          </Select>
                        </div>

                        {script.parameters && script.parameters.length > 0 && (
                          <div className="space-y-3 border-t pt-3">
                            <Label>파라미터 설정</Label>
                            {script.parameters.map(param => (
                              <div key={param.name} className="space-y-1">
                                <Label className="text-xs">{param.name} {param.required && <span className="text-red-500">*</span>}</Label>
                                <Input 
                                  placeholder={param.description}
                                  defaultValue={param.default as string}
                                  onChange={(e) => setExecutionParams(prev => ({
                                    ...prev,
                                    [param.name]: e.target.value
                                  }))}
                                />
                              </div>
                            ))}
                          </div>
                        )}

                        <div className="bg-muted p-3 rounded-md text-xs font-mono">
                          <p className="font-semibold mb-1">Command Preview:</p>
                          {script.command}
                        </div>
                      </div>

                      <DialogFooter>
                        <Button variant="outline" onClick={() => setShowExecuteDialog(false)}>취소</Button>
                        <Button onClick={handleExecute} disabled={!selectedEnvId}>실행하기</Button>
                      </DialogFooter>
                    </DialogContent>
                  </Dialog>
                  
                  {/* Edit/Delete Dropdown */}
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="outline" size="icon">
                        <MoreVertical className="w-4 h-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem onClick={() => openEditDialog(script)}>
                        <Pencil className="w-4 h-4 mr-2" />
                        편집
                      </DropdownMenuItem>
                      <DropdownMenuItem 
                        onClick={() => {
                          setDeletingScript(script);
                          setShowDeleteDialog(true);
                        }}
                        className="text-destructive focus:text-destructive"
                      >
                        <Trash2 className="w-4 h-4 mr-2" />
                        삭제
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </CardFooter>
              </Card>
            ))}
          </div>
        </TabsContent>

        <TabsContent value="executions" className="mt-4">
          <Card>
            <CardHeader>
              <CardTitle>최근 실행 이력</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {executions.length === 0 ? (
                  <p className="text-center text-muted-foreground py-8">실행 이력이 없습니다.</p>
                ) : (
                  executions.map((exec) => (
                    <div key={exec.id} className="flex items-center justify-between p-4 border rounded-lg hover:bg-muted/50 transition-colors">
                      <div className="flex items-center gap-4">
                        <div className="p-2 bg-muted rounded-full">
                          {getStatusIcon(exec.status)}
                        </div>
                        <div>
                          <p className="font-medium">{exec.script_name}</p>
                          <div className="flex items-center gap-2 text-sm text-muted-foreground">
                            <span>{exec.environment_name}</span>
                            <span>•</span>
                            <span>{formatDistanceToNow(new Date(exec.started_at), { addSuffix: true, locale: ko })}</span>
                            <span>•</span>
                            <span>{exec.executed_by}</span>
                          </div>
                        </div>
                      </div>
                      <div className="flex items-center gap-4">
                        <Badge variant="outline">{exec.status}</Badge>
                        {exec.status === 'running' || exec.status === 'pending' ? (
                          <Button variant="ghost" size="sm" onClick={() => scriptsApi.cancelExecution(exec.id)}>
                            취소
                          </Button>
                        ) : null}
                      </div>
                    </div>
                  ))
                )}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      {/* Create/Edit Script Dialog */}
      <Dialog open={showCreateDialog} onOpenChange={setShowCreateDialog}>
        <DialogContent className="sm:max-w-[600px]">
          <DialogHeader>
            <DialogTitle>{editingScript ? '스크립트 수정' : '새 스크립트 등록'}</DialogTitle>
            <DialogDescription>
              {editingScript ? '스크립트 정보를 수정합니다.' : '새로운 스크립트를 등록합니다.'}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4 py-4 max-h-[60vh] overflow-y-auto">
            <div className="space-y-2">
              <Label htmlFor="script-name">이름 *</Label>
              <Input
                id="script-name"
                value={scriptForm.name}
                onChange={(e) => setScriptForm(prev => ({ ...prev, name: e.target.value }))}
                placeholder="예: 데이터베이스 백업"
                disabled={isSubmitting}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="script-description">설명</Label>
              <Textarea
                id="script-description"
                value={scriptForm.description}
                onChange={(e) => setScriptForm(prev => ({ ...prev, description: e.target.value }))}
                placeholder="스크립트에 대한 설명을 입력하세요"
                rows={2}
                disabled={isSubmitting}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="script-command">명령어 *</Label>
              <Textarea
                id="script-command"
                value={scriptForm.command}
                onChange={(e) => setScriptForm(prev => ({ ...prev, command: e.target.value }))}
                placeholder="예: ./scripts/backup-db.sh"
                rows={3}
                className="font-mono text-sm"
                disabled={isSubmitting}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="script-working-dir">작업 디렉토리</Label>
              <Input
                id="script-working-dir"
                value={scriptForm.working_directory}
                onChange={(e) => setScriptForm(prev => ({ ...prev, working_directory: e.target.value }))}
                placeholder="예: /home/user/project (비워두면 프로젝트 루트)"
                disabled={isSubmitting}
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label>위험도</Label>
                <Select
                  value={scriptForm.risk_level}
                  onValueChange={(value: 'low' | 'medium' | 'high' | 'critical') => 
                    setScriptForm(prev => ({ ...prev, risk_level: value }))
                  }
                  disabled={isSubmitting}
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="low">Low - 안전</SelectItem>
                    <SelectItem value="medium">Medium - 주의</SelectItem>
                    <SelectItem value="high">High - 위험</SelectItem>
                    <SelectItem value="critical">Critical - 매우 위험</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-2">
                <Label htmlFor="script-duration">예상 소요 시간 (초)</Label>
                <Input
                  id="script-duration"
                  type="number"
                  min={1}
                  value={scriptForm.estimated_duration}
                  onChange={(e) => setScriptForm(prev => ({ ...prev, estimated_duration: parseInt(e.target.value) || 60 }))}
                  disabled={isSubmitting}
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label>허용 환경</Label>
              <div className="flex flex-wrap gap-2">
                <Badge 
                  variant={scriptForm.allowed_environments.includes('*') ? 'default' : 'outline'}
                  className="cursor-pointer"
                  onClick={() => {
                    if (scriptForm.allowed_environments.includes('*')) {
                      setScriptForm(prev => ({ ...prev, allowed_environments: [] }));
                    } else {
                      setScriptForm(prev => ({ ...prev, allowed_environments: ['*'] }));
                    }
                  }}
                >
                  모든 환경
                </Badge>
                {environments.map(env => (
                  <Badge
                    key={env.id}
                    variant={scriptForm.allowed_environments.includes(env.id) ? 'default' : 'outline'}
                    className="cursor-pointer"
                    onClick={() => {
                      if (scriptForm.allowed_environments.includes('*')) {
                        setScriptForm(prev => ({ ...prev, allowed_environments: [env.id] }));
                      } else if (scriptForm.allowed_environments.includes(env.id)) {
                        setScriptForm(prev => ({ 
                          ...prev, 
                          allowed_environments: prev.allowed_environments.filter(e => e !== env.id)
                        }));
                      } else {
                        setScriptForm(prev => ({ 
                          ...prev, 
                          allowed_environments: [...prev.allowed_environments, env.id]
                        }));
                      }
                    }}
                  >
                    {env.name}
                  </Badge>
                ))}
              </div>
            </div>
          </div>

          <DialogFooter>
            <Button variant="outline" onClick={() => setShowCreateDialog(false)} disabled={isSubmitting}>
              취소
            </Button>
            <Button onClick={handleSaveScript} disabled={isSubmitting}>
              {isSubmitting ? '저장 중...' : (editingScript ? '수정' : '등록')}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>스크립트 삭제</AlertDialogTitle>
            <AlertDialogDescription>
              정말로 '{deletingScript?.name}' 스크립트를 삭제하시겠습니까?
              <br />
              이 작업은 되돌릴 수 없습니다.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>취소</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDeleteScript}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              삭제
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

---

## frontend/src/pages/admin/AdminSetup.tsx

```tsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';
import { authApi } from '@/lib/adminApi';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Loader2, Shield, AlertCircle, CheckCircle2, KeyRound } from 'lucide-react';

export default function AdminSetup() {
  const navigate = useNavigate();
  const { user, refreshUser } = useAuth();
  
  const [currentPassword, setCurrentPassword] = useState('');
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const validatePassword = (password: string): string | null => {
    if (password.length < 8) {
      return '비밀번호는 최소 8자 이상이어야 합니다.';
    }
    if (!/[A-Za-z]/.test(password)) {
      return '비밀번호에 영문자가 포함되어야 합니다.';
    }
    if (!/[0-9]/.test(password)) {
      return '비밀번호에 숫자가 포함되어야 합니다.';
    }
    return null;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    // Validate passwords match
    if (newPassword !== confirmPassword) {
      setError('새 비밀번호가 일치하지 않습니다.');
      return;
    }

    // Validate password strength
    const passwordError = validatePassword(newPassword);
    if (passwordError) {
      setError(passwordError);
      return;
    }

    // Prevent using the same password
    if (currentPassword === newPassword) {
      setError('새 비밀번호는 현재 비밀번호와 달라야 합니다.');
      return;
    }

    setIsSubmitting(true);

    try {
      await authApi.changePassword(currentPassword, newPassword);
      
      // Refresh user to get updated password_change_required status
      await refreshUser();
      
      // Navigate to admin dashboard
      navigate('/admin/environments', { replace: true });
    } catch (err) {
      console.error('Password change failed:', err);
      if (err instanceof Error) {
        if (err.message.includes('400') || err.message.includes('Invalid old password')) {
          setError('현재 비밀번호가 올바르지 않습니다.');
        } else {
          setError(err.message);
        }
      } else {
        setError('비밀번호 변경 중 오류가 발생했습니다.');
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  const passwordStrength = newPassword.length > 0 ? validatePassword(newPassword) === null : null;

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-background to-muted p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1 text-center">
          <div className="mx-auto mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-amber-500/10">
            <KeyRound className="h-6 w-6 text-amber-500" />
          </div>
          <CardTitle className="text-2xl font-bold">초기 설정</CardTitle>
          <CardDescription>
            보안을 위해 기본 비밀번호를 변경해주세요
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Alert className="mb-6 border-amber-500/50 bg-amber-500/10">
            <Shield className="h-4 w-4 text-amber-500" />
            <AlertDescription className="text-amber-700 dark:text-amber-300">
              <strong>{user?.username}</strong> 계정의 기본 비밀번호를 변경해야 관리자 대시보드를 사용할 수 있습니다.
            </AlertDescription>
          </Alert>
          
          <form onSubmit={handleSubmit} className="space-y-4">
            {error && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
            
            <div className="space-y-2">
              <Label htmlFor="currentPassword">현재 비밀번호</Label>
              <Input
                id="currentPassword"
                type="password"
                placeholder="admin123"
                value={currentPassword}
                onChange={(e) => setCurrentPassword(e.target.value)}
                disabled={isSubmitting}
                autoComplete="current-password"
                autoFocus
                required
              />
              <p className="text-xs text-muted-foreground">
                기본 비밀번호: <code className="bg-muted px-1 py-0.5 rounded">admin123</code>
              </p>
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="newPassword">새 비밀번호</Label>
              <Input
                id="newPassword"
                type="password"
                value={newPassword}
                onChange={(e) => setNewPassword(e.target.value)}
                disabled={isSubmitting}
                autoComplete="new-password"
                required
              />
              {newPassword.length > 0 && (
                <div className="flex items-center gap-2 text-xs">
                  {passwordStrength ? (
                    <>
                      <CheckCircle2 className="h-3 w-3 text-green-500" />
                      <span className="text-green-600 dark:text-green-400">안전한 비밀번호입니다</span>
                    </>
                  ) : (
                    <>
                      <AlertCircle className="h-3 w-3 text-amber-500" />
                      <span className="text-amber-600 dark:text-amber-400">
                        8자 이상, 영문자와 숫자 포함 필요
                      </span>
                    </>
                  )}
                </div>
              )}
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="confirmPassword">새 비밀번호 확인</Label>
              <Input
                id="confirmPassword"
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                disabled={isSubmitting}
                autoComplete="new-password"
                required
              />
              {confirmPassword.length > 0 && newPassword !== confirmPassword && (
                <div className="flex items-center gap-2 text-xs">
                  <AlertCircle className="h-3 w-3 text-red-500" />
                  <span className="text-red-600 dark:text-red-400">비밀번호가 일치하지 않습니다</span>
                </div>
              )}
              {confirmPassword.length > 0 && newPassword === confirmPassword && (
                <div className="flex items-center gap-2 text-xs">
                  <CheckCircle2 className="h-3 w-3 text-green-500" />
                  <span className="text-green-600 dark:text-green-400">비밀번호가 일치합니다</span>
                </div>
              )}
            </div>
            
            <Button 
              type="submit" 
              className="w-full" 
              disabled={isSubmitting || !currentPassword || !newPassword || !confirmPassword || newPassword !== confirmPassword || !passwordStrength}
            >
              {isSubmitting ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  변경 중...
                </>
              ) : (
                '비밀번호 변경 및 시작하기'
              )}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

```

---

## frontend/src/pages/admin/AdminUsers.tsx

```tsx
import { useEffect, useState } from 'react';
import {
  User as UserIcon,
  Plus,
  Pencil,
  Trash2,
  RotateCcw,
  Shield,
  Key,
  CheckCircle,
  XCircle,
} from 'lucide-react';
import { usersApi } from '@/lib/adminApi';
import type { User, UserRole } from '@/types/admin';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { format } from 'date-fns';
import { useToast } from '@/hooks/use-toast';

const ROLE_LABELS: Record<UserRole, string> = {
  user: '일반 사용자',
  viewer: '뷰어',
  operator: '운영자',
  admin: '관리자',
};

const ROLE_COLORS: Record<UserRole, string> = {
  user: 'bg-gray-100 text-gray-800',
  viewer: 'bg-blue-100 text-blue-800',
  operator: 'bg-yellow-100 text-yellow-800',
  admin: 'bg-red-100 text-red-800',
};

export default function AdminUsers() {
  const { toast } = useToast();
  const [users, setUsers] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  
  // Create/Edit dialog states
  const [showDialog, setShowDialog] = useState(false);
  const [editingUser, setEditingUser] = useState<User | null>(null);
  const [userForm, setUserForm] = useState({
    username: '',
    email: '',
    password: '',
    role: 'user' as UserRole,
    is_active: true,
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // Password reset dialog
  const [showPasswordDialog, setShowPasswordDialog] = useState(false);
  const [passwordResetUser, setPasswordResetUser] = useState<User | null>(null);
  const [newPassword, setNewPassword] = useState('');
  
  // Delete dialog
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [deletingUser, setDeletingUser] = useState<User | null>(null);

  useEffect(() => {
    loadUsers();
  }, []);

  const loadUsers = async () => {
    setIsLoading(true);
    try {
      const data = await usersApi.list();
      setUsers(data);
    } catch (error) {
      console.error('Failed to load users:', error);
      toast({
        title: "로드 실패",
        description: "사용자 목록을 불러오는데 실패했습니다.",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  const openCreateDialog = () => {
    setEditingUser(null);
    setUserForm({
      username: '',
      email: '',
      password: '',
      role: 'user',
      is_active: true,
    });
    setShowDialog(true);
  };

  const openEditDialog = (user: User) => {
    setEditingUser(user);
    setUserForm({
      username: user.username,
      email: user.email || '',
      password: '',
      role: user.role,
      is_active: user.is_active,
    });
    setShowDialog(true);
  };

  const handleSaveUser = async () => {
    if (!userForm.username) {
      toast({
        title: "입력 오류",
        description: "사용자명은 필수입니다.",
        variant: "destructive",
      });
      return;
    }

    if (!editingUser && !userForm.password) {
      toast({
        title: "입력 오류",
        description: "새 사용자의 비밀번호는 필수입니다.",
        variant: "destructive",
      });
      return;
    }

    setIsSubmitting(true);
    try {
      if (editingUser) {
        await usersApi.update(editingUser.id, {
          email: userForm.email || undefined,
          role: userForm.role,
          is_active: userForm.is_active,
        });
        toast({
          title: "사용자 수정 완료",
          description: `'${userForm.username}' 사용자가 수정되었습니다.`,
        });
      } else {
        await usersApi.create({
          username: userForm.username,
          password: userForm.password,
          email: userForm.email || undefined,
          role: userForm.role,
        });
        toast({
          title: "사용자 등록 완료",
          description: `'${userForm.username}' 사용자가 등록되었습니다.`,
        });
      }
      
      setShowDialog(false);
      loadUsers();
    } catch (error) {
      console.error('Failed to save user:', error);
      toast({
        title: editingUser ? "수정 실패" : "등록 실패",
        description: error instanceof Error ? error.message : '사용자 저장에 실패했습니다.',
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleResetPassword = async () => {
    if (!passwordResetUser || !newPassword) return;

    try {
      await usersApi.resetPassword(passwordResetUser.id, newPassword);
      toast({
        title: "비밀번호 재설정 완료",
        description: `'${passwordResetUser.username}' 사용자의 비밀번호가 재설정되었습니다.`,
      });
      setShowPasswordDialog(false);
      setNewPassword('');
      setPasswordResetUser(null);
    } catch (error) {
      console.error('Failed to reset password:', error);
      toast({
        title: "비밀번호 재설정 실패",
        description: error instanceof Error ? error.message : '비밀번호 재설정에 실패했습니다.',
        variant: "destructive",
      });
    }
  };

  const handleDeleteUser = async () => {
    if (!deletingUser) return;

    try {
      await usersApi.delete(deletingUser.id);
      toast({
        title: "사용자 삭제 완료",
        description: `'${deletingUser.username}' 사용자가 삭제되었습니다.`,
      });
      setShowDeleteDialog(false);
      setDeletingUser(null);
      loadUsers();
    } catch (error) {
      console.error('Failed to delete user:', error);
      toast({
        title: "삭제 실패",
        description: error instanceof Error ? error.message : '사용자 삭제에 실패했습니다.',
        variant: "destructive",
      });
    }
  };

  const handleToggleActive = async (user: User) => {
    try {
      await usersApi.update(user.id, { is_active: !user.is_active });
      toast({
        title: user.is_active ? "사용자 비활성화" : "사용자 활성화",
        description: `'${user.username}' 사용자가 ${user.is_active ? '비활성화' : '활성화'}되었습니다.`,
      });
      loadUsers();
    } catch (error) {
      console.error('Failed to toggle user status:', error);
      toast({
        title: "상태 변경 실패",
        description: error instanceof Error ? error.message : '사용자 상태 변경에 실패했습니다.',
        variant: "destructive",
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
      </div>
    );
  }

  return (
    <div className="space-y-6 container mx-auto p-4">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold tracking-tight">사용자 관리</h1>
        <div className="flex items-center gap-2">
          <Button onClick={openCreateDialog}>
            <Plus className="w-4 h-4 mr-2" />
            사용자 등록
          </Button>
          <Button variant="outline" onClick={loadUsers}>
            <RotateCcw className="w-4 h-4 mr-2" />
            새로고침
          </Button>
        </div>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <UserIcon className="w-5 h-5" />
            사용자 목록 ({users.length}명)
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="rounded-md border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>사용자명</TableHead>
                  <TableHead>이메일</TableHead>
                  <TableHead>역할</TableHead>
                  <TableHead>상태</TableHead>
                  <TableHead>가입일</TableHead>
                  <TableHead>최근 로그인</TableHead>
                  <TableHead className="text-right">관리</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {users.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={7} className="text-center h-24 text-muted-foreground">
                      등록된 사용자가 없습니다.
                    </TableCell>
                  </TableRow>
                ) : (
                  users.map((user) => (
                    <TableRow key={user.id}>
                      <TableCell className="font-medium">{user.username}</TableCell>
                      <TableCell>{user.email || '-'}</TableCell>
                      <TableCell>
                        <Badge className={ROLE_COLORS[user.role]}>
                          {ROLE_LABELS[user.role]}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2">
                          {user.is_active ? (
                            <CheckCircle className="w-4 h-4 text-green-500" />
                          ) : (
                            <XCircle className="w-4 h-4 text-red-500" />
                          )}
                          <span className={user.is_active ? 'text-green-600' : 'text-red-600'}>
                            {user.is_active ? '활성' : '비활성'}
                          </span>
                        </div>
                      </TableCell>
                      <TableCell className="text-sm text-muted-foreground">
                        {format(new Date(user.created_at), 'yyyy-MM-dd')}
                      </TableCell>
                      <TableCell className="text-sm text-muted-foreground">
                        {user.last_login ? format(new Date(user.last_login), 'yyyy-MM-dd HH:mm') : '-'}
                      </TableCell>
                      <TableCell className="text-right">
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button variant="ghost" size="sm">
                              관리
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                            <DropdownMenuItem onClick={() => openEditDialog(user)}>
                              <Pencil className="w-4 h-4 mr-2" />
                              편집
                            </DropdownMenuItem>
                            <DropdownMenuItem onClick={() => {
                              setPasswordResetUser(user);
                              setShowPasswordDialog(true);
                            }}>
                              <Key className="w-4 h-4 mr-2" />
                              비밀번호 재설정
                            </DropdownMenuItem>
                            <DropdownMenuItem onClick={() => handleToggleActive(user)}>
                              <Shield className="w-4 h-4 mr-2" />
                              {user.is_active ? '비활성화' : '활성화'}
                            </DropdownMenuItem>
                            <DropdownMenuItem 
                              onClick={() => {
                                setDeletingUser(user);
                                setShowDeleteDialog(true);
                              }}
                              className="text-destructive focus:text-destructive"
                            >
                              <Trash2 className="w-4 h-4 mr-2" />
                              삭제
                            </DropdownMenuItem>
                          </DropdownMenuContent>
                        </DropdownMenu>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>

      {/* Create/Edit User Dialog */}
      <Dialog open={showDialog} onOpenChange={setShowDialog}>
        <DialogContent className="sm:max-w-[500px]">
          <DialogHeader>
            <DialogTitle>{editingUser ? '사용자 수정' : '새 사용자 등록'}</DialogTitle>
            <DialogDescription>
              {editingUser ? '사용자 정보를 수정합니다.' : '새로운 사용자를 등록합니다.'}
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="username">사용자명 *</Label>
              <Input
                id="username"
                value={userForm.username}
                onChange={(e) => setUserForm(prev => ({ ...prev, username: e.target.value }))}
                placeholder="사용자명"
                disabled={isSubmitting || !!editingUser}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="email">이메일</Label>
              <Input
                id="email"
                type="email"
                value={userForm.email}
                onChange={(e) => setUserForm(prev => ({ ...prev, email: e.target.value }))}
                placeholder="user@example.com"
                disabled={isSubmitting}
              />
            </div>

            {!editingUser && (
              <div className="space-y-2">
                <Label htmlFor="password">비밀번호 *</Label>
                <Input
                  id="password"
                  type="password"
                  value={userForm.password}
                  onChange={(e) => setUserForm(prev => ({ ...prev, password: e.target.value }))}
                  placeholder="비밀번호"
                  disabled={isSubmitting}
                />
              </div>
            )}

            <div className="space-y-2">
              <Label>역할</Label>
              <Select
                value={userForm.role}
                onValueChange={(value: UserRole) => setUserForm(prev => ({ ...prev, role: value }))}
                disabled={isSubmitting}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="user">일반 사용자</SelectItem>
                  <SelectItem value="viewer">뷰어</SelectItem>
                  <SelectItem value="operator">운영자</SelectItem>
                  <SelectItem value="admin">관리자</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {editingUser && (
              <div className="flex items-center justify-between">
                <Label htmlFor="is_active">활성 상태</Label>
                <Switch
                  id="is_active"
                  checked={userForm.is_active}
                  onCheckedChange={(checked) => setUserForm(prev => ({ ...prev, is_active: checked }))}
                  disabled={isSubmitting}
                />
              </div>
            )}
          </div>

          <DialogFooter>
            <Button variant="outline" onClick={() => setShowDialog(false)} disabled={isSubmitting}>
              취소
            </Button>
            <Button onClick={handleSaveUser} disabled={isSubmitting}>
              {isSubmitting ? '저장 중...' : (editingUser ? '수정' : '등록')}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Password Reset Dialog */}
      <Dialog open={showPasswordDialog} onOpenChange={setShowPasswordDialog}>
        <DialogContent className="sm:max-w-[400px]">
          <DialogHeader>
            <DialogTitle>비밀번호 재설정</DialogTitle>
            <DialogDescription>
              '{passwordResetUser?.username}' 사용자의 새 비밀번호를 입력하세요.
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="new-password">새 비밀번호</Label>
              <Input
                id="new-password"
                type="password"
                value={newPassword}
                onChange={(e) => setNewPassword(e.target.value)}
                placeholder="새 비밀번호"
              />
            </div>
          </div>

          <DialogFooter>
            <Button variant="outline" onClick={() => {
              setShowPasswordDialog(false);
              setNewPassword('');
            }}>
              취소
            </Button>
            <Button onClick={handleResetPassword} disabled={!newPassword}>
              재설정
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>사용자 삭제</AlertDialogTitle>
            <AlertDialogDescription>
              정말로 '{deletingUser?.username}' 사용자를 삭제하시겠습니까?
              <br />
              이 작업은 되돌릴 수 없습니다.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>취소</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDeleteUser}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              삭제
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

---

## frontend/src/types/admin.ts

```ts
export type EnvironmentType = 'zerotrust' | 'local' | 'gcp' | 'aws' | 'production' | 'staging';
export type RiskLevel = 'low' | 'medium' | 'high' | 'critical';
export type TaskStatus = 'pending' | 'running' | 'success' | 'failed' | 'cancelled';
export type UserRole = 'user' | 'viewer' | 'operator' | 'admin';
export type ServiceStatus = 'up' | 'down' | 'starting' | 'stopping' | 'unknown';
export type DocumentCategory = 'deployment' | 'troubleshooting' | 'architecture' | 'runbook' | 'general';
export type AuditAction = 'login' | 'logout' | 'view' | 'create' | 'update' | 'delete' | 'execute' | 'deploy' | 'rollback';

export interface Environment {
  id: string;
  name: string;
  env_type: EnvironmentType;
  description?: string;
  compose_file: string;
  env_file?: string;
  is_active: boolean;
  priority: number;
  created_at: string;
  updated_at: string;
}

export interface ContainerInfo {
  name: string;
  image: string;
  status: ServiceStatus;
  health?: string;
  ports: string[];
  created_at?: string;
  started_at?: string;
}

export interface EnvironmentStatus {
  environment_id: string;
  environment_name: string;
  containers: ContainerInfo[];
  total_containers: number;
  running_containers: number;
  last_deployment?: string;
  deployed_by?: string;
}

export interface ScriptParameter {
  name: string;
  param_type: string;
  required: boolean;
  default?: unknown;
  description?: string;
}

export interface Script {
  id: string;
  name: string;
  description?: string;
  command: string;
  working_dir?: string;
  risk_level: RiskLevel;
  estimated_duration?: number;
  allowed_environments: string[];
  required_role: UserRole;
  parameters: ScriptParameter[];
  pre_hooks: string[];
  post_hooks: string[];
  tags: string[];
  created_at: string;
  updated_at: string;
}

export interface TaskExecution {
  id: string;
  script_id: string;
  script_name: string;
  environment_id: string;
  environment_name: string;
  status: TaskStatus;
  parameters: Record<string, unknown>;
  started_at: string;
  finished_at?: string;
  executed_by: string;
  exit_code?: number;
  error_message?: string;
}

export interface Document {
  id: string;
  title: string;
  file_path: string;
  category: DocumentCategory;
  tags: string[];
  related_environments: string[];
  related_scripts: string[];
  content?: string;
  last_modified: string;
}

export interface AuditLog {
  id: string;
  user_id: string;
  username: string;
  action: AuditAction;
  resource_type: string;
  resource_id?: string;
  resource_name?: string;
  environment_id?: string;
  environment_name?: string;
  details: Record<string, unknown>;
  ip_address?: string;
  user_agent?: string;
  timestamp: string;
  success: boolean;
  error_message?: string;
}

export interface User {
  id: string;
  username: string;
  email?: string;
  role: UserRole;
  is_active: boolean;
  created_at: string;
  last_login?: string;
  password_change_required?: boolean;
}

export interface SetupStatus {
  setup_required: boolean;
  has_users: boolean;
  is_default_admin: boolean;
}

export interface Token {
  access_token: string;
  token_type: string;
  expires_in: number;
  // refresh_token is now sent via HTTP-Only cookie, not in response body
}

export interface HealthCheck {
  status: string;
  version: string;
  timestamp: string;
}

```

---

## frontend/src/types/api.ts

```ts
export interface SentimentData {
  pos: number;
  neg: number;
  neu: number;
}

export interface KeywordData {
  word: string;
  score: number;
}

export interface AnalysisResponse {
  query: string;
  window: string;
  article_count: number;
  sentiments: SentimentData;
  top_keywords: KeywordData[];
  analyzed_at: string;
}

export interface Article {
  id: string;
  title: string;
  source: string;
  published_at: string;
  url: string;
  snippet?: string;
}

export interface ArticlesResponse {
  query: string;
  articles: Article[];
  total: number;
}

export type SourceType = "RSS" | "WEB" | "WEB_SEARCH" | "API" | "WEBHOOK" | "BROWSER_AGENT";

export interface DataSource {
  id: number;
  name: string;
  url: string;
  sourceType: SourceType;
  isActive: boolean;
  lastCollected: string | null;
  collectionFrequency: number;
  metadata: Record<string, unknown>;
  searchUrlTemplate?: string;
  searchPriority?: number;
  createdAt: string;
  updatedAt: string;
}

export interface PageResponse<T> {
  content: T[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
  first?: boolean;
  last?: boolean;
  hasNext?: boolean;
  hasPrevious?: boolean;
}

// ============================================
// ML Add-on Types (Backend: /api/v1/ml)
// ============================================

export type AddonCategory =
  | 'SENTIMENT'
  | 'CONTEXT'
  | 'FACTCHECK'
  | 'COMMUNITY'
  | 'SOURCE_QUALITY'
  | 'ENTITY_EXTRACTION'
  | 'SUMMARIZATION'
  | 'TOPIC_CLASSIFICATION'
  | 'TOXICITY'
  | 'MISINFORMATION'
  | 'CUSTOM';

export type AddonInvokeType = 'HTTP_SYNC' | 'HTTP_ASYNC' | 'QUEUE' | 'FILE_POLL';
export type AddonAuthType = 'NONE' | 'API_KEY' | 'BEARER_TOKEN' | 'BASIC' | 'OAUTH2';
export type AddonHealthStatus = 'HEALTHY' | 'DEGRADED' | 'UNHEALTHY' | 'UNKNOWN';
export type ExecutionStatus = 'PENDING' | 'RUNNING' | 'SUCCESS' | 'FAILED' | 'TIMEOUT' | 'CANCELLED' | 'SKIPPED';

/** ML Add-on Registry Entity */
export interface MlAddon {
  id: number;
  addonKey: string;
  name: string;
  description?: string;
  category: AddonCategory;
  invokeType: AddonInvokeType;
  endpointUrl?: string;
  queueTopic?: string;
  storagePath?: string;
  authType: AddonAuthType;
  authCredentials?: string;
  timeoutMs: number;
  maxQps: number;
  maxRetries: number;
  dependsOn?: string[];
  enabled: boolean;
  priority: number;
  config?: Record<string, unknown>;
  healthCheckUrl?: string;
  healthStatus: AddonHealthStatus;
  totalExecutions: number;
  successCount: number;
  failureCount: number;
  avgLatencyMs: number;
  createdAt: string;
  updatedAt: string;
}

/** ML Add-on Execution History */
export interface MlAddonExecution {
  id: number;
  requestId: string;
  batchId?: string;
  addon: MlAddon;
  articleId?: number;
  targetUrl?: string;
  status: ExecutionStatus;
  requestPayload?: Record<string, unknown>;
  responsePayload?: Record<string, unknown>;
  errorMessage?: string;
  errorCode?: string;
  retryCount: number;
  latencyMs: number;
  importance?: string;
  createdAt: string;
  completedAt?: string;
}

/** ML Add-on Analysis Request */
export interface MlAddonRequest {
  requestId: string;
  addonId: string;
  task?: string;
  inputSchemaVersion?: string;
  article: {
    id?: number;
    title?: string;
    content?: string;
    url?: string;
    source?: string;
    publishedAt?: string;
    metadata?: Record<string, unknown>;
  };
  comments?: {
    articleId?: string;
    items?: Array<{
      id: string;
      content: string;
      createdAt?: string;
      likes?: number;
      replies?: number;
      authorId?: string;
    }>;
    platform?: string;
  };
  context?: {
    language?: string;
    country?: string;
    previousResults?: Record<string, unknown>;
    relatedArticleIds?: string[];
  };
  options?: {
    importance?: string;
    debug?: boolean;
    timeoutMs?: number;
    params?: Record<string, unknown>;
  };
}

/** ML Add-on Analysis Response */
export interface MlAddonResponse {
  requestId: string;
  addonId: string;
  status: 'success' | 'error' | 'partial';
  outputSchemaVersion?: string;
  results?: MlAnalysisResults;
  error?: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
    retryable?: boolean;
  };
  meta?: {
    processingTimeMs: number;
    modelVersion?: string;
    tokensUsed?: number;
    cacheHit?: boolean;
  };
}

/** ML Analysis Results (all possible analysis types) */
export interface MlAnalysisResults {
  sentiment?: {
    score: number;
    label: 'positive' | 'negative' | 'neutral';
    distribution?: Record<string, number>;
    emotions?: Record<string, number>;
    explanations?: string[];
  };
  reliability?: {
    score: number;
    grade: 'high' | 'medium' | 'low';
    factors?: Record<string, number>;
    warnings?: string[];
    explanations?: string[];
  };
  bias?: {
    label: string;
    score: number;
    details?: Record<string, number>;
    explanations?: string[];
  };
  factcheck?: {
    status: 'verified' | 'suspicious' | 'conflicting' | 'unverified';
    confidence: number;
    claims?: Array<{
      claim: string;
      verdict: string;
      confidence: number;
      sources?: string[];
    }>;
    sources?: string[];
    notes?: string;
  };
  entities?: {
    persons?: Array<{ name: string; count: number; context?: string }>;
    organizations?: Array<{ name: string; count: number; context?: string }>;
    locations?: Array<{ name: string; count: number; context?: string }>;
    misc?: Array<{ name: string; count: number; context?: string }>;
  };
  summary?: {
    abstractiveSummary?: string;
    extractiveSentences?: string[];
    keyPoints?: string[];
  };
  topics?: {
    labels: string[];
    scores?: Record<string, number>;
    primaryTopic?: string;
  };
  discussion?: {
    overallSentiment?: string;
    sentimentDistribution?: Record<string, number>;
    stanceDistribution?: Record<string, number>;
    toxicityScore?: number;
    topKeywords?: Array<{ word: string; count: number }>;
    timeSeries?: Array<{ timestamp: string; count: number }>;
    botLikelihood?: number;
  };
  toxicity?: {
    score: number;
    categories?: Record<string, number>;
    flaggedPhrases?: string[];
  };
  misinformation?: {
    riskLevel: 'low' | 'mid' | 'high';
    score: number;
    indicators?: string[];
    explanations?: string[];
  };
  raw?: Record<string, unknown>;
}

// ============================================
// Dashboard Event Types (Backend: /api/v1/events)
// ============================================

export type DashboardEventType =
  | 'HEARTBEAT'
  | 'NEW_DATA'
  | 'SOURCE_UPDATED'
  | 'STATS_UPDATED'
  | 'COLLECTION_STARTED'
  | 'COLLECTION_COMPLETED'
  | 'ERROR';

/** Dashboard SSE Event */
export interface DashboardEvent {
  eventType: DashboardEventType;
  timestamp: string;
  message?: string;
  data?: Record<string, unknown>;
}

/** Dashboard Statistics */
export interface DashboardStats {
  totalCollected: number;
  todayCollected: number;
  activeSourceCount: number;
  timestamp: number;
}

// ============================================
// Data Source Extended Types
// ============================================

/** Browser Agent Configuration for Data Source */
export interface BrowserAgentConfig {
  enabled: boolean;
  selectors?: {
    title?: string;
    content?: string;
    date?: string;
    author?: string;
  };
  waitForSelector?: string;
  scrollToLoad?: boolean;
  maxScrolls?: number;
  javascript?: boolean;
}

/** Extended Data Source with Browser Agent */
export interface DataSourceExtended extends DataSource {
  browserAgentConfig?: BrowserAgentConfig;
}

// ============================================
// Source Update/Create Request Types
// ============================================

export interface DataSourceCreateRequest {
  name: string;
  url: string;
  sourceType: SourceType;
  collectionFrequency?: number;
  metadata?: Record<string, unknown>;
  browserAgentConfig?: BrowserAgentConfig;
}

export interface DataSourceUpdateRequest {
  name?: string;
  url?: string;
  sourceType?: SourceType;
  collectionFrequency?: number;
  metadata?: Record<string, unknown>;
  browserAgentConfig?: BrowserAgentConfig;
}

// ============================================
// Factcheck Detailed Analytics Types (Backend: /api/ml-addons/factcheck)
// ============================================

/** Analysis mode for factcheck */
export type FactcheckAnalysisMode = 
  | 'heuristic'
  | 'ml_basic'
  | 'ml_full'
  | 'external_api'
  | 'hybrid';

/** Claim verdict */
export type ClaimVerdict = 
  | 'verified'
  | 'false'
  | 'unverified'
  | 'misleading'
  | 'partially_true';

/** Credibility grade */
export type CredibilityGrade = 'A' | 'B' | 'C' | 'D' | 'F';

/** Source credibility analysis from backend */
export interface SourceAnalytics {
  source_name?: string;
  is_trusted: boolean;
  trust_score: number;
  trust_level: 'trusted' | 'unknown' | 'untrusted';
  matched_trusted_source?: string;
  reason: string;
}

/** Clickbait detection analysis from backend */
export interface ClickbaitAnalytics {
  is_clickbait: boolean;
  score: number;
  detected_patterns: Array<{
    pattern: string;
    matched_text: string;
    severity: 'low' | 'medium' | 'high';
  }>;
  total_patterns_checked: number;
}

/** Misinformation risk analysis from backend */
export interface MisinfoAnalytics {
  risk_score: number;
  risk_level: 'low' | 'medium' | 'high';
  detected_patterns: Array<{
    pattern: string;
    matched_text: string;
    type: 'misinformation' | 'unverifiable';
    category?: string;
    severity: 'low' | 'medium' | 'high';
  }>;
  unverifiable_claim_count: number;
}

/** Individual claim analysis from backend */
export interface ClaimAnalytics {
  claim_id: string;
  claim_text: string;
  verdict: ClaimVerdict;
  confidence: number;
  ml_confidence?: number;
  claim_indicator?: string;
  analysis_method: string;
  entities?: Array<{
    entity: string;
    word: string;
    score: number;
  }>;
  semantic_similarity_scores?: Array<{
    reference_index: number;
    similarity: number;
  }>;
  supporting_factors: string[];
  contradicting_factors: string[];
  external_verification?: Record<string, unknown>;
}

/** Score breakdown from backend */
export interface ScoreBreakdown {
  source_weight: number;
  clickbait_weight: number;
  misinfo_weight: number;
  verification_weight: number;
  source_contribution: number;
  clickbait_contribution: number;
  misinfo_contribution: number;
  verification_contribution: number;
  total_score: number;
  grade: CredibilityGrade;
}

/** Detailed analytics returned from factcheck backend */
export interface DetailedAnalytics {
  source_analysis: SourceAnalytics;
  clickbait_analysis: ClickbaitAnalytics;
  misinfo_analysis: MisinfoAnalytics;
  claim_analyses: ClaimAnalytics[];
  score_breakdown: ScoreBreakdown;
  analysis_mode: FactcheckAnalysisMode;
  ml_models_used: string[];
  external_apis_used: string[];
  processing_time_ms: number;
  analyzed_at: string;
}

/** Claim result in factcheck response */
export interface FactcheckClaimResult {
  claim: string;
  verdict: ClaimVerdict;
  confidence: number;
  evidence?: string;
  source_url?: string;
  ml_analysis?: {
    ml_confidence?: number;
    entities?: Array<{ entity: string; word: string; score: number }>;
    supporting: string[];
    contradicting: string[];
  };
}

/** Factcheck result from backend */
export interface FactcheckResult {
  overall_credibility: number;
  credibility_grade: CredibilityGrade;
  verdict: 'verified' | 'suspicious' | 'unverified';
  claims_analyzed: number;
  verified_claims: number;
  false_claims: number;
  unverified_claims: number;
  claims?: FactcheckClaimResult[];
  risk_flags?: string[];
  explanations?: string[];
  detailed_analytics?: DetailedAnalytics;
}

/** Factcheck addon request */
export interface FactcheckAddonRequest {
  request_id: string;
  addon_id: string;
  task?: string;
  input_schema_version?: string;
  article?: {
    id?: number;
    title?: string;
    content?: string;
    url?: string;
    source?: string;
    published_at?: string;
  };
  context?: {
    language?: string;
    country?: string;
  };
  options?: {
    importance?: string;
    debug?: boolean;
    timeout_ms?: number;
    analysis_mode?: FactcheckAnalysisMode;
    include_detailed_analytics?: boolean;
  };
}

/** Factcheck addon response */
export interface FactcheckAddonResponse {
  request_id: string;
  addon_id: string;
  status: 'success' | 'error' | 'partial';
  output_schema_version?: string;
  results?: {
    factcheck?: FactcheckResult;
    raw?: Record<string, unknown>;
  };
  error?: {
    code: string;
    message: string;
    details?: string;
  };
  meta?: {
    model_version: string;
    latency_ms: number;
    processed_at: string;
    ml_enabled?: boolean;
    models_loaded?: string[];
  };
}

// ============================================
// LLM Provider Settings Types (Backend: /api/v1/llm-providers)
// ============================================

/**
 * LLM Provider 타입
 */
export type LlmProviderType = 
  | 'OPENAI'
  | 'ANTHROPIC'
  | 'GOOGLE'
  | 'OPENROUTER'
  | 'OLLAMA'
  | 'AZURE_OPENAI'
  | 'TOGETHER_AI'
  | 'CUSTOM';

/**
 * LLM Provider 타입 정보
 */
export interface LlmProviderTypeInfo {
  value: LlmProviderType;
  displayName: string;
  description: string;
  requiresApiKey: boolean;
  defaultBaseUrl?: string;
}

/**
 * LLM Provider 설정 DTO
 */
export interface LlmProviderSettings {
  id: number;
  providerType: LlmProviderType;
  providerDisplayName: string;
  userId?: string;
  isGlobal: boolean;
  apiKeyMasked: string;
  hasApiKey: boolean;
  defaultModel?: string;
  baseUrl?: string;
  enabled: boolean;
  priority: number;
  maxTokens: number;
  temperature: number;
  timeoutMs: number;
  maxRequestsPerMinute: number;
  azureDeploymentName?: string;
  azureApiVersion?: string;
  lastTestedAt?: string;
  lastTestSuccess?: boolean;
  createdAt: string;
  updatedAt?: string;
}

/**
 * LLM Provider 설정 요청
 */
export interface LlmProviderSettingsRequest {
  providerType: LlmProviderType;
  apiKey?: string;
  defaultModel?: string;
  baseUrl?: string;
  enabled?: boolean;
  priority?: number;
  maxTokens?: number;
  temperature?: number;
  timeoutMs?: number;
  maxRequestsPerMinute?: number;
  azureDeploymentName?: string;
  azureApiVersion?: string;
}

/**
 * LLM Provider 연결 테스트 결과
 */
export interface LlmTestResult {
  success: boolean;
  providerType: LlmProviderType;
  message: string;
  error?: string;
  responseTime?: number;
  availableModels?: string[];
}

// ============================================
// Config Export/Import Types (Backend: /api/v1/admin/config-export)
// ============================================

/**
 * LLM Provider Export 형식
 */
export interface LlmProviderExport {
  providerType: LlmProviderType;
  defaultModel: string;
  baseUrl?: string;
  enabled: boolean;
  priority: number;
  maxTokens: number;
  temperature: number;
  timeoutMs: number;
  azureDeploymentName?: string;
  azureApiVersion?: string;
  apiKeyMasked?: string;
}

/**
 * ML Addon Export 형식
 */
export interface MlAddonExport {
  addon_key: string;
  name: string;
  description?: string;
  endpoint_url: string;
  version?: string;
  status: string;
  config?: Record<string, unknown>;
}

/**
 * 전체 시스템 설정 Export 형식
 */
export interface SystemConfigExport {
  version: string;
  exportedAt: string;
  exportedBy?: string;
  llmProviders: LlmProviderExport[];
  mlAddons: MlAddonExport[];
  metadata?: Record<string, unknown>;
}

/**
 * LLM Provider Import 형식
 */
export interface LlmProviderImport {
  providerType: LlmProviderType;
  apiKey?: string;
  defaultModel: string;
  baseUrl?: string;
  enabled?: boolean;
  priority?: number;
  maxTokens?: number;
  temperature?: number;
  timeoutMs?: number;
  azureDeploymentName?: string;
  azureApiVersion?: string;
}

/**
 * ML Addon Import 형식
 */
export interface MlAddonImport {
  addon_key: string;
  name: string;
  description?: string;
  endpoint_url: string;
  version?: string;
  config?: Record<string, unknown>;
}

/**
 * 전체 시스템 설정 Import 형식
 */
export interface SystemConfigImport {
  version: string;
  llmProviders: LlmProviderImport[];
  mlAddons: MlAddonImport[];
  metadata?: Record<string, unknown>;
}

/**
 * Import 결과
 */
export interface ConfigImportResult {
  success: boolean;
  message: string;
  llmProvidersImported: number;
  llmProvidersFailed: number;
  mlAddonsImported: number;
  mlAddonsFailed: number;
  errors: string[];
  warnings: string[];
}

/**
 * Import 옵션
 */
export interface ConfigImportOptions {
  overwriteExisting?: boolean;
  skipLlmProviders?: boolean;
  skipMlAddons?: boolean;
  validateOnly?: boolean;
}

```

---

## frontend/src/vite-env.d.ts

```ts
/// <reference types="vite/client" />

```

---

## frontend/tailwind.config.ts

```ts
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./pages/**/*.{ts,tsx}", "./components/**/*.{ts,tsx}", "./app/**/*.{ts,tsx}", "./src/**/*.{ts,tsx}"],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
        success: {
          DEFAULT: "hsl(var(--success))",
          foreground: "hsl(var(--success-foreground))",
        },
        warning: {
          DEFAULT: "hsl(var(--warning))",
          foreground: "hsl(var(--warning-foreground))",
        },
        // Neutral color palette for balanced viewpoints
        teal: {
          50: "hsl(var(--teal-50))",
          100: "hsl(var(--teal-100))",
          200: "hsl(var(--teal-200))",
          500: "hsl(var(--teal-500))",
          600: "hsl(var(--teal-600))",
          700: "hsl(var(--teal-700))",
          900: "hsl(var(--teal-900))",
          950: "hsl(var(--teal-950))",
        },
        coral: {
          50: "hsl(var(--coral-50))",
          100: "hsl(var(--coral-100))",
          200: "hsl(var(--coral-200))",
          500: "hsl(var(--coral-500))",
          600: "hsl(var(--coral-600))",
          700: "hsl(var(--coral-700))",
          900: "hsl(var(--coral-900))",
          950: "hsl(var(--coral-950))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
      // Safe area inset for iOS devices (notch, home indicator)
      padding: {
        'safe': 'env(safe-area-inset-bottom)',
      },
      spacing: {
        'safe-bottom': 'env(safe-area-inset-bottom)',
        'safe-top': 'env(safe-area-inset-top)',
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;

```

---

## frontend/tests/e2e/all-pages.spec.ts

```ts
import { test, expect, Page } from '@playwright/test';

// 모든 페이지 정의
const ALL_PAGES = [
  { path: '/', name: '홈', expectText: 'NewsInsight' },
  { path: '/search', name: '통합검색', expectSelector: 'input, [role="textbox"]' },
  { path: '/dashboard', name: '대시보드', expectSelector: 'main' },
  { path: '/operations', name: '운영관리', expectSelector: 'main' },
  { path: '/collected-data', name: '수집데이터', expectSelector: 'main' },
  { path: '/tools', name: '도구허브', expectSelector: 'main' },
  { path: '/ml-addons', name: 'ML Add-ons', expectSelector: 'main' },
  { path: '/ai-agent', name: 'AI 에이전트', expectSelector: 'main' },
  { path: '/ai-jobs', name: 'AI 작업', expectSelector: 'main' },
  { path: '/parallel-search', name: '병렬검색', expectSelector: 'main' },
  { path: '/workspace', name: '작업공간', expectSelector: 'main' },
  { path: '/projects', name: '프로젝트', expectSelector: 'main' },
  { path: '/history', name: '검색기록', expectSelector: 'main' },
  { path: '/url-collections', name: 'URL 컬렉션', expectSelector: 'main' },
  { path: '/settings', name: '설정', expectSelector: 'main' },
  { path: '/admin/login', name: '관리자 로그인', expectSelector: 'main' },
];

// 콘솔 에러 수집 헬퍼
async function collectConsoleErrors(page: Page): Promise<string[]> {
  const errors: string[] = [];
  page.on('console', msg => {
    if (msg.type() === 'error') {
      errors.push(msg.text());
    }
  });
  page.on('pageerror', err => {
    errors.push(err.message);
  });
  return errors;
}

// API 요청 수집 헬퍼
async function collectApiRequests(page: Page): Promise<{ url: string; status: number }[]> {
  const requests: { url: string; status: number }[] = [];
  page.on('response', response => {
    const url = response.url();
    if (url.includes('/api/')) {
      requests.push({ url, status: response.status() });
    }
  });
  return requests;
}

test.describe('전체 페이지 로드 테스트', () => {
  for (const pageInfo of ALL_PAGES) {
    test(`${pageInfo.name} (${pageInfo.path}) 페이지 로드`, async ({ page }) => {
      // 콘솔 에러 및 API 요청 수집 시작
      const errors = await collectConsoleErrors(page);
      const apiRequests = await collectApiRequests(page);

      // 페이지 이동
      const response = await page.goto(pageInfo.path, { 
        waitUntil: 'networkidle',
        timeout: 30000 
      });

      // HTTP 응답 확인
      expect(response?.status()).toBe(200);

      // 기본 렌더링 확인
      if (pageInfo.expectText) {
        await expect(page.getByText(pageInfo.expectText).first()).toBeVisible({ timeout: 10000 });
      }
      if (pageInfo.expectSelector) {
        await expect(page.locator(pageInfo.expectSelector).first()).toBeVisible({ timeout: 10000 });
      }

      // 잠시 대기 후 API 요청 및 에러 로그
      await page.waitForTimeout(2000);

      // 결과 출력
      console.log(`\n=== ${pageInfo.name} (${pageInfo.path}) ===`);
      console.log(`API 요청: ${apiRequests.length}건`);
      apiRequests.forEach(req => {
        const statusEmoji = req.status >= 200 && req.status < 300 ? '✅' : 
                           req.status >= 400 ? '❌' : '⚠️';
        console.log(`  ${statusEmoji} [${req.status}] ${req.url.replace(/^.*\/api/, '/api')}`);
      });
      
      if (errors.length > 0) {
        console.log(`콘솔 에러: ${errors.length}건`);
        errors.forEach(err => console.log(`  ❌ ${err.substring(0, 100)}`));
      }

      // 심각한 에러가 없는지 확인 (네트워크 에러 제외)
      const criticalErrors = errors.filter(e => 
        !e.includes('Failed to fetch') && 
        !e.includes('NetworkError') &&
        !e.includes('net::ERR')
      );
      expect(criticalErrors.length).toBe(0);
    });
  }
});

test.describe('주요 기능 테스트', () => {
  test('ML Add-ons 페이지에서 애드온 목록 로드', async ({ page }) => {
    await page.goto('/ml-addons');
    await page.waitForLoadState('networkidle');
    
    // 애드온 카드 또는 목록 항목 확인
    const addonItems = page.locator('[data-testid="addon-card"], .addon-card, [class*="card"]');
    await expect(addonItems.first()).toBeVisible({ timeout: 10000 });
  });

  test('검색 페이지에서 검색 실행 가능', async ({ page }) => {
    await page.goto('/search');
    await page.waitForLoadState('networkidle');
    
    // 검색 입력 필드 찾기
    const searchInput = page.getByPlaceholder(/검색|search|키워드/i).first();
    await expect(searchInput).toBeVisible({ timeout: 10000 });
    
    // 검색어 입력
    await searchInput.fill('테스트 검색어');
    
    // 검색 버튼 찾기 및 클릭
    const searchButton = page.getByRole('button', { name: /검색|search/i }).first();
    if (await searchButton.isVisible()) {
      await searchButton.click();
      await page.waitForTimeout(2000);
    }
  });

  test('URL 컬렉션 페이지 데이터 로드', async ({ page }) => {
    await page.goto('/url-collections');
    await page.waitForLoadState('networkidle');
    
    // 컬렉션 목록 또는 빈 상태 확인
    await page.waitForTimeout(2000);
    const mainContent = page.locator('main');
    await expect(mainContent).toBeVisible();
  });

  test('검색 기록 페이지 로드', async ({ page }) => {
    await page.goto('/history');
    await page.waitForLoadState('networkidle');
    
    // 검색 기록 테이블 또는 빈 상태 확인
    await page.waitForTimeout(2000);
    const mainContent = page.locator('main');
    await expect(mainContent).toBeVisible();
  });

  test('설정 페이지에서 테마 변경 가능', async ({ page }) => {
    await page.goto('/settings');
    await page.waitForLoadState('networkidle');
    
    // 테마 관련 요소 찾기
    const themeSection = page.getByText(/테마|theme|다크|라이트/i).first();
    await expect(themeSection).toBeVisible({ timeout: 10000 });
  });
});

```

---

## frontend/tests/e2e/api.spec.ts

```ts
import { test, expect } from '@playwright/test';

/**
 * API 엔드포인트 E2E 테스트
 * 프론트엔드에서 호출하는 API가 정상 응답하는지 확인
 */
test.describe('API 헬스체크', () => {
  test('API Gateway 헬스체크', async ({ request }) => {
    const response = await request.get('/api/actuator/health');
    
    // 200 또는 503 (일부 서비스 다운) 모두 게이트웨이는 동작 중
    expect([200, 503]).toContain(response.status());
  });
});

test.describe('검색 API', () => {
  test('검색 API 호출 가능', async ({ request }) => {
    const response = await request.post('/api/v1/search', {
      data: {
        query: 'test',
        mode: 'quick',
      },
    });
    
    // 200, 401 (인증 필요), 400 (잘못된 요청) 모두 API 동작 확인
    expect([200, 400, 401, 500]).toContain(response.status());
  });
});

test.describe('Articles API', () => {
  test('기사 목록 조회 가능', async ({ request }) => {
    const response = await request.get('/api/v1/articles');
    
    // API 응답 확인
    expect([200, 401, 500]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toBeDefined();
    }
  });
});

test.describe('Config API', () => {
  test('프론트엔드 설정 조회 가능', async ({ request }) => {
    const response = await request.get('/api/v1/config/frontend');
    
    // API 응답 확인
    expect([200, 404, 500]).toContain(response.status());
  });
});

test.describe('Crawler API', () => {
  test('LLM 프로바이더 목록 조회 가능', async ({ request }) => {
    const response = await request.get('/api/v1/crawler/providers');
    
    // API 응답 확인
    expect([200, 404, 500, 502]).toContain(response.status());
  });

  test('프로바이더 모델 목록 조회 가능', async ({ request }) => {
    // OpenAI 모델 목록 조회 (API 키 없어도 static fallback 반환)
    const response = await request.get('/api/v1/crawler/providers/openai/models');
    
    // API 응답 확인
    expect([200, 400, 401, 500, 502]).toContain(response.status());
  });
});

```

---

## frontend/tests/e2e/app.spec.ts

```ts
import { test, expect } from '@playwright/test';

test.describe('홈 페이지', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('홈 페이지가 정상적으로 로드됨', async ({ page }) => {
    // 페이지 제목 확인
    await expect(page).toHaveTitle(/NewsInsight/i);
    
    // 로고 또는 브랜드 텍스트 확인
    await expect(page.getByText('NewsInsight')).toBeVisible();
  });

  test('네비게이션 메뉴가 표시됨', async ({ page }) => {
    // 데스크톱에서 네비게이션 메뉴 확인
    const nav = page.locator('nav, [role="navigation"], header');
    await expect(nav.first()).toBeVisible();
  });

  test('검색 바로가기 버튼이 동작함', async ({ page }) => {
    // Ctrl+K 명령 팔레트 트리거 확인
    const commandButton = page.getByRole('button', { name: /검색/i });
    if (await commandButton.isVisible()) {
      await commandButton.click();
      // 명령 팔레트 또는 검색 다이얼로그가 열리는지 확인
      await expect(page.getByRole('dialog')).toBeVisible({ timeout: 5000 });
    }
  });

  test('알림 벨 아이콘이 표시됨', async ({ page }) => {
    const notificationBell = page.getByRole('button', { name: /알림/i });
    await expect(notificationBell).toBeVisible();
  });

  test('테마 토글이 동작함', async ({ page }) => {
    // 테마 토글 버튼 찾기
    const themeButton = page.getByRole('button', { name: /테마|theme/i });
    if (await themeButton.isVisible()) {
      await themeButton.click();
      // 드롭다운 메뉴가 열리는지 확인
      await expect(page.getByRole('menu')).toBeVisible({ timeout: 3000 });
    }
  });
});

test.describe('검색 페이지', () => {
  test('검색 페이지로 이동 가능', async ({ page }) => {
    await page.goto('/search');
    
    // 검색 입력 필드 확인
    const searchInput = page.getByRole('textbox', { name: /검색|search/i })
      .or(page.getByPlaceholder(/검색|search/i));
    
    await expect(searchInput.first()).toBeVisible({ timeout: 10000 });
  });
});

test.describe('대시보드', () => {
  test('대시보드 페이지로 이동 가능', async ({ page }) => {
    await page.goto('/dashboard');
    
    // 대시보드 컨텐츠 영역 확인
    await expect(page.locator('main')).toBeVisible();
  });
});

test.describe('설정 페이지', () => {
  test('설정 페이지로 이동 가능', async ({ page }) => {
    await page.goto('/settings');
    
    // 설정 페이지 컨텐츠 확인
    await expect(page.locator('main')).toBeVisible();
  });
});

test.describe('반응형 디자인', () => {
  test('모바일 뷰에서 하단 네비게이션이 표시됨', async ({ page }) => {
    // 모바일 뷰포트 설정
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/');
    
    // 모바일 하단 네비게이션 확인 (data-testid 또는 클래스로 찾기)
    const bottomNav = page.locator('[role="navigation"]').last();
    await expect(bottomNav).toBeVisible({ timeout: 5000 });
  });

  test('데스크톱 뷰에서 사이드 네비게이션이 표시됨', async ({ page }) => {
    // 데스크톱 뷰포트 설정
    await page.setViewportSize({ width: 1280, height: 800 });
    await page.goto('/');
    
    // 네비게이션 영역 확인
    await expect(page.locator('header')).toBeVisible();
  });
});

```

---

## frontend/tsconfig.app.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}

```

---

## frontend/tsconfig.json

```json
{
  "files": [],
  "references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}

```

---

## frontend/tsconfig.node.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

```

---

## frontend/vite.config.ts

```ts
import { defineConfig, loadEnv } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '');
  
  // API Gateway (Spring Cloud Gateway) - 포트 8000
  // 프로덕션: docker-compose에서 api-gateway:8000
  // 개발: 로컬에서 실행 시 localhost:8000
  const apiGatewayUrl = env.VITE_API_BASE_URL || "http://localhost:8081";
  
  // Cloudflare Tunnel 환경인지 확인 (환경변수로 제어)
  const isCloudflareTunnel = env.VITE_CLOUDFLARE_TUNNEL === 'true';

  return {
    server: {
      host: "::",
      port: 8080,
      allowedHosts: ["news.nodove.com", "localhost", "127.0.0.1", "frontend"],
      // Cloudflare Tunnel 환경에서 CORS 허용
      cors: true,
      // HMR 설정 - Cloudflare Tunnel 환경에서만 외부 호스트로 설정
      // 로컬 개발 환경에서는 기본값 사용 (localhost)
      hmr: isCloudflareTunnel
        ? {
            host: "news.nodove.com",
            protocol: "wss",
            clientPort: 443,
          }
        : true, // 로컬: 기본 HMR 설정 사용
      proxy: {
        // API Gateway - 모든 /api/** 요청을 게이트웨이로 프록시
        // 게이트웨이가 내부적으로 각 서비스로 라우팅:
        //   /api/v1/** -> collector-service
        //   /api/browser-use/** -> browser-use-api (StripPrefix=2 적용)
        "/api": {
          target: apiGatewayUrl,
          changeOrigin: true,
          secure: false,
          ws: true,
          configure: (proxy, _options) => {
            proxy.on("error", (err, _req, _res) => {
              console.log("[Proxy Error] /api:", err.message);
            });
            proxy.on("proxyReq", (_proxyReq, req, _res) => {
              console.log("[Proxy] /api:", req.method, req.url, "->", apiGatewayUrl);
            });
          },
        },
      },
    },
    plugins: [react()],
    resolve: {
      alias: {
        "@": path.resolve(__dirname, "./src"),
      },
    },
  };
});

```

---

## mcp/aiagent_mcp/server.py

```py
"""
AI Agent MCP Server - Multi-Provider LLM 관리 및 라우팅

여러 LLM Provider를 등록/관리하고, 가용성 기반 자동 선택,
로드밸런싱, 헬스체크, 사용량 추적 기능을 제공하는 MCP 서버입니다.

Version: 1.0.0
Port: 5010
"""

import os
import json
import asyncio
import hashlib
import random
import time
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any, Tuple
from contextlib import contextmanager
from base64 import b64encode, b64decode

import httpx
import requests
from mcp.server import FastMCP
from starlette.responses import JSONResponse
from starlette.requests import Request

# Shared modules
import sys

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from shared.db import get_postgres_conn, check_db_connection, DB_BACKEND
from shared.health import create_health_response

# ─────────────────────────────────────────────
# 1. MCP 서버 기본 설정
# ─────────────────────────────────────────────

# 포트 설정 (shared ports 모듈에서 가져오거나 환경변수)
try:
    from shared.ports import MCP_PORTS

    PORT = MCP_PORTS.get("aiagent_mcp", 5010)
except ImportError:
    PORT = int(os.environ.get("PORT", "5010"))

server = FastMCP(
    "ai-agent-mcp",
    host="0.0.0.0",
    port=PORT,
)


# Health check endpoint (using shared module)
@server.custom_route("/health", methods=["GET"])
async def health_endpoint(request: Request) -> JSONResponse:
    db_status = check_db_connection()
    return JSONResponse(
        create_health_response(
            server_name="ai-agent-mcp", version="1.0.0", extra_info=db_status
        )
    )


# DB 설정은 shared.db에서 가져옴 (get_postgres_conn)

# 암호화 키 (API key 암호화용)
ENCRYPTION_KEY = os.environ.get("ENCRYPTION_KEY", "newsinsight-default-key-change-me")

# 기본 타임아웃 (초)
DEFAULT_TIMEOUT = int(os.environ.get("DEFAULT_TIMEOUT", "60"))

# 헬스체크 간격 (초)
HEALTH_CHECK_INTERVAL = int(os.environ.get("HEALTH_CHECK_INTERVAL", "60"))


# ─────────────────────────────────────────────
# 2. 간단한 암호화/복호화 (API Key 보호용)
# ─────────────────────────────────────────────


def _get_cipher_key() -> bytes:
    """암호화 키를 32바이트로 패딩/해싱"""
    return hashlib.sha256(ENCRYPTION_KEY.encode()).digest()


def encrypt_api_key(plain_key: str) -> str:
    """API key를 간단히 암호화 (XOR + base64)"""
    if not plain_key:
        return ""
    key = _get_cipher_key()
    encrypted = bytes([ord(c) ^ key[i % len(key)] for i, c in enumerate(plain_key)])
    return b64encode(encrypted).decode()


def decrypt_api_key(encrypted_key: str) -> str:
    """암호화된 API key 복호화"""
    if not encrypted_key:
        return ""
    try:
        key = _get_cipher_key()
        encrypted = b64decode(encrypted_key)
        decrypted = bytes([b ^ key[i % len(key)] for i, b in enumerate(encrypted)])
        return decrypted.decode()
    except Exception:
        return ""


# ─────────────────────────────────────────────
# 3. DB 연결 헬퍼 (shared.db 모듈 사용)
# ─────────────────────────────────────────────
# get_postgres_conn()은 shared.db에서 import됨


# ─────────────────────────────────────────────
# 4. Provider 데이터 모델
# ─────────────────────────────────────────────


class ProviderInfo:
    """Provider 정보 데이터 클래스"""

    def __init__(self, row: tuple):
        (
            self.id,
            self.provider_key,
            self.name,
            self.description,
            self.provider_type,
            self.base_url,
            self.api_version,
            self.auth_type,
            self.api_key_encrypted,
            self.auth_header_name,
            self.auth_header_prefix,
            self.custom_headers,
            self.supported_models,
            self.default_model,
            self.max_requests_per_minute,
            self.max_tokens_per_minute,
            self.max_concurrent_requests,
            self.input_price_per_1k,
            self.output_price_per_1k,
            self.priority,
            self.weight,
            self.is_fallback,
            self.enabled,
            self.health_status,
            self.last_health_check,
            self.total_requests,
            self.successful_requests,
            self.failed_requests,
            self.avg_latency_ms,
            self.config,
        ) = row

        # JSON 파싱
        self.supported_models = self._parse_json(self.supported_models, [])
        self.custom_headers = self._parse_json(self.custom_headers, {})
        self.config = self._parse_json(self.config, {})

    def _parse_json(self, val, default):
        if val is None:
            return default
        if isinstance(val, (dict, list)):
            return val
        if isinstance(val, str):
            try:
                return json.loads(val)
            except:
                return default
        return default

    def to_dict(self, include_api_key: bool = False) -> Dict:
        result = {
            "id": self.id,
            "provider_key": self.provider_key,
            "name": self.name,
            "description": self.description,
            "provider_type": self.provider_type,
            "base_url": self.base_url,
            "api_version": self.api_version,
            "auth_type": self.auth_type,
            "auth_header_name": self.auth_header_name,
            "supported_models": self.supported_models,
            "default_model": self.default_model,
            "max_requests_per_minute": self.max_requests_per_minute,
            "priority": self.priority,
            "weight": self.weight,
            "is_fallback": self.is_fallback,
            "enabled": self.enabled,
            "health_status": self.health_status,
            "last_health_check": self.last_health_check.isoformat()
            if self.last_health_check
            else None,
            "stats": {
                "total_requests": self.total_requests or 0,
                "successful_requests": self.successful_requests or 0,
                "failed_requests": self.failed_requests or 0,
                "success_rate": round(
                    (self.successful_requests or 0)
                    / max(self.total_requests or 1, 1)
                    * 100,
                    1,
                ),
                "avg_latency_ms": round(self.avg_latency_ms, 1)
                if self.avg_latency_ms
                else None,
            },
        }
        if include_api_key and self.api_key_encrypted:
            result["has_api_key"] = True
        return result


# ─────────────────────────────────────────────
# 5. Provider CRUD 함수
# ─────────────────────────────────────────────


def list_providers(enabled_only: bool = False) -> List[ProviderInfo]:
    """등록된 모든 Provider 목록 조회"""
    conn = get_postgres_conn()
    with conn.cursor() as cur:
        query = """
            SELECT 
                id, provider_key, name, description, provider_type,
                base_url, api_version, auth_type, api_key_encrypted,
                auth_header_name, auth_header_prefix, custom_headers,
                supported_models, default_model,
                max_requests_per_minute, max_tokens_per_minute, max_concurrent_requests,
                input_price_per_1k, output_price_per_1k,
                priority, weight, is_fallback, enabled, health_status, last_health_check,
                total_requests, successful_requests, failed_requests, avg_latency_ms,
                config
            FROM ai_providers
        """
        if enabled_only:
            query += " WHERE enabled = TRUE"
        query += " ORDER BY priority DESC, weight DESC"
        cur.execute(query)
        rows = cur.fetchall()

    return [ProviderInfo(row) for row in rows]


def get_provider(provider_key: str) -> Optional[ProviderInfo]:
    """특정 Provider 조회"""
    conn = get_postgres_conn()
    with conn.cursor() as cur:
        query = """
            SELECT 
                id, provider_key, name, description, provider_type,
                base_url, api_version, auth_type, api_key_encrypted,
                auth_header_name, auth_header_prefix, custom_headers,
                supported_models, default_model,
                max_requests_per_minute, max_tokens_per_minute, max_concurrent_requests,
                input_price_per_1k, output_price_per_1k,
                priority, weight, is_fallback, enabled, health_status, last_health_check,
                total_requests, successful_requests, failed_requests, avg_latency_ms,
                config
            FROM ai_providers
            WHERE provider_key = %s
        """
        cur.execute(query, (provider_key,))
        row = cur.fetchone()

    return ProviderInfo(row) if row else None


def create_provider(data: Dict[str, Any]) -> Dict[str, Any]:
    """새 Provider 등록"""
    conn = get_postgres_conn()

    # API key 암호화
    api_key = data.get("api_key", "")
    api_key_encrypted = encrypt_api_key(api_key) if api_key else None

    # supported_models JSON 변환
    supported_models = data.get("supported_models", [])
    if isinstance(supported_models, list):
        supported_models = json.dumps(supported_models)

    custom_headers = data.get("custom_headers", {})
    if isinstance(custom_headers, dict):
        custom_headers = json.dumps(custom_headers)

    config = data.get("config", {})
    if isinstance(config, dict):
        config = json.dumps(config)

    with conn.cursor() as cur:
        query = """
            INSERT INTO ai_providers (
                provider_key, name, description, provider_type,
                base_url, api_version, auth_type, api_key_encrypted,
                auth_header_name, auth_header_prefix, custom_headers,
                supported_models, default_model,
                max_requests_per_minute, max_tokens_per_minute, max_concurrent_requests,
                input_price_per_1k, output_price_per_1k,
                priority, weight, is_fallback, enabled, config
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
            )
            RETURNING id, provider_key
        """
        cur.execute(
            query,
            (
                data["provider_key"],
                data["name"],
                data.get("description"),
                data["provider_type"],
                data["base_url"],
                data.get("api_version"),
                data.get("auth_type", "BEARER_TOKEN"),
                api_key_encrypted,
                data.get("auth_header_name", "Authorization"),
                data.get("auth_header_prefix", "Bearer"),
                custom_headers,
                supported_models,
                data.get("default_model"),
                data.get("max_requests_per_minute", 60),
                data.get("max_tokens_per_minute", 100000),
                data.get("max_concurrent_requests", 10),
                data.get("input_price_per_1k", 0.0),
                data.get("output_price_per_1k", 0.0),
                data.get("priority", 100),
                data.get("weight", 1),
                data.get("is_fallback", False),
                data.get("enabled", True),
                config,
            ),
        )
        result = cur.fetchone()

    return {"id": result[0], "provider_key": result[1], "status": "created"}


def update_provider(provider_key: str, data: Dict[str, Any]) -> Dict[str, Any]:
    """Provider 정보 업데이트"""
    conn = get_postgres_conn()

    # 업데이트할 필드 준비
    updates = []
    params = []

    field_mapping = {
        "name": "name",
        "description": "description",
        "base_url": "base_url",
        "api_version": "api_version",
        "auth_type": "auth_type",
        "auth_header_name": "auth_header_name",
        "auth_header_prefix": "auth_header_prefix",
        "default_model": "default_model",
        "max_requests_per_minute": "max_requests_per_minute",
        "max_tokens_per_minute": "max_tokens_per_minute",
        "max_concurrent_requests": "max_concurrent_requests",
        "input_price_per_1k": "input_price_per_1k",
        "output_price_per_1k": "output_price_per_1k",
        "priority": "priority",
        "weight": "weight",
        "is_fallback": "is_fallback",
        "enabled": "enabled",
    }

    for key, col in field_mapping.items():
        if key in data:
            updates.append(f"{col} = %s")
            params.append(data[key])

    # API key 업데이트
    if "api_key" in data:
        updates.append("api_key_encrypted = %s")
        params.append(encrypt_api_key(data["api_key"]) if data["api_key"] else None)

    # supported_models 업데이트
    if "supported_models" in data:
        updates.append("supported_models = %s")
        models = data["supported_models"]
        params.append(json.dumps(models) if isinstance(models, list) else models)

    # custom_headers 업데이트
    if "custom_headers" in data:
        updates.append("custom_headers = %s")
        headers = data["custom_headers"]
        params.append(json.dumps(headers) if isinstance(headers, dict) else headers)

    # config 업데이트
    if "config" in data:
        updates.append("config = %s")
        config = data["config"]
        params.append(json.dumps(config) if isinstance(config, dict) else config)

    if not updates:
        return {"status": "no_changes"}

    updates.append("updated_at = CURRENT_TIMESTAMP")
    params.append(provider_key)

    with conn.cursor() as cur:
        query = f"""
            UPDATE ai_providers 
            SET {", ".join(updates)}
            WHERE provider_key = %s
            RETURNING id
        """
        cur.execute(query, params)
        result = cur.fetchone()

    if result:
        return {"id": result[0], "provider_key": provider_key, "status": "updated"}
    return {"status": "not_found"}


def delete_provider(provider_key: str) -> Dict[str, Any]:
    """Provider 삭제"""
    conn = get_postgres_conn()
    with conn.cursor() as cur:
        cur.execute(
            "DELETE FROM ai_providers WHERE provider_key = %s RETURNING id",
            (provider_key,),
        )
        result = cur.fetchone()

    if result:
        return {"id": result[0], "provider_key": provider_key, "status": "deleted"}
    return {"status": "not_found"}


# ─────────────────────────────────────────────
# 6. Provider 선택 로직 (로드밸런싱)
# ─────────────────────────────────────────────


def select_provider(
    model: Optional[str] = None,
    provider_type: Optional[str] = None,
    strategy: str = "priority",
) -> Optional[ProviderInfo]:
    """
    가용한 Provider를 선택합니다.

    Args:
        model: 특정 모델 요청 시 해당 모델을 지원하는 Provider 선택
        provider_type: 특정 Provider 타입 지정 (OPENAI, ANTHROPIC 등)
        strategy: 선택 전략
            - "priority": 우선순위 기반 (기본)
            - "round_robin": 라운드로빈
            - "weighted_random": 가중치 기반 랜덤
            - "least_latency": 최소 지연시간
            - "least_errors": 최소 에러율

    Returns:
        선택된 Provider 또는 None
    """
    providers = list_providers(enabled_only=True)

    if not providers:
        return None

    # 필터링: health_status가 HEALTHY 또는 UNKNOWN인 것만
    healthy_providers = [
        p for p in providers if p.health_status in ("HEALTHY", "UNKNOWN", None)
    ]

    # 건강한 Provider가 없으면 fallback Provider 사용
    if not healthy_providers:
        healthy_providers = [p for p in providers if p.is_fallback]

    if not healthy_providers:
        healthy_providers = providers  # 마지막 수단

    # 모델 필터링
    if model:
        model_providers = [p for p in healthy_providers if model in p.supported_models]
        if model_providers:
            healthy_providers = model_providers

    # Provider 타입 필터링
    if provider_type:
        type_providers = [
            p for p in healthy_providers if p.provider_type == provider_type
        ]
        if type_providers:
            healthy_providers = type_providers

    if not healthy_providers:
        return None

    # 선택 전략 적용
    if strategy == "priority":
        # 우선순위 순 (이미 정렬되어 있음)
        return healthy_providers[0]

    elif strategy == "round_robin":
        # 간단한 라운드로빈 (요청 수 기반)
        sorted_by_requests = sorted(
            healthy_providers, key=lambda p: p.total_requests or 0
        )
        return sorted_by_requests[0]

    elif strategy == "weighted_random":
        # 가중치 기반 랜덤
        total_weight = sum(p.weight or 1 for p in healthy_providers)
        rand = random.uniform(0, total_weight)
        cumulative = 0
        for p in healthy_providers:
            cumulative += p.weight or 1
            if rand <= cumulative:
                return p
        return healthy_providers[0]

    elif strategy == "least_latency":
        # 최소 지연시간
        with_latency = [p for p in healthy_providers if p.avg_latency_ms]
        if with_latency:
            return min(with_latency, key=lambda p: p.avg_latency_ms)
        return healthy_providers[0]

    elif strategy == "least_errors":
        # 최소 에러율
        def error_rate(p):
            total = p.total_requests or 0
            failed = p.failed_requests or 0
            return failed / max(total, 1)

        return min(healthy_providers, key=error_rate)

    else:
        return healthy_providers[0]


# ─────────────────────────────────────────────
# 7. LLM API 호출
# ─────────────────────────────────────────────


async def call_llm_provider(
    provider: ProviderInfo,
    messages: List[Dict[str, str]],
    model: Optional[str] = None,
    temperature: float = 0.7,
    max_tokens: int = 4096,
    timeout: int = DEFAULT_TIMEOUT,
) -> Dict[str, Any]:
    """
    선택된 Provider의 LLM API를 호출합니다.
    """
    model = model or provider.default_model

    # API key 복호화
    api_key = (
        decrypt_api_key(provider.api_key_encrypted)
        if provider.api_key_encrypted
        else ""
    )

    # 헤더 구성
    headers = {"Content-Type": "application/json"}

    if provider.auth_type == "BEARER_TOKEN" and api_key:
        prefix = provider.auth_header_prefix or "Bearer"
        header_name = provider.auth_header_name or "Authorization"
        headers[header_name] = f"{prefix} {api_key}"
    elif provider.auth_type == "API_KEY" and api_key:
        header_name = provider.auth_header_name or "x-api-key"
        headers[header_name] = api_key

    # custom_headers 추가
    if provider.custom_headers:
        headers.update(provider.custom_headers)

    # Provider 타입별 요청 구성
    start_time = time.time()

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            if provider.provider_type == "AIDOVE":
                # AiDove는 특별한 형식
                last_message = messages[-1]["content"] if messages else ""
                payload = {"chatInput": last_message}
                response = await client.post(
                    provider.base_url, json=payload, headers=headers
                )

            elif provider.provider_type == "ANTHROPIC":
                # Anthropic Claude API
                url = f"{provider.base_url}/v1/messages"
                headers["anthropic-version"] = provider.api_version or "2024-01-01"

                # system 메시지 분리
                system_msg = ""
                chat_messages = []
                for msg in messages:
                    if msg["role"] == "system":
                        system_msg = msg["content"]
                    else:
                        chat_messages.append(msg)

                payload = {
                    "model": model,
                    "messages": chat_messages,
                    "max_tokens": max_tokens,
                    "temperature": temperature,
                }
                if system_msg:
                    payload["system"] = system_msg

                response = await client.post(url, json=payload, headers=headers)

            elif provider.provider_type == "OLLAMA":
                # Ollama API
                url = f"{provider.base_url}/api/chat"
                payload = {
                    "model": model,
                    "messages": messages,
                    "stream": False,
                    "options": {
                        "temperature": temperature,
                        "num_predict": max_tokens,
                    },
                }
                response = await client.post(url, json=payload, headers=headers)

            else:
                # OpenAI 호환 API (OpenAI, Groq, DeepSeek, Azure 등)
                url = f"{provider.base_url}/chat/completions"
                payload = {
                    "model": model,
                    "messages": messages,
                    "temperature": temperature,
                    "max_tokens": max_tokens,
                }
                response = await client.post(url, json=payload, headers=headers)

        latency_ms = int((time.time() - start_time) * 1000)

        # 응답 처리
        if response.status_code != 200:
            error_text = response.text
            update_provider_stats(
                provider.provider_key, success=False, latency_ms=latency_ms
            )
            return {
                "success": False,
                "error": f"API error: {response.status_code}",
                "details": error_text[:500],
                "latency_ms": latency_ms,
            }

        data = response.json()

        # Provider 타입별 응답 파싱
        if provider.provider_type == "AIDOVE":
            text = data.get("reply") or data.get("output") or ""
            input_tokens = 0
            output_tokens = 0
        elif provider.provider_type == "ANTHROPIC":
            content = data.get("content", [])
            text = content[0].get("text", "") if content else ""
            usage = data.get("usage", {})
            input_tokens = usage.get("input_tokens", 0)
            output_tokens = usage.get("output_tokens", 0)
        elif provider.provider_type == "OLLAMA":
            text = data.get("message", {}).get("content", "")
            input_tokens = data.get("prompt_eval_count", 0)
            output_tokens = data.get("eval_count", 0)
        else:
            # OpenAI 호환
            choices = data.get("choices", [])
            text = choices[0].get("message", {}).get("content", "") if choices else ""
            usage = data.get("usage", {})
            input_tokens = usage.get("prompt_tokens", 0)
            output_tokens = usage.get("completion_tokens", 0)

        # 통계 업데이트
        update_provider_stats(
            provider.provider_key,
            success=True,
            latency_ms=latency_ms,
            input_tokens=input_tokens,
            output_tokens=output_tokens,
        )

        return {
            "success": True,
            "text": text,
            "model": model,
            "provider": provider.provider_key,
            "provider_type": provider.provider_type,
            "usage": {
                "input_tokens": input_tokens,
                "output_tokens": output_tokens,
                "total_tokens": input_tokens + output_tokens,
            },
            "latency_ms": latency_ms,
        }

    except httpx.TimeoutException:
        latency_ms = int((time.time() - start_time) * 1000)
        update_provider_stats(
            provider.provider_key, success=False, latency_ms=latency_ms
        )
        return {
            "success": False,
            "error": "Timeout",
            "latency_ms": latency_ms,
        }
    except Exception as e:
        latency_ms = int((time.time() - start_time) * 1000)
        update_provider_stats(
            provider.provider_key, success=False, latency_ms=latency_ms
        )
        return {
            "success": False,
            "error": str(e),
            "latency_ms": latency_ms,
        }


def update_provider_stats(
    provider_key: str,
    success: bool,
    latency_ms: int,
    input_tokens: int = 0,
    output_tokens: int = 0,
):
    """Provider 통계 업데이트"""
    try:
        conn = get_postgres_conn()
        with conn.cursor() as cur:
            if success:
                cur.execute(
                    """
                    UPDATE ai_providers SET
                        total_requests = COALESCE(total_requests, 0) + 1,
                        successful_requests = COALESCE(successful_requests, 0) + 1,
                        total_tokens_used = COALESCE(total_tokens_used, 0) + %s,
                        avg_latency_ms = CASE 
                            WHEN avg_latency_ms IS NULL THEN %s
                            ELSE (avg_latency_ms * 0.9 + %s * 0.1)
                        END,
                        stats_updated_at = CURRENT_TIMESTAMP
                    WHERE provider_key = %s
                """,
                    (
                        input_tokens + output_tokens,
                        latency_ms,
                        latency_ms,
                        provider_key,
                    ),
                )
            else:
                cur.execute(
                    """
                    UPDATE ai_providers SET
                        total_requests = COALESCE(total_requests, 0) + 1,
                        failed_requests = COALESCE(failed_requests, 0) + 1,
                        stats_updated_at = CURRENT_TIMESTAMP
                    WHERE provider_key = %s
                """,
                    (provider_key,),
                )
    except Exception as e:
        print(f"Error updating stats: {e}")


# ─────────────────────────────────────────────
# 8. 헬스체크
# ─────────────────────────────────────────────


async def check_provider_health(provider: ProviderInfo) -> Dict[str, Any]:
    """Provider 헬스체크 수행"""
    start_time = time.time()

    try:
        async with httpx.AsyncClient(timeout=10) as client:
            # Provider 타입별 헬스체크
            if provider.provider_type == "AIDOVE":
                # AiDove는 간단한 ping
                response = await client.post(
                    provider.base_url,
                    json={"chatInput": "ping"},
                    headers={"Content-Type": "application/json"},
                )
                healthy = response.status_code == 200
            elif provider.provider_type == "OLLAMA":
                # Ollama API 확인
                response = await client.get(f"{provider.base_url}/api/tags")
                healthy = response.status_code == 200
            else:
                # OpenAI 호환 API - models 엔드포인트 확인
                api_key = (
                    decrypt_api_key(provider.api_key_encrypted)
                    if provider.api_key_encrypted
                    else ""
                )
                headers = {"Content-Type": "application/json"}

                if api_key:
                    if provider.auth_type == "API_KEY":
                        headers[provider.auth_header_name or "x-api-key"] = api_key
                    else:
                        prefix = provider.auth_header_prefix or "Bearer"
                        headers[provider.auth_header_name or "Authorization"] = (
                            f"{prefix} {api_key}"
                        )

                response = await client.get(
                    f"{provider.base_url}/models",
                    headers=headers,
                )
                healthy = response.status_code == 200

        latency_ms = int((time.time() - start_time) * 1000)
        status = "HEALTHY" if healthy else "UNHEALTHY"

    except Exception as e:
        latency_ms = int((time.time() - start_time) * 1000)
        status = "UNHEALTHY"
        healthy = False

    # DB 업데이트
    try:
        conn = get_postgres_conn()
        with conn.cursor() as cur:
            cur.execute(
                """
                UPDATE ai_providers SET
                    health_status = %s,
                    last_health_check = CURRENT_TIMESTAMP
                WHERE provider_key = %s
            """,
                (status, provider.provider_key),
            )

            # 헬스 히스토리 기록
            cur.execute(
                """
                INSERT INTO ai_provider_health_history (provider_id, status, latency_ms)
                VALUES (%s, %s, %s)
            """,
                (provider.id, status, latency_ms),
            )
    except Exception as e:
        print(f"Error updating health status: {e}")

    return {
        "provider_key": provider.provider_key,
        "status": status,
        "latency_ms": latency_ms,
        "checked_at": datetime.utcnow().isoformat(),
    }


# ─────────────────────────────────────────────
# 9. MCP Tools
# ─────────────────────────────────────────────


@server.tool()
async def list_ai_providers(enabled_only: bool = False) -> Dict[str, Any]:
    """
    등록된 AI Provider 목록을 반환합니다.

    Args:
        enabled_only: True면 활성화된 Provider만 반환

    Returns:
        Provider 목록
    """
    providers = list_providers(enabled_only)
    return {
        "count": len(providers),
        "providers": [p.to_dict() for p in providers],
    }


@server.tool()
async def get_ai_provider(provider_key: str) -> Dict[str, Any]:
    """
    특정 AI Provider 정보를 반환합니다.

    Args:
        provider_key: Provider 고유 키

    Returns:
        Provider 상세 정보
    """
    provider = get_provider(provider_key)
    if provider:
        return {"found": True, "provider": provider.to_dict()}
    return {"found": False, "error": "Provider not found"}


@server.tool()
async def register_ai_provider(
    provider_key: str,
    name: str,
    provider_type: str,
    base_url: str,
    api_key: Optional[str] = None,
    supported_models: Optional[List[str]] = None,
    default_model: Optional[str] = None,
    auth_type: str = "BEARER_TOKEN",
    priority: int = 100,
    enabled: bool = True,
    description: Optional[str] = None,
) -> Dict[str, Any]:
    """
    새 AI Provider를 등록합니다.

    Args:
        provider_key: Provider 고유 키 (예: openai-main)
        name: Provider 표시 이름
        provider_type: Provider 타입 (OPENAI, ANTHROPIC, GOOGLE, GROQ, DEEPSEEK, OLLAMA, AIDOVE, CUSTOM)
        base_url: API Base URL
        api_key: API 키 (암호화되어 저장)
        supported_models: 지원 모델 목록
        default_model: 기본 모델
        auth_type: 인증 방식 (BEARER_TOKEN, API_KEY, NONE)
        priority: 우선순위 (높을수록 우선)
        enabled: 활성화 여부
        description: 설명

    Returns:
        등록 결과
    """
    data = {
        "provider_key": provider_key,
        "name": name,
        "provider_type": provider_type,
        "base_url": base_url,
        "api_key": api_key,
        "supported_models": supported_models or [],
        "default_model": default_model,
        "auth_type": auth_type,
        "priority": priority,
        "enabled": enabled,
        "description": description,
    }

    try:
        result = create_provider(data)
        return {"success": True, **result}
    except Exception as e:
        return {"success": False, "error": str(e)}


@server.tool()
async def update_ai_provider(
    provider_key: str,
    name: Optional[str] = None,
    base_url: Optional[str] = None,
    api_key: Optional[str] = None,
    supported_models: Optional[List[str]] = None,
    default_model: Optional[str] = None,
    priority: Optional[int] = None,
    enabled: Optional[bool] = None,
    description: Optional[str] = None,
) -> Dict[str, Any]:
    """
    기존 AI Provider 정보를 업데이트합니다.

    Args:
        provider_key: Provider 고유 키
        (이하 업데이트할 필드들)

    Returns:
        업데이트 결과
    """
    data = {}
    if name is not None:
        data["name"] = name
    if base_url is not None:
        data["base_url"] = base_url
    if api_key is not None:
        data["api_key"] = api_key
    if supported_models is not None:
        data["supported_models"] = supported_models
    if default_model is not None:
        data["default_model"] = default_model
    if priority is not None:
        data["priority"] = priority
    if enabled is not None:
        data["enabled"] = enabled
    if description is not None:
        data["description"] = description

    try:
        result = update_provider(provider_key, data)
        return {"success": True, **result}
    except Exception as e:
        return {"success": False, "error": str(e)}


@server.tool()
async def delete_ai_provider(provider_key: str) -> Dict[str, Any]:
    """
    AI Provider를 삭제합니다.

    Args:
        provider_key: Provider 고유 키

    Returns:
        삭제 결과
    """
    try:
        result = delete_provider(provider_key)
        return {"success": True, **result}
    except Exception as e:
        return {"success": False, "error": str(e)}


@server.tool()
async def chat_completion(
    message: str,
    model: Optional[str] = None,
    provider_key: Optional[str] = None,
    provider_type: Optional[str] = None,
    system_prompt: Optional[str] = None,
    temperature: float = 0.7,
    max_tokens: int = 4096,
    strategy: str = "priority",
) -> Dict[str, Any]:
    """
    LLM에 메시지를 전송하고 응답을 받습니다.
    Provider는 자동 선택되거나 지정할 수 있습니다.

    Args:
        message: 사용자 메시지
        model: 사용할 모델 (옵션)
        provider_key: 특정 Provider 지정 (옵션)
        provider_type: Provider 타입 지정 (옵션)
        system_prompt: 시스템 프롬프트 (옵션)
        temperature: 온도 (0-2)
        max_tokens: 최대 토큰 수
        strategy: Provider 선택 전략 (priority, round_robin, weighted_random, least_latency, least_errors)

    Returns:
        LLM 응답
    """
    # Provider 선택
    if provider_key:
        provider = get_provider(provider_key)
        if not provider:
            return {"success": False, "error": f"Provider not found: {provider_key}"}
        if not provider.enabled:
            return {"success": False, "error": f"Provider is disabled: {provider_key}"}
    else:
        provider = select_provider(
            model=model, provider_type=provider_type, strategy=strategy
        )
        if not provider:
            return {"success": False, "error": "No available provider"}

    # 메시지 구성
    messages = []
    if system_prompt:
        messages.append({"role": "system", "content": system_prompt})
    messages.append({"role": "user", "content": message})

    # LLM 호출
    result = await call_llm_provider(
        provider=provider,
        messages=messages,
        model=model,
        temperature=temperature,
        max_tokens=max_tokens,
    )

    return result


@server.tool()
async def check_all_providers_health() -> Dict[str, Any]:
    """
    모든 활성화된 Provider의 헬스체크를 수행합니다.

    Returns:
        헬스체크 결과 목록
    """
    providers = list_providers(enabled_only=True)
    results = []

    for provider in providers:
        result = await check_provider_health(provider)
        results.append(result)

    healthy_count = sum(1 for r in results if r["status"] == "HEALTHY")

    return {
        "total": len(results),
        "healthy": healthy_count,
        "unhealthy": len(results) - healthy_count,
        "results": results,
        "checked_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def get_provider_stats(provider_key: Optional[str] = None) -> Dict[str, Any]:
    """
    Provider 사용 통계를 반환합니다.

    Args:
        provider_key: 특정 Provider (없으면 전체)

    Returns:
        사용 통계
    """
    if provider_key:
        provider = get_provider(provider_key)
        if not provider:
            return {"found": False, "error": "Provider not found"}

        return {
            "provider_key": provider_key,
            "stats": provider.to_dict()["stats"],
        }

    # 전체 통계
    providers = list_providers()
    total_requests = sum(p.total_requests or 0 for p in providers)
    total_successful = sum(p.successful_requests or 0 for p in providers)
    total_failed = sum(p.failed_requests or 0 for p in providers)

    return {
        "total_providers": len(providers),
        "enabled_providers": sum(1 for p in providers if p.enabled),
        "healthy_providers": sum(1 for p in providers if p.health_status == "HEALTHY"),
        "total_requests": total_requests,
        "total_successful": total_successful,
        "total_failed": total_failed,
        "overall_success_rate": round(
            total_successful / max(total_requests, 1) * 100, 1
        ),
        "providers": [
            {
                "provider_key": p.provider_key,
                "name": p.name,
                "enabled": p.enabled,
                "health_status": p.health_status,
                **p.to_dict()["stats"],
            }
            for p in providers
        ],
    }


@server.tool()
async def health_check() -> Dict[str, Any]:
    """
    서버 상태 및 DB 연결 상태를 확인합니다.

    Returns:
        서버 상태 정보
    """
    status = {
        "server": "AI Agent MCP",
        "version": "1.0.0",
        "db_backend": DB_BACKEND,
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
    }

    try:
        conn = get_postgres_conn()
        with conn.cursor() as cur:
            cur.execute("SELECT COUNT(*) FROM ai_providers")
            count = cur.fetchone()[0]
        status["postgres"] = "connected"
        status["provider_count"] = count
    except Exception as e:
        status["db_error"] = str(e)
        status["status"] = "degraded"

    return status


# ─────────────────────────────────────────────
# 10. HTTP 헬스체크 핸들러
# ─────────────────────────────────────────────

from http.server import HTTPServer, BaseHTTPRequestHandler
import threading


class HealthCheckHandler(BaseHTTPRequestHandler):
    """간단한 헬스체크 엔드포인트 핸들러"""

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = {
                "status": "healthy",
                "server": "ai-agent-mcp",
                "version": "1.0.0",
            }
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


if __name__ == "__main__":
    print(f"Starting AI Agent MCP Server v1.0.0 on port {PORT}")
    print(f"DB Backend: {DB_BACKEND}")
    server.run(transport="streamable-http")

```

---

## mcp/bias_mcp/server.py

```py
"""
Bias Analysis MCP Server - 뉴스 기사 편향도 분석

실제 프로젝트 스키마(collected_data, article_analysis)를 기반으로
기사의 정치적/이념적 편향도를 분석하는 MCP 서버입니다.

Version: 1.0.0
Port: 5001
"""

import os
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any

import requests
from mcp.server import FastMCP
from starlette.responses import JSONResponse
from starlette.requests import Request

# Shared modules
import sys
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from shared.db import get_postgres_conn, get_mongo_db, DB_BACKEND, check_db_connection
from shared.health import create_health_response
from shared.aidove import AIDOVE_WEBHOOK_URL, call_aidove

# ─────────────────────────────────────────────
# 1. MCP 서버 기본 설정
# ─────────────────────────────────────────────

# 포트 설정 (shared ports 모듈에서 가져오거나 환경변수)
try:
    from shared.ports import MCP_PORTS
    PORT = MCP_PORTS.get("bias_mcp", 5001)
except ImportError:
    PORT = int(os.environ.get("PORT", "5001"))

server = FastMCP(
    "bias-analysis-mcp",
    host="0.0.0.0",
    port=PORT,
)


# Health check endpoint (using shared module)
@server.custom_route("/health", methods=["GET"])
async def health_endpoint(request: Request) -> JSONResponse:
    db_status = check_db_connection()
    return JSONResponse(
        create_health_response(
            server_name="bias-analysis-mcp",
            version="1.0.0",
            extra_info=db_status
        )
    )


# DB 설정은 shared.db에서 가져옴 (DB_BACKEND, get_postgres_conn, get_mongo_db)
# AiDove 설정은 shared.aidove에서 가져옴 (AIDOVE_WEBHOOK_URL, call_aidove)


# ─────────────────────────────────────────────
# 2. 편향도 관련 상수 및 설정
# ─────────────────────────────────────────────

# 언론사별 일반적인 편향 성향 (참고용, 실제 분석에는 ML 결과 사용)
# -1.0 = 진보, 0.0 = 중도, 1.0 = 보수
MEDIA_BIAS_REFERENCE = {
    # 보수 성향
    "조선일보": 0.7,
    "동아일보": 0.6,
    "중앙일보": 0.4,
    "매일경제": 0.3,
    "한국경제": 0.4,
    # 중도
    "연합뉴스": 0.0,
    "KBS": 0.0,
    "MBC": -0.1,
    "SBS": 0.1,
    "YTN": 0.0,
    "JTBC": -0.2,
    # 진보 성향
    "한겨레": -0.7,
    "경향신문": -0.6,
    "오마이뉴스": -0.8,
    "프레시안": -0.8,
}

# 편향 레이블 정의
BIAS_LABELS = {
    "far_left": (-1.0, -0.6),
    "left": (-0.6, -0.2),
    "center_left": (-0.2, -0.05),
    "center": (-0.05, 0.05),
    "center_right": (0.05, 0.2),
    "right": (0.2, 0.6),
    "far_right": (0.6, 1.0),
}

BIAS_LABEL_KR = {
    "far_left": "극진보",
    "left": "진보",
    "center_left": "중도진보",
    "center": "중도",
    "center_right": "중도보수",
    "right": "보수",
    "far_right": "극보수",
}


def get_bias_label(score: float) -> str:
    """편향 점수를 레이블로 변환"""
    for label, (low, high) in BIAS_LABELS.items():
        if low <= score < high:
            return label
    return "center"


# ─────────────────────────────────────────────
# 3. DB 연결 헬퍼 (shared.db 모듈 사용)
# ─────────────────────────────────────────────
# get_postgres_conn(), get_mongo_db()는 shared.db에서 import됨


# ─────────────────────────────────────────────
# 4. 편향도 데이터 조회
# ─────────────────────────────────────────────


def get_bias_data_from_db(
    keyword: str, days: int = 7, limit: int = 100
) -> List[Dict[str, Any]]:
    """
    키워드에 해당하는 기사의 편향도 데이터를 DB에서 조회.

    실제 스키마:
    - collected_data: 수집된 기사 원본
    - article_analysis: ML 분석 결과 (bias_score, bias_label 등)
    - data_sources: 언론사 정보
    """
    cutoff = datetime.utcnow() - timedelta(days=days)

    if DB_BACKEND == "postgres":
        conn = get_postgres_conn()
        with conn.cursor() as cur:
            query = """
                SELECT 
                    cd.id,
                    cd.title,
                    COALESCE(aa.summary, LEFT(cd.content, 500)) as summary,
                    ds.name as source_name,
                    COALESCE(cd.published_date, cd.collected_at) as published_at,
                    cd.url,
                    aa.bias_score,
                    aa.bias_label,
                    aa.bias_indicators,
                    aa.political_leaning,
                    aa.objectivity_score,
                    aa.emotional_language_score,
                    aa.source_diversity_score
                FROM collected_data cd
                LEFT JOIN data_sources ds ON cd.source_id = ds.id
                LEFT JOIN article_analysis aa ON cd.id = aa.article_id
                WHERE (
                    LOWER(cd.title) LIKE LOWER(%s)
                    OR LOWER(cd.content) LIKE LOWER(%s)
                )
                AND COALESCE(cd.published_date, cd.collected_at) >= %s
                ORDER BY COALESCE(cd.published_date, cd.collected_at) DESC
                LIMIT %s
            """
            like_keyword = f"%{keyword}%"
            cur.execute(query, (like_keyword, like_keyword, cutoff, limit))
            rows = cur.fetchall()

        articles = []
        for row in rows:
            (
                id_,
                title,
                summary,
                source_name,
                published_at,
                url,
                bias_score,
                bias_label,
                bias_indicators,
                political_leaning,
                objectivity_score,
                emotional_language_score,
                source_diversity_score,
            ) = row

            # JSONB 파싱
            if isinstance(bias_indicators, str):
                try:
                    bias_indicators = json.loads(bias_indicators)
                except:
                    bias_indicators = {}

            articles.append(
                {
                    "id": id_,
                    "title": title,
                    "summary": summary,
                    "source_name": source_name or "기타",
                    "published_at": published_at,
                    "url": url,
                    "bias_score": bias_score,
                    "bias_label": bias_label,
                    "bias_indicators": bias_indicators or {},
                    "political_leaning": political_leaning,
                    "objectivity_score": objectivity_score,
                    "emotional_language_score": emotional_language_score,
                    "source_diversity_score": source_diversity_score,
                }
            )
        return articles

    elif DB_BACKEND == "mongo":
        db = get_mongo_db()
        cursor = (
            db.collected_data.find(
                {
                    "$or": [
                        {"title": {"$regex": keyword, "$options": "i"}},
                        {"content": {"$regex": keyword, "$options": "i"}},
                    ],
                    "collected_at": {"$gte": cutoff},
                }
            )
            .sort("collected_at", -1)
            .limit(limit)
        )

        articles = []
        for doc in cursor:
            articles.append(
                {
                    "id": str(doc.get("_id")),
                    "title": doc.get("title", ""),
                    "summary": doc.get("content", "")[:500],
                    "source_name": doc.get("source_name", "기타"),
                    "published_at": doc.get("published_date")
                    or doc.get("collected_at"),
                    "url": doc.get("url"),
                    "bias_score": doc.get("bias_score"),
                    "bias_label": doc.get("bias_label"),
                    "bias_indicators": doc.get("bias_indicators", {}),
                    "political_leaning": doc.get("political_leaning"),
                    "objectivity_score": doc.get("objectivity_score"),
                    "emotional_language_score": doc.get("emotional_language_score"),
                    "source_diversity_score": doc.get("source_diversity_score"),
                }
            )
        return articles

    else:
        raise RuntimeError(f"지원하지 않는 DB_BACKEND: {DB_BACKEND}")


# ─────────────────────────────────────────────
# 5. 편향도 분석 (룰 기반 Fallback)
# ─────────────────────────────────────────────

# 편향 키워드 사전
PROGRESSIVE_KEYWORDS = [
    "민주",
    "진보",
    "개혁",
    "평등",
    "복지",
    "인권",
    "노동",
    "환경",
    "시민",
    "연대",
    "공정",
    "정의",
    "평화",
    "다양성",
    "포용",
]
CONSERVATIVE_KEYWORDS = [
    "보수",
    "전통",
    "안보",
    "자유시장",
    "규제완화",
    "국익",
    "경쟁",
    "성장",
    "기업",
    "세금인하",
    "강력",
    "질서",
    "애국",
    "국가",
]
EMOTIONAL_KEYWORDS = [
    "충격",
    "경악",
    "분노",
    "폭로",
    "긴급",
    "속보",
    "단독",
    "파문",
    "논란",
    "폭풍",
    "대란",
    "갈등",
    "비난",
    "공격",
    "반박",
]


def analyze_bias_fallback(title: str, content: str, source_name: str) -> Dict[str, Any]:
    """
    룰 기반 편향도 분석 (ML 결과가 없을 때 사용).
    """
    text = f"{title} {content}".lower()

    # 키워드 기반 분석
    prog_count = sum(1 for w in PROGRESSIVE_KEYWORDS if w in text)
    cons_count = sum(1 for w in CONSERVATIVE_KEYWORDS if w in text)
    emotional_count = sum(1 for w in EMOTIONAL_KEYWORDS if w in text)

    # 언론사 기반 참조
    media_bias = MEDIA_BIAS_REFERENCE.get(source_name, 0.0)

    # 키워드 기반 점수 계산
    keyword_bias = 0.0
    total_keywords = prog_count + cons_count
    if total_keywords > 0:
        keyword_bias = (cons_count - prog_count) / total_keywords * 0.5

    # 종합 점수 (언론사 50%, 키워드 50%)
    bias_score = media_bias * 0.5 + keyword_bias * 0.5
    bias_score = max(-1.0, min(1.0, bias_score))

    # 객관성 점수 (감정적 표현이 적을수록 높음)
    objectivity_score = max(0.0, 1.0 - emotional_count * 0.1)

    return {
        "bias_score": round(bias_score, 3),
        "bias_label": get_bias_label(bias_score),
        "objectivity_score": round(objectivity_score, 3),
        "emotional_language_score": round(min(1.0, emotional_count * 0.15), 3),
        "analysis_method": "rule_based",
    }


# ─────────────────────────────────────────────
# 6. 편향도 분석 로직
# ─────────────────────────────────────────────


def compute_bias_analysis(
    keyword: str,
    days: int = 7,
) -> Dict[str, Any]:
    """
    키워드 관련 기사들의 편향도를 종합 분석합니다.
    """
    articles = get_bias_data_from_db(keyword, days)

    if not articles:
        return {
            "keyword": keyword,
            "days": days,
            "article_count": 0,
            "avg_bias_score": 0.0,
            "avg_bias_label": "center",
            "bias_distribution": {},
            "source_bias_breakdown": {},
            "ml_analyzed_count": 0,
            "note": "분석할 기사가 없습니다.",
        }

    bias_scores = []
    source_bias = {}
    bias_label_counts = {}
    ml_count = 0
    objectivity_scores = []
    emotional_scores = []

    for article in articles:
        source = article.get("source_name", "기타")

        # ML 분석 결과가 있으면 사용, 없으면 룰 기반 분석
        if article.get("bias_score") is not None:
            bias_score = float(article["bias_score"])
            bias_label = article.get("bias_label") or get_bias_label(bias_score)
            objectivity = article.get("objectivity_score")
            emotional = article.get("emotional_language_score")
            ml_count += 1
        else:
            fallback = analyze_bias_fallback(
                article.get("title", ""), article.get("summary", ""), source
            )
            bias_score = fallback["bias_score"]
            bias_label = fallback["bias_label"]
            objectivity = fallback["objectivity_score"]
            emotional = fallback["emotional_language_score"]

        bias_scores.append(bias_score)

        if objectivity is not None:
            objectivity_scores.append(objectivity)
        if emotional is not None:
            emotional_scores.append(emotional)

        # 출처별 편향 집계
        if source not in source_bias:
            source_bias[source] = {"scores": [], "count": 0}
        source_bias[source]["scores"].append(bias_score)
        source_bias[source]["count"] += 1

        # 레이블별 카운트
        label_kr = BIAS_LABEL_KR.get(bias_label, bias_label)
        bias_label_counts[label_kr] = bias_label_counts.get(label_kr, 0) + 1

    # 평균 계산
    avg_bias = sum(bias_scores) / len(bias_scores) if bias_scores else 0.0
    avg_objectivity = (
        sum(objectivity_scores) / len(objectivity_scores)
        if objectivity_scores
        else None
    )
    avg_emotional = (
        sum(emotional_scores) / len(emotional_scores) if emotional_scores else None
    )

    # 출처별 평균 편향
    source_breakdown = {}
    for source, data in source_bias.items():
        avg = sum(data["scores"]) / len(data["scores"])
        source_breakdown[source] = {
            "avg_bias_score": round(avg, 3),
            "bias_label": BIAS_LABEL_KR.get(get_bias_label(avg), get_bias_label(avg)),
            "article_count": data["count"],
        }

    # 편향 분포 비율
    total = len(articles)
    bias_distribution = {
        label: round(count / total, 3) for label, count in bias_label_counts.items()
    }

    return {
        "keyword": keyword,
        "days": days,
        "article_count": len(articles),
        "ml_analyzed_count": ml_count,
        "avg_bias_score": round(avg_bias, 3),
        "avg_bias_label": BIAS_LABEL_KR.get(
            get_bias_label(avg_bias), get_bias_label(avg_bias)
        ),
        "avg_objectivity_score": round(avg_objectivity, 3) if avg_objectivity else None,
        "avg_emotional_language_score": round(avg_emotional, 3)
        if avg_emotional
        else None,
        "bias_distribution": bias_distribution,
        "source_bias_breakdown": source_breakdown,
        "bias_spectrum": {
            "min": round(min(bias_scores), 3),
            "max": round(max(bias_scores), 3),
            "std": round(
                (sum((x - avg_bias) ** 2 for x in bias_scores) / len(bias_scores))
                ** 0.5,
                3,
            )
            if len(bias_scores) > 1
            else 0.0,
        },
        "note": f"ML 분석 {ml_count}건, 룰 기반 {len(articles) - ml_count}건",
    }


# ─────────────────────────────────────────────
# 7. AiDove 호출 헬퍼
# ─────────────────────────────────────────────


def call_aidove(prompt: str, session_id: Optional[str] = None) -> str:
    """AiDove API를 호출하여 자연어 리포트를 생성합니다."""
    payload = {"chatInput": prompt}
    if session_id:
        payload["sessionId"] = session_id

    try:
        resp = requests.post(AIDOVE_WEBHOOK_URL, json=payload, timeout=60)
        resp.raise_for_status()
        data = resp.json()
        return data.get("reply", data.get("output", "리포트 생성에 실패했습니다."))
    except requests.RequestException as e:
        return f"AiDove 호출 실패: {str(e)}"


# ─────────────────────────────────────────────
# 8. MCP Tools
# ─────────────────────────────────────────────


@server.tool()
async def get_bias_raw(
    keyword: str,
    days: int = 7,
) -> Dict[str, Any]:
    """
    키워드 관련 기사들의 편향도 분석 데이터를 JSON으로 반환합니다.

    Args:
        keyword: 검색할 키워드
        days: 분석 기간 (일)

    Returns:
        편향도 분석 데이터 (평균 편향, 출처별 편향, 분포 등)
    """
    result = compute_bias_analysis(keyword, days)
    result["generated_at"] = datetime.utcnow().isoformat()
    return result


@server.tool()
async def get_bias_report(
    keyword: str,
    days: int = 7,
    session_id: Optional[str] = None,
) -> str:
    """
    키워드 관련 기사들의 편향도를 분석하여 AiDove가 작성한 자연어 리포트를 반환합니다.

    Args:
        keyword: 검색할 키워드
        days: 분석 기간 (일)
        session_id: AiDove 세션 ID (선택)

    Returns:
        자연어 편향도 분석 리포트
    """
    raw = await get_bias_raw(keyword=keyword, days=days)

    prompt = f"""
너는 'News Insight'라는 뉴스 분석 서비스의 편향도 분석 리포트 작성 어시스턴트야.

아래 JSON은 특정 키워드에 대한 뉴스 기사들의 편향도 분석 결과야.

키워드: {keyword}
기간: 최근 {days}일

JSON 데이터:
{json.dumps(raw, ensure_ascii=False, indent=2, default=str)}

요청사항:
1. 전체 기사의 평균 편향 성향을 설명해줘 (진보/중도/보수 스펙트럼에서 어디에 위치하는지).
2. 언론사별 편향 차이가 있다면 주요 차이점을 설명해줘.
3. 편향 분포(진보~보수 비율)를 기반으로 해당 키워드에 대한 언론 보도의 다양성을 평가해줘.
4. 객관성 점수와 감정적 표현 사용 정도를 분석해줘.
5. 독자가 이 키워드에 대한 뉴스를 읽을 때 주의해야 할 점을 조언해줘.
6. 마지막에는 '편향도 분석의 한계'에 대한 짧은 주의 문장을 적어줘.

전체 리포트는 3~6 단락 정도의 자연스러운 한국어로 작성해줘.
"""
    report = call_aidove(prompt, session_id=session_id)
    return report


@server.tool()
async def get_source_bias_list() -> Dict[str, Any]:
    """
    참조용 언론사별 일반적인 편향 성향 목록을 반환합니다.

    Note: 이는 일반적인 참조 자료이며, 실제 기사별 편향은 ML 분석으로 판단합니다.

    Returns:
        언론사별 편향 참조 데이터
    """
    result = []
    for source, score in sorted(MEDIA_BIAS_REFERENCE.items(), key=lambda x: x[1]):
        result.append(
            {
                "source": source,
                "bias_score": score,
                "bias_label": BIAS_LABEL_KR.get(
                    get_bias_label(score), get_bias_label(score)
                ),
            }
        )

    return {
        "description": "언론사별 일반적인 편향 성향 참조 자료 (실제 기사별 분석과 다를 수 있음)",
        "scale": "−1.0(진보) ~ 0.0(중도) ~ +1.0(보수)",
        "sources": result,
    }


@server.tool()
async def health_check() -> Dict[str, Any]:
    """
    서버 상태 및 DB 연결 상태를 확인합니다.

    Returns:
        서버 상태 정보
    """
    status = {
        "server": "Bias Analysis MCP",
        "version": "1.0.0",
        "db_backend": DB_BACKEND,
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
    }

    try:
        if DB_BACKEND == "postgres":
            conn = get_postgres_conn()
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
            status["postgres"] = "connected"
        elif DB_BACKEND == "mongo":
            db = get_mongo_db()
            db.command("ping")
            status["mongo"] = "connected"
    except Exception as e:
        status["db_error"] = str(e)
        status["status"] = "degraded"

    return status


# ─────────────────────────────────────────────
# 9. HTTP 헬스체크 핸들러
# ─────────────────────────────────────────────

from http.server import HTTPServer, BaseHTTPRequestHandler
import threading


class HealthCheckHandler(BaseHTTPRequestHandler):
    """간단한 헬스체크 엔드포인트 핸들러"""

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = {
                "status": "healthy",
                "server": "bias-analysis-mcp",
                "version": "1.0.0",
            }
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


if __name__ == "__main__":
    print(f"Starting Bias Analysis MCP Server v1.0.0 on port {PORT}")
    print(f"DB Backend: {DB_BACKEND}")
    server.run(transport="streamable-http")

```

---

## mcp/factcheck_mcp/server.py

```py
"""
Fact Check MCP Server - 뉴스 기사 팩트체크 및 신뢰도 분석

실제 프로젝트 스키마(collected_data, article_analysis)를 기반으로
기사의 사실 검증 및 신뢰도를 분석하는 MCP 서버입니다.

Version: 1.0.0
Port: 5002
"""

import os
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any

import requests
from mcp.server import FastMCP
from starlette.responses import JSONResponse
from starlette.requests import Request

# Shared modules
import sys
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from shared.db import get_postgres_conn, get_mongo_db, DB_BACKEND, check_db_connection
from shared.health import create_health_response
from shared.aidove import AIDOVE_WEBHOOK_URL, call_aidove

# ─────────────────────────────────────────────
# 1. MCP 서버 기본 설정
# ─────────────────────────────────────────────

# 포트 설정 (shared ports 모듈에서 가져오거나 환경변수)
try:
    from shared.ports import MCP_PORTS
    PORT = MCP_PORTS.get("factcheck_mcp", 5002)
except ImportError:
    PORT = int(os.environ.get("PORT", "5002"))

server = FastMCP(
    "factcheck-mcp",
    host="0.0.0.0",
    port=PORT,
)


# Health check endpoint (using shared module)
@server.custom_route("/health", methods=["GET"])
async def health_endpoint(request: Request) -> JSONResponse:
    db_status = check_db_connection()
    return JSONResponse(
        create_health_response(
            server_name="factcheck-mcp",
            version="1.0.0",
            extra_info=db_status
        )
    )

# DB 설정은 shared.db에서 가져옴 (DB_BACKEND, get_postgres_conn, get_mongo_db)
# AiDove 설정은 shared.aidove에서 가져옴 (AIDOVE_WEBHOOK_URL, call_aidove)


# ─────────────────────────────────────────────
# 2. 신뢰도 관련 상수 및 설정
# ─────────────────────────────────────────────

# 언론사별 신뢰도 기준 (0.0 ~ 1.0)
MEDIA_RELIABILITY = {
    # 통신사/공영방송 (높은 신뢰도)
    "연합뉴스": 0.95,
    "KBS": 0.90,
    "MBC": 0.85,
    "SBS": 0.85,
    "YTN": 0.85,
    # 주요 종합지
    "조선일보": 0.80,
    "중앙일보": 0.80,
    "동아일보": 0.80,
    "한겨레": 0.80,
    "경향신문": 0.80,
    # 경제지
    "한국경제": 0.80,
    "매일경제": 0.80,
    # 케이블/종편
    "JTBC": 0.85,
    "TV조선": 0.75,
    "채널A": 0.75,
    "MBN": 0.75,
    # 인터넷 매체
    "뉴시스": 0.75,
    "뉴스1": 0.75,
    "머니투데이": 0.75,
    "이데일리": 0.75,
}
DEFAULT_RELIABILITY = 0.60

# 신뢰도 레이블
RELIABILITY_LABELS = {
    "very_high": (0.9, 1.0),
    "high": (0.75, 0.9),
    "medium": (0.5, 0.75),
    "low": (0.25, 0.5),
    "very_low": (0.0, 0.25),
}

RELIABILITY_LABEL_KR = {
    "very_high": "매우 높음",
    "high": "높음",
    "medium": "보통",
    "low": "낮음",
    "very_low": "매우 낮음",
}


def get_reliability_label(score: float) -> str:
    """신뢰도 점수를 레이블로 변환"""
    for label, (low, high) in RELIABILITY_LABELS.items():
        if low <= score < high:
            return label
    return "medium"


# 팩트체크 관련 키워드
CLAIM_INDICATORS = [
    "주장",
    "발표",
    "밝혔다",
    "전했다",
    "보도했다",
    "알려졌다",
    "것으로 알려졌다",
    "관계자에 따르면",
    "소식통에 따르면",
]
VERIFIED_INDICATORS = [
    "확인됐다",
    "확인했다",
    "사실로 드러났다",
    "밝혀졌다",
    "공식 발표",
    "공식 확인",
    "정부 발표",
]
UNVERIFIED_INDICATORS = [
    "추정",
    "의혹",
    "논란",
    "루머",
    "소문",
    "미확인",
    "것으로 보인다",
    "가능성",
    "예상",
    "전망",
]


# ─────────────────────────────────────────────
# 3. DB 연결 헬퍼 (shared.db 모듈 사용)
# ─────────────────────────────────────────────
# get_postgres_conn(), get_mongo_db()는 shared.db에서 import됨


# ─────────────────────────────────────────────
# 4. 팩트체크 데이터 조회
# ─────────────────────────────────────────────


def get_factcheck_data_from_db(
    keyword: str, days: int = 7, limit: int = 100
) -> List[Dict[str, Any]]:
    """
    키워드에 해당하는 기사의 신뢰도/팩트체크 데이터를 DB에서 조회.
    """
    cutoff = datetime.utcnow() - timedelta(days=days)

    if DB_BACKEND == "postgres":
        conn = get_postgres_conn()
        with conn.cursor() as cur:
            query = """
                SELECT 
                    cd.id,
                    cd.title,
                    COALESCE(aa.summary, LEFT(cd.content, 500)) as summary,
                    cd.content,
                    ds.name as source_name,
                    COALESCE(cd.published_date, cd.collected_at) as published_at,
                    cd.url,
                    cd.trust_score,
                    aa.reliability_score,
                    aa.fact_check_status,
                    aa.claim_count,
                    aa.verified_claim_count,
                    aa.source_count,
                    aa.citation_quality_score,
                    aa.consistency_score
                FROM collected_data cd
                LEFT JOIN data_sources ds ON cd.source_id = ds.id
                LEFT JOIN article_analysis aa ON cd.id = aa.article_id
                WHERE (
                    LOWER(cd.title) LIKE LOWER(%s)
                    OR LOWER(cd.content) LIKE LOWER(%s)
                )
                AND COALESCE(cd.published_date, cd.collected_at) >= %s
                ORDER BY COALESCE(cd.published_date, cd.collected_at) DESC
                LIMIT %s
            """
            like_keyword = f"%{keyword}%"
            cur.execute(query, (like_keyword, like_keyword, cutoff, limit))
            rows = cur.fetchall()

        articles = []
        for row in rows:
            (
                id_,
                title,
                summary,
                content,
                source_name,
                published_at,
                url,
                trust_score,
                reliability_score,
                fact_check_status,
                claim_count,
                verified_claim_count,
                source_count,
                citation_quality_score,
                consistency_score,
            ) = row

            articles.append(
                {
                    "id": id_,
                    "title": title,
                    "summary": summary,
                    "content": content,
                    "source_name": source_name or "기타",
                    "published_at": published_at,
                    "url": url,
                    "trust_score": trust_score,
                    "reliability_score": reliability_score,
                    "fact_check_status": fact_check_status,
                    "claim_count": claim_count,
                    "verified_claim_count": verified_claim_count,
                    "source_count": source_count,
                    "citation_quality_score": citation_quality_score,
                    "consistency_score": consistency_score,
                }
            )
        return articles

    elif DB_BACKEND == "mongo":
        db = get_mongo_db()
        cursor = (
            db.collected_data.find(
                {
                    "$or": [
                        {"title": {"$regex": keyword, "$options": "i"}},
                        {"content": {"$regex": keyword, "$options": "i"}},
                    ],
                    "collected_at": {"$gte": cutoff},
                }
            )
            .sort("collected_at", -1)
            .limit(limit)
        )

        articles = []
        for doc in cursor:
            articles.append(
                {
                    "id": str(doc.get("_id")),
                    "title": doc.get("title", ""),
                    "summary": doc.get("content", "")[:500],
                    "content": doc.get("content", ""),
                    "source_name": doc.get("source_name", "기타"),
                    "published_at": doc.get("published_date")
                    or doc.get("collected_at"),
                    "url": doc.get("url"),
                    "trust_score": doc.get("trust_score"),
                    "reliability_score": doc.get("reliability_score"),
                    "fact_check_status": doc.get("fact_check_status"),
                    "claim_count": doc.get("claim_count"),
                    "verified_claim_count": doc.get("verified_claim_count"),
                    "source_count": doc.get("source_count"),
                    "citation_quality_score": doc.get("citation_quality_score"),
                    "consistency_score": doc.get("consistency_score"),
                }
            )
        return articles

    else:
        raise RuntimeError(f"지원하지 않는 DB_BACKEND: {DB_BACKEND}")


# ─────────────────────────────────────────────
# 5. 신뢰도 분석 (룰 기반 Fallback)
# ─────────────────────────────────────────────


def analyze_reliability_fallback(
    title: str, content: str, source_name: str
) -> Dict[str, Any]:
    """
    룰 기반 신뢰도 분석 (ML 결과가 없을 때 사용).
    """
    text = f"{title} {content}".lower()

    # 주장/검증 지표 분석
    claim_count = sum(1 for w in CLAIM_INDICATORS if w in text)
    verified_count = sum(1 for w in VERIFIED_INDICATORS if w in text)
    unverified_count = sum(1 for w in UNVERIFIED_INDICATORS if w in text)

    # 언론사 기본 신뢰도
    base_reliability = MEDIA_RELIABILITY.get(source_name, DEFAULT_RELIABILITY)

    # 검증 비율에 따른 조정
    total_indicators = claim_count + verified_count + unverified_count
    if total_indicators > 0:
        verification_ratio = (
            verified_count - unverified_count * 0.5
        ) / total_indicators
        adjustment = verification_ratio * 0.2  # 최대 ±0.2 조정
    else:
        adjustment = 0.0

    reliability_score = max(0.0, min(1.0, base_reliability + adjustment))

    # 인용 품질 (간단한 휴리스틱)
    has_quotes = '"' in content or "'" in content
    has_source_attribution = any(
        indicator in text for indicator in ["에 따르면", "관계자는", "대변인은"]
    )
    citation_quality = 0.5
    if has_quotes:
        citation_quality += 0.2
    if has_source_attribution:
        citation_quality += 0.3

    return {
        "reliability_score": round(reliability_score, 3),
        "reliability_label": get_reliability_label(reliability_score),
        "claim_count": claim_count,
        "verified_indicators": verified_count,
        "unverified_indicators": unverified_count,
        "citation_quality_score": round(citation_quality, 3),
        "analysis_method": "rule_based",
    }


# ─────────────────────────────────────────────
# 6. 팩트체크 분석 로직
# ─────────────────────────────────────────────


def compute_factcheck_analysis(
    keyword: str,
    days: int = 7,
) -> Dict[str, Any]:
    """
    키워드 관련 기사들의 신뢰도 및 팩트체크 상태를 종합 분석합니다.
    """
    articles = get_factcheck_data_from_db(keyword, days)

    if not articles:
        return {
            "keyword": keyword,
            "days": days,
            "article_count": 0,
            "avg_reliability_score": 0.0,
            "reliability_label": "medium",
            "reliability_distribution": {},
            "source_reliability": {},
            "ml_analyzed_count": 0,
            "note": "분석할 기사가 없습니다.",
        }

    reliability_scores = []
    source_reliability = {}
    reliability_counts = {}
    ml_count = 0
    citation_scores = []
    consistency_scores = []
    total_claims = 0
    total_verified = 0

    for article in articles:
        source = article.get("source_name", "기타")

        # ML 분석 결과가 있으면 사용, 없으면 룰 기반 분석
        if article.get("reliability_score") is not None:
            reliability_score = float(article["reliability_score"])
            citation_quality = article.get("citation_quality_score")
            consistency = article.get("consistency_score")
            claims = article.get("claim_count") or 0
            verified = article.get("verified_claim_count") or 0
            ml_count += 1
        else:
            fallback = analyze_reliability_fallback(
                article.get("title", ""), article.get("content", ""), source
            )
            reliability_score = fallback["reliability_score"]
            citation_quality = fallback["citation_quality_score"]
            consistency = None
            claims = fallback["claim_count"]
            verified = fallback["verified_indicators"]

        reliability_scores.append(reliability_score)
        total_claims += claims
        total_verified += verified

        if citation_quality is not None:
            citation_scores.append(citation_quality)
        if consistency is not None:
            consistency_scores.append(consistency)

        # 출처별 신뢰도 집계
        if source not in source_reliability:
            source_reliability[source] = {"scores": [], "count": 0}
        source_reliability[source]["scores"].append(reliability_score)
        source_reliability[source]["count"] += 1

        # 레이블별 카운트
        label = get_reliability_label(reliability_score)
        label_kr = RELIABILITY_LABEL_KR.get(label, label)
        reliability_counts[label_kr] = reliability_counts.get(label_kr, 0) + 1

    # 평균 계산
    avg_reliability = (
        sum(reliability_scores) / len(reliability_scores) if reliability_scores else 0.0
    )
    avg_citation = (
        sum(citation_scores) / len(citation_scores) if citation_scores else None
    )
    avg_consistency = (
        sum(consistency_scores) / len(consistency_scores)
        if consistency_scores
        else None
    )

    # 출처별 평균 신뢰도
    source_breakdown = {}
    for source, data in source_reliability.items():
        avg = sum(data["scores"]) / len(data["scores"])
        source_breakdown[source] = {
            "avg_reliability_score": round(avg, 3),
            "reliability_label": RELIABILITY_LABEL_KR.get(
                get_reliability_label(avg), get_reliability_label(avg)
            ),
            "article_count": data["count"],
        }

    # 신뢰도 분포 비율
    total = len(articles)
    reliability_distribution = {
        label: round(count / total, 3) for label, count in reliability_counts.items()
    }

    # 검증 비율
    verification_ratio = total_verified / total_claims if total_claims > 0 else None

    return {
        "keyword": keyword,
        "days": days,
        "article_count": len(articles),
        "ml_analyzed_count": ml_count,
        "avg_reliability_score": round(avg_reliability, 3),
        "reliability_label": RELIABILITY_LABEL_KR.get(
            get_reliability_label(avg_reliability),
            get_reliability_label(avg_reliability),
        ),
        "avg_citation_quality": round(avg_citation, 3) if avg_citation else None,
        "avg_consistency_score": round(avg_consistency, 3) if avg_consistency else None,
        "reliability_distribution": reliability_distribution,
        "source_reliability": source_breakdown,
        "claim_statistics": {
            "total_claims": total_claims,
            "verified_claims": total_verified,
            "verification_ratio": round(verification_ratio, 3)
            if verification_ratio
            else None,
        },
        "reliability_spectrum": {
            "min": round(min(reliability_scores), 3),
            "max": round(max(reliability_scores), 3),
            "std": round(
                (
                    sum((x - avg_reliability) ** 2 for x in reliability_scores)
                    / len(reliability_scores)
                )
                ** 0.5,
                3,
            )
            if len(reliability_scores) > 1
            else 0.0,
        },
        "note": f"ML 분석 {ml_count}건, 룰 기반 {len(articles) - ml_count}건",
    }


# ─────────────────────────────────────────────
# 7. AiDove 호출 헬퍼
# ─────────────────────────────────────────────


def call_aidove(prompt: str, session_id: Optional[str] = None) -> str:
    """AiDove API를 호출하여 자연어 리포트를 생성합니다."""
    payload = {"chatInput": prompt}
    if session_id:
        payload["sessionId"] = session_id

    try:
        resp = requests.post(AIDOVE_WEBHOOK_URL, json=payload, timeout=60)
        resp.raise_for_status()
        data = resp.json()
        return data.get("reply", data.get("output", "리포트 생성에 실패했습니다."))
    except requests.RequestException as e:
        return f"AiDove 호출 실패: {str(e)}"


# ─────────────────────────────────────────────
# 8. MCP Tools
# ─────────────────────────────────────────────


@server.tool()
async def get_factcheck_raw(
    keyword: str,
    days: int = 7,
) -> Dict[str, Any]:
    """
    키워드 관련 기사들의 신뢰도 및 팩트체크 분석 데이터를 JSON으로 반환합니다.

    Args:
        keyword: 검색할 키워드
        days: 분석 기간 (일)

    Returns:
        신뢰도/팩트체크 분석 데이터
    """
    result = compute_factcheck_analysis(keyword, days)
    result["generated_at"] = datetime.utcnow().isoformat()
    return result


@server.tool()
async def get_factcheck_report(
    keyword: str,
    days: int = 7,
    session_id: Optional[str] = None,
) -> str:
    """
    키워드 관련 기사들의 신뢰도를 분석하여 AiDove가 작성한 자연어 리포트를 반환합니다.

    Args:
        keyword: 검색할 키워드
        days: 분석 기간 (일)
        session_id: AiDove 세션 ID (선택)

    Returns:
        자연어 신뢰도/팩트체크 분석 리포트
    """
    raw = await get_factcheck_raw(keyword=keyword, days=days)

    prompt = f"""
너는 'News Insight'라는 뉴스 분석 서비스의 팩트체크 리포트 작성 어시스턴트야.

아래 JSON은 특정 키워드에 대한 뉴스 기사들의 신뢰도 및 팩트체크 분석 결과야.

키워드: {keyword}
기간: 최근 {days}일

JSON 데이터:
{json.dumps(raw, ensure_ascii=False, indent=2, default=str)}

요청사항:
1. 전체 기사의 평균 신뢰도를 설명하고, 이 키워드에 대한 보도가 전반적으로 신뢰할 만한지 평가해줘.
2. 언론사별 신뢰도 차이가 있다면 주요 차이점을 설명해줘.
3. 주장(claim) 대비 검증된 주장의 비율을 분석하고, 이 키워드 관련 보도의 검증 수준을 평가해줘.
4. 인용 품질(citation quality)과 일관성(consistency) 점수를 기반으로 기사들의 저널리즘 품질을 평가해줘.
5. 독자가 이 키워드에 대한 뉴스를 읽을 때 특히 주의해야 할 점이나 추가로 확인해야 할 사항을 조언해줘.
6. 마지막에는 '자동화된 팩트체크의 한계'에 대한 짧은 주의 문장을 적어줘.

전체 리포트는 3~6 단락 정도의 자연스러운 한국어로 작성해줘.
"""
    report = call_aidove(prompt, session_id=session_id)
    return report


@server.tool()
async def get_source_reliability_list() -> Dict[str, Any]:
    """
    참조용 언론사별 기본 신뢰도 목록을 반환합니다.

    Returns:
        언론사별 신뢰도 참조 데이터
    """
    result = []
    for source, score in sorted(MEDIA_RELIABILITY.items(), key=lambda x: -x[1]):
        result.append(
            {
                "source": source,
                "reliability_score": score,
                "reliability_label": RELIABILITY_LABEL_KR.get(
                    get_reliability_label(score), get_reliability_label(score)
                ),
            }
        )

    return {
        "description": "언론사별 기본 신뢰도 참조 자료 (실제 기사별 분석과 다를 수 있음)",
        "scale": "0.0(매우 낮음) ~ 1.0(매우 높음)",
        "sources": result,
    }


@server.tool()
async def health_check() -> Dict[str, Any]:
    """
    서버 상태 및 DB 연결 상태를 확인합니다.

    Returns:
        서버 상태 정보
    """
    status = {
        "server": "Fact Check MCP",
        "version": "1.0.0",
        "db_backend": DB_BACKEND,
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
    }

    try:
        if DB_BACKEND == "postgres":
            conn = get_postgres_conn()
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
            status["postgres"] = "connected"
        elif DB_BACKEND == "mongo":
            db = get_mongo_db()
            db.command("ping")
            status["mongo"] = "connected"
    except Exception as e:
        status["db_error"] = str(e)
        status["status"] = "degraded"

    return status


# ─────────────────────────────────────────────
# 9. HTTP 헬스체크 핸들러
# ─────────────────────────────────────────────

from http.server import HTTPServer, BaseHTTPRequestHandler
import threading


class HealthCheckHandler(BaseHTTPRequestHandler):
    """간단한 헬스체크 엔드포인트 핸들러"""

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = {
                "status": "healthy",
                "server": "factcheck-mcp",
                "version": "1.0.0",
            }
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


if __name__ == "__main__":
    print(f"Starting Fact Check MCP Server v1.0.0 on port {PORT}")
    print(f"DB Backend: {DB_BACKEND}")
    server.run(transport="streamable-http")

```

---

## mcp/huggingface_mcp/server.py

```py
"""
Hugging Face MCP Server - NLP/ML Inference 및 Hub 연동

뉴스 기사 텍스트 분석(감성, 분류, 요약, NER 등)을 위한 MCP 서버입니다.
Hugging Face Inference API와 Hub를 활용합니다.

Version: 1.0.0
Port: 5011
"""

import os
import json
import uuid
import asyncio
import hashlib
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any, Union
from pathlib import Path

import aiohttp
import aiofiles
from mcp.server import FastMCP
from starlette.responses import JSONResponse
from starlette.requests import Request

# ─────────────────────────────────────────────
# 1. MCP 서버 기본 설정
# ─────────────────────────────────────────────

# 포트 설정 (환경변수에서 읽음)
PORT = int(os.environ.get("PORT", "5011"))

server = FastMCP(
    "huggingface-nlp-mcp",
    host="0.0.0.0",
    port=PORT,
)


# Health check endpoint
@server.custom_route("/health", methods=["GET"])
async def health_endpoint(request: Request) -> JSONResponse:
    return JSONResponse(
        {
            "status": "healthy",
            "server": "huggingface-nlp-mcp",
            "version": "1.0.0",
        }
    )


# Hugging Face API 설정
HF_TOKEN = os.environ.get("HF_TOKEN", "")
HF_INFERENCE_URL = "https://api-inference.huggingface.co/models"
HF_API_URL = "https://huggingface.co/api"

# 공유 데이터 디렉토리
DATA_DIR = Path(os.environ.get("DATA_DIR", "/app/data"))
CACHE_DIR = DATA_DIR / "cache"
RESULTS_DIR = DATA_DIR / "results"

# Job Queue 설정
JOB_TIMEOUT = int(os.environ.get("JOB_TIMEOUT", "600"))  # 10분

# ─────────────────────────────────────────────
# 2. Job Queue 관리 (In-Memory)
# ─────────────────────────────────────────────


class JobStatus:
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"


_jobs: Dict[str, Dict[str, Any]] = {}


def create_job(job_type: str, params: Dict[str, Any]) -> str:
    """새 Job을 생성하고 Job ID를 반환합니다."""
    job_id = str(uuid.uuid4())
    _jobs[job_id] = {
        "id": job_id,
        "type": job_type,
        "status": JobStatus.PENDING,
        "params": params,
        "result": None,
        "error": None,
        "created_at": datetime.utcnow().isoformat(),
        "updated_at": datetime.utcnow().isoformat(),
        "progress": 0,
    }
    return job_id


def update_job(job_id: str, **kwargs):
    """Job 상태를 업데이트합니다."""
    if job_id in _jobs:
        _jobs[job_id].update(kwargs)
        _jobs[job_id]["updated_at"] = datetime.utcnow().isoformat()


def get_job(job_id: str) -> Optional[Dict[str, Any]]:
    """Job 정보를 조회합니다."""
    return _jobs.get(job_id)


# ─────────────────────────────────────────────
# 3. 캐싱 유틸리티
# ─────────────────────────────────────────────


def get_cache_key(text: str, model: str, task: str) -> str:
    """캐시 키를 생성합니다."""
    content = f"{text}:{model}:{task}"
    return hashlib.md5(content.encode()).hexdigest()


async def save_to_cache(key: str, data: Any):
    """결과를 캐시에 저장합니다."""
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    cache_file = CACHE_DIR / f"{key}.json"
    async with aiofiles.open(cache_file, "w") as f:
        await f.write(json.dumps(data, ensure_ascii=False, default=str))


async def load_from_cache(key: str) -> Optional[Any]:
    """캐시에서 결과를 로드합니다."""
    cache_file = CACHE_DIR / f"{key}.json"
    if cache_file.exists():
        async with aiofiles.open(cache_file, "r") as f:
            content = await f.read()
            return json.loads(content)
    return None


# ─────────────────────────────────────────────
# 4. Hugging Face Inference API 클라이언트
# ─────────────────────────────────────────────


class HuggingFaceClient:
    """Hugging Face Inference API 클라이언트"""

    def __init__(self, token: str):
        self.token = token
        self.headers = {"Authorization": f"Bearer {token}"} if token else {}

    async def _call_inference(
        self,
        model_id: str,
        inputs: Any,
        parameters: Optional[Dict[str, Any]] = None,
        options: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Inference API를 호출합니다."""
        url = f"{HF_INFERENCE_URL}/{model_id}"

        payload = {"inputs": inputs}
        if parameters:
            payload["parameters"] = parameters
        if options:
            payload["options"] = options

        async with aiohttp.ClientSession() as session:
            async with session.post(
                url,
                headers=self.headers,
                json=payload,
                timeout=aiohttp.ClientTimeout(total=120),
            ) as resp:
                if resp.status == 503:
                    # 모델 로딩 중
                    data = await resp.json()
                    estimated_time = data.get("estimated_time", 60)
                    return {
                        "loading": True,
                        "estimated_time": estimated_time,
                        "message": "모델이 로딩 중입니다. 잠시 후 다시 시도해주세요.",
                    }
                elif resp.status != 200:
                    text = await resp.text()
                    raise Exception(f"HuggingFace API 오류: {resp.status} - {text}")
                return await resp.json()

    # ─── 텍스트 분류 ───

    async def classify_text(
        self,
        text: str,
        model_id: str = "facebook/bart-large-mnli",
        candidate_labels: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        """
        텍스트 분류 (Zero-shot 또는 일반 분류).

        Args:
            text: 분류할 텍스트
            model_id: 분류 모델 ID
            candidate_labels: Zero-shot 분류 시 후보 레이블
        """
        if candidate_labels:
            # Zero-shot classification
            return await self._call_inference(
                model_id,
                {"text": text, "candidate_labels": candidate_labels},
            )
        else:
            return await self._call_inference(model_id, text)

    # ─── 감성 분석 ───

    async def analyze_sentiment(
        self,
        text: str,
        model_id: str = "cardiffnlp/twitter-roberta-base-sentiment-latest",
    ) -> Dict[str, Any]:
        """
        텍스트 감성 분석 (긍정/부정/중립).

        Args:
            text: 분석할 텍스트
            model_id: 감성 분석 모델 ID
        """
        result = await self._call_inference(model_id, text)

        # 결과 정규화
        if isinstance(result, list) and len(result) > 0:
            if isinstance(result[0], list):
                result = result[0]

            # 레이블 한글화
            label_map = {
                "positive": "긍정",
                "negative": "부정",
                "neutral": "중립",
                "POSITIVE": "긍정",
                "NEGATIVE": "부정",
                "NEUTRAL": "중립",
                "LABEL_0": "부정",
                "LABEL_1": "중립",
                "LABEL_2": "긍정",
            }

            for item in result:
                if "label" in item:
                    item["label_kr"] = label_map.get(item["label"], item["label"])

        return {"results": result}

    # ─── 텍스트 요약 ───

    async def summarize_text(
        self,
        text: str,
        model_id: str = "facebook/bart-large-cnn",
        max_length: int = 150,
        min_length: int = 30,
    ) -> Dict[str, Any]:
        """
        텍스트 요약.

        Args:
            text: 요약할 텍스트
            model_id: 요약 모델 ID
            max_length: 최대 요약 길이
            min_length: 최소 요약 길이
        """
        result = await self._call_inference(
            model_id,
            text,
            parameters={
                "max_length": max_length,
                "min_length": min_length,
            },
        )
        return result

    # ─── 개체명 인식 (NER) ───

    async def extract_entities(
        self,
        text: str,
        model_id: str = "dslim/bert-base-NER",
    ) -> Dict[str, Any]:
        """
        개체명 인식 (Named Entity Recognition).

        Args:
            text: 분석할 텍스트
            model_id: NER 모델 ID
        """
        result = await self._call_inference(model_id, text)

        # 엔티티 그룹화
        entities = {}
        if isinstance(result, list):
            for ent in result:
                entity_type = ent.get("entity_group", ent.get("entity", "MISC"))
                word = ent.get("word", "")

                if entity_type not in entities:
                    entities[entity_type] = []

                # 중복 제거
                if word and word not in entities[entity_type]:
                    entities[entity_type].append(word)

        return {
            "raw": result,
            "grouped": entities,
            "total_count": len(result) if isinstance(result, list) else 0,
        }

    # ─── 키워드 추출 ───

    async def extract_keywords(
        self,
        text: str,
        model_id: str = "ml6team/keyphrase-extraction-kbir-inspec",
    ) -> Dict[str, Any]:
        """
        키워드/키프레이즈 추출.

        Args:
            text: 분석할 텍스트
            model_id: 키워드 추출 모델 ID
        """
        result = await self._call_inference(model_id, text)

        # 키워드 추출 및 정리
        keywords = []
        if isinstance(result, list):
            for item in result:
                word = item.get("word", "").strip()
                if word and word not in keywords:
                    keywords.append(word)

        return {
            "keywords": keywords,
            "raw": result,
        }

    # ─── 텍스트 생성 ───

    async def generate_text(
        self,
        prompt: str,
        model_id: str = "gpt2",
        max_new_tokens: int = 100,
        temperature: float = 0.7,
    ) -> Dict[str, Any]:
        """
        텍스트 생성.

        Args:
            prompt: 입력 프롬프트
            model_id: 생성 모델 ID
            max_new_tokens: 최대 생성 토큰 수
            temperature: 샘플링 온도
        """
        result = await self._call_inference(
            model_id,
            prompt,
            parameters={
                "max_new_tokens": max_new_tokens,
                "temperature": temperature,
                "return_full_text": False,
            },
        )
        return result

    # ─── 질의응답 ───

    async def question_answering(
        self,
        question: str,
        context: str,
        model_id: str = "deepset/roberta-base-squad2",
    ) -> Dict[str, Any]:
        """
        문서 기반 질의응답.

        Args:
            question: 질문
            context: 답변을 찾을 문서/컨텍스트
            model_id: QA 모델 ID
        """
        result = await self._call_inference(
            model_id,
            {"question": question, "context": context},
        )
        return result

    # ─── 임베딩 ───

    async def get_embeddings(
        self,
        texts: List[str],
        model_id: str = "sentence-transformers/all-MiniLM-L6-v2",
    ) -> Dict[str, Any]:
        """
        텍스트 임베딩 생성.

        Args:
            texts: 임베딩할 텍스트 목록
            model_id: 임베딩 모델 ID
        """
        result = await self._call_inference(
            model_id,
            {"inputs": texts, "options": {"wait_for_model": True}},
        )
        return {
            "embeddings": result,
            "dimension": len(result[0]) if result and len(result) > 0 else 0,
            "count": len(texts),
        }

    # ─── Hub API ───

    async def search_models(
        self,
        query: str,
        task: Optional[str] = None,
        limit: int = 10,
    ) -> List[Dict[str, Any]]:
        """
        Hugging Face Hub에서 모델을 검색합니다.

        Args:
            query: 검색어
            task: 태스크 필터 (text-classification, summarization 등)
            limit: 최대 결과 수
        """
        params = {"search": query, "limit": limit}
        if task:
            params["pipeline_tag"] = task

        url = f"{HF_API_URL}/models"

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params, headers=self.headers) as resp:
                if resp.status != 200:
                    text = await resp.text()
                    raise Exception(f"HuggingFace Hub API 오류: {resp.status} - {text}")
                return await resp.json()

    async def get_model_info(self, model_id: str) -> Dict[str, Any]:
        """
        모델 상세 정보를 조회합니다.

        Args:
            model_id: 모델 ID (예: "facebook/bart-large-cnn")
        """
        url = f"{HF_API_URL}/models/{model_id}"

        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=self.headers) as resp:
                if resp.status != 200:
                    text = await resp.text()
                    raise Exception(f"HuggingFace Hub API 오류: {resp.status} - {text}")
                return await resp.json()


# 전역 클라이언트 인스턴스
_hf_client: Optional[HuggingFaceClient] = None


def get_hf_client() -> HuggingFaceClient:
    """HuggingFace 클라이언트를 반환합니다."""
    global _hf_client
    if _hf_client is None:
        _hf_client = HuggingFaceClient(HF_TOKEN)
    return _hf_client


# ─────────────────────────────────────────────
# 5. 뉴스 기사 종합 분석
# ─────────────────────────────────────────────


async def analyze_news_article(
    title: str,
    content: str,
    include_sentiment: bool = True,
    include_entities: bool = True,
    include_summary: bool = True,
    include_keywords: bool = True,
    include_classification: bool = True,
) -> Dict[str, Any]:
    """
    뉴스 기사를 종합적으로 분석합니다.
    """
    client = get_hf_client()
    full_text = f"{title}\n\n{content}"

    result = {
        "analyzed_at": datetime.utcnow().isoformat(),
        "title": title,
        "content_length": len(content),
    }

    tasks = []
    task_names = []

    # 감성 분석
    if include_sentiment:
        tasks.append(client.analyze_sentiment(full_text[:512]))
        task_names.append("sentiment")

    # 개체명 인식
    if include_entities:
        tasks.append(client.extract_entities(full_text[:512]))
        task_names.append("entities")

    # 요약
    if include_summary and len(content) > 200:
        tasks.append(client.summarize_text(content[:1024]))
        task_names.append("summary")

    # 키워드 추출
    if include_keywords:
        tasks.append(client.extract_keywords(full_text[:512]))
        task_names.append("keywords")

    # 분류 (Zero-shot)
    if include_classification:
        categories = ["정치", "경제", "사회", "문화", "스포츠", "IT/과학", "국제"]
        tasks.append(
            client.classify_text(
                title,
                model_id="facebook/bart-large-mnli",
                candidate_labels=categories,
            )
        )
        task_names.append("classification")

    # 병렬 실행
    if tasks:
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for name, res in zip(task_names, results):
            if isinstance(res, Exception):
                result[name] = {"error": str(res)}
            else:
                result[name] = res

    return result


# ─────────────────────────────────────────────
# 6. 배치 처리
# ─────────────────────────────────────────────


async def process_batch_articles(
    job_id: str,
    articles: List[Dict[str, str]],
    analysis_options: Dict[str, bool],
) -> Dict[str, Any]:
    """
    여러 기사를 배치로 분석합니다.
    """
    update_job(job_id, status=JobStatus.PROCESSING, progress=0)

    results = []
    total = len(articles)

    for idx, article in enumerate(articles):
        try:
            result = await analyze_news_article(
                title=article.get("title", ""),
                content=article.get("content", ""),
                **analysis_options,
            )
            results.append(
                {
                    "article_id": article.get("id", idx),
                    "success": True,
                    "result": result,
                }
            )
        except Exception as e:
            results.append(
                {
                    "article_id": article.get("id", idx),
                    "success": False,
                    "error": str(e),
                }
            )

        progress = int((idx + 1) / total * 100)
        update_job(job_id, progress=progress)

    # 결과 저장
    RESULTS_DIR.mkdir(parents=True, exist_ok=True)
    result_file = RESULTS_DIR / f"{job_id}.json"
    async with aiofiles.open(result_file, "w") as f:
        await f.write(json.dumps(results, ensure_ascii=False, default=str, indent=2))

    final_result = {
        "total": total,
        "success_count": sum(1 for r in results if r["success"]),
        "failed_count": sum(1 for r in results if not r["success"]),
        "results": results,
        "result_file": str(result_file),
    }

    update_job(job_id, status=JobStatus.COMPLETED, result=final_result, progress=100)
    return final_result


# ─────────────────────────────────────────────
# 7. MCP Tools
# ─────────────────────────────────────────────


@server.tool()
async def analyze_sentiment(
    text: str,
    model_id: str = "cardiffnlp/twitter-roberta-base-sentiment-latest",
) -> Dict[str, Any]:
    """
    텍스트의 감성을 분석합니다 (긍정/부정/중립).

    뉴스 기사 제목이나 본문의 감성 성향을 파악할 수 있습니다.

    Args:
        text: 분석할 텍스트
        model_id: 감성 분석 모델 ID

    Returns:
        감성 분석 결과 (레이블, 신뢰도)
    """
    client = get_hf_client()
    result = await client.analyze_sentiment(text[:512], model_id)

    return {
        "text_preview": text[:100] + "..." if len(text) > 100 else text,
        "model": model_id,
        "sentiment": result,
        "analyzed_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def classify_news(
    text: str,
    categories: Optional[List[str]] = None,
) -> Dict[str, Any]:
    """
    뉴스 기사를 카테고리로 분류합니다 (Zero-shot).

    Args:
        text: 분류할 텍스트 (제목 또는 본문)
        categories: 분류 카테고리 목록 (기본: 정치, 경제, 사회, 문화, 스포츠, IT/과학, 국제)

    Returns:
        카테고리별 확률
    """
    if categories is None:
        categories = ["정치", "경제", "사회", "문화", "스포츠", "IT/과학", "국제"]

    client = get_hf_client()
    result = await client.classify_text(
        text[:512],
        model_id="facebook/bart-large-mnli",
        candidate_labels=categories,
    )

    return {
        "text_preview": text[:100] + "..." if len(text) > 100 else text,
        "categories": categories,
        "classification": result,
        "top_category": result.get("labels", [None])[0]
        if isinstance(result, dict)
        else None,
        "analyzed_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def summarize_article(
    text: str,
    max_length: int = 150,
    min_length: int = 30,
    model_id: str = "facebook/bart-large-cnn",
) -> Dict[str, Any]:
    """
    뉴스 기사를 요약합니다.

    Args:
        text: 요약할 텍스트
        max_length: 최대 요약 길이 (토큰)
        min_length: 최소 요약 길이 (토큰)
        model_id: 요약 모델 ID

    Returns:
        요약된 텍스트
    """
    client = get_hf_client()
    result = await client.summarize_text(
        text[:1024],
        model_id=model_id,
        max_length=max_length,
        min_length=min_length,
    )

    summary = ""
    if isinstance(result, dict):
        if (
            "results" in result
            and isinstance(result["results"], list)
            and len(result["results"]) > 0
        ):
            first_result = result["results"][0]
            if isinstance(first_result, dict):
                summary = first_result.get("summary_text", "")
        else:
            summary = result.get("summary_text", "")

    return {
        "original_length": len(text),
        "summary": summary,
        "summary_length": len(summary),
        "compression_ratio": round(len(summary) / len(text), 2) if text else 0,
        "model": model_id,
        "analyzed_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def extract_entities(
    text: str,
    model_id: str = "dslim/bert-base-NER",
) -> Dict[str, Any]:
    """
    텍스트에서 개체명을 추출합니다 (인물, 조직, 장소 등).

    Args:
        text: 분석할 텍스트
        model_id: NER 모델 ID

    Returns:
        추출된 개체명 (유형별 그룹화)
    """
    client = get_hf_client()
    result = await client.extract_entities(text[:512], model_id)

    # 엔티티 유형 한글화
    type_map = {
        "PER": "인물",
        "ORG": "조직",
        "LOC": "장소",
        "MISC": "기타",
        "DATE": "날짜",
        "TIME": "시간",
        "MONEY": "금액",
        "PERCENT": "비율",
    }

    grouped_kr = {}
    for entity_type, entities in result.get("grouped", {}).items():
        kr_type = type_map.get(entity_type, entity_type)
        grouped_kr[kr_type] = entities

    return {
        "text_preview": text[:100] + "..." if len(text) > 100 else text,
        "entities": grouped_kr,
        "total_count": result.get("total_count", 0),
        "model": model_id,
        "analyzed_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def extract_keywords(
    text: str,
) -> Dict[str, Any]:
    """
    텍스트에서 핵심 키워드를 추출합니다.

    Args:
        text: 분석할 텍스트

    Returns:
        추출된 키워드 목록
    """
    client = get_hf_client()
    result = await client.extract_keywords(text[:512])

    return {
        "text_preview": text[:100] + "..." if len(text) > 100 else text,
        "keywords": result.get("keywords", []),
        "analyzed_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def answer_question(
    question: str,
    context: str,
    model_id: str = "deepset/roberta-base-squad2",
) -> Dict[str, Any]:
    """
    문서 기반 질의응답을 수행합니다.

    뉴스 기사 본문에서 특정 질문에 대한 답을 찾습니다.

    Args:
        question: 질문
        context: 답변을 찾을 문서 (기사 본문)
        model_id: QA 모델 ID

    Returns:
        답변과 신뢰도
    """
    client = get_hf_client()
    result = await client.question_answering(question, context[:1024], model_id)

    return {
        "question": question,
        "answer": result.get("answer", ""),
        "confidence": result.get("score", 0),
        "start": result.get("start", 0),
        "end": result.get("end", 0),
        "model": model_id,
        "analyzed_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def analyze_article_full(
    title: str,
    content: str,
    include_sentiment: bool = True,
    include_entities: bool = True,
    include_summary: bool = True,
    include_keywords: bool = True,
    include_classification: bool = True,
) -> Dict[str, Any]:
    """
    뉴스 기사를 종합적으로 분석합니다.

    감성, 개체명, 요약, 키워드, 분류를 한 번에 수행합니다.

    Args:
        title: 기사 제목
        content: 기사 본문
        include_sentiment: 감성 분석 포함
        include_entities: 개체명 추출 포함
        include_summary: 요약 포함
        include_keywords: 키워드 추출 포함
        include_classification: 카테고리 분류 포함

    Returns:
        종합 분석 결과
    """
    result = await analyze_news_article(
        title=title,
        content=content,
        include_sentiment=include_sentiment,
        include_entities=include_entities,
        include_summary=include_summary,
        include_keywords=include_keywords,
        include_classification=include_classification,
    )
    return result


@server.tool()
async def start_batch_analysis(
    articles: List[Dict[str, str]],
    include_sentiment: bool = True,
    include_entities: bool = True,
    include_summary: bool = True,
    include_keywords: bool = True,
    include_classification: bool = True,
) -> Dict[str, Any]:
    """
    여러 기사를 배치로 분석하는 Job을 시작합니다.

    Args:
        articles: 기사 목록 [{"id": "...", "title": "...", "content": "..."}]
        include_sentiment: 감성 분석 포함
        include_entities: 개체명 추출 포함
        include_summary: 요약 포함
        include_keywords: 키워드 추출 포함
        include_classification: 카테고리 분류 포함

    Returns:
        Job ID 및 예상 처리 시간
    """
    if not articles:
        return {"error": "기사 목록이 필요합니다."}

    if len(articles) > 50:
        return {"error": "한 번에 최대 50개 기사만 처리할 수 있습니다."}

    job_id = create_job(
        "batch_analysis",
        {
            "article_count": len(articles),
        },
    )

    analysis_options = {
        "include_sentiment": include_sentiment,
        "include_entities": include_entities,
        "include_summary": include_summary,
        "include_keywords": include_keywords,
        "include_classification": include_classification,
    }

    asyncio.create_task(process_batch_articles(job_id, articles, analysis_options))

    return {
        "job_id": job_id,
        "status": JobStatus.PENDING,
        "article_count": len(articles),
        "estimated_time_seconds": len(articles) * 10,
        "message": f"배치 분석이 시작되었습니다. get_job_status('{job_id}')로 진행 상황을 확인하세요.",
    }


@server.tool()
async def get_job_status(
    job_id: str,
) -> Dict[str, Any]:
    """
    Job의 현재 상태를 조회합니다.

    Args:
        job_id: 조회할 Job ID

    Returns:
        Job 상태, 진행률, 결과
    """
    job = get_job(job_id)
    if not job:
        return {"error": f"Job을 찾을 수 없습니다: {job_id}"}

    response = {
        "job_id": job["id"],
        "type": job["type"],
        "status": job["status"],
        "progress": job["progress"],
        "created_at": job["created_at"],
        "updated_at": job["updated_at"],
    }

    if job["status"] == JobStatus.COMPLETED:
        response["result"] = job["result"]
    elif job["status"] == JobStatus.FAILED:
        response["error"] = job["error"]

    return response


@server.tool()
async def search_models(
    query: str,
    task: Optional[str] = None,
    limit: int = 10,
) -> Dict[str, Any]:
    """
    Hugging Face Hub에서 모델을 검색합니다.

    Args:
        query: 검색어 (예: "korean sentiment", "news classification")
        task: 태스크 필터 (text-classification, summarization, ner 등)
        limit: 최대 결과 수

    Returns:
        검색된 모델 목록
    """
    client = get_hf_client()
    models = await client.search_models(query, task, limit)

    # 결과 정리
    results = []
    for model in models:
        results.append(
            {
                "id": model.get("id", ""),
                "author": model.get("author", ""),
                "downloads": model.get("downloads", 0),
                "likes": model.get("likes", 0),
                "pipeline_tag": model.get("pipeline_tag", ""),
                "tags": model.get("tags", [])[:5],
            }
        )

    return {
        "query": query,
        "task_filter": task,
        "count": len(results),
        "models": results,
    }


@server.tool()
async def list_recommended_models() -> Dict[str, Any]:
    """
    NewsInsight에서 권장하는 NLP 모델 목록을 반환합니다.

    Returns:
        태스크별 권장 모델 목록
    """
    return {
        "sentiment_analysis": [
            {
                "id": "cardiffnlp/twitter-roberta-base-sentiment-latest",
                "description": "Twitter 데이터 학습, 범용 감성 분석",
                "languages": ["en"],
            },
            {
                "id": "nlptown/bert-base-multilingual-uncased-sentiment",
                "description": "다국어 감성 분석 (1-5점)",
                "languages": ["multilingual"],
            },
        ],
        "text_classification": [
            {
                "id": "facebook/bart-large-mnli",
                "description": "Zero-shot 분류 (임의 레이블)",
                "languages": ["en"],
            },
        ],
        "summarization": [
            {
                "id": "facebook/bart-large-cnn",
                "description": "뉴스 요약에 최적화",
                "languages": ["en"],
            },
            {
                "id": "google/pegasus-xsum",
                "description": "극단적 요약 (1문장)",
                "languages": ["en"],
            },
        ],
        "named_entity_recognition": [
            {
                "id": "dslim/bert-base-NER",
                "description": "영어 NER (인물, 조직, 장소)",
                "languages": ["en"],
            },
        ],
        "question_answering": [
            {
                "id": "deepset/roberta-base-squad2",
                "description": "영어 문서 QA",
                "languages": ["en"],
            },
        ],
        "embeddings": [
            {
                "id": "sentence-transformers/all-MiniLM-L6-v2",
                "description": "빠르고 효율적인 문장 임베딩",
                "languages": ["en"],
            },
        ],
        "note": "한국어 모델은 Hub에서 'korean'으로 검색하여 사용하세요.",
    }


@server.tool()
async def health_check() -> Dict[str, Any]:
    """
    서버 상태 및 HuggingFace API 연결 상태를 확인합니다.

    Returns:
        서버 상태 정보
    """
    status = {
        "server": "HuggingFace NLP MCP",
        "version": "1.0.0",
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
        "token_configured": bool(HF_TOKEN),
        "data_dir": str(DATA_DIR),
        "active_jobs": len(
            [
                j
                for j in _jobs.values()
                if j["status"] in [JobStatus.PENDING, JobStatus.PROCESSING]
            ]
        ),
    }

    # API 연결 테스트
    try:
        client = get_hf_client()
        models = await client.search_models("test", limit=1)
        status["huggingface_api"] = "connected"
    except Exception as e:
        status["huggingface_api"] = f"error: {str(e)}"
        status["status"] = "degraded"

    return status


# ─────────────────────────────────────────────
# 8. HTTP 헬스체크 핸들러
# ─────────────────────────────────────────────

from http.server import HTTPServer, BaseHTTPRequestHandler
import threading


class HealthCheckHandler(BaseHTTPRequestHandler):
    """간단한 헬스체크 엔드포인트 핸들러"""

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = {
                "status": "healthy",
                "server": "huggingface-nlp-mcp",
                "version": "1.0.0",
            }
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


# ─────────────────────────────────────────────
# 9. 서버 시작
# ─────────────────────────────────────────────

if __name__ == "__main__":
    # 디렉토리 생성
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    RESULTS_DIR.mkdir(parents=True, exist_ok=True)

    print(f"Starting HuggingFace NLP MCP Server v1.0.0 on port {PORT}")
    print(f"HF Token configured: {bool(HF_TOKEN)}")
    print(f"Data directory: {DATA_DIR}")

    server.run(transport="streamable-http")

```

---

## mcp/kaggle_mcp/server.py

```py
"""
Kaggle MCP Server - 데이터셋 및 Kernels 연동

Kaggle 데이터셋 검색/다운로드 및 Kernel 실행을 위한 MCP 서버입니다.
원격 GPU를 활용한 ML 학습이 가능합니다.

Version: 1.0.0
Port: 5012
"""

import os
import json
import uuid
import asyncio
import subprocess
import shutil
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any
from pathlib import Path

import aiohttp
import aiofiles
from mcp.server import FastMCP
from starlette.responses import JSONResponse
from starlette.requests import Request

# ─────────────────────────────────────────────
# 1. MCP 서버 기본 설정
# ─────────────────────────────────────────────

# 포트 설정 (환경변수에서 읽음)
PORT = int(os.environ.get("PORT", "5012"))

server = FastMCP(
    "kaggle-ml-mcp",
    host="0.0.0.0",
    port=PORT,
)


# Health check endpoint
@server.custom_route("/health", methods=["GET"])
async def health_endpoint(request: Request) -> JSONResponse:
    return JSONResponse(
        {
            "status": "healthy",
            "server": "kaggle-ml-mcp",
            "version": "1.0.0",
        }
    )


# Kaggle API 설정
KAGGLE_USERNAME = os.environ.get("KAGGLE_USERNAME", "")
KAGGLE_KEY = os.environ.get("KAGGLE_KEY", "")

# 공유 데이터 디렉토리
DATA_DIR = Path(os.environ.get("DATA_DIR", "/app/data"))
DATASETS_DIR = DATA_DIR / "datasets"
KERNELS_DIR = DATA_DIR / "kernels"
RESULTS_DIR = DATA_DIR / "results"

# ─────────────────────────────────────────────
# 2. Job Queue 관리 (In-Memory)
# ─────────────────────────────────────────────


class JobStatus:
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"


_jobs: Dict[str, Dict[str, Any]] = {}


def create_job(job_type: str, params: Dict[str, Any]) -> str:
    """새 Job을 생성하고 Job ID를 반환합니다."""
    job_id = str(uuid.uuid4())
    _jobs[job_id] = {
        "id": job_id,
        "type": job_type,
        "status": JobStatus.PENDING,
        "params": params,
        "result": None,
        "error": None,
        "created_at": datetime.utcnow().isoformat(),
        "updated_at": datetime.utcnow().isoformat(),
        "progress": 0,
    }
    return job_id


def update_job(job_id: str, **kwargs):
    """Job 상태를 업데이트합니다."""
    if job_id in _jobs:
        _jobs[job_id].update(kwargs)
        _jobs[job_id]["updated_at"] = datetime.utcnow().isoformat()


def get_job(job_id: str) -> Optional[Dict[str, Any]]:
    """Job 정보를 조회합니다."""
    return _jobs.get(job_id)


# ─────────────────────────────────────────────
# 3. Kaggle API 초기화
# ─────────────────────────────────────────────


def setup_kaggle_credentials():
    """Kaggle 자격 증명을 설정합니다."""
    kaggle_dir = Path.home() / ".kaggle"
    kaggle_dir.mkdir(exist_ok=True)

    kaggle_json = kaggle_dir / "kaggle.json"

    if KAGGLE_USERNAME and KAGGLE_KEY:
        credentials = {"username": KAGGLE_USERNAME, "key": KAGGLE_KEY}
        with open(kaggle_json, "w") as f:
            json.dump(credentials, f)
        kaggle_json.chmod(0o600)
        return True

    return kaggle_json.exists()


def run_kaggle_command(args: List[str], cwd: Optional[Path] = None) -> Dict[str, Any]:
    """Kaggle CLI 명령을 실행합니다."""
    try:
        result = subprocess.run(
            ["kaggle"] + args, capture_output=True, text=True, timeout=300, cwd=cwd
        )
        return {
            "success": result.returncode == 0,
            "stdout": result.stdout,
            "stderr": result.stderr,
            "returncode": result.returncode,
        }
    except subprocess.TimeoutExpired:
        return {
            "success": False,
            "error": "명령 실행 시간 초과 (5분)",
            "returncode": -1,
        }
    except Exception as e:
        return {"success": False, "error": str(e), "returncode": -1}


# ─────────────────────────────────────────────
# 4. 데이터셋 관련 함수
# ─────────────────────────────────────────────


async def search_datasets(
    query: str,
    sort_by: str = "hottest",
    file_type: Optional[str] = None,
    license_name: Optional[str] = None,
    max_size: Optional[int] = None,
    page: int = 1,
    page_size: int = 20,
) -> Dict[str, Any]:
    """
    Kaggle 데이터셋을 검색합니다.

    Args:
        query: 검색어
        sort_by: 정렬 기준 (hottest, votes, updated, relevance)
        file_type: 파일 타입 필터 (csv, json, sqlite 등)
        license_name: 라이센스 필터
        max_size: 최대 크기 (bytes)
        page: 페이지 번호
        page_size: 페이지 크기
    """
    args = ["datasets", "list", "-s", query, "--sort-by", sort_by]

    if file_type:
        args.extend(["--file-type", file_type])
    if license_name:
        args.extend(["--license-name", license_name])
    if max_size:
        args.extend(["--max-size", str(max_size)])

    args.extend(["-p", str(page)])
    args.extend(["--page-size", str(page_size)])
    args.extend(["--csv"])

    result = run_kaggle_command(args)

    if not result["success"]:
        return {"error": result.get("stderr") or result.get("error")}

    # CSV 파싱
    lines = result["stdout"].strip().split("\n")
    if len(lines) < 2:
        return {"datasets": [], "count": 0}

    headers = lines[0].split(",")
    datasets = []

    for line in lines[1:]:
        values = line.split(",")
        if len(values) >= len(headers):
            dataset = dict(zip(headers, values))
            datasets.append(dataset)

    return {
        "query": query,
        "sort_by": sort_by,
        "page": page,
        "datasets": datasets,
        "count": len(datasets),
    }


async def download_dataset(
    dataset_ref: str,
    job_id: str,
    unzip: bool = True,
) -> Dict[str, Any]:
    """
    데이터셋을 다운로드합니다.

    Args:
        dataset_ref: 데이터셋 참조 (예: "username/dataset-name")
        job_id: Job ID
        unzip: 압축 해제 여부
    """
    update_job(job_id, status=JobStatus.PROCESSING, progress=10)

    # 다운로드 디렉토리 생성
    dataset_dir = DATASETS_DIR / dataset_ref.replace("/", "_")
    dataset_dir.mkdir(parents=True, exist_ok=True)

    args = ["datasets", "download", "-d", dataset_ref, "-p", str(dataset_dir)]
    if unzip:
        args.append("--unzip")

    update_job(job_id, progress=30)

    result = run_kaggle_command(args)

    if not result["success"]:
        update_job(
            job_id,
            status=JobStatus.FAILED,
            error=result.get("stderr") or result.get("error"),
        )
        return {"error": result.get("stderr") or result.get("error")}

    update_job(job_id, progress=80)

    # 다운로드된 파일 목록
    files = []
    for f in dataset_dir.rglob("*"):
        if f.is_file():
            files.append(
                {
                    "name": f.name,
                    "path": str(f.relative_to(DATA_DIR)),
                    "size": f.stat().st_size,
                }
            )

    final_result = {
        "dataset_ref": dataset_ref,
        "download_path": str(dataset_dir),
        "files": files,
        "file_count": len(files),
        "total_size": sum(f["size"] for f in files),
    }

    update_job(job_id, status=JobStatus.COMPLETED, result=final_result, progress=100)
    return final_result


async def get_dataset_metadata(dataset_ref: str) -> Dict[str, Any]:
    """
    데이터셋 메타데이터를 조회합니다.
    """
    args = ["datasets", "metadata", "-d", dataset_ref]
    result = run_kaggle_command(args)

    if not result["success"]:
        return {"error": result.get("stderr") or result.get("error")}

    try:
        metadata = json.loads(result["stdout"])
        return metadata
    except json.JSONDecodeError:
        return {"raw_output": result["stdout"]}


# ─────────────────────────────────────────────
# 5. Kernel 관련 함수
# ─────────────────────────────────────────────


async def search_kernels(
    query: str,
    kernel_type: Optional[str] = None,
    output_type: Optional[str] = None,
    sort_by: str = "hotness",
    page: int = 1,
    page_size: int = 20,
) -> Dict[str, Any]:
    """
    Kaggle Kernels(Notebooks)를 검색합니다.

    Args:
        query: 검색어
        kernel_type: script, notebook
        output_type: all, visualization, data
        sort_by: hotness, commentCount, dateCreated, dateRun, relevance, voteCount
        page: 페이지 번호
        page_size: 페이지 크기
    """
    args = ["kernels", "list", "-s", query, "--sort-by", sort_by]

    if kernel_type:
        args.extend(["--kernel-type", kernel_type])
    if output_type:
        args.extend(["--output-type", output_type])

    args.extend(["-p", str(page)])
    args.extend(["--page-size", str(page_size)])
    args.extend(["--csv"])

    result = run_kaggle_command(args)

    if not result["success"]:
        return {"error": result.get("stderr") or result.get("error")}

    # CSV 파싱
    lines = result["stdout"].strip().split("\n")
    if len(lines) < 2:
        return {"kernels": [], "count": 0}

    headers = lines[0].split(",")
    kernels = []

    for line in lines[1:]:
        values = line.split(",")
        if len(values) >= len(headers):
            kernel = dict(zip(headers, values))
            kernels.append(kernel)

    return {
        "query": query,
        "sort_by": sort_by,
        "page": page,
        "kernels": kernels,
        "count": len(kernels),
    }


async def get_kernel_output(kernel_ref: str) -> Dict[str, Any]:
    """
    Kernel 실행 결과를 다운로드합니다.
    """
    output_dir = RESULTS_DIR / kernel_ref.replace("/", "_")
    output_dir.mkdir(parents=True, exist_ok=True)

    args = ["kernels", "output", kernel_ref, "-p", str(output_dir)]
    result = run_kaggle_command(args)

    if not result["success"]:
        return {"error": result.get("stderr") or result.get("error")}

    # 다운로드된 파일 목록
    files = []
    for f in output_dir.rglob("*"):
        if f.is_file():
            files.append(
                {
                    "name": f.name,
                    "path": str(f.relative_to(DATA_DIR)),
                    "size": f.stat().st_size,
                }
            )

    return {
        "kernel_ref": kernel_ref,
        "output_path": str(output_dir),
        "files": files,
        "file_count": len(files),
    }


async def push_kernel(
    job_id: str,
    kernel_name: str,
    code_file: str,
    language: str = "python",
    kernel_type: str = "script",
    dataset_sources: Optional[List[str]] = None,
    competition_sources: Optional[List[str]] = None,
    enable_gpu: bool = False,
    enable_internet: bool = True,
) -> Dict[str, Any]:
    """
    새로운 Kernel을 Kaggle에 푸시합니다 (원격 실행용).

    Args:
        job_id: Job ID
        kernel_name: 커널 이름
        code_file: 코드 파일 경로 (DATA_DIR 기준)
        language: python, r
        kernel_type: script, notebook
        dataset_sources: 사용할 데이터셋 목록
        competition_sources: 사용할 competition 목록
        enable_gpu: GPU 사용 여부
        enable_internet: 인터넷 사용 여부
    """
    update_job(job_id, status=JobStatus.PROCESSING, progress=10)

    if not KAGGLE_USERNAME:
        update_job(
            job_id,
            status=JobStatus.FAILED,
            error="KAGGLE_USERNAME이 설정되지 않았습니다.",
        )
        return {"error": "KAGGLE_USERNAME이 설정되지 않았습니다."}

    # 커널 디렉토리 생성
    kernel_dir = KERNELS_DIR / kernel_name
    kernel_dir.mkdir(parents=True, exist_ok=True)

    # 코드 파일 복사
    source_file = DATA_DIR / code_file
    if not source_file.exists():
        update_job(
            job_id,
            status=JobStatus.FAILED,
            error=f"코드 파일을 찾을 수 없습니다: {code_file}",
        )
        return {"error": f"코드 파일을 찾을 수 없습니다: {code_file}"}

    target_file = kernel_dir / source_file.name
    shutil.copy(source_file, target_file)

    update_job(job_id, progress=30)

    # kernel-metadata.json 생성
    kernel_slug = f"{KAGGLE_USERNAME}/{kernel_name}"
    metadata = {
        "id": kernel_slug,
        "title": kernel_name,
        "code_file": source_file.name,
        "language": language,
        "kernel_type": kernel_type,
        "is_private": True,
        "enable_gpu": enable_gpu,
        "enable_internet": enable_internet,
    }

    if dataset_sources:
        metadata["dataset_sources"] = dataset_sources
    if competition_sources:
        metadata["competition_sources"] = competition_sources

    metadata_file = kernel_dir / "kernel-metadata.json"
    with open(metadata_file, "w") as f:
        json.dump(metadata, f, indent=2)

    update_job(job_id, progress=50)

    # Kernel 푸시
    args = ["kernels", "push", "-p", str(kernel_dir)]
    result = run_kaggle_command(args)

    if not result["success"]:
        update_job(
            job_id,
            status=JobStatus.FAILED,
            error=result.get("stderr") or result.get("error"),
        )
        return {"error": result.get("stderr") or result.get("error")}

    update_job(job_id, progress=80)

    final_result = {
        "kernel_slug": kernel_slug,
        "kernel_url": f"https://www.kaggle.com/code/{kernel_slug}",
        "status": "pushed",
        "message": result["stdout"],
        "gpu_enabled": enable_gpu,
        "note": "커널이 Kaggle에 제출되었습니다. 실행 완료까지 시간이 걸릴 수 있습니다.",
    }

    update_job(job_id, status=JobStatus.COMPLETED, result=final_result, progress=100)
    return final_result


async def check_kernel_status(kernel_ref: str) -> Dict[str, Any]:
    """
    Kernel 실행 상태를 확인합니다.
    """
    args = ["kernels", "status", kernel_ref]
    result = run_kaggle_command(args)

    if not result["success"]:
        return {"error": result.get("stderr") or result.get("error")}

    # 상태 파싱
    output = result["stdout"].strip()
    status_map = {
        "queued": "대기 중",
        "running": "실행 중",
        "complete": "완료",
        "error": "오류",
        "cancelAcknowledged": "취소됨",
    }

    return {
        "kernel_ref": kernel_ref,
        "raw_status": output,
        "status_kr": status_map.get(output.lower(), output),
        "kernel_url": f"https://www.kaggle.com/code/{kernel_ref}",
    }


# ─────────────────────────────────────────────
# 6. MCP Tools
# ─────────────────────────────────────────────


@server.tool()
async def search_kaggle_datasets(
    query: str,
    sort_by: str = "hottest",
    file_type: Optional[str] = None,
    max_size_mb: Optional[int] = None,
    page: int = 1,
) -> Dict[str, Any]:
    """
    Kaggle에서 데이터셋을 검색합니다.

    뉴스 분석, 텍스트 분류 등에 활용할 수 있는 데이터셋을 찾습니다.

    Args:
        query: 검색어 (예: "news classification", "sentiment analysis")
        sort_by: 정렬 기준 (hottest, votes, updated, relevance)
        file_type: 파일 타입 필터 (csv, json, sqlite 등)
        max_size_mb: 최대 크기 (MB)
        page: 페이지 번호

    Returns:
        검색된 데이터셋 목록
    """
    max_size = max_size_mb * 1024 * 1024 if max_size_mb else None
    result = await search_datasets(
        query=query, sort_by=sort_by, file_type=file_type, max_size=max_size, page=page
    )
    result["searched_at"] = datetime.utcnow().isoformat()
    return result


@server.tool()
async def download_kaggle_dataset(
    dataset_ref: str,
    unzip: bool = True,
) -> Dict[str, Any]:
    """
    Kaggle 데이터셋을 다운로드합니다.

    Args:
        dataset_ref: 데이터셋 참조 (예: "username/dataset-name")
        unzip: 압축 해제 여부

    Returns:
        Job ID - get_job_status로 진행 상황 확인
    """
    job_id = create_job(
        "dataset_download", {"dataset_ref": dataset_ref, "unzip": unzip}
    )

    asyncio.create_task(download_dataset(dataset_ref, job_id, unzip))

    return {
        "job_id": job_id,
        "status": JobStatus.PENDING,
        "dataset_ref": dataset_ref,
        "message": f"다운로드가 시작되었습니다. get_job_status('{job_id}')로 진행 상황을 확인하세요.",
    }


@server.tool()
async def get_dataset_info(
    dataset_ref: str,
) -> Dict[str, Any]:
    """
    데이터셋의 상세 정보를 조회합니다.

    Args:
        dataset_ref: 데이터셋 참조 (예: "username/dataset-name")

    Returns:
        데이터셋 메타데이터 (크기, 파일 목록, 설명 등)
    """
    return await get_dataset_metadata(dataset_ref)


@server.tool()
async def search_kaggle_kernels(
    query: str,
    kernel_type: Optional[str] = None,
    sort_by: str = "hotness",
    page: int = 1,
) -> Dict[str, Any]:
    """
    Kaggle Kernels(Notebooks)를 검색합니다.

    ML 학습 코드, 데이터 분석 코드 등을 찾습니다.

    Args:
        query: 검색어 (예: "news classification bert")
        kernel_type: script, notebook
        sort_by: hotness, commentCount, dateCreated, relevance, voteCount
        page: 페이지 번호

    Returns:
        검색된 커널 목록
    """
    result = await search_kernels(
        query=query, kernel_type=kernel_type, sort_by=sort_by, page=page
    )
    result["searched_at"] = datetime.utcnow().isoformat()
    return result


@server.tool()
async def submit_training_kernel(
    kernel_name: str,
    code_file: str,
    dataset_sources: Optional[List[str]] = None,
    enable_gpu: bool = False,
) -> Dict[str, Any]:
    """
    ML 학습 Kernel을 Kaggle에 제출합니다 (원격 GPU 실행).

    코드 파일을 Kaggle에 업로드하고 원격으로 실행합니다.
    Kaggle의 무료 GPU/TPU를 활용할 수 있습니다.

    Args:
        kernel_name: 커널 이름 (고유해야 함)
        code_file: 코드 파일 경로 (DATA_DIR 기준, 예: "scripts/train.py")
        dataset_sources: 사용할 데이터셋 목록 (예: ["username/dataset-name"])
        enable_gpu: GPU 사용 여부 (P100 GPU)

    Returns:
        Job ID - get_job_status로 진행 상황 확인
    """
    job_id = create_job(
        "kernel_push",
        {"kernel_name": kernel_name, "code_file": code_file, "enable_gpu": enable_gpu},
    )

    asyncio.create_task(
        push_kernel(
            job_id=job_id,
            kernel_name=kernel_name,
            code_file=code_file,
            dataset_sources=dataset_sources,
            enable_gpu=enable_gpu,
        )
    )

    return {
        "job_id": job_id,
        "status": JobStatus.PENDING,
        "kernel_name": kernel_name,
        "gpu_enabled": enable_gpu,
        "message": f"커널 제출이 시작되었습니다. get_job_status('{job_id}')로 진행 상황을 확인하세요.",
    }


@server.tool()
async def get_kernel_status(
    kernel_ref: str,
) -> Dict[str, Any]:
    """
    제출된 Kernel의 실행 상태를 확인합니다.

    Args:
        kernel_ref: 커널 참조 (예: "username/kernel-name")

    Returns:
        커널 실행 상태 (queued, running, complete, error)
    """
    return await check_kernel_status(kernel_ref)


@server.tool()
async def download_kernel_output(
    kernel_ref: str,
) -> Dict[str, Any]:
    """
    완료된 Kernel의 출력 파일을 다운로드합니다.

    학습된 모델 파일, 결과 CSV 등을 가져옵니다.

    Args:
        kernel_ref: 커널 참조 (예: "username/kernel-name")

    Returns:
        다운로드된 파일 목록
    """
    return await get_kernel_output(kernel_ref)


@server.tool()
async def list_local_datasets() -> Dict[str, Any]:
    """
    로컬에 다운로드된 데이터셋 목록을 조회합니다.

    Returns:
        로컬 데이터셋 목록 및 파일 정보
    """
    DATASETS_DIR.mkdir(parents=True, exist_ok=True)

    datasets = []
    for dataset_dir in DATASETS_DIR.iterdir():
        if dataset_dir.is_dir():
            files = []
            total_size = 0
            for f in dataset_dir.rglob("*"):
                if f.is_file():
                    size = f.stat().st_size
                    files.append(
                        {
                            "name": f.name,
                            "path": str(f.relative_to(DATA_DIR)),
                            "size": size,
                        }
                    )
                    total_size += size

            datasets.append(
                {
                    "name": dataset_dir.name,
                    "path": str(dataset_dir.relative_to(DATA_DIR)),
                    "files": files[:10],  # 처음 10개만
                    "file_count": len(files),
                    "total_size": total_size,
                    "total_size_mb": round(total_size / 1024 / 1024, 2),
                }
            )

    return {"datasets": datasets, "count": len(datasets), "data_dir": str(DATA_DIR)}


@server.tool()
async def get_job_status(
    job_id: str,
) -> Dict[str, Any]:
    """
    Job의 현재 상태를 조회합니다.

    Args:
        job_id: 조회할 Job ID

    Returns:
        Job 상태, 진행률, 결과
    """
    job = get_job(job_id)
    if not job:
        return {"error": f"Job을 찾을 수 없습니다: {job_id}"}

    response = {
        "job_id": job["id"],
        "type": job["type"],
        "status": job["status"],
        "progress": job["progress"],
        "created_at": job["created_at"],
        "updated_at": job["updated_at"],
    }

    if job["status"] == JobStatus.COMPLETED:
        response["result"] = job["result"]
    elif job["status"] == JobStatus.FAILED:
        response["error"] = job["error"]

    return response


@server.tool()
async def health_check() -> Dict[str, Any]:
    """
    서버 상태 및 Kaggle API 연결 상태를 확인합니다.

    Returns:
        서버 상태 정보
    """
    # 자격 증명 설정
    credentials_ok = setup_kaggle_credentials()

    status = {
        "server": "Kaggle ML MCP",
        "version": "1.0.0",
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
        "credentials_configured": bool(KAGGLE_USERNAME and KAGGLE_KEY),
        "credentials_file_exists": credentials_ok,
        "data_dir": str(DATA_DIR),
        "active_jobs": len(
            [
                j
                for j in _jobs.values()
                if j["status"] in [JobStatus.PENDING, JobStatus.PROCESSING]
            ]
        ),
    }

    # API 연결 테스트
    if credentials_ok:
        test_result = run_kaggle_command(
            ["datasets", "list", "-s", "test", "--page-size", "1"]
        )
        if test_result["success"]:
            status["kaggle_api"] = "connected"
        else:
            status["kaggle_api"] = f"error: {test_result.get('stderr', 'unknown')}"
            status["status"] = "degraded"
    else:
        status["kaggle_api"] = "not_configured"
        status["status"] = "degraded"

    return status


# ─────────────────────────────────────────────
# 7. HTTP 헬스체크 핸들러
# ─────────────────────────────────────────────

from http.server import HTTPServer, BaseHTTPRequestHandler
import threading


class HealthCheckHandler(BaseHTTPRequestHandler):
    """간단한 헬스체크 엔드포인트 핸들러"""

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = {
                "status": "healthy",
                "server": "kaggle-ml-mcp",
                "version": "1.0.0",
            }
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


# ─────────────────────────────────────────────
# 8. 서버 시작
# ─────────────────────────────────────────────

if __name__ == "__main__":
    # 디렉토리 생성
    DATASETS_DIR.mkdir(parents=True, exist_ok=True)
    KERNELS_DIR.mkdir(parents=True, exist_ok=True)
    RESULTS_DIR.mkdir(parents=True, exist_ok=True)

    # Kaggle 자격 증명 설정
    setup_kaggle_credentials()

    print(f"Starting Kaggle ML MCP Server v1.0.0 on port {PORT}")
    print(f"Kaggle credentials configured: {bool(KAGGLE_USERNAME and KAGGLE_KEY)}")
    print(f"Data directory: {DATA_DIR}")

    server.run(transport="streamable-http")

```

---

## mcp/mltraining_mcp/server.py

```py
"""
ML Training Orchestrator MCP Server - 통합 ML 워크플로우 관리

여러 ML MCP 서버(Roboflow, HuggingFace, Kaggle)를 오케스트레이션하여
뉴스 분석을 위한 종합적인 ML 워크플로우를 제공합니다.

Version: 1.0.0
Port: 5020
"""

import os
import json
import uuid
import asyncio
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any, Callable
from pathlib import Path
from enum import Enum

import aiohttp
import aiofiles
import yaml
from mcp.server import FastMCP
from starlette.responses import JSONResponse
from starlette.requests import Request

# ─────────────────────────────────────────────
# 1. MCP 서버 기본 설정
# ─────────────────────────────────────────────

# 포트 설정 (환경변수에서 읽음)
PORT = int(os.environ.get("PORT", "5020"))

server = FastMCP(
    "ml-training-orchestrator",
    host="0.0.0.0",
    port=PORT,
)


# Health check endpoint
@server.custom_route("/health", methods=["GET"])
async def health_endpoint(request: Request) -> JSONResponse:
    return JSONResponse(
        {
            "status": "healthy",
            "server": "ml-training-orchestrator",
            "version": "1.0.0",
        }
    )


# 하위 MCP 서버 URL
ROBOFLOW_MCP_URL = os.environ.get("ROBOFLOW_MCP_URL", "http://roboflow-mcp:5010")
HUGGINGFACE_MCP_URL = os.environ.get(
    "HUGGINGFACE_MCP_URL", "http://huggingface-mcp:5011"
)
KAGGLE_MCP_URL = os.environ.get("KAGGLE_MCP_URL", "http://kaggle-mcp:5012")

# 공유 데이터 디렉토리
DATA_DIR = Path(os.environ.get("DATA_DIR", "/app/data"))
WORKFLOWS_DIR = DATA_DIR / "workflows"
PIPELINES_DIR = DATA_DIR / "pipelines"

# ─────────────────────────────────────────────
# 2. 워크플로우 상태 관리
# ─────────────────────────────────────────────


class WorkflowStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class StepStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


# 워크플로우 저장소
_workflows: Dict[str, Dict[str, Any]] = {}


def create_workflow(name: str, description: str, steps: List[Dict]) -> str:
    """새 워크플로우를 생성합니다."""
    workflow_id = str(uuid.uuid4())
    _workflows[workflow_id] = {
        "id": workflow_id,
        "name": name,
        "description": description,
        "status": WorkflowStatus.PENDING,
        "steps": [
            {
                **step,
                "status": StepStatus.PENDING,
                "result": None,
                "error": None,
                "started_at": None,
                "completed_at": None,
            }
            for step in steps
        ],
        "current_step": 0,
        "created_at": datetime.utcnow().isoformat(),
        "updated_at": datetime.utcnow().isoformat(),
        "completed_at": None,
    }
    return workflow_id


def update_workflow(workflow_id: str, **kwargs):
    """워크플로우 상태를 업데이트합니다."""
    if workflow_id in _workflows:
        _workflows[workflow_id].update(kwargs)
        _workflows[workflow_id]["updated_at"] = datetime.utcnow().isoformat()


def get_workflow(workflow_id: str) -> Optional[Dict[str, Any]]:
    """워크플로우 정보를 조회합니다."""
    return _workflows.get(workflow_id)


# ─────────────────────────────────────────────
# 3. MCP 클라이언트 (하위 서버 호출)
# ─────────────────────────────────────────────


class MCPClient:
    """하위 MCP 서버 호출 클라이언트"""

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip("/")

    async def call_tool(self, tool_name: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """MCP 도구를 호출합니다."""
        url = f"{self.base_url}/mcp"

        payload = {
            "jsonrpc": "2.0",
            "method": "tools/call",
            "params": {"name": tool_name, "arguments": params},
            "id": str(uuid.uuid4()),
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(
                url, json=payload, timeout=aiohttp.ClientTimeout(total=300)
            ) as resp:
                if resp.status != 200:
                    text = await resp.text()
                    raise Exception(f"MCP 호출 실패: {resp.status} - {text}")

                result = await resp.json()
                if "error" in result:
                    raise Exception(f"MCP 오류: {result['error']}")

                return result.get("result", {})

    async def health_check(self) -> bool:
        """서버 상태를 확인합니다."""
        try:
            url = f"{self.base_url}/health"
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url, timeout=aiohttp.ClientTimeout(total=10)
                ) as resp:
                    return resp.status == 200
        except:
            return False


# 클라이언트 인스턴스
roboflow_client = MCPClient(ROBOFLOW_MCP_URL)
huggingface_client = MCPClient(HUGGINGFACE_MCP_URL)
kaggle_client = MCPClient(KAGGLE_MCP_URL)


# ─────────────────────────────────────────────
# 4. 워크플로우 실행 엔진
# ─────────────────────────────────────────────


async def execute_step(
    workflow_id: str, step_index: int, step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """단일 스텝을 실행합니다."""
    workflow = get_workflow(workflow_id)
    if not workflow:
        raise Exception(f"워크플로우를 찾을 수 없습니다: {workflow_id}")

    # 스텝 시작
    workflow["steps"][step_index]["status"] = StepStatus.RUNNING
    workflow["steps"][step_index]["started_at"] = datetime.utcnow().isoformat()
    update_workflow(workflow_id, current_step=step_index)

    try:
        # 파라미터 템플릿 처리 (이전 스텝 결과 참조)
        params = resolve_params(step.get("params", {}), context)

        # MCP 서버 선택 및 도구 호출
        service = step.get("service", "").lower()
        tool = step.get("tool", "")

        if service == "roboflow":
            result = await roboflow_client.call_tool(tool, params)
        elif service == "huggingface":
            result = await huggingface_client.call_tool(tool, params)
        elif service == "kaggle":
            result = await kaggle_client.call_tool(tool, params)
        elif service == "internal":
            result = await execute_internal_function(tool, params, context)
        else:
            raise Exception(f"알 수 없는 서비스: {service}")

        # 스텝 완료
        workflow["steps"][step_index]["status"] = StepStatus.COMPLETED
        workflow["steps"][step_index]["result"] = result
        workflow["steps"][step_index]["completed_at"] = datetime.utcnow().isoformat()

        return result

    except Exception as e:
        workflow["steps"][step_index]["status"] = StepStatus.FAILED
        workflow["steps"][step_index]["error"] = str(e)
        workflow["steps"][step_index]["completed_at"] = datetime.utcnow().isoformat()
        raise


def resolve_params(params: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
    """파라미터 템플릿을 해석합니다."""
    resolved = {}

    for key, value in params.items():
        if isinstance(value, str) and value.startswith("$"):
            # 컨텍스트 참조 (예: $steps.0.result.data)
            path = value[1:].split(".")
            resolved[key] = get_nested_value(context, path)
        elif isinstance(value, dict):
            resolved[key] = resolve_params(value, context)
        elif isinstance(value, list):
            resolved[key] = [
                resolve_params(item, context) if isinstance(item, dict) else item
                for item in value
            ]
        else:
            resolved[key] = value

    return resolved


def get_nested_value(obj: Any, path: List[str]) -> Any:
    """중첩된 값을 가져옵니다."""
    for key in path:
        if isinstance(obj, dict):
            obj = obj.get(key)
        elif isinstance(obj, list) and key.isdigit():
            obj = obj[int(key)]
        else:
            return None
    return obj


async def execute_internal_function(
    function_name: str, params: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """내부 함수를 실행합니다."""
    if function_name == "wait":
        seconds = params.get("seconds", 5)
        await asyncio.sleep(seconds)
        return {"waited": seconds}

    elif function_name == "log":
        message = params.get("message", "")
        print(f"[WORKFLOW] {message}")
        return {"logged": message}

    elif function_name == "merge_results":
        keys = params.get("keys", [])
        merged = {}
        for key in keys:
            path = key.split(".")
            value = get_nested_value(context, path)
            if value:
                merged[key] = value
        return {"merged": merged}

    elif function_name == "conditional":
        condition = params.get("condition", "")
        # 간단한 조건 평가 (실제로는 더 안전한 방법 필요)
        result = eval(condition, {"context": context})
        return {"condition_result": result}

    else:
        return {"error": f"알 수 없는 내부 함수: {function_name}"}


async def run_workflow(workflow_id: str):
    """워크플로우를 실행합니다."""
    workflow = get_workflow(workflow_id)
    if not workflow:
        return

    update_workflow(workflow_id, status=WorkflowStatus.RUNNING)

    context = {
        "workflow_id": workflow_id,
        "steps": [],
    }

    try:
        for i, step in enumerate(workflow["steps"]):
            # 조건부 스킵
            if step.get("condition"):
                condition_result = await execute_internal_function(
                    "conditional", {"condition": step["condition"]}, context
                )
                if not condition_result.get("condition_result"):
                    workflow["steps"][i]["status"] = StepStatus.SKIPPED
                    context["steps"].append({"skipped": True})
                    continue

            # 스텝 실행
            result = await execute_step(workflow_id, i, step, context)
            context["steps"].append(result)

            # 실패 시 중단 (continue_on_error가 아니면)
            if workflow["steps"][i]["status"] == StepStatus.FAILED:
                if not step.get("continue_on_error"):
                    raise Exception(f"스텝 {i} 실패: {workflow['steps'][i]['error']}")

        # 워크플로우 완료
        update_workflow(
            workflow_id,
            status=WorkflowStatus.COMPLETED,
            completed_at=datetime.utcnow().isoformat(),
        )

    except Exception as e:
        update_workflow(
            workflow_id,
            status=WorkflowStatus.FAILED,
            completed_at=datetime.utcnow().isoformat(),
        )


# ─────────────────────────────────────────────
# 5. 사전 정의 파이프라인
# ─────────────────────────────────────────────

PREDEFINED_PIPELINES = {
    "news_article_analysis": {
        "name": "뉴스 기사 종합 분석",
        "description": "텍스트 분석 + 이미지 분석을 결합한 뉴스 기사 종합 분석",
        "steps": [
            {
                "name": "텍스트 감성 분석",
                "service": "huggingface",
                "tool": "analyze_sentiment",
                "params": {"text": "$input.text"},
            },
            {
                "name": "개체명 추출",
                "service": "huggingface",
                "tool": "extract_entities",
                "params": {"text": "$input.text"},
            },
            {
                "name": "키워드 추출",
                "service": "huggingface",
                "tool": "extract_keywords",
                "params": {"text": "$input.text"},
            },
            {
                "name": "뉴스 분류",
                "service": "huggingface",
                "tool": "classify_news",
                "params": {"text": "$input.title"},
            },
        ],
    },
    "news_image_analysis": {
        "name": "뉴스 이미지 종합 분석",
        "description": "뉴스 기사 이미지의 객체 탐지 및 텍스트 추출",
        "steps": [
            {
                "name": "객체 탐지",
                "service": "roboflow",
                "tool": "detect_objects",
                "params": {"image_url": "$input.image_url"},
            },
            {
                "name": "OCR 텍스트 추출",
                "service": "roboflow",
                "tool": "extract_text_ocr",
                "params": {"image_url": "$input.image_url"},
            },
        ],
    },
    "ml_training_pipeline": {
        "name": "ML 모델 학습 파이프라인",
        "description": "Kaggle 데이터셋 다운로드 → 학습 코드 제출 → 결과 수집",
        "steps": [
            {
                "name": "데이터셋 검색",
                "service": "kaggle",
                "tool": "search_kaggle_datasets",
                "params": {"query": "$input.dataset_query", "max_size_mb": 500},
            },
            {
                "name": "데이터셋 다운로드",
                "service": "kaggle",
                "tool": "download_kaggle_dataset",
                "params": {"dataset_ref": "$input.dataset_ref"},
            },
            {
                "name": "대기 (다운로드 완료)",
                "service": "internal",
                "tool": "wait",
                "params": {"seconds": 30},
            },
            {
                "name": "학습 Kernel 제출",
                "service": "kaggle",
                "tool": "submit_training_kernel",
                "params": {
                    "kernel_name": "$input.kernel_name",
                    "code_file": "$input.code_file",
                    "dataset_sources": "$input.dataset_sources",
                    "enable_gpu": "$input.enable_gpu",
                },
            },
        ],
    },
    "full_news_pipeline": {
        "name": "뉴스 기사 전체 분석 파이프라인",
        "description": "텍스트 + 이미지 + 요약을 포함한 전체 뉴스 분석",
        "steps": [
            {
                "name": "기사 요약",
                "service": "huggingface",
                "tool": "summarize_article",
                "params": {"text": "$input.content", "max_length": 150},
            },
            {
                "name": "감성 분석",
                "service": "huggingface",
                "tool": "analyze_sentiment",
                "params": {"text": "$input.title"},
            },
            {
                "name": "카테고리 분류",
                "service": "huggingface",
                "tool": "classify_news",
                "params": {"text": "$input.title"},
            },
            {
                "name": "개체명 추출",
                "service": "huggingface",
                "tool": "extract_entities",
                "params": {"text": "$input.content"},
            },
            {
                "name": "이미지 분석 (조건부)",
                "service": "roboflow",
                "tool": "analyze_news_image_full",
                "params": {"image_url": "$input.image_url"},
                "condition": "context.get('input', {}).get('image_url')",
                "continue_on_error": True,
            },
        ],
    },
}


# ─────────────────────────────────────────────
# 6. MCP Tools
# ─────────────────────────────────────────────


@server.tool()
async def list_pipelines() -> Dict[str, Any]:
    """
    사용 가능한 사전 정의 파이프라인 목록을 반환합니다.

    Returns:
        파이프라인 목록 및 설명
    """
    pipelines = []
    for key, pipeline in PREDEFINED_PIPELINES.items():
        pipelines.append(
            {
                "id": key,
                "name": pipeline["name"],
                "description": pipeline["description"],
                "step_count": len(pipeline["steps"]),
                "steps": [s["name"] for s in pipeline["steps"]],
            }
        )

    return {"pipelines": pipelines, "count": len(pipelines)}


@server.tool()
async def run_pipeline(
    pipeline_id: str,
    input_data: Dict[str, Any],
) -> Dict[str, Any]:
    """
    사전 정의된 파이프라인을 실행합니다.

    Args:
        pipeline_id: 파이프라인 ID (list_pipelines로 확인)
        input_data: 파이프라인 입력 데이터

    Returns:
        워크플로우 ID 및 상태
    """
    if pipeline_id not in PREDEFINED_PIPELINES:
        return {"error": f"파이프라인을 찾을 수 없습니다: {pipeline_id}"}

    pipeline = PREDEFINED_PIPELINES[pipeline_id]

    # 입력 데이터를 컨텍스트에 추가
    steps = []
    for step in pipeline["steps"]:
        step_copy = step.copy()
        # $input 참조를 실제 값으로 변환
        if "params" in step_copy:
            step_copy["params"] = resolve_input_params(step_copy["params"], input_data)
        steps.append(step_copy)

    workflow_id = create_workflow(
        name=pipeline["name"], description=pipeline["description"], steps=steps
    )

    # 비동기 실행
    asyncio.create_task(run_workflow(workflow_id))

    return {
        "workflow_id": workflow_id,
        "pipeline_id": pipeline_id,
        "pipeline_name": pipeline["name"],
        "status": WorkflowStatus.PENDING,
        "step_count": len(steps),
        "message": f"파이프라인이 시작되었습니다. get_workflow_status('{workflow_id}')로 진행 상황을 확인하세요.",
    }


def resolve_input_params(
    params: Dict[str, Any], input_data: Dict[str, Any]
) -> Dict[str, Any]:
    """$input 참조를 실제 값으로 변환합니다."""
    resolved = {}

    for key, value in params.items():
        if isinstance(value, str) and value.startswith("$input."):
            input_key = value[7:]  # "$input." 제거
            resolved[key] = input_data.get(input_key)
        elif isinstance(value, dict):
            resolved[key] = resolve_input_params(value, input_data)
        else:
            resolved[key] = value

    return resolved


@server.tool()
async def create_custom_workflow(
    name: str,
    description: str,
    steps: List[Dict[str, Any]],
) -> Dict[str, Any]:
    """
    커스텀 워크플로우를 생성합니다.

    Args:
        name: 워크플로우 이름
        description: 워크플로우 설명
        steps: 스텝 목록 [{service, tool, params, ...}]

    Returns:
        워크플로우 ID

    Example:
        steps = [
            {"service": "huggingface", "tool": "analyze_sentiment", "params": {"text": "..."}}
        ]
    """
    workflow_id = create_workflow(name, description, steps)

    return {
        "workflow_id": workflow_id,
        "name": name,
        "step_count": len(steps),
        "status": WorkflowStatus.PENDING,
        "message": "워크플로우가 생성되었습니다. start_workflow로 실행하세요.",
    }


@server.tool()
async def start_workflow(
    workflow_id: str,
) -> Dict[str, Any]:
    """
    생성된 워크플로우를 실행합니다.

    Args:
        workflow_id: 워크플로우 ID

    Returns:
        실행 상태
    """
    workflow = get_workflow(workflow_id)
    if not workflow:
        return {"error": f"워크플로우를 찾을 수 없습니다: {workflow_id}"}

    if workflow["status"] != WorkflowStatus.PENDING:
        return {
            "error": f"워크플로우가 이미 실행 중이거나 완료되었습니다: {workflow['status']}"
        }

    asyncio.create_task(run_workflow(workflow_id))

    return {
        "workflow_id": workflow_id,
        "status": WorkflowStatus.RUNNING,
        "message": "워크플로우가 시작되었습니다.",
    }


@server.tool()
async def get_workflow_status(
    workflow_id: str,
) -> Dict[str, Any]:
    """
    워크플로우의 현재 상태를 조회합니다.

    Args:
        workflow_id: 워크플로우 ID

    Returns:
        워크플로우 상태, 각 스텝 진행 상황, 결과
    """
    workflow = get_workflow(workflow_id)
    if not workflow:
        return {"error": f"워크플로우를 찾을 수 없습니다: {workflow_id}"}

    # 스텝 요약
    step_summary = []
    for i, step in enumerate(workflow["steps"]):
        step_summary.append(
            {
                "index": i,
                "name": step.get("name", f"Step {i}"),
                "service": step.get("service"),
                "tool": step.get("tool"),
                "status": step["status"],
                "has_result": step["result"] is not None,
                "error": step.get("error"),
            }
        )

    # 진행률 계산
    completed = sum(
        1
        for s in workflow["steps"]
        if s["status"] in [StepStatus.COMPLETED, StepStatus.SKIPPED]
    )
    progress = int(completed / len(workflow["steps"]) * 100) if workflow["steps"] else 0

    return {
        "workflow_id": workflow_id,
        "name": workflow["name"],
        "status": workflow["status"],
        "progress": progress,
        "current_step": workflow["current_step"],
        "total_steps": len(workflow["steps"]),
        "steps": step_summary,
        "created_at": workflow["created_at"],
        "updated_at": workflow["updated_at"],
        "completed_at": workflow.get("completed_at"),
    }


@server.tool()
async def get_workflow_results(
    workflow_id: str,
) -> Dict[str, Any]:
    """
    완료된 워크플로우의 전체 결과를 조회합니다.

    Args:
        workflow_id: 워크플로우 ID

    Returns:
        각 스텝의 상세 결과
    """
    workflow = get_workflow(workflow_id)
    if not workflow:
        return {"error": f"워크플로우를 찾을 수 없습니다: {workflow_id}"}

    results = []
    for i, step in enumerate(workflow["steps"]):
        results.append(
            {
                "index": i,
                "name": step.get("name", f"Step {i}"),
                "status": step["status"],
                "result": step["result"],
                "error": step.get("error"),
                "started_at": step.get("started_at"),
                "completed_at": step.get("completed_at"),
            }
        )

    return {
        "workflow_id": workflow_id,
        "name": workflow["name"],
        "status": workflow["status"],
        "results": results,
    }


@server.tool()
async def cancel_workflow(
    workflow_id: str,
) -> Dict[str, Any]:
    """
    실행 중인 워크플로우를 취소합니다.

    Args:
        workflow_id: 워크플로우 ID

    Returns:
        취소 결과
    """
    workflow = get_workflow(workflow_id)
    if not workflow:
        return {"error": f"워크플로우를 찾을 수 없습니다: {workflow_id}"}

    if workflow["status"] not in [WorkflowStatus.PENDING, WorkflowStatus.RUNNING]:
        return {"error": f"워크플로우를 취소할 수 없습니다: {workflow['status']}"}

    update_workflow(
        workflow_id,
        status=WorkflowStatus.CANCELLED,
        completed_at=datetime.utcnow().isoformat(),
    )

    return {
        "workflow_id": workflow_id,
        "status": WorkflowStatus.CANCELLED,
        "message": "워크플로우가 취소되었습니다.",
    }


@server.tool()
async def analyze_news_full(
    title: str,
    content: str,
    image_url: Optional[str] = None,
) -> Dict[str, Any]:
    """
    뉴스 기사를 원스톱으로 종합 분석합니다.

    텍스트 분석(감성, 분류, 개체명, 요약)과 이미지 분석(객체탐지, OCR)을
    한 번에 수행합니다.

    Args:
        title: 기사 제목
        content: 기사 본문
        image_url: 기사 이미지 URL (선택)

    Returns:
        워크플로우 ID - get_workflow_status로 결과 확인
    """
    input_data = {
        "title": title,
        "content": content,
    }
    if image_url:
        input_data["image_url"] = image_url

    return await run_pipeline("full_news_pipeline", input_data)


@server.tool()
async def check_services_status() -> Dict[str, Any]:
    """
    모든 하위 MCP 서비스의 상태를 확인합니다.

    Returns:
        각 서비스의 연결 상태
    """
    services = {
        "roboflow": {"url": ROBOFLOW_MCP_URL, "client": roboflow_client},
        "huggingface": {"url": HUGGINGFACE_MCP_URL, "client": huggingface_client},
        "kaggle": {"url": KAGGLE_MCP_URL, "client": kaggle_client},
    }

    results = {}
    for name, info in services.items():
        is_healthy = await info["client"].health_check()
        results[name] = {
            "url": info["url"],
            "status": "connected" if is_healthy else "disconnected",
            "healthy": is_healthy,
        }

    all_healthy = all(r["healthy"] for r in results.values())

    return {
        "overall_status": "healthy" if all_healthy else "degraded",
        "services": results,
        "checked_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def health_check() -> Dict[str, Any]:
    """
    오케스트레이터 서버 상태를 확인합니다.

    Returns:
        서버 상태 정보
    """
    status = {
        "server": "ML Training Orchestrator",
        "version": "1.0.0",
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
        "data_dir": str(DATA_DIR),
        "active_workflows": len(
            [w for w in _workflows.values() if w["status"] == WorkflowStatus.RUNNING]
        ),
        "total_workflows": len(_workflows),
        "available_pipelines": len(PREDEFINED_PIPELINES),
    }

    return status


# ─────────────────────────────────────────────
# 7. HTTP 헬스체크 핸들러
# ─────────────────────────────────────────────

from http.server import HTTPServer, BaseHTTPRequestHandler
import threading


class HealthCheckHandler(BaseHTTPRequestHandler):
    """간단한 헬스체크 엔드포인트 핸들러"""

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = {
                "status": "healthy",
                "server": "ml-training-orchestrator",
                "version": "1.0.0",
            }
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


# ─────────────────────────────────────────────
# 8. 서버 시작
# ─────────────────────────────────────────────

if __name__ == "__main__":
    # 디렉토리 생성
    WORKFLOWS_DIR.mkdir(parents=True, exist_ok=True)
    PIPELINES_DIR.mkdir(parents=True, exist_ok=True)

    print(f"Starting ML Training Orchestrator v1.0.0 on port {PORT}")
    print(f"Roboflow MCP: {ROBOFLOW_MCP_URL}")
    print(f"HuggingFace MCP: {HUGGINGFACE_MCP_URL}")
    print(f"Kaggle MCP: {KAGGLE_MCP_URL}")
    print(f"Data directory: {DATA_DIR}")

    server.run(transport="streamable-http")

```

---

## mcp/newsinsight_mcp/server.py

```py
"""
NewsInsight MCP Server - 감성 분석 및 여론 온도 제공

실제 프로젝트 스키마(collected_data, article_analysis, article_discussion)를 기반으로
기사 및 댓글 감성 분석, 여론 온도 계산 기능을 제공하는 MCP 서버입니다.

Version: 2.0.0
Port: 5000
"""

import os
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any

import requests
from mcp.server import FastMCP
from starlette.responses import JSONResponse
from starlette.requests import Request

# Shared modules
import sys
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from shared.db import get_postgres_conn, get_mongo_db, DB_BACKEND, check_db_connection
from shared.health import create_health_response
from shared.aidove import AIDOVE_WEBHOOK_URL, call_aidove

# ─────────────────────────────────────────────
# 1. MCP 서버 기본 설정
# ─────────────────────────────────────────────

# 포트 설정 (shared ports 모듈에서 가져오거나 환경변수)
try:
    from shared.ports import MCP_PORTS
    PORT = MCP_PORTS.get("newsinsight_mcp", 5000)
except ImportError:
    PORT = int(os.environ.get("PORT", "5000"))

server = FastMCP(
    "news-insight-mcp",
    host="0.0.0.0",
    port=PORT,
)


# Health check endpoint (using shared module)
@server.custom_route("/health", methods=["GET"])
async def health_endpoint(request: Request) -> JSONResponse:
    db_status = check_db_connection()
    return JSONResponse(
        create_health_response(
            server_name="news-insight-mcp",
            version="2.0.0",
            extra_info=db_status
        )
    )

# DB 설정은 shared.db에서 가져옴 (DB_BACKEND, get_postgres_conn, get_mongo_db)
# AiDove 설정은 shared.aidove에서 가져옴 (AIDOVE_WEBHOOK_URL, call_aidove)


# ─────────────────────────────────────────────
# 2. 신뢰 매체 / 가중치 설정
# ─────────────────────────────────────────────

# 참고: 백엔드 TrustScoreConfig와 별도로 MCP 전용 가중치 사용
# 0.8 = 일반, 1.0 = 신뢰, 1.2 = 주요 매체
TRUSTED_SOURCES_WEIGHTS = {
    # 주요 방송
    "KBS": 1.2,
    "MBC": 1.2,
    "SBS": 1.2,
    "YTN": 1.2,
    "JTBC": 1.2,
    # 통신사
    "연합뉴스": 1.2,
    # 경제지
    "한국경제": 1.2,
    "매일경제": 1.2,
    # 종합일간지
    "조선일보": 1.2,
    "중앙일보": 1.0,
    "동아일보": 1.0,
    "한겨레": 1.0,
    "경향신문": 1.0,
    # 인터넷 매체
    "머니투데이": 1.0,
    "뉴시스": 1.0,
    "뉴스1": 1.0,
}
DEFAULT_SOURCE_WEIGHT = 0.8


# ─────────────────────────────────────────────
# 3. DB 연결 헬퍼 (shared.db 모듈 사용)
# ─────────────────────────────────────────────
# get_postgres_conn(), get_mongo_db()는 shared.db에서 import됨


# ─────────────────────────────────────────────
# 4. 기사 / 댓글 조회 함수 (실제 스키마 기반)
# ─────────────────────────────────────────────


def get_articles_from_db(
    keyword: str, days: int = 7, limit: int = 50
) -> List[Dict[str, Any]]:
    """
    keyword와 기간(days)에 해당하는 기사 목록을 DB에서 조회.

    실제 스키마:
    - collected_data: 수집된 기사 원본
    - article_analysis: ML 분석 결과 (감성, 편향도 등)
    - data_sources: 언론사 정보
    """
    cutoff = datetime.utcnow() - timedelta(days=days)

    if DB_BACKEND == "postgres":
        conn = get_postgres_conn()
        with conn.cursor() as cur:
            query = """
                SELECT 
                    cd.id,
                    cd.title,
                    COALESCE(aa.summary, LEFT(cd.content, 500)) as summary,
                    ds.name as source_name,
                    COALESCE(cd.published_date, cd.collected_at) as published_at,
                    cd.url,
                    aa.sentiment_score,
                    aa.sentiment_label,
                    aa.sentiment_distribution,
                    cd.trust_score,
                    aa.reliability_score,
                    aa.bias_score,
                    aa.bias_label
                FROM collected_data cd
                LEFT JOIN data_sources ds ON cd.source_id = ds.id
                LEFT JOIN article_analysis aa ON cd.id = aa.article_id
                WHERE (
                    LOWER(cd.title) LIKE LOWER(%s)
                    OR LOWER(cd.content) LIKE LOWER(%s)
                )
                AND COALESCE(cd.published_date, cd.collected_at) >= %s
                ORDER BY COALESCE(cd.published_date, cd.collected_at) DESC
                LIMIT %s
            """
            like_keyword = f"%{keyword}%"
            cur.execute(query, (like_keyword, like_keyword, cutoff, limit))
            rows = cur.fetchall()

        articles = []
        for row in rows:
            (
                id_,
                title,
                summary,
                source_name,
                published_at,
                url,
                sentiment_score,
                sentiment_label,
                sentiment_distribution,
                trust_score,
                reliability_score,
                bias_score,
                bias_label,
            ) = row

            # JSONB 파싱
            if isinstance(sentiment_distribution, str):
                try:
                    sentiment_distribution = json.loads(sentiment_distribution)
                except:
                    sentiment_distribution = {}

            articles.append(
                {
                    "id": id_,
                    "title": title,
                    "summary": summary,
                    "source_name": source_name or "기타",
                    "published_at": published_at,
                    "url": url,
                    # ML 분석 결과
                    "sentiment_score": sentiment_score,
                    "sentiment_label": sentiment_label,
                    "sentiment_distribution": sentiment_distribution or {},
                    "trust_score": trust_score,
                    "reliability_score": reliability_score,
                    "bias_score": bias_score,
                    "bias_label": bias_label,
                }
            )
        return articles

    elif DB_BACKEND == "mongo":
        db = get_mongo_db()
        # MongoDB: ai_responses 컬렉션 활용
        cursor = (
            db.ai_responses.find(
                {
                    "$or": [
                        {"text": {"$regex": keyword, "$options": "i"}},
                    ],
                    "createdAt": {"$gte": cutoff},
                },
                {
                    "_id": 1,
                    "text": 1,
                    "providerId": 1,
                    "createdAt": 1,
                },
            )
            .sort("createdAt", -1)
            .limit(limit)
        )

        articles = []
        for doc in cursor:
            text = doc.get("text", "")
            articles.append(
                {
                    "id": str(doc.get("_id")),
                    "title": text[:100] + "..." if len(text) > 100 else text,
                    "summary": text[:500] if text else "",
                    "source_name": doc.get("providerId", "AI"),
                    "published_at": doc.get("createdAt"),
                    "url": None,
                    "sentiment_score": None,
                    "sentiment_label": None,
                    "sentiment_distribution": {},
                    "trust_score": None,
                    "reliability_score": None,
                    "bias_score": None,
                    "bias_label": None,
                }
            )
        return articles

    else:
        raise RuntimeError(f"지원하지 않는 DB_BACKEND: {DB_BACKEND}")


def get_discussions_from_db(
    keyword: str, days: int = 7, limit: int = 30
) -> List[Dict[str, Any]]:
    """
    keyword와 기간(days)에 해당하는 댓글/여론 데이터를 DB에서 조회.

    실제 스키마:
    - article_discussion: 기사별 여론 분석 집계 데이터
      - sample_positive_comments, sample_negative_comments: JSONB 샘플 댓글
      - sentiment_distribution: 감성 분포
      - overall_sentiment: 전체 감성
    """
    cutoff = datetime.utcnow() - timedelta(days=days)

    if DB_BACKEND == "postgres":
        conn = get_postgres_conn()
        with conn.cursor() as cur:
            query = """
                SELECT 
                    ad.article_id,
                    ad.total_comment_count,
                    ad.analyzed_count,
                    ad.overall_sentiment,
                    ad.sentiment_distribution,
                    ad.emotion_distribution,
                    ad.stance_distribution,
                    ad.top_keywords,
                    ad.sample_positive_comments,
                    ad.sample_negative_comments,
                    ad.discussion_quality_score,
                    ad.bot_likelihood_score,
                    ad.toxicity_score,
                    ds.name as source_name,
                    cd.published_date,
                    cd.title as article_title
                FROM article_discussion ad
                JOIN collected_data cd ON ad.article_id = cd.id
                LEFT JOIN data_sources ds ON cd.source_id = ds.id
                WHERE (
                    LOWER(cd.title) LIKE LOWER(%s)
                    OR LOWER(cd.content) LIKE LOWER(%s)
                )
                AND COALESCE(cd.published_date, cd.collected_at) >= %s
                ORDER BY cd.published_date DESC
                LIMIT %s
            """
            like_keyword = f"%{keyword}%"
            cur.execute(query, (like_keyword, like_keyword, cutoff, limit))
            rows = cur.fetchall()

        discussions = []
        for row in rows:
            (
                article_id,
                total_count,
                analyzed_count,
                overall_sentiment,
                sentiment_dist,
                emotion_dist,
                stance_dist,
                top_keywords,
                positive_samples,
                negative_samples,
                quality_score,
                bot_score,
                toxicity_score,
                source_name,
                published_date,
                article_title,
            ) = row

            # JSONB 파싱
            def parse_json(val):
                if val is None:
                    return {}
                if isinstance(val, (dict, list)):
                    return val
                if isinstance(val, str):
                    try:
                        return json.loads(val)
                    except:
                        return {}
                return {}

            discussions.append(
                {
                    "article_id": article_id,
                    "article_title": article_title,
                    "total_comment_count": total_count or 0,
                    "analyzed_count": analyzed_count or 0,
                    "overall_sentiment": overall_sentiment,
                    "sentiment_distribution": parse_json(sentiment_dist),
                    "emotion_distribution": parse_json(emotion_dist),
                    "stance_distribution": parse_json(stance_dist),
                    "top_keywords": parse_json(top_keywords)
                    if isinstance(parse_json(top_keywords), list)
                    else [],
                    "sample_positive_comments": parse_json(positive_samples)
                    if isinstance(parse_json(positive_samples), list)
                    else [],
                    "sample_negative_comments": parse_json(negative_samples)
                    if isinstance(parse_json(negative_samples), list)
                    else [],
                    "discussion_quality_score": quality_score,
                    "bot_likelihood_score": bot_score,
                    "toxicity_score": toxicity_score,
                    "source_name": source_name or "기타",
                    "published_at": published_date,
                }
            )
        return discussions

    elif DB_BACKEND == "mongo":
        # MongoDB에서는 article_discussion에 해당하는 컬렉션이 없을 수 있음
        return []

    else:
        raise RuntimeError(f"지원하지 않는 DB_BACKEND: {DB_BACKEND}")


# ─────────────────────────────────────────────
# 5. 감성 분석 (룰 기반 Fallback)
# ─────────────────────────────────────────────

POSITIVE_WORDS = [
    "호조",
    "호재",
    "강세",
    "성장",
    "최고",
    "회복",
    "긍정",
    "기대",
    "추천",
    "좋은",
    "상승",
    "돌파",
    "성공",
    "환영",
    "지지",
    "호평",
    "개선",
    "발전",
    "혁신",
    "협력",
]
NEGATIVE_WORDS = [
    "우려",
    "불안",
    "논란",
    "폭락",
    "위기",
    "악재",
    "반발",
    "불신",
    "구조조정",
    "부정",
    "반대",
    "화나요",
    "하락",
    "실패",
    "비판",
    "갈등",
    "충돌",
    "파탄",
    "악화",
    "손실",
]


def analyze_sentiment_fallback(text: str) -> float:
    """
    룰 기반 감성 분석 (ML 결과가 없을 때 사용).
    - 긍정 키워드 +1, 부정 키워드 -1
    - 최종 범위: [-1, 1]
    """
    if not text:
        return 0.0

    text = text.lower()
    score = 0

    for w in POSITIVE_WORDS:
        if w in text:
            score += 1
    for w in NEGATIVE_WORDS:
        if w in text:
            score -= 1

    # 정규화: [-1, 1] 범위로
    if score > 0:
        return min(1.0, score / 3)
    elif score < 0:
        return max(-1.0, score / 3)
    return 0.0


# ─────────────────────────────────────────────
# 6. 기사/댓글 여론 온도 계산 로직
# ─────────────────────────────────────────────


def compute_article_temperature(
    keyword: str,
    days: int = 7,
    trusted_only: bool = True,
) -> Dict[str, Any]:
    """
    언론 기사 논조 기반 여론 온도를 계산한다.
    DB에 저장된 ML 분석 결과를 우선 사용하고, 없으면 룰 기반 분석.
    """
    articles = get_articles_from_db(keyword, days)
    now = datetime.utcnow()

    if not articles:
        return {
            "temperature": 50.0,
            "score_raw": 0.0,
            "pos_ratio": 0.0,
            "neg_ratio": 0.0,
            "neu_ratio": 1.0,
            "article_count": 0,
            "ml_analyzed_count": 0,
            "trusted_only": trusted_only,
            "note": "분석할 기사가 없습니다.",
        }

    weighted_sum = 0.0
    weight_total = 0.0
    pos_w = neg_w = neu_w = 0.0
    used_ml_count = 0
    filtered_count = 0

    for a in articles:
        title = a.get("title", "")
        summary = a.get("summary", "")
        source_name = a.get("source_name", "기타")
        published_at = a.get("published_at", now)

        # DB에 저장된 ML 분석 결과
        stored_sentiment_score = a.get("sentiment_score")

        # 1) 신뢰 매체 필터
        if trusted_only and source_name not in TRUSTED_SOURCES_WEIGHTS:
            filtered_count += 1
            continue

        # 2) 출처 가중치
        source_weight = TRUSTED_SOURCES_WEIGHTS.get(source_name, DEFAULT_SOURCE_WEIGHT)

        # 3) 시간 가중치 (최근일수록 가중치 ↑, 최소 0.3)
        if isinstance(published_at, datetime):
            age_days = max(0.0, (now - published_at).total_seconds() / 86400)
        else:
            age_days = 0.0

        if days > 0:
            w_time = max(0.3, 1.0 - age_days / float(days))
        else:
            w_time = 1.0

        w = source_weight * w_time

        # 4) 감성 점수: DB ML 결과 우선, 없으면 룰 기반
        if stored_sentiment_score is not None:
            s = float(stored_sentiment_score)
            used_ml_count += 1
        else:
            text_for_analysis = f"{title} {summary}"
            s = analyze_sentiment_fallback(text_for_analysis)

        weighted_sum += w * s
        weight_total += w

        if s > 0.1:
            pos_w += w
        elif s < -0.1:
            neg_w += w
        else:
            neu_w += w

    if weight_total == 0:
        return {
            "temperature": 50.0,
            "score_raw": 0.0,
            "pos_ratio": 0.0,
            "neg_ratio": 0.0,
            "neu_ratio": 1.0,
            "article_count": len(articles),
            "ml_analyzed_count": 0,
            "trusted_only": trusted_only,
            "note": f"신뢰 매체 기준으로 분석할 기사가 부족합니다. (필터링: {filtered_count}건)",
        }

    score_raw = weighted_sum / weight_total  # [-1,1]
    temperature = 50.0 + 50.0 * score_raw
    temperature = max(0.0, min(100.0, temperature))

    pos_ratio = pos_w / weight_total
    neg_ratio = neg_w / weight_total
    neu_ratio = neu_w / weight_total

    return {
        "temperature": round(temperature, 1),
        "score_raw": round(score_raw, 3),
        "pos_ratio": round(pos_ratio, 3),
        "neg_ratio": round(neg_ratio, 3),
        "neu_ratio": round(neu_ratio, 3),
        "article_count": len(articles) - filtered_count,
        "total_found": len(articles),
        "ml_analyzed_count": used_ml_count,
        "trusted_only": trusted_only,
        "note": f"ML 분석 {used_ml_count}건, 룰 기반 {len(articles) - filtered_count - used_ml_count}건",
    }


def compute_discussion_temperature(
    keyword: str,
    days: int = 7,
) -> Dict[str, Any]:
    """
    댓글/여론 데이터 기반 여론 온도 계산.
    article_discussion 테이블의 집계된 분석 결과 활용.
    """
    discussions = get_discussions_from_db(keyword, days)

    if not discussions:
        return {
            "temperature": 50.0,
            "score_raw": 0.0,
            "pos_ratio": 0.0,
            "neg_ratio": 0.0,
            "neu_ratio": 1.0,
            "comment_count": 0,
            "discussion_count": 0,
            "avg_quality_score": None,
            "avg_bot_likelihood": None,
            "note": "분석할 댓글 데이터가 없습니다.",
        }

    total_comments = 0
    weighted_pos = 0.0
    weighted_neg = 0.0
    weighted_neu = 0.0
    quality_scores = []
    bot_scores = []

    for disc in discussions:
        count = disc.get("total_comment_count", 0)
        if count == 0:
            continue

        total_comments += count
        sentiment_dist = disc.get("sentiment_distribution", {})

        # 가중치 = 댓글 수 (볼륨 기반)
        w = float(count)

        pos = float(sentiment_dist.get("positive", 0.0))
        neg = float(sentiment_dist.get("negative", 0.0))
        neu = float(sentiment_dist.get("neutral", 0.0))

        weighted_pos += w * pos
        weighted_neg += w * neg
        weighted_neu += w * neu

        if disc.get("discussion_quality_score") is not None:
            quality_scores.append(disc["discussion_quality_score"])
        if disc.get("bot_likelihood_score") is not None:
            bot_scores.append(disc["bot_likelihood_score"])

    if total_comments == 0:
        return {
            "temperature": 50.0,
            "score_raw": 0.0,
            "pos_ratio": 0.0,
            "neg_ratio": 0.0,
            "neu_ratio": 1.0,
            "comment_count": 0,
            "discussion_count": len(discussions),
            "avg_quality_score": None,
            "avg_bot_likelihood": None,
            "note": "댓글 데이터가 부족합니다.",
        }

    # 비율 계산
    total_w = weighted_pos + weighted_neg + weighted_neu
    if total_w > 0:
        pos_ratio = weighted_pos / total_w
        neg_ratio = weighted_neg / total_w
        neu_ratio = weighted_neu / total_w
    else:
        pos_ratio = neg_ratio = 0.0
        neu_ratio = 1.0

    # 점수 계산 (긍정 - 부정)
    score_raw = pos_ratio - neg_ratio  # [-1, 1]
    temperature = 50.0 + 50.0 * score_raw
    temperature = max(0.0, min(100.0, temperature))

    # 평균 품질/봇 점수
    avg_quality = sum(quality_scores) / len(quality_scores) if quality_scores else None
    avg_bot = sum(bot_scores) / len(bot_scores) if bot_scores else None

    return {
        "temperature": round(temperature, 1),
        "score_raw": round(score_raw, 3),
        "pos_ratio": round(pos_ratio, 3),
        "neg_ratio": round(neg_ratio, 3),
        "neu_ratio": round(neu_ratio, 3),
        "comment_count": total_comments,
        "discussion_count": len(discussions),
        "avg_quality_score": round(avg_quality, 1) if avg_quality else None,
        "avg_bot_likelihood": round(avg_bot, 3) if avg_bot else None,
        "note": "",
    }


def compute_combined_temperature(
    article_info: Dict[str, Any],
    discussion_info: Dict[str, Any],
    article_weight: float = 0.6,
    discussion_weight: float = 0.4,
) -> Dict[str, Any]:
    """
    기사 기반 + 댓글 기반 여론 온도를 섞어서 종합 온도 계산.
    """
    a_score = article_info.get("score_raw", 0.0)
    d_score = discussion_info.get("score_raw", 0.0)

    # 데이터가 없는 경우 가중치 조정
    has_articles = article_info.get("article_count", 0) > 0
    has_discussions = discussion_info.get("comment_count", 0) > 0

    if not has_articles and not has_discussions:
        return {
            "temperature": 50.0,
            "score_raw": 0.0,
            "article_weight": article_weight,
            "discussion_weight": discussion_weight,
            "data_source": "none",
        }
    elif not has_articles:
        combined_raw = d_score
        data_source = "discussion_only"
    elif not has_discussions:
        combined_raw = a_score
        data_source = "article_only"
    else:
        combined_raw = article_weight * a_score + discussion_weight * d_score
        data_source = "both"

    temperature = 50.0 + 50.0 * combined_raw
    temperature = max(0.0, min(100.0, temperature))

    return {
        "temperature": round(temperature, 1),
        "score_raw": round(combined_raw, 3),
        "article_weight": article_weight,
        "discussion_weight": discussion_weight,
        "data_source": data_source,
    }


# ─────────────────────────────────────────────
# 7. AiDove 호출 헬퍼
# ─────────────────────────────────────────────


def call_aidove(prompt: str, session_id: Optional[str] = None) -> str:
    """AiDove API를 호출하여 자연어 리포트를 생성합니다."""
    payload = {"chatInput": prompt}
    if session_id:
        payload["sessionId"] = session_id

    try:
        resp = requests.post(AIDOVE_WEBHOOK_URL, json=payload, timeout=60)
        resp.raise_for_status()
        data = resp.json()
        return data.get("reply", data.get("output", "리포트 생성에 실패했습니다."))
    except requests.RequestException as e:
        return f"AiDove 호출 실패: {str(e)}"


# ─────────────────────────────────────────────
# 8. MCP Tools
# ─────────────────────────────────────────────


@server.tool()
async def get_sentiment_raw(
    keyword: str,
    days: int = 7,
    trusted_only: bool = True,
    article_weight: float = 0.6,
    discussion_weight: float = 0.4,
) -> Dict[str, Any]:
    """
    기사/댓글/종합 여론 온도를 모두 계산해서 JSON으로 반환합니다.

    Args:
        keyword: 검색할 키워드
        days: 분석 기간 (일)
        trusted_only: 신뢰 매체만 분석할지 여부
        article_weight: 기사 가중치 (0-1)
        discussion_weight: 댓글 가중치 (0-1)

    Returns:
        기사/댓글/종합 여론 온도 데이터
    """
    article_info = compute_article_temperature(keyword, days, trusted_only)
    discussion_info = compute_discussion_temperature(keyword, days)

    # weight 정규화
    total_w = article_weight + discussion_weight
    if total_w <= 0:
        article_weight_n = 0.6
        discussion_weight_n = 0.4
    else:
        article_weight_n = article_weight / total_w
        discussion_weight_n = discussion_weight / total_w

    combined_info = compute_combined_temperature(
        article_info,
        discussion_info,
        article_weight=article_weight_n,
        discussion_weight=discussion_weight_n,
    )

    return {
        "keyword": keyword,
        "days": days,
        "trusted_only": trusted_only,
        "article": article_info,
        "discussion": discussion_info,
        "combined": combined_info,
        "generated_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def get_sentiment_report(
    keyword: str,
    days: int = 7,
    trusted_only: bool = True,
    article_weight: float = 0.6,
    discussion_weight: float = 0.4,
    session_id: Optional[str] = None,
) -> str:
    """
    여론 온도 데이터를 기반으로 AiDove가 작성한 자연어 한국어 리포트를 반환합니다.

    Args:
        keyword: 검색할 키워드
        days: 분석 기간 (일)
        trusted_only: 신뢰 매체만 분석할지 여부
        article_weight: 기사 가중치 (0-1)
        discussion_weight: 댓글 가중치 (0-1)
        session_id: AiDove 세션 ID (선택)

    Returns:
        자연어 여론 분석 리포트
    """
    raw = await get_sentiment_raw(
        keyword=keyword,
        days=days,
        trusted_only=trusted_only,
        article_weight=article_weight,
        discussion_weight=discussion_weight,
    )

    prompt = f"""
너는 'News Insight'라는 뉴스 여론 분석 서비스의 리포트 작성 어시스턴트야.

아래 JSON은 특정 키워드에 대해 기사/댓글/종합 관점에서 계산한 여론 온도 데이터야.

키워드: {keyword}
기간: 최근 {days}일
신뢰매체 필터: {trusted_only}

JSON 데이터:
{json.dumps(raw, ensure_ascii=False, indent=2, default=str)}

요청사항:
1. 기사 기반 여론 온도와 댓글 기반 여론 온도의 차이를 설명해줘.
2. 종합 여론 온도(기사 {article_weight:.0%}, 댓글 {discussion_weight:.0%} 비율)를 기준으로
   지금 여론이 '전반적으로 긍정/부정/중립' 중 어디에 가까운지 분석해줘.
3. 기사와 댓글이 서로 반대되는 경우(예: 기사 긍정, 댓글 부정)라면,
   그 이유를 추정해서 설명해줘. (추정일 경우 '추정'이라고 명시)
4. 신뢰 매체 필터(trusted_only)의 의미를 한 줄 정도로 설명해줘.
5. 마지막에는 '데이터 수집 범위와 분석 방식에 따른 한계'에 대한 짧은 주의 문장을 적어줘.

전체 리포트는 3~6 단락 정도의 자연스러운 한국어로 작성해줘.
"""
    report = call_aidove(prompt, session_id=session_id)
    return report


@server.tool()
async def get_article_list(
    keyword: str,
    days: int = 7,
    limit: int = 20,
) -> Dict[str, Any]:
    """
    키워드로 검색한 기사 목록을 반환합니다 (ML 분석 결과 포함).

    Args:
        keyword: 검색할 키워드
        days: 검색 기간 (일)
        limit: 최대 결과 수

    Returns:
        기사 목록 및 메타데이터
    """
    articles = get_articles_from_db(keyword, days, limit)

    result = []
    for a in articles:
        published_at = a.get("published_at")
        result.append(
            {
                "id": a.get("id"),
                "title": a.get("title"),
                "source": a.get("source_name"),
                "published_at": published_at.isoformat()
                if isinstance(published_at, datetime)
                else str(published_at)
                if published_at
                else None,
                "url": a.get("url"),
                "summary": (a.get("summary") or "")[:200],
                "sentiment": {
                    "score": a.get("sentiment_score"),
                    "label": a.get("sentiment_label"),
                },
                "reliability_score": a.get("reliability_score"),
                "bias": {
                    "score": a.get("bias_score"),
                    "label": a.get("bias_label"),
                },
            }
        )

    return {
        "keyword": keyword,
        "days": days,
        "count": len(result),
        "articles": result,
    }


@server.tool()
async def get_discussion_summary(
    keyword: str,
    days: int = 7,
) -> Dict[str, Any]:
    """
    키워드 관련 여론/댓글 요약 정보를 반환합니다.

    Args:
        keyword: 검색할 키워드
        days: 검색 기간 (일)

    Returns:
        여론/댓글 요약 통계
    """
    discussions = get_discussions_from_db(keyword, days)

    if not discussions:
        return {
            "keyword": keyword,
            "days": days,
            "has_data": False,
            "message": "관련 여론 데이터가 없습니다.",
        }

    # 집계
    total_comments = sum(d.get("total_comment_count", 0) for d in discussions)

    # 주요 키워드 집계
    all_keywords: Dict[str, int] = {}
    for d in discussions:
        for kw in d.get("top_keywords", []):
            if isinstance(kw, dict):
                word = kw.get("word", "")
                count = kw.get("count", 0)
                all_keywords[word] = all_keywords.get(word, 0) + count

    top_keywords = sorted(all_keywords.items(), key=lambda x: x[1], reverse=True)[:10]

    # 감성 분포 평균
    total_sentiment = {"positive": 0.0, "negative": 0.0, "neutral": 0.0}
    sentiment_count = 0
    for d in discussions:
        dist = d.get("sentiment_distribution", {})
        if dist:
            sentiment_count += 1
            for k in total_sentiment:
                total_sentiment[k] += float(dist.get(k, 0.0))

    if sentiment_count > 0:
        for k in total_sentiment:
            total_sentiment[k] = round(total_sentiment[k] / sentiment_count, 3)

    # 품질/봇 점수 평균
    quality_scores = [
        d["discussion_quality_score"]
        for d in discussions
        if d.get("discussion_quality_score") is not None
    ]
    bot_scores = [
        d["bot_likelihood_score"]
        for d in discussions
        if d.get("bot_likelihood_score") is not None
    ]

    return {
        "keyword": keyword,
        "days": days,
        "has_data": True,
        "total_comments": total_comments,
        "article_count": len(discussions),
        "avg_sentiment": total_sentiment,
        "top_keywords": [{"word": w, "count": c} for w, c in top_keywords],
        "avg_quality_score": round(sum(quality_scores) / len(quality_scores), 1)
        if quality_scores
        else None,
        "avg_bot_likelihood": round(sum(bot_scores) / len(bot_scores), 3)
        if bot_scores
        else None,
    }


@server.tool()
async def health_check() -> Dict[str, Any]:
    """
    서버 상태 및 DB 연결 상태를 확인합니다.

    Returns:
        서버 상태 정보
    """
    status = {
        "server": "News Insight MCP",
        "version": "2.0.0",
        "db_backend": DB_BACKEND,
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
    }

    # DB 연결 테스트
    try:
        if DB_BACKEND == "postgres":
            conn = get_postgres_conn()
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
            status["postgres"] = "connected"
        elif DB_BACKEND == "mongo":
            db = get_mongo_db()
            db.command("ping")
            status["mongo"] = "connected"
    except Exception as e:
        status["db_error"] = str(e)
        status["status"] = "degraded"

    return status


# ─────────────────────────────────────────────
# 9. HTTP 서버 및 헬스체크 엔드포인트
# ─────────────────────────────────────────────

from http.server import HTTPServer, BaseHTTPRequestHandler
import threading


class HealthCheckHandler(BaseHTTPRequestHandler):
    """간단한 헬스체크 엔드포인트 핸들러"""

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = {
                "status": "healthy",
                "server": "news-insight-mcp",
                "version": "2.0.0",
            }
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass  # 로그 출력 억제


def start_health_server(port: int):
    """헬스체크용 HTTP 서버를 별도 스레드에서 시작"""
    health_port = port  # 동일 포트에서 /health 제공
    # MCP 서버가 HTTP를 처리하므로 별도 헬스 서버는 필요 없을 수 있음
    pass


if __name__ == "__main__":
    print(f"Starting News Insight MCP Server v2.0.0 on port {PORT}")
    print(f"DB Backend: {DB_BACKEND}")
    server.run(transport="streamable-http")

```

---

## mcp/roboflow_mcp/server.py

```py
"""
Roboflow MCP Server - Computer Vision 이미지 분석

뉴스 기사 이미지의 객체 탐지, 분류, 텍스트 추출(OCR) 등을 수행하는 MCP 서버입니다.
Roboflow API와 연동하여 다양한 CV 모델을 활용합니다.

Version: 1.0.0
Port: 5008 (changed from 5010 to avoid conflict with aiagent_mcp)
"""

import os
import json
import uuid
import asyncio
import base64
import hashlib
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any, Union
from pathlib import Path
from urllib.parse import urlparse
import io

import aiohttp
import aiofiles
from mcp.server import FastMCP
from starlette.responses import JSONResponse
from starlette.requests import Request

# ─────────────────────────────────────────────
# 1. MCP 서버 기본 설정
# ─────────────────────────────────────────────

# 포트 설정 (환경변수에서 읽음)
PORT = int(os.environ.get("PORT", "5008"))

server = FastMCP(
    "roboflow-cv-mcp",
    host="0.0.0.0",
    port=PORT,
)


# Health check endpoint
@server.custom_route("/health", methods=["GET"])
async def health_endpoint(request: Request) -> JSONResponse:
    return JSONResponse(
        {
            "status": "healthy",
            "server": "roboflow-cv-mcp",
            "version": "1.0.0",
        }
    )


# Roboflow API 설정
ROBOFLOW_API_KEY = os.environ.get("ROBOFLOW_API_KEY", "")
ROBOFLOW_API_URL = "https://detect.roboflow.com"
ROBOFLOW_INFER_URL = "https://infer.roboflow.com"
ROBOFLOW_UPLOAD_URL = "https://api.roboflow.com"

# 공유 데이터 디렉토리
DATA_DIR = Path(os.environ.get("DATA_DIR", "/app/data"))
CACHE_DIR = DATA_DIR / "cache"
RESULTS_DIR = DATA_DIR / "results"

# Job Queue 설정
JOB_TIMEOUT = int(os.environ.get("JOB_TIMEOUT", "300"))  # 5분
POLL_INTERVAL = int(os.environ.get("POLL_INTERVAL", "2"))

# ─────────────────────────────────────────────
# 2. Job Queue 관리 (In-Memory)
# ─────────────────────────────────────────────


class JobStatus:
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"


# Job 저장소 (실제 운영에서는 Redis 등 사용)
_jobs: Dict[str, Dict[str, Any]] = {}


def create_job(job_type: str, params: Dict[str, Any]) -> str:
    """새 Job을 생성하고 Job ID를 반환합니다."""
    job_id = str(uuid.uuid4())
    _jobs[job_id] = {
        "id": job_id,
        "type": job_type,
        "status": JobStatus.PENDING,
        "params": params,
        "result": None,
        "error": None,
        "created_at": datetime.utcnow().isoformat(),
        "updated_at": datetime.utcnow().isoformat(),
        "progress": 0,
    }
    return job_id


def update_job(job_id: str, **kwargs):
    """Job 상태를 업데이트합니다."""
    if job_id in _jobs:
        _jobs[job_id].update(kwargs)
        _jobs[job_id]["updated_at"] = datetime.utcnow().isoformat()


def get_job(job_id: str) -> Optional[Dict[str, Any]]:
    """Job 정보를 조회합니다."""
    return _jobs.get(job_id)


def cleanup_old_jobs(max_age_hours: int = 24):
    """오래된 Job을 정리합니다."""
    cutoff = datetime.utcnow() - timedelta(hours=max_age_hours)
    to_delete = []
    for job_id, job in _jobs.items():
        created = datetime.fromisoformat(job["created_at"])
        if created < cutoff:
            to_delete.append(job_id)
    for job_id in to_delete:
        del _jobs[job_id]


# ─────────────────────────────────────────────
# 3. 이미지 처리 유틸리티
# ─────────────────────────────────────────────


async def download_image(url: str) -> bytes:
    """URL에서 이미지를 다운로드합니다."""
    async with aiohttp.ClientSession() as session:
        async with session.get(url, timeout=aiohttp.ClientTimeout(total=30)) as resp:
            if resp.status != 200:
                raise Exception(f"이미지 다운로드 실패: HTTP {resp.status}")
            return await resp.read()


def encode_image_base64(image_bytes: bytes) -> str:
    """이미지를 base64로 인코딩합니다."""
    return base64.b64encode(image_bytes).decode("utf-8")


def get_image_hash(image_bytes: bytes) -> str:
    """이미지 해시를 계산합니다 (캐싱용)."""
    return hashlib.md5(image_bytes).hexdigest()


async def save_to_cache(key: str, data: Any):
    """결과를 캐시에 저장합니다."""
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    cache_file = CACHE_DIR / f"{key}.json"
    async with aiofiles.open(cache_file, "w") as f:
        await f.write(json.dumps(data, ensure_ascii=False, default=str))


async def load_from_cache(key: str) -> Optional[Any]:
    """캐시에서 결과를 로드합니다."""
    cache_file = CACHE_DIR / f"{key}.json"
    if cache_file.exists():
        async with aiofiles.open(cache_file, "r") as f:
            content = await f.read()
            return json.loads(content)
    return None


# ─────────────────────────────────────────────
# 4. Roboflow API 클라이언트
# ─────────────────────────────────────────────


class RoboflowClient:
    """Roboflow API 클라이언트"""

    def __init__(self, api_key: str):
        self.api_key = api_key

    async def detect_objects(
        self,
        image_source: Union[str, bytes],
        model_id: str = "yolov8n-640",
        confidence: float = 0.4,
        overlap: float = 0.3,
    ) -> Dict[str, Any]:
        """
        객체 탐지를 수행합니다.

        Args:
            image_source: 이미지 URL 또는 bytes
            model_id: Roboflow 모델 ID (예: "coco/3")
            confidence: 신뢰도 임계값
            overlap: IoU 임계값
        """
        # 이미지 준비
        if isinstance(image_source, str) and image_source.startswith(
            ("http://", "https://")
        ):
            image_bytes = await download_image(image_source)
        elif isinstance(image_source, str):
            # base64 문자열
            image_bytes = base64.b64decode(image_source)
        else:
            image_bytes = image_source

        image_b64 = encode_image_base64(image_bytes)

        # API 호출
        url = f"{ROBOFLOW_INFER_URL}/{model_id}"
        params = {
            "api_key": self.api_key,
            "confidence": confidence,
            "overlap": overlap,
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(
                url,
                params=params,
                data=image_b64,
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                timeout=aiohttp.ClientTimeout(total=60),
            ) as resp:
                if resp.status != 200:
                    text = await resp.text()
                    raise Exception(f"Roboflow API 오류: {resp.status} - {text}")
                return await resp.json()

    async def classify_image(
        self,
        image_source: Union[str, bytes],
        model_id: str,
    ) -> Dict[str, Any]:
        """
        이미지 분류를 수행합니다.

        Args:
            image_source: 이미지 URL 또는 bytes
            model_id: Roboflow 분류 모델 ID
        """
        if isinstance(image_source, str) and image_source.startswith(
            ("http://", "https://")
        ):
            image_bytes = await download_image(image_source)
        elif isinstance(image_source, str):
            image_bytes = base64.b64decode(image_source)
        else:
            image_bytes = image_source

        image_b64 = encode_image_base64(image_bytes)

        url = f"{ROBOFLOW_INFER_URL}/{model_id}"
        params = {"api_key": self.api_key}

        async with aiohttp.ClientSession() as session:
            async with session.post(
                url,
                params=params,
                data=image_b64,
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                timeout=aiohttp.ClientTimeout(total=60),
            ) as resp:
                if resp.status != 200:
                    text = await resp.text()
                    raise Exception(f"Roboflow API 오류: {resp.status} - {text}")
                return await resp.json()

    async def ocr_image(
        self,
        image_source: Union[str, bytes],
    ) -> Dict[str, Any]:
        """
        이미지에서 텍스트를 추출합니다 (OCR).
        Roboflow의 DocTR 모델을 사용합니다.

        Args:
            image_source: 이미지 URL 또는 bytes
        """
        if isinstance(image_source, str) and image_source.startswith(
            ("http://", "https://")
        ):
            image_bytes = await download_image(image_source)
        elif isinstance(image_source, str):
            image_bytes = base64.b64decode(image_source)
        else:
            image_bytes = image_source

        image_b64 = encode_image_base64(image_bytes)

        # DocTR OCR 모델
        url = f"{ROBOFLOW_INFER_URL}/doctr/ocr"
        params = {"api_key": self.api_key}

        async with aiohttp.ClientSession() as session:
            async with session.post(
                url,
                params=params,
                data=image_b64,
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                timeout=aiohttp.ClientTimeout(total=60),
            ) as resp:
                if resp.status != 200:
                    text = await resp.text()
                    raise Exception(f"Roboflow OCR API 오류: {resp.status} - {text}")
                return await resp.json()

    async def list_workspaces(self) -> Dict[str, Any]:
        """사용 가능한 워크스페이스 목록을 조회합니다."""
        url = f"{ROBOFLOW_UPLOAD_URL}/"
        params = {"api_key": self.api_key}

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                if resp.status != 200:
                    text = await resp.text()
                    raise Exception(f"Roboflow API 오류: {resp.status} - {text}")
                return await resp.json()

    async def list_projects(self, workspace: str) -> Dict[str, Any]:
        """워크스페이스의 프로젝트 목록을 조회합니다."""
        url = f"{ROBOFLOW_UPLOAD_URL}/{workspace}"
        params = {"api_key": self.api_key}

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                if resp.status != 200:
                    text = await resp.text()
                    raise Exception(f"Roboflow API 오류: {resp.status} - {text}")
                return await resp.json()

    async def get_model_info(
        self, workspace: str, project: str, version: int
    ) -> Dict[str, Any]:
        """모델 버전 정보를 조회합니다."""
        url = f"{ROBOFLOW_UPLOAD_URL}/{workspace}/{project}/{version}"
        params = {"api_key": self.api_key}

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                if resp.status != 200:
                    text = await resp.text()
                    raise Exception(f"Roboflow API 오류: {resp.status} - {text}")
                return await resp.json()


# 전역 클라이언트 인스턴스
_roboflow_client: Optional[RoboflowClient] = None


def get_roboflow_client() -> RoboflowClient:
    """Roboflow 클라이언트를 반환합니다."""
    global _roboflow_client
    if _roboflow_client is None:
        if not ROBOFLOW_API_KEY:
            raise RuntimeError("ROBOFLOW_API_KEY가 설정되어 있지 않습니다.")
        _roboflow_client = RoboflowClient(ROBOFLOW_API_KEY)
    return _roboflow_client


# ─────────────────────────────────────────────
# 5. 뉴스 이미지 분석 기능
# ─────────────────────────────────────────────


async def analyze_news_image(
    image_source: Union[str, bytes],
    analyze_objects: bool = True,
    analyze_text: bool = True,
    custom_model_id: Optional[str] = None,
) -> Dict[str, Any]:
    """
    뉴스 기사 이미지를 종합적으로 분석합니다.

    - 객체 탐지: 사람, 차량, 건물 등 주요 객체 식별
    - OCR: 이미지 내 텍스트 추출 (간판, 현수막, 자막 등)
    """
    client = get_roboflow_client()
    result = {
        "analyzed_at": datetime.utcnow().isoformat(),
        "objects": None,
        "text": None,
        "summary": {},
    }

    # 객체 탐지
    if analyze_objects:
        try:
            model_id = custom_model_id or "coco/3"  # COCO 모델 사용
            objects_result = await client.detect_objects(
                image_source,
                model_id=model_id,
                confidence=0.3,
            )
            result["objects"] = objects_result

            # 탐지된 객체 요약
            if "predictions" in objects_result:
                class_counts = {}
                for pred in objects_result["predictions"]:
                    cls = pred.get("class", "unknown")
                    class_counts[cls] = class_counts.get(cls, 0) + 1
                result["summary"]["detected_objects"] = class_counts
                result["summary"]["object_count"] = len(objects_result["predictions"])
        except Exception as e:
            result["objects"] = {"error": str(e)}

    # OCR
    if analyze_text:
        try:
            ocr_result = await client.ocr_image(image_source)
            result["text"] = ocr_result

            # 추출된 텍스트 요약
            if "result" in ocr_result:
                extracted_text = []
                for page in ocr_result.get("result", {}).get("pages", []):
                    for block in page.get("blocks", []):
                        for line in block.get("lines", []):
                            text = " ".join(
                                w.get("value", "") for w in line.get("words", [])
                            )
                            if text.strip():
                                extracted_text.append(text.strip())
                result["summary"]["extracted_text"] = extracted_text
                result["summary"]["text_line_count"] = len(extracted_text)
        except Exception as e:
            result["text"] = {"error": str(e)}

    return result


# ─────────────────────────────────────────────
# 6. 배치 처리 기능
# ─────────────────────────────────────────────


async def process_batch_images(
    job_id: str,
    image_sources: List[str],
    analyze_objects: bool = True,
    analyze_text: bool = True,
) -> Dict[str, Any]:
    """
    여러 이미지를 배치로 처리합니다.
    Job Queue 패턴으로 진행 상황을 추적합니다.
    """
    update_job(job_id, status=JobStatus.PROCESSING, progress=0)

    results = []
    total = len(image_sources)

    for idx, source in enumerate(image_sources):
        try:
            result = await analyze_news_image(
                source,
                analyze_objects=analyze_objects,
                analyze_text=analyze_text,
            )
            results.append(
                {
                    "source": source[:100] if isinstance(source, str) else "bytes",
                    "success": True,
                    "result": result,
                }
            )
        except Exception as e:
            results.append(
                {
                    "source": source[:100] if isinstance(source, str) else "bytes",
                    "success": False,
                    "error": str(e),
                }
            )

        # 진행 상황 업데이트
        progress = int((idx + 1) / total * 100)
        update_job(job_id, progress=progress)

    # 결과 저장
    RESULTS_DIR.mkdir(parents=True, exist_ok=True)
    result_file = RESULTS_DIR / f"{job_id}.json"
    async with aiofiles.open(result_file, "w") as f:
        await f.write(json.dumps(results, ensure_ascii=False, default=str, indent=2))

    final_result = {
        "total": total,
        "success_count": sum(1 for r in results if r["success"]),
        "failed_count": sum(1 for r in results if not r["success"]),
        "results": results,
        "result_file": str(result_file),
    }

    update_job(job_id, status=JobStatus.COMPLETED, result=final_result, progress=100)
    return final_result


# ─────────────────────────────────────────────
# 7. MCP Tools
# ─────────────────────────────────────────────


@server.tool()
async def detect_objects(
    image_url: str,
    model_id: str = "coco/3",
    confidence: float = 0.4,
) -> Dict[str, Any]:
    """
    이미지에서 객체를 탐지합니다.

    Args:
        image_url: 분석할 이미지 URL
        model_id: Roboflow 모델 ID (기본: coco/3 - COCO 데이터셋 학습 모델)
        confidence: 신뢰도 임계값 (0.0-1.0)

    Returns:
        탐지된 객체 목록 (위치, 클래스, 신뢰도)
    """
    client = get_roboflow_client()
    result = await client.detect_objects(
        image_url,
        model_id=model_id,
        confidence=confidence,
    )

    # 결과 정리
    predictions = result.get("predictions", [])
    summary = {}
    for pred in predictions:
        cls = pred.get("class", "unknown")
        summary[cls] = summary.get(cls, 0) + 1

    return {
        "model_id": model_id,
        "image_width": result.get("image", {}).get("width"),
        "image_height": result.get("image", {}).get("height"),
        "object_count": len(predictions),
        "class_summary": summary,
        "predictions": predictions,
        "analyzed_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def extract_text_ocr(
    image_url: str,
) -> Dict[str, Any]:
    """
    이미지에서 텍스트를 추출합니다 (OCR).

    뉴스 이미지의 자막, 간판, 현수막 등의 텍스트를 읽을 수 있습니다.

    Args:
        image_url: 분석할 이미지 URL

    Returns:
        추출된 텍스트 및 위치 정보
    """
    client = get_roboflow_client()
    result = await client.ocr_image(image_url)

    # 텍스트 추출 및 정리
    extracted_lines = []
    full_text = []

    for page in result.get("result", {}).get("pages", []):
        for block in page.get("blocks", []):
            for line in block.get("lines", []):
                words = [w.get("value", "") for w in line.get("words", [])]
                line_text = " ".join(words).strip()
                if line_text:
                    extracted_lines.append(
                        {
                            "text": line_text,
                            "geometry": line.get("geometry"),
                        }
                    )
                    full_text.append(line_text)

    return {
        "full_text": "\n".join(full_text),
        "line_count": len(extracted_lines),
        "lines": extracted_lines,
        "analyzed_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def analyze_news_image_full(
    image_url: str,
    include_objects: bool = True,
    include_text: bool = True,
) -> Dict[str, Any]:
    """
    뉴스 이미지를 종합적으로 분석합니다.

    객체 탐지와 OCR을 함께 수행하여 이미지의 전체적인 내용을 파악합니다.

    Args:
        image_url: 분석할 이미지 URL
        include_objects: 객체 탐지 포함 여부
        include_text: OCR 텍스트 추출 포함 여부

    Returns:
        종합 분석 결과 (객체, 텍스트, 요약)
    """
    result = await analyze_news_image(
        image_url,
        analyze_objects=include_objects,
        analyze_text=include_text,
    )
    return result


@server.tool()
async def start_batch_analysis(
    image_urls: List[str],
    include_objects: bool = True,
    include_text: bool = True,
) -> Dict[str, Any]:
    """
    여러 이미지를 배치로 분석하는 Job을 시작합니다.

    대량의 뉴스 이미지를 비동기로 처리합니다.
    Job ID를 반환하며, get_job_status로 진행 상황을 확인할 수 있습니다.

    Args:
        image_urls: 분석할 이미지 URL 목록
        include_objects: 객체 탐지 포함 여부
        include_text: OCR 텍스트 추출 포함 여부

    Returns:
        Job ID 및 예상 처리 시간
    """
    if not image_urls:
        return {"error": "이미지 URL이 필요합니다."}

    if len(image_urls) > 100:
        return {"error": "한 번에 최대 100개 이미지만 처리할 수 있습니다."}

    job_id = create_job(
        "batch_analysis",
        {
            "image_count": len(image_urls),
            "include_objects": include_objects,
            "include_text": include_text,
        },
    )

    # 비동기 처리 시작
    asyncio.create_task(
        process_batch_images(
            job_id,
            image_urls,
            analyze_objects=include_objects,
            analyze_text=include_text,
        )
    )

    return {
        "job_id": job_id,
        "status": JobStatus.PENDING,
        "image_count": len(image_urls),
        "estimated_time_seconds": len(image_urls) * 3,  # 이미지당 약 3초
        "message": f"배치 분석이 시작되었습니다. get_job_status('{job_id}')로 진행 상황을 확인하세요.",
    }


@server.tool()
async def get_job_status(
    job_id: str,
) -> Dict[str, Any]:
    """
    Job의 현재 상태를 조회합니다.

    Args:
        job_id: 조회할 Job ID

    Returns:
        Job 상태 (pending/processing/completed/failed), 진행률, 결과
    """
    job = get_job(job_id)
    if not job:
        return {"error": f"Job을 찾을 수 없습니다: {job_id}"}

    response = {
        "job_id": job["id"],
        "type": job["type"],
        "status": job["status"],
        "progress": job["progress"],
        "created_at": job["created_at"],
        "updated_at": job["updated_at"],
    }

    if job["status"] == JobStatus.COMPLETED:
        response["result"] = job["result"]
    elif job["status"] == JobStatus.FAILED:
        response["error"] = job["error"]

    return response


@server.tool()
async def list_available_models() -> Dict[str, Any]:
    """
    NewsInsight에서 사용 가능한 Roboflow 모델 목록을 반환합니다.

    Returns:
        사용 가능한 모델 목록 및 설명
    """
    # 기본 제공 모델 + Roboflow Universe 인기 모델
    models = [
        {
            "id": "coco/3",
            "name": "COCO Object Detection",
            "description": "80개 일반 객체 탐지 (사람, 차량, 동물 등)",
            "type": "object_detection",
            "classes": 80,
        },
        {
            "id": "yolov8n-640",
            "name": "YOLOv8 Nano",
            "description": "빠른 일반 객체 탐지",
            "type": "object_detection",
            "classes": 80,
        },
        {
            "id": "doctr/ocr",
            "name": "DocTR OCR",
            "description": "문서 및 이미지 텍스트 인식",
            "type": "ocr",
            "classes": None,
        },
        {
            "id": "face-detection-mik1i/3",
            "name": "Face Detection",
            "description": "얼굴 탐지",
            "type": "object_detection",
            "classes": 1,
        },
    ]

    # Roboflow 워크스페이스의 커스텀 모델 조회 시도
    custom_models = []
    try:
        client = get_roboflow_client()
        workspaces = await client.list_workspaces()
        for ws in workspaces.get("workspaces", []):
            ws_name = ws.get("name", "")
            if ws_name:
                try:
                    projects = await client.list_projects(ws_name)
                    for proj in projects.get("projects", []):
                        if proj.get("versions"):
                            latest = max(proj["versions"])
                            custom_models.append(
                                {
                                    "id": f"{ws_name}/{proj['id']}/{latest}",
                                    "name": proj.get("name", proj["id"]),
                                    "description": f"Custom model: {proj.get('annotation', '')}",
                                    "type": proj.get("type", "object_detection"),
                                    "classes": proj.get("classes", {}).keys()
                                    if proj.get("classes")
                                    else None,
                                }
                            )
                except:
                    pass
    except:
        pass

    return {
        "builtin_models": models,
        "custom_models": custom_models,
        "note": "custom_models는 Roboflow 워크스페이스에 등록된 모델입니다.",
    }


@server.tool()
async def health_check() -> Dict[str, Any]:
    """
    서버 상태 및 Roboflow API 연결 상태를 확인합니다.

    Returns:
        서버 상태 정보
    """
    status = {
        "server": "Roboflow CV MCP",
        "version": "1.0.0",
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
        "api_key_configured": bool(ROBOFLOW_API_KEY),
        "data_dir": str(DATA_DIR),
        "active_jobs": len(
            [
                j
                for j in _jobs.values()
                if j["status"] in [JobStatus.PENDING, JobStatus.PROCESSING]
            ]
        ),
    }

    # API 연결 테스트
    if ROBOFLOW_API_KEY:
        try:
            client = get_roboflow_client()
            await client.list_workspaces()
            status["roboflow_api"] = "connected"
        except Exception as e:
            status["roboflow_api"] = f"error: {str(e)}"
            status["status"] = "degraded"
    else:
        status["roboflow_api"] = "not_configured"
        status["status"] = "degraded"

    return status


# ─────────────────────────────────────────────
# 8. HTTP 헬스체크 핸들러
# ─────────────────────────────────────────────

from http.server import HTTPServer, BaseHTTPRequestHandler
import threading


class HealthCheckHandler(BaseHTTPRequestHandler):
    """간단한 헬스체크 엔드포인트 핸들러"""

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = {
                "status": "healthy",
                "server": "roboflow-cv-mcp",
                "version": "1.0.0",
            }
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


# ─────────────────────────────────────────────
# 9. 서버 시작
# ─────────────────────────────────────────────

if __name__ == "__main__":
    # 디렉토리 생성
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    RESULTS_DIR.mkdir(parents=True, exist_ok=True)

    print(f"Starting Roboflow CV MCP Server v1.0.0 on port {PORT}")
    print(f"API Key configured: {bool(ROBOFLOW_API_KEY)}")
    print(f"Data directory: {DATA_DIR}")

    server.run(transport="streamable-http")

```

---

## mcp/sentiment_mcp/server.py

```py
"""
Sentiment Analysis MCP Server - 뉴스 감정 분석

실제 프로젝트 스키마(collected_data, article_analysis)와 sentiment-addon을 연동하여
뉴스 기사의 감정 분석을 수행하는 MCP 서버입니다.

Version: 1.0.0
Port: 5004
"""

import os
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any
from collections import Counter

import requests
from mcp.server import FastMCP
from starlette.responses import JSONResponse
from starlette.requests import Request

# Shared modules
import sys
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from shared.db import get_postgres_conn, get_mongo_db, DB_BACKEND, check_db_connection
from shared.health import create_health_response
from shared.aidove import AIDOVE_WEBHOOK_URL, call_aidove

# ─────────────────────────────────────────────
# 1. MCP 서버 기본 설정
# ─────────────────────────────────────────────

# 포트 설정 (shared ports 모듈에서 가져오거나 환경변수)
try:
    from shared.ports import MCP_PORTS
    PORT = MCP_PORTS.get("sentiment_mcp", 5004)
except ImportError:
    PORT = int(os.environ.get("PORT", "5004"))

server = FastMCP(
    "sentiment-analysis-mcp",
    host="0.0.0.0",
    port=PORT,
)


@server.custom_route("/health", methods=["GET"])
async def health_endpoint(request: Request) -> JSONResponse:
    db_status = check_db_connection()
    return JSONResponse(
        create_health_response(
            server_name="sentiment-analysis-mcp",
            version="1.0.0",
            extra_info=db_status
        )
    )

# DB 설정은 shared.db에서 가져옴 (DB_BACKEND, get_postgres_conn, get_mongo_db)
# AiDove 설정은 shared.aidove에서 가져옴 (AIDOVE_WEBHOOK_URL, call_aidove)

# Sentiment Addon URL (서비스별 설정)
SENTIMENT_ADDON_URL = os.environ.get(
    "SENTIMENT_ADDON_URL", "http://sentiment-addon:8002"
)


# ─────────────────────────────────────────────
# 2. 감정 분석 관련 상수
# ─────────────────────────────────────────────

# 감정 레이블 매핑 (한국어)
SENTIMENT_LABELS = {
    "positive": "긍정",
    "negative": "부정",
    "neutral": "중립",
}

# 상세 감정 레이블
EMOTION_LABELS = {
    "joy": "기쁨",
    "sadness": "슬픔",
    "anger": "분노",
    "fear": "두려움",
    "surprise": "놀라움",
    "disgust": "혐오",
    "neutral": "중립",
}

# 불용어
STOPWORDS = {
    "있다",
    "하다",
    "되다",
    "이다",
    "않다",
    "없다",
    "같다",
    "보다",
    "위해",
    "대해",
    "통해",
    "따라",
    "관련",
    "대한",
    "에서",
    "으로",
}


# ─────────────────────────────────────────────
# 3. DB 연결 헬퍼 (shared.db 모듈 사용)
# ─────────────────────────────────────────────
# get_postgres_conn(), get_mongo_db()는 shared.db에서 import됨


# ─────────────────────────────────────────────
# 4. 기사 데이터 조회
# ─────────────────────────────────────────────


def get_articles_for_sentiment_analysis(
    keyword: Optional[str] = None, days: int = 7, limit: int = 100
) -> List[Dict[str, Any]]:
    """
    감정 분석을 위한 기사 데이터를 DB에서 조회.
    """
    cutoff = datetime.utcnow() - timedelta(days=days)

    if DB_BACKEND == "postgres":
        conn = get_postgres_conn()
        with conn.cursor() as cur:
            if keyword:
                query = """
                    SELECT 
                        cd.id,
                        cd.title,
                        LEFT(cd.content, 2000) as content,
                        ds.name as source_name,
                        COALESCE(cd.published_date, cd.collected_at) as published_at,
                        cd.url,
                        aa.sentiment,
                        aa.sentiment_score,
                        aa.emotions
                    FROM collected_data cd
                    LEFT JOIN data_sources ds ON cd.source_id = ds.id
                    LEFT JOIN article_analysis aa ON cd.id = aa.article_id
                    WHERE (
                        LOWER(cd.title) LIKE LOWER(%s)
                        OR LOWER(cd.content) LIKE LOWER(%s)
                    )
                    AND COALESCE(cd.published_date, cd.collected_at) >= %s
                    ORDER BY COALESCE(cd.published_date, cd.collected_at) DESC
                    LIMIT %s
                """
                like_keyword = f"%{keyword}%"
                cur.execute(query, (like_keyword, like_keyword, cutoff, limit))
            else:
                query = """
                    SELECT 
                        cd.id,
                        cd.title,
                        LEFT(cd.content, 2000) as content,
                        ds.name as source_name,
                        COALESCE(cd.published_date, cd.collected_at) as published_at,
                        cd.url,
                        aa.sentiment,
                        aa.sentiment_score,
                        aa.emotions
                    FROM collected_data cd
                    LEFT JOIN data_sources ds ON cd.source_id = ds.id
                    LEFT JOIN article_analysis aa ON cd.id = aa.article_id
                    WHERE COALESCE(cd.published_date, cd.collected_at) >= %s
                    ORDER BY COALESCE(cd.published_date, cd.collected_at) DESC
                    LIMIT %s
                """
                cur.execute(query, (cutoff, limit))

            rows = cur.fetchall()

        articles = []
        for row in rows:
            (
                id_,
                title,
                content,
                source_name,
                published_at,
                url,
                sentiment,
                sentiment_score,
                emotions,
            ) = row

            def parse_json(val):
                if val is None:
                    return None
                if isinstance(val, (dict, list)):
                    return val
                if isinstance(val, str):
                    try:
                        return json.loads(val)
                    except:
                        return val
                return val

            articles.append(
                {
                    "id": id_,
                    "title": title,
                    "content": content,
                    "source_name": source_name or "기타",
                    "published_at": published_at,
                    "url": url,
                    "sentiment": sentiment,
                    "sentiment_score": sentiment_score,
                    "emotions": parse_json(emotions),
                }
            )
        return articles

    elif DB_BACKEND == "mongo":
        db = get_mongo_db()
        query_filter = {"collected_at": {"$gte": cutoff}}
        if keyword:
            query_filter["$or"] = [
                {"title": {"$regex": keyword, "$options": "i"}},
                {"content": {"$regex": keyword, "$options": "i"}},
            ]

        cursor = (
            db.collected_data.find(query_filter).sort("collected_at", -1).limit(limit)
        )

        articles = []
        for doc in cursor:
            articles.append(
                {
                    "id": str(doc.get("_id")),
                    "title": doc.get("title", ""),
                    "content": doc.get("content", "")[:2000],
                    "source_name": doc.get("source_name", "기타"),
                    "published_at": doc.get("published_date")
                    or doc.get("collected_at"),
                    "url": doc.get("url"),
                    "sentiment": doc.get("sentiment"),
                    "sentiment_score": doc.get("sentiment_score"),
                    "emotions": doc.get("emotions"),
                }
            )
        return articles

    else:
        raise RuntimeError(f"지원하지 않는 DB_BACKEND: {DB_BACKEND}")


# ─────────────────────────────────────────────
# 5. 감정 분석 로직
# ─────────────────────────────────────────────


def call_sentiment_addon(text: str) -> Dict[str, Any]:
    """
    Sentiment addon API를 호출하여 감정 분석을 수행합니다.
    """
    try:
        response = requests.post(
            f"{SENTIMENT_ADDON_URL}/analyze",
            json={
                "article": {
                    "title": "",
                    "content": text[:2000],
                    "source": "",
                    "url": "",
                },
                "options": {
                    "detailed_emotions": True,
                },
            },
            timeout=30,
        )
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        return {"error": str(e)}


def analyze_sentiment_heuristic(text: str) -> Dict[str, Any]:
    """
    ML addon이 불가능할 때 사용하는 키워드 기반 감정 분석.
    """
    # 감정 키워드
    positive_keywords = {
        "좋다",
        "훌륭하다",
        "성공",
        "발전",
        "희망",
        "기쁨",
        "긍정",
        "최고",
        "향상",
        "개선",
        "성장",
        "달성",
        "혁신",
        "승리",
        "만족",
        "행복",
        "축하",
        "기대",
    }
    negative_keywords = {
        "나쁘다",
        "실패",
        "위기",
        "우려",
        "걱정",
        "문제",
        "손실",
        "하락",
        "감소",
        "비판",
        "논란",
        "갈등",
        "사고",
        "피해",
        "충격",
        "실망",
        "불안",
        "위험",
    }

    text_lower = text.lower()
    positive_count = sum(1 for kw in positive_keywords if kw in text_lower)
    negative_count = sum(1 for kw in negative_keywords if kw in text_lower)

    total = positive_count + negative_count
    if total == 0:
        return {
            "sentiment": "neutral",
            "sentiment_kr": "중립",
            "confidence": 0.5,
            "positive_score": 0.33,
            "negative_score": 0.33,
            "neutral_score": 0.34,
        }

    positive_ratio = positive_count / total
    negative_ratio = negative_count / total

    if positive_ratio > 0.6:
        sentiment = "positive"
    elif negative_ratio > 0.6:
        sentiment = "negative"
    else:
        sentiment = "neutral"

    return {
        "sentiment": sentiment,
        "sentiment_kr": SENTIMENT_LABELS.get(sentiment, "중립"),
        "confidence": max(positive_ratio, negative_ratio, 0.4),
        "positive_score": positive_ratio,
        "negative_score": negative_ratio,
        "neutral_score": 1 - positive_ratio - negative_ratio
        if positive_ratio + negative_ratio < 1
        else 0,
    }


def compute_sentiment_analysis(
    keyword: Optional[str] = None,
    days: int = 7,
    use_addon: bool = True,
) -> Dict[str, Any]:
    """
    키워드 관련(또는 전체) 기사들의 감정 분석을 수행합니다.
    """
    articles = get_articles_for_sentiment_analysis(keyword, days)

    if not articles:
        return {
            "keyword": keyword,
            "days": days,
            "article_count": 0,
            "sentiment_distribution": {},
            "average_sentiment_score": None,
            "timeline": {},
            "source_sentiment": {},
            "note": "분석할 기사가 없습니다.",
        }

    sentiment_counts = Counter()
    sentiment_scores = []
    timeline: Dict[str, Dict[str, int]] = {}
    source_sentiments: Dict[str, List[float]] = {}
    analyzed_count = 0
    addon_used = 0

    for article in articles:
        source = article.get("source_name", "기타")

        # 이미 분석된 결과가 있으면 사용
        if article.get("sentiment"):
            sentiment = article["sentiment"]
            score = article.get("sentiment_score", 0.5)
            analyzed_count += 1
        elif use_addon:
            # Sentiment addon 호출
            text = f"{article.get('title', '')} {article.get('content', '')}"
            result = call_sentiment_addon(text)
            if "error" not in result and result.get("data"):
                data = result["data"]
                sentiment = data.get("sentiment", {}).get("label", "neutral")
                score = data.get("sentiment", {}).get("confidence", 0.5)
                addon_used += 1
            else:
                # Fallback to heuristic
                heuristic = analyze_sentiment_heuristic(text)
                sentiment = heuristic["sentiment"]
                score = heuristic["confidence"]
        else:
            # Heuristic only
            text = f"{article.get('title', '')} {article.get('content', '')}"
            heuristic = analyze_sentiment_heuristic(text)
            sentiment = heuristic["sentiment"]
            score = heuristic["confidence"]

        sentiment_counts[sentiment] += 1
        sentiment_scores.append(
            score
            if sentiment == "positive"
            else (1 - score if sentiment == "negative" else 0.5)
        )

        # 날짜별 감정 분포
        pub_date = article.get("published_at")
        if isinstance(pub_date, datetime):
            date_key = pub_date.strftime("%Y-%m-%d")
            if date_key not in timeline:
                timeline[date_key] = {"positive": 0, "negative": 0, "neutral": 0}
            timeline[date_key][sentiment] = timeline[date_key].get(sentiment, 0) + 1

        # 출처별 감정 점수
        if source not in source_sentiments:
            source_sentiments[source] = []
        source_sentiments[source].append(
            score
            if sentiment == "positive"
            else (1 - score if sentiment == "negative" else 0.5)
        )

    # 결과 집계
    total = len(articles)
    sentiment_distribution = {
        SENTIMENT_LABELS.get(s, s): {
            "count": count,
            "ratio": round(count / total, 3),
        }
        for s, count in sentiment_counts.most_common()
    }

    # 출처별 평균 감정
    source_sentiment_avg = {
        source: {
            "avg_score": round(sum(scores) / len(scores), 3),
            "article_count": len(scores),
        }
        for source, scores in sorted(
            source_sentiments.items(), key=lambda x: len(x[1]), reverse=True
        )[:10]
    }

    # 타임라인 정렬
    sorted_timeline = {
        date: {SENTIMENT_LABELS.get(s, s): count for s, count in counts.items()}
        for date, counts in sorted(timeline.items())
    }

    # 전체 감정 추세
    avg_sentiment = (
        sum(sentiment_scores) / len(sentiment_scores) if sentiment_scores else 0.5
    )
    if avg_sentiment > 0.55:
        overall_sentiment = "긍정적"
    elif avg_sentiment < 0.45:
        overall_sentiment = "부정적"
    else:
        overall_sentiment = "중립적"

    return {
        "keyword": keyword,
        "days": days,
        "article_count": len(articles),
        "analyzed_from_db": analyzed_count,
        "addon_analyzed": addon_used,
        "sentiment_distribution": sentiment_distribution,
        "average_sentiment_score": round(avg_sentiment, 3),
        "overall_sentiment": overall_sentiment,
        "timeline": sorted_timeline,
        "source_sentiment": source_sentiment_avg,
        "generated_at": datetime.utcnow().isoformat(),
    }


# ─────────────────────────────────────────────
# 6. AiDove 호출 헬퍼
# ─────────────────────────────────────────────


def call_aidove(prompt: str, session_id: Optional[str] = None) -> str:
    """AiDove API를 호출하여 자연어 리포트를 생성합니다."""
    payload = {"chatInput": prompt}
    if session_id:
        payload["sessionId"] = session_id

    try:
        resp = requests.post(AIDOVE_WEBHOOK_URL, json=payload, timeout=60)
        resp.raise_for_status()
        data = resp.json()
        return data.get("reply", data.get("output", "리포트 생성에 실패했습니다."))
    except requests.RequestException as e:
        return f"AiDove 호출 실패: {str(e)}"


# ─────────────────────────────────────────────
# 7. MCP Tools
# ─────────────────────────────────────────────


@server.tool()
async def get_sentiment_raw(
    keyword: Optional[str] = None,
    days: int = 7,
) -> Dict[str, Any]:
    """
    키워드 관련(또는 전체) 뉴스의 감정 분석 데이터를 JSON으로 반환합니다.

    Args:
        keyword: 검색할 키워드 (None이면 전체 분석)
        days: 분석 기간 (일)

    Returns:
        감정 분석 데이터 (감정 분포, 점수, 트렌드 등)
    """
    return compute_sentiment_analysis(keyword, days)


@server.tool()
async def get_sentiment_report(
    keyword: Optional[str] = None,
    days: int = 7,
    session_id: Optional[str] = None,
) -> str:
    """
    키워드 관련(또는 전체) 뉴스의 감정을 분석하여 AiDove가 작성한 자연어 리포트를 반환합니다.

    Args:
        keyword: 검색할 키워드 (None이면 전체 분석)
        days: 분석 기간 (일)
        session_id: AiDove 세션 ID (선택)

    Returns:
        자연어 감정 분석 리포트
    """
    raw = await get_sentiment_raw(keyword=keyword, days=days)

    keyword_desc = f"'{keyword}'" if keyword else "전체 뉴스"

    prompt = f"""
너는 'News Insight'라는 뉴스 분석 서비스의 감정 분석 리포트 작성 어시스턴트야.

아래 JSON은 {keyword_desc}에 대한 감정 분석 결과야.

분석 대상: {keyword_desc}
기간: 최근 {days}일

JSON 데이터:
{json.dumps(raw, ensure_ascii=False, indent=2, default=str)}

요청사항:
1. 전체적인 감정 분포를 요약해줘. 긍정/부정/중립 비율이 어떻게 되는지 설명해줘.
2. 평균 감정 점수와 전체적인 감정 추세를 해석해줘.
3. 타임라인(일별 감정 분포)을 분석하여 감정의 변화 추이를 설명해줘. 특정 날짜에 부정적/긍정적 기사가 많았다면 그 의미를 추정해봐.
4. 출처별 감정 차이가 있다면 분석해줘. 어떤 언론사가 더 긍정적/부정적으로 보도하는지 설명해줘.
5. 이 분석 결과가 독자에게 어떤 시사점을 주는지 간단히 설명해줘.
6. 마지막에는 '감정 분석의 한계'에 대한 짧은 주의 문장을 적어줘.

전체 리포트는 3~5 단락 정도의 자연스러운 한국어로 작성해줘.
"""
    report = call_aidove(prompt, session_id=session_id)
    return report


@server.tool()
async def analyze_text_sentiment(
    text: str,
) -> Dict[str, Any]:
    """
    주어진 텍스트의 감정을 분석합니다.

    Args:
        text: 분석할 텍스트

    Returns:
        감정 분석 결과 (감정 레이블, 점수, 상세 감정)
    """
    # Try addon first
    result = call_sentiment_addon(text)

    if "error" not in result and result.get("data"):
        data = result["data"]
        return {
            "text": text[:200] + "..." if len(text) > 200 else text,
            "sentiment": data.get("sentiment", {}),
            "emotions": data.get("emotions", {}),
            "analysis_method": "ml_addon",
            "generated_at": datetime.utcnow().isoformat(),
        }
    else:
        # Fallback to heuristic
        heuristic = analyze_sentiment_heuristic(text)
        return {
            "text": text[:200] + "..." if len(text) > 200 else text,
            "sentiment": {
                "label": heuristic["sentiment"],
                "label_kr": heuristic["sentiment_kr"],
                "confidence": heuristic["confidence"],
                "scores": {
                    "positive": heuristic["positive_score"],
                    "negative": heuristic["negative_score"],
                    "neutral": heuristic["neutral_score"],
                },
            },
            "emotions": None,
            "analysis_method": "heuristic",
            "note": "ML 모델을 사용할 수 없어 키워드 기반 분석을 수행했습니다.",
            "generated_at": datetime.utcnow().isoformat(),
        }


@server.tool()
async def compare_sentiment(
    keywords: List[str],
    days: int = 7,
) -> Dict[str, Any]:
    """
    여러 키워드의 감정 분석 결과를 비교합니다.

    Args:
        keywords: 비교할 키워드 목록
        days: 분석 기간 (일)

    Returns:
        키워드별 감정 비교 데이터
    """
    comparisons = []

    for keyword in keywords[:5]:  # 최대 5개까지
        result = compute_sentiment_analysis(keyword, days, use_addon=False)
        comparisons.append(
            {
                "keyword": keyword,
                "article_count": result["article_count"],
                "sentiment_distribution": result["sentiment_distribution"],
                "average_sentiment_score": result["average_sentiment_score"],
                "overall_sentiment": result["overall_sentiment"],
            }
        )

    return {
        "keywords": keywords[:5],
        "days": days,
        "comparisons": comparisons,
        "generated_at": datetime.utcnow().isoformat(),
    }


@server.tool()
async def health_check() -> Dict[str, Any]:
    """
    서버 상태 및 DB 연결 상태를 확인합니다.

    Returns:
        서버 상태 정보
    """
    status = {
        "server": "Sentiment Analysis MCP",
        "version": "1.0.0",
        "db_backend": DB_BACKEND,
        "sentiment_addon_url": SENTIMENT_ADDON_URL,
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
    }

    # DB 연결 확인
    try:
        if DB_BACKEND == "postgres":
            conn = get_postgres_conn()
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
            status["postgres"] = "connected"
        elif DB_BACKEND == "mongo":
            db = get_mongo_db()
            db.command("ping")
            status["mongo"] = "connected"
    except Exception as e:
        status["db_error"] = str(e)
        status["status"] = "degraded"

    # Sentiment addon 연결 확인
    try:
        resp = requests.get(f"{SENTIMENT_ADDON_URL}/health", timeout=5)
        if resp.status_code == 200:
            status["sentiment_addon"] = "connected"
        else:
            status["sentiment_addon"] = "unavailable"
    except Exception as e:
        status["sentiment_addon"] = f"error: {str(e)}"

    return status


# ─────────────────────────────────────────────
# 8. 메인 실행
# ─────────────────────────────────────────────

if __name__ == "__main__":
    print(f"Starting Sentiment Analysis MCP Server v1.0.0 on port {PORT}")
    print(f"DB Backend: {DB_BACKEND}")
    print(f"Sentiment Addon: {SENTIMENT_ADDON_URL}")
    server.run(transport="streamable-http")

```

---

## mcp/shared/__init__.py

```py
"""
NewsInsight MCP Shared Module

공통 기능을 제공하는 공유 모듈:
- DB 연결 (PostgreSQL, MongoDB)
- Health check 엔드포인트
- AiDove 호출 헬퍼
- 공통 유틸리티
"""

from .db import (
    get_postgres_conn,
    get_mongo_db,
    DB_BACKEND,
    POSTGRES_DSN,
    MONGODB_URI,
)
from .health import create_health_endpoint, HealthCheckHandler
from .aidove import call_aidove, AIDOVE_WEBHOOK_URL
from .utils import parse_json

__all__ = [
    # DB
    "get_postgres_conn",
    "get_mongo_db",
    "DB_BACKEND",
    "POSTGRES_DSN",
    "MONGODB_URI",
    # Health
    "create_health_endpoint",
    "HealthCheckHandler",
    # AiDove
    "call_aidove",
    "AIDOVE_WEBHOOK_URL",
    # Utils
    "parse_json",
]

```

---

## mcp/shared/aidove.py

```py
"""
NewsInsight MCP Shared - AiDove Integration Module

AiDove API 호출을 위한 공유 모듈입니다.
"""

import os
from typing import Optional

import requests

# AiDove Webhook URL
AIDOVE_WEBHOOK_URL = os.environ.get(
    "AIDOVE_WEBHOOK_URL", "https://workflow.nodove.com/webhook/aidove"
)

# 기본 타임아웃 (초)
AIDOVE_TIMEOUT = int(os.environ.get("AIDOVE_TIMEOUT", "60"))


def call_aidove(
    prompt: str,
    session_id: Optional[str] = None,
    timeout: int = AIDOVE_TIMEOUT,
) -> str:
    """
    AiDove API를 호출하여 자연어 리포트를 생성합니다.
    
    Args:
        prompt: LLM에 전달할 프롬프트
        session_id: 세션 ID (대화 컨텍스트 유지용)
        timeout: 요청 타임아웃 (초)
        
    Returns:
        str: AiDove 응답 텍스트
    """
    payload = {"chatInput": prompt}
    if session_id:
        payload["sessionId"] = session_id

    try:
        resp = requests.post(AIDOVE_WEBHOOK_URL, json=payload, timeout=timeout)
        resp.raise_for_status()
        data = resp.json()
        return data.get("reply", data.get("output", "리포트 생성에 실패했습니다."))
    except requests.Timeout:
        return f"AiDove 호출 타임아웃 ({timeout}초)"
    except requests.RequestException as e:
        return f"AiDove 호출 실패: {str(e)}"


async def call_aidove_async(
    prompt: str,
    session_id: Optional[str] = None,
    timeout: int = AIDOVE_TIMEOUT,
) -> str:
    """
    AiDove API를 비동기로 호출합니다.
    
    Args:
        prompt: LLM에 전달할 프롬프트
        session_id: 세션 ID (대화 컨텍스트 유지용)
        timeout: 요청 타임아웃 (초)
        
    Returns:
        str: AiDove 응답 텍스트
    """
    import httpx
    
    payload = {"chatInput": prompt}
    if session_id:
        payload["sessionId"] = session_id

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            resp = await client.post(AIDOVE_WEBHOOK_URL, json=payload)
            resp.raise_for_status()
            data = resp.json()
            return data.get("reply", data.get("output", "리포트 생성에 실패했습니다."))
    except httpx.TimeoutException:
        return f"AiDove 호출 타임아웃 ({timeout}초)"
    except httpx.HTTPError as e:
        return f"AiDove 호출 실패: {str(e)}"

```

---

## mcp/shared/db.py

```py
"""
NewsInsight MCP Shared - Database Connection Module

PostgreSQL과 MongoDB 연결을 관리하는 공유 모듈입니다.
모든 MCP 서버에서 동일한 DB 연결 로직을 사용합니다.
"""

import os
from typing import Optional, Any
from urllib.parse import urlparse

# DB 백엔드 선택: "postgres" 또는 "mongo"
DB_BACKEND = os.environ.get("DB_BACKEND", "postgres")

# PostgreSQL 접속 정보 (표준: DATABASE_URL)
POSTGRES_DSN = os.environ.get("DATABASE_URL")

# MongoDB 접속 정보 (표준: MONGODB_URI - URI에 DB명 포함)
MONGODB_URI = os.environ.get("MONGODB_URI", "mongodb://localhost:27017/newsinsight")

# Connection pool
_pg_conn = None
_mongo_client = None
_mongo_db = None


def get_postgres_conn():
    """
    PostgreSQL 연결을 반환합니다.
    
    싱글톤 패턴으로 연결을 재사용합니다.
    연결이 끊어진 경우 자동으로 재연결합니다.
    
    Returns:
        psycopg2 connection object
        
    Raises:
        RuntimeError: DATABASE_URL이 설정되지 않은 경우
    """
    global _pg_conn
    import psycopg2

    if _pg_conn is None or _pg_conn.closed != 0:
        if not POSTGRES_DSN:
            raise RuntimeError("DATABASE_URL (Postgres DSN)이 설정되어 있지 않습니다.")
        _pg_conn = psycopg2.connect(POSTGRES_DSN)
        _pg_conn.autocommit = True  # 읽기 전용이므로 autocommit
    return _pg_conn


def get_mongo_db():
    """
    MongoDB 데이터베이스 객체를 반환합니다.
    
    싱글톤 패턴으로 연결을 재사용합니다.
    URI에서 데이터베이스 이름을 자동으로 추출합니다.
    
    Returns:
        pymongo Database object
        
    Raises:
        RuntimeError: MONGODB_URI가 설정되지 않은 경우
    """
    global _mongo_client, _mongo_db
    from pymongo import MongoClient

    if _mongo_db is None:
        if not MONGODB_URI:
            raise RuntimeError("MONGODB_URI가 설정되어 있지 않습니다.")

        _mongo_client = MongoClient(MONGODB_URI)

        # URI에서 DB명 추출 (예: mongodb://...../newsinsight?...)
        parsed = urlparse(MONGODB_URI)
        db_name = parsed.path.lstrip("/").split("?")[0] or "newsinsight"
        _mongo_db = _mongo_client[db_name]

    return _mongo_db


def check_db_connection() -> dict:
    """
    DB 연결 상태를 확인합니다.
    
    Returns:
        dict: DB 연결 상태 정보
    """
    status = {"db_backend": DB_BACKEND}
    
    try:
        if DB_BACKEND == "postgres":
            conn = get_postgres_conn()
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
            status["postgres"] = "connected"
        elif DB_BACKEND == "mongo":
            db = get_mongo_db()
            db.command("ping")
            status["mongo"] = "connected"
    except Exception as e:
        status["db_error"] = str(e)
        status["status"] = "degraded"
    
    return status


def close_connections():
    """
    모든 DB 연결을 닫습니다.
    서버 종료 시 호출합니다.
    """
    global _pg_conn, _mongo_client, _mongo_db
    
    if _pg_conn is not None:
        try:
            _pg_conn.close()
        except:
            pass
        _pg_conn = None
    
    if _mongo_client is not None:
        try:
            _mongo_client.close()
        except:
            pass
        _mongo_client = None
        _mongo_db = None

```

---

## mcp/shared/health.py

```py
"""
NewsInsight MCP Shared - Health Check Module

Health check 엔드포인트와 핸들러를 제공하는 공유 모듈입니다.
"""

import json
from datetime import datetime
from typing import Callable
from http.server import BaseHTTPRequestHandler

from starlette.responses import JSONResponse
from starlette.requests import Request


def create_health_endpoint(server_name: str, version: str = "1.0.0"):
    """
    Health check 엔드포인트 핸들러를 생성합니다.

    Args:
        server_name: 서버 이름 (예: "news-insight-mcp")
        version: 서버 버전

    Returns:
        async function: Starlette 라우트 핸들러

    Usage:
        @server.custom_route("/health", methods=["GET"])
        async def health_endpoint(request: Request) -> JSONResponse:
            return await create_health_endpoint("my-server", "1.0.0")(request)
    """

    async def health_handler(request: Request) -> JSONResponse:
        return JSONResponse(
            {
                "status": "healthy",
                "server": server_name,
                "version": version,
                "timestamp": datetime.utcnow().isoformat(),
            }
        )

    return health_handler


class HealthCheckHandler(BaseHTTPRequestHandler):
    """
    간단한 HTTP 헬스체크 엔드포인트 핸들러.

    별도의 HTTP 서버로 헬스체크를 제공할 때 사용합니다.

    Usage:
        handler = HealthCheckHandler.create_handler("my-server", "1.0.0")
        httpd = HTTPServer(("0.0.0.0", 8080), handler)
        httpd.serve_forever()
    """

    server_name = "mcp-server"
    server_version = "1.0.0"

    @classmethod
    def create_handler(cls, server_name: str, version: str = "1.0.0"):
        """
        커스텀 서버 정보로 핸들러 클래스를 생성합니다.
        """

        class CustomHandler(cls):
            pass

        CustomHandler.server_name = server_name
        CustomHandler.server_version = version
        return CustomHandler

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = {
                "status": "healthy",
                "server": self.server_name,
                "version": self.server_version,
            }
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        # 로깅 비활성화
        pass


def create_health_response(
    server_name: str,
    version: str = "1.0.0",
    extra_info: dict = None,
) -> dict:
    """
    Health check 응답 딕셔너리를 생성합니다.

    Args:
        server_name: 서버 이름 (예: "news-insight-mcp")
        version: 서버 버전
        extra_info: 추가 상태 정보 (예: DB 연결 상태)

    Returns:
        dict: Health check 응답 딕셔너리

    Usage:
        return JSONResponse(create_health_response("my-server", "1.0.0", db_status))
    """
    response = {
        "status": "healthy",
        "server": server_name,
        "version": version,
        "timestamp": datetime.utcnow().isoformat(),
    }

    if extra_info:
        response.update(extra_info)
        # Check for error conditions
        if extra_info.get("db_error"):
            response["status"] = "degraded"

    return response


def get_health_status(
    server_name: str,
    version: str,
    db_status: dict = None,
    extra_status: dict = None,
) -> dict:
    """
    종합 헬스 상태를 반환합니다.

    Args:
        server_name: 서버 이름
        version: 서버 버전
        db_status: DB 연결 상태 (선택)
        extra_status: 추가 상태 정보 (선택)

    Returns:
        dict: 종합 헬스 상태
    """
    status = {
        "server": server_name,
        "version": version,
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
    }

    if db_status:
        status.update(db_status)
        if db_status.get("db_error"):
            status["status"] = "degraded"

    if extra_status:
        status.update(extra_status)

    return status

```

---

## mcp/shared/ports.py

```py
"""
NewsInsight MCP Shared - Port Configuration

모든 MCP 서버의 포트 할당을 중앙 관리합니다.
포트 충돌을 방지하고 일관된 포트 번호를 유지합니다.

Port Range: 5000-5020
"""

# MCP 서버 포트 할당
MCP_PORTS = {
    "newsinsight_mcp": 5000,  # 감정 분석 및 여론 온도
    "bias_mcp": 5001,  # 편향성 분석
    "factcheck_mcp": 5002,  # 팩트체크
    "topic_mcp": 5003,  # 토픽 추출
    "sentiment_mcp": 5004,  # 감정 분석 (외부 addon)
    "aiagent_mcp": 5010,  # AI Agent LLM 라우팅
    "huggingface_mcp": 5011,  # HuggingFace 모델
    "kaggle_mcp": 5012,  # Kaggle 데이터셋
    "mltraining_mcp": 5013,  # ML 학습
    "roboflow_mcp": 5014,  # Computer Vision
}

# 예약된 포트 (다른 서비스용)
RESERVED_PORTS = {
    5005: "reserved",
    5006: "reserved",
    5007: "reserved",
    5008: "reserved",
    5009: "reserved",
    5015: "reserved",
}


def get_port(server_name: str, default: int = 5000) -> int:
    """
    서버 이름으로 할당된 포트를 반환합니다.

    환경변수 PORT가 설정되어 있으면 환경변수 값을 우선합니다.

    Args:
        server_name: 서버 이름 (예: "newsinsight_mcp")
        default: 기본 포트 번호

    Returns:
        int: 포트 번호
    """
    import os

    # 환경변수 우선
    env_port = os.environ.get("PORT")
    if env_port:
        try:
            return int(env_port)
        except ValueError:
            pass

    return MCP_PORTS.get(server_name, default)


def validate_ports() -> dict:
    """
    포트 할당의 유효성을 검증합니다.

    Returns:
        dict: 검증 결과 (conflicts, warnings)
    """
    result = {
        "valid": True,
        "conflicts": [],
        "warnings": [],
    }

    # 포트 중복 확인
    port_to_servers = {}
    for server, port in MCP_PORTS.items():
        if port in port_to_servers:
            result["valid"] = False
            result["conflicts"].append(
                {
                    "port": port,
                    "servers": [port_to_servers[port], server],
                }
            )
        else:
            port_to_servers[port] = server

    # 예약된 포트 사용 확인
    for server, port in MCP_PORTS.items():
        if port in RESERVED_PORTS:
            result["warnings"].append(
                {
                    "port": port,
                    "server": server,
                    "reason": f"Using reserved port: {RESERVED_PORTS[port]}",
                }
            )

    return result


if __name__ == "__main__":
    # 포트 할당 출력
    print("MCP Server Port Assignments:")
    print("-" * 40)
    for server, port in sorted(MCP_PORTS.items(), key=lambda x: x[1]):
        print(f"  {server}: {port}")

    print("\nValidation:")
    validation = validate_ports()
    if validation["valid"]:
        print("  ✓ All ports are valid")
    else:
        for conflict in validation["conflicts"]:
            print(f"  ✗ Port conflict: {conflict}")

```

---

## mcp/shared/utils.py

```py
"""
NewsInsight MCP Shared - Utility Functions

공통 유틸리티 함수를 제공하는 모듈입니다.
"""

import json
from typing import Any, TypeVar, Union

T = TypeVar('T')


def parse_json(val: Any, default: T = None) -> Union[T, Any]:
    """
    JSON 문자열 또는 값을 파싱합니다.
    
    DB에서 조회한 JSONB 필드를 안전하게 파싱합니다.
    이미 파싱된 dict/list는 그대로 반환합니다.
    
    Args:
        val: 파싱할 값 (str, dict, list, None)
        default: 파싱 실패 시 반환할 기본값
        
    Returns:
        파싱된 값 또는 기본값
        
    Examples:
        >>> parse_json('{"key": "value"}', {})
        {'key': 'value'}
        >>> parse_json(None, [])
        []
        >>> parse_json({'already': 'parsed'}, {})
        {'already': 'parsed'}
    """
    if val is None:
        return default
    if isinstance(val, (dict, list)):
        return val
    if isinstance(val, str):
        try:
            return json.loads(val)
        except (json.JSONDecodeError, ValueError):
            return default
    return default


def parse_json_list(val: Any) -> list:
    """JSON을 리스트로 파싱합니다."""
    return parse_json(val, [])


def parse_json_dict(val: Any) -> dict:
    """JSON을 딕셔너리로 파싱합니다."""
    return parse_json(val, {})


def truncate_text(text: str, max_length: int = 500, suffix: str = "...") -> str:
    """
    텍스트를 지정된 길이로 자릅니다.
    
    Args:
        text: 자를 텍스트
        max_length: 최대 길이
        suffix: 잘린 경우 추가할 접미사
        
    Returns:
        잘린 텍스트
    """
    if not text or len(text) <= max_length:
        return text or ""
    return text[:max_length - len(suffix)] + suffix


def safe_float(val: Any, default: float = 0.0) -> float:
    """
    값을 안전하게 float로 변환합니다.
    
    Args:
        val: 변환할 값
        default: 변환 실패 시 기본값
        
    Returns:
        float 값
    """
    if val is None:
        return default
    try:
        return float(val)
    except (ValueError, TypeError):
        return default


def safe_int(val: Any, default: int = 0) -> int:
    """
    값을 안전하게 int로 변환합니다.
    
    Args:
        val: 변환할 값
        default: 변환 실패 시 기본값
        
    Returns:
        int 값
    """
    if val is None:
        return default
    try:
        return int(val)
    except (ValueError, TypeError):
        return default

```

---

## mcp/topic_mcp/server.py

```py
"""
Topic Analysis MCP Server - 뉴스 토픽/트렌드 분석

실제 프로젝트 스키마(collected_data, article_analysis)를 기반으로
뉴스 토픽, 키워드 트렌드, 관련 이슈를 분석하는 MCP 서버입니다.

Version: 1.0.0
Port: 5003
"""

import os
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any
from collections import Counter

import requests
from mcp.server import FastMCP
from starlette.responses import JSONResponse
from starlette.requests import Request

# Shared modules
import sys
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from shared.db import get_postgres_conn, get_mongo_db, DB_BACKEND, check_db_connection
from shared.health import create_health_response
from shared.aidove import AIDOVE_WEBHOOK_URL, call_aidove

# ─────────────────────────────────────────────
# 1. MCP 서버 기본 설정
# ─────────────────────────────────────────────

# 포트 설정 (shared ports 모듈에서 가져오거나 환경변수)
try:
    from shared.ports import MCP_PORTS
    PORT = MCP_PORTS.get("topic_mcp", 5003)
except ImportError:
    PORT = int(os.environ.get("PORT", "5003"))

server = FastMCP(
    "topic-analysis-mcp",
    host="0.0.0.0",
    port=PORT,
)


# Health check endpoint (using shared module)
@server.custom_route("/health", methods=["GET"])
async def health_endpoint(request: Request) -> JSONResponse:
    db_status = check_db_connection()
    return JSONResponse(
        create_health_response(
            server_name="topic-analysis-mcp",
            version="1.0.0",
            extra_info=db_status
        )
    )

# DB 설정은 shared.db에서 가져옴 (DB_BACKEND, get_postgres_conn, get_mongo_db)
# AiDove 설정은 shared.aidove에서 가져옴 (AIDOVE_WEBHOOK_URL, call_aidove)


# ─────────────────────────────────────────────
# 2. 토픽 분석 관련 상수
# ─────────────────────────────────────────────

# 카테고리 매핑
CATEGORY_KEYWORDS = {
    "정치": [
        "대통령",
        "국회",
        "여당",
        "야당",
        "정부",
        "선거",
        "의원",
        "장관",
        "청와대",
        "총리",
    ],
    "경제": [
        "주식",
        "코스피",
        "환율",
        "금리",
        "물가",
        "GDP",
        "수출",
        "투자",
        "기업",
        "은행",
    ],
    "사회": [
        "사건",
        "사고",
        "범죄",
        "재판",
        "경찰",
        "검찰",
        "법원",
        "시민",
        "단체",
        "복지",
    ],
    "국제": [
        "미국",
        "중국",
        "일본",
        "러시아",
        "북한",
        "유럽",
        "UN",
        "외교",
        "정상회담",
        "무역",
    ],
    "문화": [
        "영화",
        "드라마",
        "음악",
        "공연",
        "전시",
        "예술",
        "연예",
        "방송",
        "K-POP",
        "한류",
    ],
    "IT/과학": [
        "AI",
        "인공지능",
        "반도체",
        "스마트폰",
        "IT",
        "테크",
        "우주",
        "로봇",
        "디지털",
        "플랫폼",
    ],
    "스포츠": [
        "축구",
        "야구",
        "농구",
        "올림픽",
        "월드컵",
        "선수",
        "감독",
        "경기",
        "리그",
        "승리",
    ],
}

# 불용어 (분석에서 제외할 일반적인 단어)
STOPWORDS = {
    "있다",
    "하다",
    "되다",
    "이다",
    "않다",
    "없다",
    "같다",
    "보다",
    "위해",
    "대해",
    "통해",
    "따라",
    "관련",
    "대한",
    "에서",
    "으로",
    "에게",
    "까지",
    "부터",
    "처럼",
    "오늘",
    "내일",
    "어제",
    "올해",
    "지난",
    "이번",
    "다음",
    "최근",
    "현재",
    "앞으로",
}


# ─────────────────────────────────────────────
# 3. DB 연결 헬퍼 (shared.db 모듈 사용)
# ─────────────────────────────────────────────
# get_postgres_conn(), get_mongo_db()는 shared.db에서 import됨


# ─────────────────────────────────────────────
# 4. 토픽 데이터 조회
# ─────────────────────────────────────────────


def get_articles_for_topic_analysis(
    keyword: Optional[str] = None, days: int = 7, limit: int = 200
) -> List[Dict[str, Any]]:
    """
    토픽 분석을 위한 기사 데이터를 DB에서 조회.
    keyword가 None이면 전체 최신 기사를 조회.
    """
    cutoff = datetime.utcnow() - timedelta(days=days)

    if DB_BACKEND == "postgres":
        conn = get_postgres_conn()
        with conn.cursor() as cur:
            if keyword:
                query = """
                    SELECT 
                        cd.id,
                        cd.title,
                        COALESCE(aa.summary, LEFT(cd.content, 1000)) as content,
                        ds.name as source_name,
                        COALESCE(cd.published_date, cd.collected_at) as published_at,
                        cd.url,
                        aa.keywords,
                        aa.entities,
                        aa.topics,
                        aa.category
                    FROM collected_data cd
                    LEFT JOIN data_sources ds ON cd.source_id = ds.id
                    LEFT JOIN article_analysis aa ON cd.id = aa.article_id
                    WHERE (
                        LOWER(cd.title) LIKE LOWER(%s)
                        OR LOWER(cd.content) LIKE LOWER(%s)
                    )
                    AND COALESCE(cd.published_date, cd.collected_at) >= %s
                    ORDER BY COALESCE(cd.published_date, cd.collected_at) DESC
                    LIMIT %s
                """
                like_keyword = f"%{keyword}%"
                cur.execute(query, (like_keyword, like_keyword, cutoff, limit))
            else:
                query = """
                    SELECT 
                        cd.id,
                        cd.title,
                        COALESCE(aa.summary, LEFT(cd.content, 1000)) as content,
                        ds.name as source_name,
                        COALESCE(cd.published_date, cd.collected_at) as published_at,
                        cd.url,
                        aa.keywords,
                        aa.entities,
                        aa.topics,
                        aa.category
                    FROM collected_data cd
                    LEFT JOIN data_sources ds ON cd.source_id = ds.id
                    LEFT JOIN article_analysis aa ON cd.id = aa.article_id
                    WHERE COALESCE(cd.published_date, cd.collected_at) >= %s
                    ORDER BY COALESCE(cd.published_date, cd.collected_at) DESC
                    LIMIT %s
                """
                cur.execute(query, (cutoff, limit))

            rows = cur.fetchall()

        articles = []
        for row in rows:
            (
                id_,
                title,
                content,
                source_name,
                published_at,
                url,
                keywords,
                entities,
                topics,
                category,
            ) = row

            # JSONB 파싱
            def parse_json(val):
                if val is None:
                    return []
                if isinstance(val, list):
                    return val
                if isinstance(val, str):
                    try:
                        return json.loads(val)
                    except:
                        return []
                return []

            articles.append(
                {
                    "id": id_,
                    "title": title,
                    "content": content,
                    "source_name": source_name or "기타",
                    "published_at": published_at,
                    "url": url,
                    "keywords": parse_json(keywords),
                    "entities": parse_json(entities),
                    "topics": parse_json(topics),
                    "category": category,
                }
            )
        return articles

    elif DB_BACKEND == "mongo":
        db = get_mongo_db()
        query_filter = {"collected_at": {"$gte": cutoff}}
        if keyword:
            query_filter["$or"] = [
                {"title": {"$regex": keyword, "$options": "i"}},
                {"content": {"$regex": keyword, "$options": "i"}},
            ]

        cursor = (
            db.collected_data.find(query_filter).sort("collected_at", -1).limit(limit)
        )

        articles = []
        for doc in cursor:
            articles.append(
                {
                    "id": str(doc.get("_id")),
                    "title": doc.get("title", ""),
                    "content": doc.get("content", "")[:1000],
                    "source_name": doc.get("source_name", "기타"),
                    "published_at": doc.get("published_date")
                    or doc.get("collected_at"),
                    "url": doc.get("url"),
                    "keywords": doc.get("keywords", []),
                    "entities": doc.get("entities", []),
                    "topics": doc.get("topics", []),
                    "category": doc.get("category"),
                }
            )
        return articles

    else:
        raise RuntimeError(f"지원하지 않는 DB_BACKEND: {DB_BACKEND}")


# ─────────────────────────────────────────────
# 5. 키워드 추출 (룰 기반 Fallback)
# ─────────────────────────────────────────────


def extract_keywords_simple(text: str, top_n: int = 20) -> List[Dict[str, Any]]:
    """
    간단한 룰 기반 키워드 추출 (ML 결과가 없을 때 사용).
    한글 명사 추출 휴리스틱 사용.
    """
    import re

    # 한글 단어 추출 (2글자 이상)
    words = re.findall(r"[가-힣]{2,}", text)

    # 불용어 제거
    words = [w for w in words if w not in STOPWORDS and len(w) >= 2]

    # 빈도 계산
    counter = Counter(words)

    # 상위 N개 반환
    result = []
    for word, count in counter.most_common(top_n):
        result.append({"word": word, "count": count})

    return result


def detect_category(text: str, keywords: List[str]) -> str:
    """
    텍스트와 키워드를 기반으로 카테고리를 추정합니다.
    """
    category_scores = {}
    combined_text = f"{text} {' '.join(keywords)}".lower()

    for category, cat_keywords in CATEGORY_KEYWORDS.items():
        score = sum(1 for kw in cat_keywords if kw in combined_text)
        if score > 0:
            category_scores[category] = score

    if category_scores:
        return max(category_scores.items(), key=lambda x: x[1])[0]
    return "기타"


# ─────────────────────────────────────────────
# 6. 토픽 분석 로직
# ─────────────────────────────────────────────


def compute_topic_analysis(
    keyword: Optional[str] = None,
    days: int = 7,
) -> Dict[str, Any]:
    """
    키워드 관련(또는 전체) 기사들의 토픽을 종합 분석합니다.
    """
    articles = get_articles_for_topic_analysis(keyword, days)

    if not articles:
        return {
            "keyword": keyword,
            "days": days,
            "article_count": 0,
            "top_keywords": [],
            "category_distribution": {},
            "source_distribution": {},
            "timeline": {},
            "related_topics": [],
            "ml_analyzed_count": 0,
            "note": "분석할 기사가 없습니다.",
        }

    # 전체 키워드 집계
    all_keywords: Counter = Counter()
    category_counts: Counter = Counter()
    source_counts: Counter = Counter()
    timeline: Dict[str, int] = {}
    ml_count = 0
    all_entities: Counter = Counter()

    for article in articles:
        source = article.get("source_name", "기타")
        source_counts[source] += 1

        # 날짜별 기사 수
        pub_date = article.get("published_at")
        if isinstance(pub_date, datetime):
            date_key = pub_date.strftime("%Y-%m-%d")
            timeline[date_key] = timeline.get(date_key, 0) + 1

        # ML 키워드가 있으면 사용, 없으면 룰 기반 추출
        if article.get("keywords") and len(article["keywords"]) > 0:
            for kw in article["keywords"]:
                if isinstance(kw, dict):
                    word = kw.get("word") or kw.get("keyword", "")
                    count = kw.get("count", 1)
                else:
                    word = str(kw)
                    count = 1
                if word and word not in STOPWORDS:
                    all_keywords[word] += count
            ml_count += 1
        else:
            text = f"{article.get('title', '')} {article.get('content', '')}"
            extracted = extract_keywords_simple(text, 10)
            for kw in extracted:
                all_keywords[kw["word"]] += kw["count"]

        # 엔티티 집계
        for entity in article.get("entities", []):
            if isinstance(entity, dict):
                name = entity.get("name") or entity.get("entity", "")
            else:
                name = str(entity)
            if name:
                all_entities[name] += 1

        # 카테고리 집계
        category = article.get("category")
        if category:
            category_counts[category] += 1
        else:
            # 카테고리가 없으면 추정
            keywords_list = [
                kw.get("word", kw) if isinstance(kw, dict) else str(kw)
                for kw in article.get("keywords", [])
            ]
            detected = detect_category(article.get("title", ""), keywords_list)
            category_counts[detected] += 1

    # 상위 키워드
    top_keywords = [
        {"word": word, "count": count} for word, count in all_keywords.most_common(30)
    ]

    # 상위 엔티티 (인물, 기관 등)
    top_entities = [
        {"name": name, "count": count} for name, count in all_entities.most_common(20)
    ]

    # 카테고리 분포
    total = len(articles)
    category_distribution = {
        cat: {"count": count, "ratio": round(count / total, 3)}
        for cat, count in category_counts.most_common()
    }

    # 출처 분포
    source_distribution = {
        source: {"count": count, "ratio": round(count / total, 3)}
        for source, count in source_counts.most_common(10)
    }

    # 타임라인 정렬
    sorted_timeline = dict(sorted(timeline.items()))

    # 관련 토픽 (상위 키워드 기반)
    related_topics = [kw["word"] for kw in top_keywords[:10]]

    return {
        "keyword": keyword,
        "days": days,
        "article_count": len(articles),
        "ml_analyzed_count": ml_count,
        "top_keywords": top_keywords,
        "top_entities": top_entities,
        "category_distribution": category_distribution,
        "source_distribution": source_distribution,
        "timeline": sorted_timeline,
        "related_topics": related_topics,
        "trend_summary": {
            "peak_date": max(timeline.items(), key=lambda x: x[1])[0]
            if timeline
            else None,
            "peak_count": max(timeline.values()) if timeline else 0,
            "avg_daily_articles": round(len(articles) / max(days, 1), 1),
        },
        "note": f"ML 분석 {ml_count}건, 룰 기반 {len(articles) - ml_count}건",
    }


def compute_trending_topics(days: int = 1, limit: int = 10) -> Dict[str, Any]:
    """
    최근 N일간 트렌딩 토픽을 분석합니다.
    """
    articles = get_articles_for_topic_analysis(keyword=None, days=days, limit=500)

    if not articles:
        return {
            "days": days,
            "article_count": 0,
            "trending_topics": [],
            "note": "분석할 기사가 없습니다.",
        }

    # 키워드 빈도 집계
    keyword_freq: Counter = Counter()
    keyword_sources: Dict[str, set] = {}  # 키워드별 출처 다양성

    for article in articles:
        source = article.get("source_name", "기타")

        # 키워드 추출
        if article.get("keywords") and len(article["keywords"]) > 0:
            keywords = []
            for kw in article["keywords"]:
                if isinstance(kw, dict):
                    keywords.append(kw.get("word") or kw.get("keyword", ""))
                else:
                    keywords.append(str(kw))
        else:
            text = f"{article.get('title', '')} {article.get('content', '')}"
            extracted = extract_keywords_simple(text, 5)
            keywords = [kw["word"] for kw in extracted]

        for word in keywords:
            if word and word not in STOPWORDS:
                keyword_freq[word] += 1
                if word not in keyword_sources:
                    keyword_sources[word] = set()
                keyword_sources[word].add(source)

    # 트렌딩 점수 계산 (빈도 × 출처 다양성)
    trending_scores = []
    for word, freq in keyword_freq.most_common(50):
        source_diversity = len(keyword_sources.get(word, set()))
        score = freq * (1 + source_diversity * 0.2)  # 다양한 출처일수록 가중치
        trending_scores.append(
            {
                "topic": word,
                "frequency": freq,
                "source_count": source_diversity,
                "trending_score": round(score, 1),
            }
        )

    # 점수 기준 정렬
    trending_scores.sort(key=lambda x: x["trending_score"], reverse=True)

    return {
        "days": days,
        "article_count": len(articles),
        "trending_topics": trending_scores[:limit],
        "generated_at": datetime.utcnow().isoformat(),
    }


# ─────────────────────────────────────────────
# 7. AiDove 호출 헬퍼
# ─────────────────────────────────────────────


def call_aidove(prompt: str, session_id: Optional[str] = None) -> str:
    """AiDove API를 호출하여 자연어 리포트를 생성합니다."""
    payload = {"chatInput": prompt}
    if session_id:
        payload["sessionId"] = session_id

    try:
        resp = requests.post(AIDOVE_WEBHOOK_URL, json=payload, timeout=60)
        resp.raise_for_status()
        data = resp.json()
        return data.get("reply", data.get("output", "리포트 생성에 실패했습니다."))
    except requests.RequestException as e:
        return f"AiDove 호출 실패: {str(e)}"


# ─────────────────────────────────────────────
# 8. MCP Tools
# ─────────────────────────────────────────────


@server.tool()
async def get_topic_raw(
    keyword: Optional[str] = None,
    days: int = 7,
) -> Dict[str, Any]:
    """
    키워드 관련(또는 전체) 뉴스의 토픽 분석 데이터를 JSON으로 반환합니다.

    Args:
        keyword: 검색할 키워드 (None이면 전체 분석)
        days: 분석 기간 (일)

    Returns:
        토픽 분석 데이터 (키워드, 카테고리, 트렌드 등)
    """
    result = compute_topic_analysis(keyword, days)
    result["generated_at"] = datetime.utcnow().isoformat()
    return result


@server.tool()
async def get_topic_report(
    keyword: Optional[str] = None,
    days: int = 7,
    session_id: Optional[str] = None,
) -> str:
    """
    키워드 관련(또는 전체) 뉴스의 토픽을 분석하여 AiDove가 작성한 자연어 리포트를 반환합니다.

    Args:
        keyword: 검색할 키워드 (None이면 전체 분석)
        days: 분석 기간 (일)
        session_id: AiDove 세션 ID (선택)

    Returns:
        자연어 토픽 분석 리포트
    """
    raw = await get_topic_raw(keyword=keyword, days=days)

    keyword_desc = f"'{keyword}'" if keyword else "전체 뉴스"

    prompt = f"""
너는 'News Insight'라는 뉴스 분석 서비스의 토픽 분석 리포트 작성 어시스턴트야.

아래 JSON은 {keyword_desc}에 대한 토픽 분석 결과야.

분석 대상: {keyword_desc}
기간: 최근 {days}일

JSON 데이터:
{json.dumps(raw, ensure_ascii=False, indent=2, default=str)}

요청사항:
1. 주요 토픽/키워드 트렌드를 요약해줘. 어떤 주제가 가장 많이 다뤄졌는지 설명해줘.
2. 카테고리 분포를 분석하고, 이 키워드가 주로 어떤 분야에서 다뤄지는지 설명해줘.
3. 타임라인(일별 기사 수)을 분석하여 보도량의 추이를 설명해줘. 특정 날짜에 급증했다면 그 이유를 추정해봐.
4. 주요 엔티티(인물, 기관 등)가 있다면 어떤 주체들이 연관되어 있는지 설명해줘.
5. 관련 토픽을 기반으로 독자가 함께 살펴볼 만한 연관 주제를 추천해줘.
6. 마지막에는 '토픽 분석의 한계'에 대한 짧은 주의 문장을 적어줘.

전체 리포트는 3~6 단락 정도의 자연스러운 한국어로 작성해줘.
"""
    report = call_aidove(prompt, session_id=session_id)
    return report


@server.tool()
async def get_trending_topics(
    days: int = 1,
    limit: int = 10,
) -> Dict[str, Any]:
    """
    최근 N일간 트렌딩 토픽 목록을 반환합니다.

    Args:
        days: 분석 기간 (일, 기본 1일)
        limit: 반환할 토픽 수 (기본 10개)

    Returns:
        트렌딩 토픽 목록
    """
    return compute_trending_topics(days, limit)


@server.tool()
async def get_category_list() -> Dict[str, Any]:
    """
    지원하는 뉴스 카테고리 목록과 관련 키워드를 반환합니다.

    Returns:
        카테고리 목록 및 키워드
    """
    return {
        "description": "뉴스 분류에 사용되는 카테고리 목록",
        "categories": [
            {
                "name": category,
                "keywords": keywords,
            }
            for category, keywords in CATEGORY_KEYWORDS.items()
        ],
    }


@server.tool()
async def health_check() -> Dict[str, Any]:
    """
    서버 상태 및 DB 연결 상태를 확인합니다.

    Returns:
        서버 상태 정보
    """
    status = {
        "server": "Topic Analysis MCP",
        "version": "1.0.0",
        "db_backend": DB_BACKEND,
        "status": "running",
        "timestamp": datetime.utcnow().isoformat(),
    }

    try:
        if DB_BACKEND == "postgres":
            conn = get_postgres_conn()
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
            status["postgres"] = "connected"
        elif DB_BACKEND == "mongo":
            db = get_mongo_db()
            db.command("ping")
            status["mongo"] = "connected"
    except Exception as e:
        status["db_error"] = str(e)
        status["status"] = "degraded"

    return status


# ─────────────────────────────────────────────
# 9. HTTP 헬스체크 핸들러
# ─────────────────────────────────────────────

from http.server import HTTPServer, BaseHTTPRequestHandler
import threading


class HealthCheckHandler(BaseHTTPRequestHandler):
    """간단한 헬스체크 엔드포인트 핸들러"""

    def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = {
                "status": "healthy",
                "server": "topic-analysis-mcp",
                "version": "1.0.0",
            }
            self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


if __name__ == "__main__":
    print(f"Starting Topic Analysis MCP Server v1.0.0 on port {PORT}")
    print(f"DB Backend: {DB_BACKEND}")
    server.run(transport="streamable-http")

```

---

## mcp.json

```json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "cloudflare": {
      "type": "local",
      "command": ["npx", "-y", "@cloudflare/mcp-server-cloudflare"],
      "enabled": true,
      "environment": {
        "CLOUDFLARE_ACCOUNT_ID": "{env:CLOUDFLARE_ACCOUNT_ID}",
        "CLOUDFLARE_API_TOKEN": "{env:CLOUDFLARE_API_TOKEN}"
      }
    },
    "gcp": {
      "type": "local",
      "command": ["npx", "-y", "@anthropic/mcp-server-gcp"],
      "enabled": true,
      "environment": {
        "GOOGLE_APPLICATION_CREDENTIALS": "{env:GOOGLE_APPLICATION_CREDENTIALS}"
      }
    },
    "aws-core": {
      "type": "local",
      "command": [
        "uvx",
        "awslabs.aws-documentation-mcp-server@latest"
      ],
      "enabled": true,
      "environment": {
        "AWS_PROFILE": "{env:AWS_PROFILE}",
        "AWS_REGION": "{env:AWS_REGION}",
        "FASTMCP_LOG_LEVEL": "ERROR"
      }
    },
    "aws-cdk": {
      "type": "local",
      "command": [
        "uvx",
        "awslabs.cdk-mcp-server@latest"
      ],
      "enabled": true,
      "environment": {
        "AWS_PROFILE": "{env:AWS_PROFILE}",
        "AWS_REGION": "{env:AWS_REGION}",
        "FASTMCP_LOG_LEVEL": "ERROR"
      }
    }
  }
}

```

---

## mkdocs.yml

```yml
site_name: Cloud Computing Project Docs
strict: true

theme:
  name: material

docs_dir: docs

nav:
  - Home: service/init_document/ko/init_document.md
  - 서비스 소개:
      - 초기 문서 (KO): service/init_document/ko/init_document.md
      - Initial Document (EN): service/init_document/en/init_document.md
  - Crawler:
      - Overview (EN): service/crawler/en/overview.md
      - Endpoints (EN): service/crawler/en/endpoints.md
      - Data Contracts (EN): service/crawler/en/data-contracts.md
      - 개요 (KO): service/crawler/ko/overview.md
      - 엔드포인트 (KO): service/crawler/ko/endpoints.md
      - 데이터 계약 (KO): service/crawler/ko/data-contracts.md
  - News Crawling Service:
      - English: service/news-crawling-service/en/news-crawling-service.md
      - 한국어: service/news-crawling-service/ko/news-crawling-service.md
  - News Keyword Service:
      - English: service/news-keyword-service/en/news-keyword-service.md
      - 한국어: service/news-keyword-service/ko/news-keyword-service.md
  - News Sentiment Service:
      - English: service/news-sentiment-service/en/news-sentiment-service.md
      - 한국어: service/news-sentiment-service/ko/news-sentiment-service.md

```

---

## package-lock.json

```json
{
  "name": "NewsInsight",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "devDependencies": {
        "puppeteer": "^24.31.0"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz",
      "integrity": "sha512-cjQ7ZlQ0Mv3b47hABuTevyTuYN4i+loJKGeV9flcCgIK37cCXRh+L1bd3iBHlynerhQ7BhCkn2BPbQUL+rGqFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.27.1",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@puppeteer/browsers": {
      "version": "2.10.13",
      "resolved": "https://registry.npmjs.org/@puppeteer/browsers/-/browsers-2.10.13.tgz",
      "integrity": "sha512-a9Ruw3j3qlnB5a/zHRTkruppynxqaeE4H9WNj5eYGRWqw0ZauZ23f4W2ARf3hghF5doozyD+CRtt7XSYuYRI/Q==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "debug": "^4.4.3",
        "extract-zip": "^2.0.1",
        "progress": "^2.0.3",
        "proxy-agent": "^6.5.0",
        "semver": "^7.7.3",
        "tar-fs": "^3.1.1",
        "yargs": "^17.7.2"
      },
      "bin": {
        "browsers": "lib/cjs/main-cli.js"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@tootallnate/quickjs-emscripten": {
      "version": "0.23.0",
      "resolved": "https://registry.npmjs.org/@tootallnate/quickjs-emscripten/-/quickjs-emscripten-0.23.0.tgz",
      "integrity": "sha512-C5Mc6rdnsaJDjO3UpGW/CQTHtCKaYlScZTly4JIu97Jxo/odCiH0ITnDXSJPTOrEKk/ycSZ0AOgTmkDtkOsvIA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "24.10.1",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.10.1.tgz",
      "integrity": "sha512-GNWcUTRBgIRJD5zj+Tq0fKOJ5XZajIiBroOF0yvj2bSU1WvNdYS/dn9UxwsujGW4JX06dnHyjV2y9rRaybH0iQ==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "undici-types": "~7.16.0"
      }
    },
    "node_modules/@types/yauzl": {
      "version": "2.10.3",
      "resolved": "https://registry.npmjs.org/@types/yauzl/-/yauzl-2.10.3.tgz",
      "integrity": "sha512-oJoftv0LSuaDZE3Le4DbKX+KS9G36NzOeSap90UIK0yMA/NhKJhqlSGtNDORNRaIbQfzjXDrQa0ytJ6mNRGz/Q==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/agent-base": {
      "version": "7.1.4",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-7.1.4.tgz",
      "integrity": "sha512-MnA+YT8fwfJPgBx3m60MNqakm30XOkyIoH1y6huTQvC0PwZG7ki8NacLBcrPbNoo8vEZy7Jpuk7+jMO+CUovTQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/ast-types": {
      "version": "0.13.4",
      "resolved": "https://registry.npmjs.org/ast-types/-/ast-types-0.13.4.tgz",
      "integrity": "sha512-x1FCFnFifvYDDzTaLII71vG5uvDwgtmDTEVWAxrgeiR8VjMONcCXJx7E+USjDtHlwFmt9MysbqgF9b9Vjr6w+w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.1"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/b4a": {
      "version": "1.7.3",
      "resolved": "https://registry.npmjs.org/b4a/-/b4a-1.7.3.tgz",
      "integrity": "sha512-5Q2mfq2WfGuFp3uS//0s6baOJLMoVduPYVeNmDYxu5OUA1/cBfvr2RIS7vi62LdNj/urk1hfmj867I3qt6uZ7Q==",
      "dev": true,
      "license": "Apache-2.0",
      "peerDependencies": {
        "react-native-b4a": "*"
      },
      "peerDependenciesMeta": {
        "react-native-b4a": {
          "optional": true
        }
      }
    },
    "node_modules/bare-events": {
      "version": "2.8.2",
      "resolved": "https://registry.npmjs.org/bare-events/-/bare-events-2.8.2.tgz",
      "integrity": "sha512-riJjyv1/mHLIPX4RwiK+oW9/4c3TEUeORHKefKAKnZ5kyslbN+HXowtbaVEqt4IMUB7OXlfixcs6gsFeo/jhiQ==",
      "dev": true,
      "license": "Apache-2.0",
      "peerDependencies": {
        "bare-abort-controller": "*"
      },
      "peerDependenciesMeta": {
        "bare-abort-controller": {
          "optional": true
        }
      }
    },
    "node_modules/bare-fs": {
      "version": "4.5.2",
      "resolved": "https://registry.npmjs.org/bare-fs/-/bare-fs-4.5.2.tgz",
      "integrity": "sha512-veTnRzkb6aPHOvSKIOy60KzURfBdUflr5VReI+NSaPL6xf+XLdONQgZgpYvUuZLVQ8dCqxpBAudaOM1+KpAUxw==",
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "dependencies": {
        "bare-events": "^2.5.4",
        "bare-path": "^3.0.0",
        "bare-stream": "^2.6.4",
        "bare-url": "^2.2.2",
        "fast-fifo": "^1.3.2"
      },
      "engines": {
        "bare": ">=1.16.0"
      },
      "peerDependencies": {
        "bare-buffer": "*"
      },
      "peerDependenciesMeta": {
        "bare-buffer": {
          "optional": true
        }
      }
    },
    "node_modules/bare-os": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/bare-os/-/bare-os-3.6.2.tgz",
      "integrity": "sha512-T+V1+1srU2qYNBmJCXZkUY5vQ0B4FSlL3QDROnKQYOqeiQR8UbjNHlPa+TIbM4cuidiN9GaTaOZgSEgsvPbh5A==",
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "engines": {
        "bare": ">=1.14.0"
      }
    },
    "node_modules/bare-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/bare-path/-/bare-path-3.0.0.tgz",
      "integrity": "sha512-tyfW2cQcB5NN8Saijrhqn0Zh7AnFNsnczRcuWODH0eYAXBsJ5gVxAUuNr7tsHSC6IZ77cA0SitzT+s47kot8Mw==",
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "dependencies": {
        "bare-os": "^3.0.1"
      }
    },
    "node_modules/bare-stream": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/bare-stream/-/bare-stream-2.7.0.tgz",
      "integrity": "sha512-oyXQNicV1y8nc2aKffH+BUHFRXmx6VrPzlnaEvMhram0nPBrKcEdcyBg5r08D0i8VxngHFAiVyn1QKXpSG0B8A==",
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "dependencies": {
        "streamx": "^2.21.0"
      },
      "peerDependencies": {
        "bare-buffer": "*",
        "bare-events": "*"
      },
      "peerDependenciesMeta": {
        "bare-buffer": {
          "optional": true
        },
        "bare-events": {
          "optional": true
        }
      }
    },
    "node_modules/bare-url": {
      "version": "2.3.2",
      "resolved": "https://registry.npmjs.org/bare-url/-/bare-url-2.3.2.tgz",
      "integrity": "sha512-ZMq4gd9ngV5aTMa5p9+UfY0b3skwhHELaDkhEHetMdX0LRkW9kzaym4oo/Eh+Ghm0CCDuMTsRIGM/ytUc1ZYmw==",
      "dev": true,
      "license": "Apache-2.0",
      "optional": true,
      "dependencies": {
        "bare-path": "^3.0.0"
      }
    },
    "node_modules/basic-ftp": {
      "version": "5.0.5",
      "resolved": "https://registry.npmjs.org/basic-ftp/-/basic-ftp-5.0.5.tgz",
      "integrity": "sha512-4Bcg1P8xhUuqcii/S0Z9wiHIrQVPMermM1any+MX5GeGD7faD3/msQUDGLol9wOcz4/jbg/WJnGqoJF6LiBdtg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/buffer-crc32": {
      "version": "0.2.13",
      "resolved": "https://registry.npmjs.org/buffer-crc32/-/buffer-crc32-0.2.13.tgz",
      "integrity": "sha512-VO9Ht/+p3SN7SKWqcrgEzjGbRSJYTx+Q1pTQC0wrWqHx0vpJraQ6GtHx8tvcg1rlK1byhU5gccxgOgj7B0TDkQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/chromium-bidi": {
      "version": "11.0.0",
      "resolved": "https://registry.npmjs.org/chromium-bidi/-/chromium-bidi-11.0.0.tgz",
      "integrity": "sha512-cM3DI+OOb89T3wO8cpPSro80Q9eKYJ7hGVXoGS3GkDPxnYSqiv+6xwpIf6XERyJ9Tdsl09hmNmY94BkgZdVekw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "mitt": "^3.0.1",
        "zod": "^3.24.1"
      },
      "peerDependencies": {
        "devtools-protocol": "*"
      }
    },
    "node_modules/cliui": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/cliui/-/cliui-8.0.1.tgz",
      "integrity": "sha512-BSeNnyus75C4//NQ9gQt1/csTXyo/8Sb+afLAkzAptFuMsod9HFokGNudZpi/oQV73hnVK+sR+5PVRMd+Dr7YQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "string-width": "^4.2.0",
        "strip-ansi": "^6.0.1",
        "wrap-ansi": "^7.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cosmiconfig": {
      "version": "9.0.0",
      "resolved": "https://registry.npmjs.org/cosmiconfig/-/cosmiconfig-9.0.0.tgz",
      "integrity": "sha512-itvL5h8RETACmOTFc4UfIyB2RfEHi71Ax6E/PivVxq9NseKbOWpeyHEOIbmAw1rs8Ak0VursQNww7lf7YtUwzg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "env-paths": "^2.2.1",
        "import-fresh": "^3.3.0",
        "js-yaml": "^4.1.0",
        "parse-json": "^5.2.0"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/d-fischer"
      },
      "peerDependencies": {
        "typescript": ">=4.9.5"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/data-uri-to-buffer": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/data-uri-to-buffer/-/data-uri-to-buffer-6.0.2.tgz",
      "integrity": "sha512-7hvf7/GW8e86rW0ptuwS3OcBGDjIi6SZva7hCyWC0yYry2cOPmLIjXAUHI6DK2HsnwJd9ifmt57i8eV2n4YNpw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/degenerator": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/degenerator/-/degenerator-5.0.1.tgz",
      "integrity": "sha512-TllpMR/t0M5sqCXfj85i4XaAzxmS5tVA16dqvdkMwGmzI+dXLXnw3J+3Vdv7VKw+ThlTMboK6i9rnZ6Nntj5CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ast-types": "^0.13.4",
        "escodegen": "^2.1.0",
        "esprima": "^4.0.1"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/devtools-protocol": {
      "version": "0.0.1521046",
      "resolved": "https://registry.npmjs.org/devtools-protocol/-/devtools-protocol-0.0.1521046.tgz",
      "integrity": "sha512-vhE6eymDQSKWUXwwA37NtTTVEzjtGVfDr3pRbsWEQ5onH/Snp2c+2xZHWJJawG/0hCCJLRGt4xVtEVUVILol4w==",
      "dev": true,
      "license": "BSD-3-Clause"
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/end-of-stream": {
      "version": "1.4.5",
      "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.4.5.tgz",
      "integrity": "sha512-ooEGc6HP26xXq/N+GCGOT0JKCLDGrq2bQUZrQ7gyrJiZANJ/8YDTxTpQBXGMn+WbIQXNVpyWymm7KYVICQnyOg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "once": "^1.4.0"
      }
    },
    "node_modules/env-paths": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/env-paths/-/env-paths-2.2.1.tgz",
      "integrity": "sha512-+h1lkLKhZMTYjog1VEpJNG7NZJWcuc2DDk/qsqSTRRCOXiLjeQ1d1/udrUGhqMxUgAlwKNZ0cf2uqan5GLuS2A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/error-ex": {
      "version": "1.3.4",
      "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.4.tgz",
      "integrity": "sha512-sqQamAnR14VgCr1A618A3sGrygcpK+HEbenA/HiEAkkUwcZIIB/tgWqHFxWgOyDh4nB4JCRimh79dR5Ywc9MDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-arrayish": "^0.2.1"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escodegen": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/escodegen/-/escodegen-2.1.0.tgz",
      "integrity": "sha512-2NlIDTwUWJN0mRPQOdtQBzbUHvdGY2P1VXSyU83Q3xKxM7WHX2Ql8dKq782Q9TgQUNOLEzEYu9bzLNj1q88I5w==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "esprima": "^4.0.1",
        "estraverse": "^5.2.0",
        "esutils": "^2.0.2"
      },
      "bin": {
        "escodegen": "bin/escodegen.js",
        "esgenerate": "bin/esgenerate.js"
      },
      "engines": {
        "node": ">=6.0"
      },
      "optionalDependencies": {
        "source-map": "~0.6.1"
      }
    },
    "node_modules/esprima": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==",
      "dev": true,
      "license": "BSD-2-Clause",
      "bin": {
        "esparse": "bin/esparse.js",
        "esvalidate": "bin/esvalidate.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/events-universal": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/events-universal/-/events-universal-1.0.1.tgz",
      "integrity": "sha512-LUd5euvbMLpwOF8m6ivPCbhQeSiYVNb8Vs0fQ8QjXo0JTkEHpz8pxdQf0gStltaPpw0Cca8b39KxvK9cfKRiAw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "bare-events": "^2.7.0"
      }
    },
    "node_modules/extract-zip": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/extract-zip/-/extract-zip-2.0.1.tgz",
      "integrity": "sha512-GDhU9ntwuKyGXdZBUgTIe+vXnWj0fppUEtMDL0+idd5Sta8TGpHssn/eusA9mrPr9qNDym6SxAYZjNvCn/9RBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "debug": "^4.1.1",
        "get-stream": "^5.1.0",
        "yauzl": "^2.10.0"
      },
      "bin": {
        "extract-zip": "cli.js"
      },
      "engines": {
        "node": ">= 10.17.0"
      },
      "optionalDependencies": {
        "@types/yauzl": "^2.9.1"
      }
    },
    "node_modules/fast-fifo": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/fast-fifo/-/fast-fifo-1.3.2.tgz",
      "integrity": "sha512-/d9sfos4yxzpwkDkuN7k2SqFKtYNmCTzgfEpz82x34IM9/zc8KGxQoXg1liNC/izpRM/MBdt44Nmx41ZWqk+FQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fd-slicer": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/fd-slicer/-/fd-slicer-1.1.0.tgz",
      "integrity": "sha512-cE1qsB/VwyQozZ+q1dGxR8LBYNZeofhEdUNGSMbQD3Gw2lAzX9Zb3uIU6Ebc/Fmyjo9AWWfnn0AUCHqtevs/8g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "pend": "~1.2.0"
      }
    },
    "node_modules/get-caller-file": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
      "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": "6.* || 8.* || >= 10.*"
      }
    },
    "node_modules/get-stream": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-5.2.0.tgz",
      "integrity": "sha512-nBF+F1rAZVCu/p7rjzgA+Yb4lfYXrpl7a6VmJrU8wF9I1CKvP/QwPNZHnOlwbTkY6dvtFIzFMSyQXbLoTQPRpA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "pump": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/get-uri": {
      "version": "6.0.5",
      "resolved": "https://registry.npmjs.org/get-uri/-/get-uri-6.0.5.tgz",
      "integrity": "sha512-b1O07XYq8eRuVzBNgJLstU6FYc1tS6wnMtF1I1D9lE8LxZSOGZ7LhxN54yPP6mGw5f2CkXY2BQUL9Fx41qvcIg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "basic-ftp": "^5.0.2",
        "data-uri-to-buffer": "^6.0.2",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/http-proxy-agent": {
      "version": "7.0.2",
      "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-7.0.2.tgz",
      "integrity": "sha512-T1gkAiYYDWYx3V5Bmyu7HcfcvL7mUrTWiM6yOfa3PIphViJ/gFPbvidQ+veqSOHci/PxBcDabeUNCzpOODJZig==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.0",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.2",
        "debug": "4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/ip-address": {
      "version": "10.1.0",
      "resolved": "https://registry.npmjs.org/ip-address/-/ip-address-10.1.0.tgz",
      "integrity": "sha512-XXADHxXmvT9+CRxhXg56LJovE+bmWnEWB78LB83VZTprKTmaC5QfruXocxzTZ2Kl0DNwKuBdlIhjL8LeY8Sf8Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 12"
      }
    },
    "node_modules/is-arrayish": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz",
      "integrity": "sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
      "integrity": "sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/json-parse-even-better-errors": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/json-parse-even-better-errors/-/json-parse-even-better-errors-2.3.1.tgz",
      "integrity": "sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lines-and-columns": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lru-cache": {
      "version": "7.18.3",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-7.18.3.tgz",
      "integrity": "sha512-jumlc0BIUrS3qJGgIkWZsyfAM7NCWiBcCDhnd+3NNM5KbBmLTgHVfWBcg6W+rLUsIpzpERPsvwUP7CckAQSOoA==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/mitt": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/mitt/-/mitt-3.0.1.tgz",
      "integrity": "sha512-vKivATfr97l2/QBCYAkXYDbrIWPM2IIKEl7YPhjCvKlG3kE2gm+uBo6nEXK3M5/Ffh/FLpKExzOQ3JJoJGFKBw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/netmask": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/netmask/-/netmask-2.0.2.tgz",
      "integrity": "sha512-dBpDMdxv9Irdq66304OLfEmQ9tbNRFnFTuZiLo+bD+r332bBmMJ8GBLXklIXXgxd3+v9+KUnZaUR5PJMa75Gsg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/pac-proxy-agent": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/pac-proxy-agent/-/pac-proxy-agent-7.2.0.tgz",
      "integrity": "sha512-TEB8ESquiLMc0lV8vcd5Ql/JAKAoyzHFXaStwjkzpOpC5Yv+pIzLfHvjTSdf3vpa2bMiUQrg9i6276yn8666aA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@tootallnate/quickjs-emscripten": "^0.23.0",
        "agent-base": "^7.1.2",
        "debug": "^4.3.4",
        "get-uri": "^6.0.1",
        "http-proxy-agent": "^7.0.0",
        "https-proxy-agent": "^7.0.6",
        "pac-resolver": "^7.0.1",
        "socks-proxy-agent": "^8.0.5"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/pac-resolver": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/pac-resolver/-/pac-resolver-7.0.1.tgz",
      "integrity": "sha512-5NPgf87AT2STgwa2ntRMr45jTKrYBGkVU36yT0ig/n/GMAa3oPqhZfIQ2kMEimReg0+t9kZViDVZ83qfVUlckg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "degenerator": "^5.0.0",
        "netmask": "^2.0.2"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/parse-json": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/parse-json/-/parse-json-5.2.0.tgz",
      "integrity": "sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.0.0",
        "error-ex": "^1.3.1",
        "json-parse-even-better-errors": "^2.3.0",
        "lines-and-columns": "^1.1.6"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/pend": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/pend/-/pend-1.2.0.tgz",
      "integrity": "sha512-F3asv42UuXchdzt+xXqfW1OGlVBe+mxa2mqI0pg5yAHZPvFmY3Y6drSf/GQ1A86WgWEN9Kzh/WrgKa6iGcHXLg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/progress": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/progress/-/progress-2.0.3.tgz",
      "integrity": "sha512-7PiHtLll5LdnKIMw100I+8xJXR5gW2QwWYkT6iJva0bXitZKa/XMrSbdmg3r2Xnaidz9Qumd0VPaMrZlF9V9sA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/proxy-agent": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/proxy-agent/-/proxy-agent-6.5.0.tgz",
      "integrity": "sha512-TmatMXdr2KlRiA2CyDu8GqR8EjahTG3aY3nXjdzFyoZbmB8hrBsTyMezhULIXKnC0jpfjlmiZ3+EaCzoInSu/A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.2",
        "debug": "^4.3.4",
        "http-proxy-agent": "^7.0.1",
        "https-proxy-agent": "^7.0.6",
        "lru-cache": "^7.14.1",
        "pac-proxy-agent": "^7.1.0",
        "proxy-from-env": "^1.1.0",
        "socks-proxy-agent": "^8.0.5"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pump": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/pump/-/pump-3.0.3.tgz",
      "integrity": "sha512-todwxLMY7/heScKmntwQG8CXVkWUOdYxIvY2s0VWAAMh/nd8SoYiRaKjlr7+iCs984f2P8zvrfWcDDYVb73NfA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "end-of-stream": "^1.1.0",
        "once": "^1.3.1"
      }
    },
    "node_modules/puppeteer": {
      "version": "24.31.0",
      "resolved": "https://registry.npmjs.org/puppeteer/-/puppeteer-24.31.0.tgz",
      "integrity": "sha512-q8y5yLxLD8xdZdzNWqdOL43NbfvUOp60SYhaLZQwHC9CdKldxQKXOyJAciOr7oUJfyAH/KgB2wKvqT2sFKoVXA==",
      "dev": true,
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@puppeteer/browsers": "2.10.13",
        "chromium-bidi": "11.0.0",
        "cosmiconfig": "^9.0.0",
        "devtools-protocol": "0.0.1521046",
        "puppeteer-core": "24.31.0",
        "typed-query-selector": "^2.12.0"
      },
      "bin": {
        "puppeteer": "lib/cjs/puppeteer/node/cli.js"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/puppeteer-core": {
      "version": "24.31.0",
      "resolved": "https://registry.npmjs.org/puppeteer-core/-/puppeteer-core-24.31.0.tgz",
      "integrity": "sha512-pnAohhSZipWQoFpXuGV7xCZfaGhqcBR9C4pVrU0QSrcMi7tQMH9J9lDBqBvyMAHQqe8HCARuREqFuVKRQOgTvg==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@puppeteer/browsers": "2.10.13",
        "chromium-bidi": "11.0.0",
        "debug": "^4.4.3",
        "devtools-protocol": "0.0.1521046",
        "typed-query-selector": "^2.12.0",
        "webdriver-bidi-protocol": "0.3.9",
        "ws": "^8.18.3"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/require-directory": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
      "integrity": "sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/semver": {
      "version": "7.7.3",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.3.tgz",
      "integrity": "sha512-SdsKMrI9TdgjdweUSR9MweHA4EJ8YxHn8DFaDisvhVlUOe4BF1tLD7GAj0lIqWVl+dPb/rExr0Btby5loQm20Q==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/smart-buffer": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/smart-buffer/-/smart-buffer-4.2.0.tgz",
      "integrity": "sha512-94hK0Hh8rPqQl2xXc3HsaBoOXKV20MToPkcXvwbISWLEs+64sBq5kFgn2kJDHb1Pry9yrP0dxrCI9RRci7RXKg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6.0.0",
        "npm": ">= 3.0.0"
      }
    },
    "node_modules/socks": {
      "version": "2.8.7",
      "resolved": "https://registry.npmjs.org/socks/-/socks-2.8.7.tgz",
      "integrity": "sha512-HLpt+uLy/pxB+bum/9DzAgiKS8CX1EvbWxI4zlmgGCExImLdiad2iCwXT5Z4c9c3Eq8rP2318mPW2c+QbtjK8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ip-address": "^10.0.1",
        "smart-buffer": "^4.2.0"
      },
      "engines": {
        "node": ">= 10.0.0",
        "npm": ">= 3.0.0"
      }
    },
    "node_modules/socks-proxy-agent": {
      "version": "8.0.5",
      "resolved": "https://registry.npmjs.org/socks-proxy-agent/-/socks-proxy-agent-8.0.5.tgz",
      "integrity": "sha512-HehCEsotFqbPW9sJ8WVYB6UbmIMv7kUUORIF2Nncq4VQvBfNBLibW9YZR5dlYCSUhwcD628pRllm7n+E+YTzJw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.2",
        "debug": "^4.3.4",
        "socks": "^2.8.3"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "optional": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/streamx": {
      "version": "2.23.0",
      "resolved": "https://registry.npmjs.org/streamx/-/streamx-2.23.0.tgz",
      "integrity": "sha512-kn+e44esVfn2Fa/O0CPFcex27fjIL6MkVae0Mm6q+E6f0hWv578YCERbv+4m02cjxvDsPKLnmxral/rR6lBMAg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "events-universal": "^1.0.0",
        "fast-fifo": "^1.3.2",
        "text-decoder": "^1.1.0"
      }
    },
    "node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/tar-fs": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/tar-fs/-/tar-fs-3.1.1.tgz",
      "integrity": "sha512-LZA0oaPOc2fVo82Txf3gw+AkEd38szODlptMYejQUhndHMLQ9M059uXR+AfS7DNo0NpINvSqDsvyaCrBVkptWg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "pump": "^3.0.0",
        "tar-stream": "^3.1.5"
      },
      "optionalDependencies": {
        "bare-fs": "^4.0.1",
        "bare-path": "^3.0.0"
      }
    },
    "node_modules/tar-stream": {
      "version": "3.1.7",
      "resolved": "https://registry.npmjs.org/tar-stream/-/tar-stream-3.1.7.tgz",
      "integrity": "sha512-qJj60CXt7IU1Ffyc3NJMjh6EkuCFej46zUqJ4J7pqYlThyd9bO0XBTmcOIhSzZJVWfsLks0+nle/j538YAW9RQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "b4a": "^1.6.4",
        "fast-fifo": "^1.2.0",
        "streamx": "^2.15.0"
      }
    },
    "node_modules/text-decoder": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/text-decoder/-/text-decoder-1.2.3.tgz",
      "integrity": "sha512-3/o9z3X0X0fTupwsYvR03pJ/DjWuqqrfwBgTQzdWDiQSm9KitAyz/9WqsT2JQW7KV2m+bC2ol/zqpW37NHxLaA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "b4a": "^1.6.4"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "dev": true,
      "license": "0BSD"
    },
    "node_modules/typed-query-selector": {
      "version": "2.12.0",
      "resolved": "https://registry.npmjs.org/typed-query-selector/-/typed-query-selector-2.12.0.tgz",
      "integrity": "sha512-SbklCd1F0EiZOyPiW192rrHZzZ5sBijB6xM+cpmrwDqObvdtunOHHIk9fCGsoK5JVIYXoyEp4iEdE3upFH3PAg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/undici-types": {
      "version": "7.16.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.16.0.tgz",
      "integrity": "sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==",
      "dev": true,
      "license": "MIT",
      "optional": true
    },
    "node_modules/webdriver-bidi-protocol": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/webdriver-bidi-protocol/-/webdriver-bidi-protocol-0.3.9.tgz",
      "integrity": "sha512-uIYvlRQ0PwtZR1EzHlTMol1G0lAlmOe6wPykF9a77AK3bkpvZHzIVxRE2ThOx5vjy2zISe0zhwf5rzuUfbo1PQ==",
      "dev": true,
      "license": "Apache-2.0"
    },
    "node_modules/wrap-ansi": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/ws": {
      "version": "8.18.3",
      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": ">=5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    },
    "node_modules/y18n": {
      "version": "5.0.8",
      "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
      "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/yargs": {
      "version": "17.7.2",
      "resolved": "https://registry.npmjs.org/yargs/-/yargs-17.7.2.tgz",
      "integrity": "sha512-7dSzzRQ++CKnNI/krKnYRV7JKKPUXMEh61soaHKg9mrWEhzFWhFnxPxGl+69cD1Ou63C13NUPCnmIcrvqCuM6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cliui": "^8.0.1",
        "escalade": "^3.1.1",
        "get-caller-file": "^2.0.5",
        "require-directory": "^2.1.1",
        "string-width": "^4.2.3",
        "y18n": "^5.0.5",
        "yargs-parser": "^21.1.1"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/yargs-parser": {
      "version": "21.1.1",
      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-21.1.1.tgz",
      "integrity": "sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/yauzl": {
      "version": "2.10.0",
      "resolved": "https://registry.npmjs.org/yauzl/-/yauzl-2.10.0.tgz",
      "integrity": "sha512-p4a9I6X6nu6IhoGmBqAcbJy1mlC4j27vEPZX9F4L4/vZT3Lyq1VkFHw/V/PUcB9Buo+DG3iHkT0x3Qya58zc3g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "buffer-crc32": "~0.2.3",
        "fd-slicer": "~1.1.0"
      }
    },
    "node_modules/zod": {
      "version": "3.25.76",
      "resolved": "https://registry.npmjs.org/zod/-/zod-3.25.76.tgz",
      "integrity": "sha512-gzUt/qt81nXsFGKIFcC3YnfEAx5NkunCfnDlvuBSSFS02bcXu4Lmea0AFIUwbLWxWPx3d9p8S5QoaujKcNQxcQ==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    }
  }
}

```

---

## package.json

```json
{
  "devDependencies": {
    "puppeteer": "^24.31.0"
  }
}

```

---

## settings.gradle.kts

```kts
// NewsInsight Spring Boot 멀티 모듈 프로젝트 설정

rootProject.name = "newsinsight"

// Backend 서비스 모듈
include(
    "backend:api-gateway-service",           // Spring Cloud Gateway
    "backend:data-collection-service",       // Data Collection Service (RSS/Web Scraper)
    "backend:shared-libs"                    // 공통 라이브러리
)

```
