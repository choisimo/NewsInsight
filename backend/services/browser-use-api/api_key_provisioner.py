"""
API Key Auto-Provisioner for Browser-Use API

This module provides automated API key provisioning via browser automation.
Users can request API keys from various providers (OpenAI, Anthropic, etc.)
through a chat interface, and the system will navigate to the provider's
website, handle authentication, and extract the generated API key.

Workflow:
1. User requests API key via chat (e.g., "OpenAI API 키 발급해줘")
2. IntentAnalyzer detects API_KEY_PROVISION intent and identifies provider
3. ApiKeyProvisioner launches stealth browser to provider's API key page
4. System handles login with human intervention for 2FA if needed
5. Extracts generated API key from the page
6. Saves to LlmProviderSettings via REST API
"""

import asyncio
import base64
import logging
import os
import re
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Optional

import httpx
from pydantic import BaseModel, Field

from intent_analyzer import APIProvider, PROVIDER_URLS, IntentAnalyzer

logger = logging.getLogger(__name__)


class ProvisioningStatus(str, Enum):
	"""Status of API key provisioning task."""

	PENDING = 'pending'
	NAVIGATING = 'navigating'
	WAITING_LOGIN = 'waiting_login'
	WAITING_2FA = 'waiting_2fa'
	GENERATING_KEY = 'generating_key'
	EXTRACTING_KEY = 'extracting_key'
	SAVING_KEY = 'saving_key'
	COMPLETED = 'completed'
	FAILED = 'failed'
	CANCELLED = 'cancelled'


class ProvisioningStep(str, Enum):
	"""Steps in the provisioning workflow."""

	NAVIGATE_TO_PROVIDER = 'navigate_to_provider'
	CHECK_LOGIN_STATUS = 'check_login_status'
	REQUEST_LOGIN = 'request_login'
	HANDLE_2FA = 'handle_2fa'
	NAVIGATE_TO_API_KEYS = 'navigate_to_api_keys'
	CREATE_NEW_KEY = 'create_new_key'
	EXTRACT_KEY = 'extract_key'
	SAVE_TO_SETTINGS = 'save_to_settings'


@dataclass
class ProvisioningContext:
	"""Context for API key provisioning task."""

	provider: APIProvider
	provider_url: str
	key_name: str = 'NewsInsight-AutoGenerated'
	extracted_key: Optional[str] = None
	status: ProvisioningStatus = ProvisioningStatus.PENDING
	current_step: Optional[ProvisioningStep] = None
	error: Optional[str] = None
	started_at: Optional[datetime] = None
	completed_at: Optional[datetime] = None
	screenshots: list[str] = field(default_factory=list)


class ProvisioningRequest(BaseModel):
	"""Request to provision an API key."""

	provider: str = Field(..., description='Provider name: openai, anthropic, google, etc.')
	key_name: Optional[str] = Field(None, description='Name for the generated key')
	auto_save: bool = Field(True, description='Automatically save to system settings')
	timeout_seconds: int = Field(300, description='Timeout for entire provisioning process')


class ProvisioningResponse(BaseModel):
	"""Response from API key provisioning."""

	job_id: str
	status: str
	provider: str
	message: str
	api_key_masked: Optional[str] = None  # e.g., "sk-...abc"
	saved_to_settings: bool = False
	error: Optional[str] = None


# Provider-specific selectors and patterns
PROVIDER_CONFIGS = {
	APIProvider.OPENAI: {
		'login_url': 'https://platform.openai.com/login',
		'api_keys_url': 'https://platform.openai.com/api-keys',
		'dashboard_url': 'https://platform.openai.com',
		'login_indicators': [
			'input[name="email"]',
			'input[name="username"]',
			'button[type="submit"]',
		],
		'logged_in_indicators': [
			'[data-testid="account-menu"]',
			'.avatar',
			'#user-menu',
		],
		'create_key_selectors': [
			'button:has-text("Create new secret key")',
			'[data-testid="create-api-key"]',
			'button:has-text("Create")',
		],
		'key_pattern': r'sk-[a-zA-Z0-9]{20,}',
		'key_display_selectors': [
			'.api-key-value',
			'[data-testid="api-key"]',
			'input[readonly][value^="sk-"]',
			'code:has-text("sk-")',
		],
	},
	APIProvider.ANTHROPIC: {
		'login_url': 'https://console.anthropic.com/login',
		'api_keys_url': 'https://console.anthropic.com/settings/keys',
		'dashboard_url': 'https://console.anthropic.com',
		'login_indicators': [
			'input[name="email"]',
			'input[type="email"]',
		],
		'logged_in_indicators': [
			'.user-avatar',
			'[data-testid="user-menu"]',
		],
		'create_key_selectors': [
			'button:has-text("Create Key")',
			'button:has-text("Generate")',
		],
		'key_pattern': r'sk-ant-[a-zA-Z0-9\-_]{40,}',
		'key_display_selectors': [
			'.api-key',
			'[data-testid="api-key-value"]',
			'input[readonly]',
		],
	},
	APIProvider.GOOGLE: {
		'login_url': 'https://accounts.google.com',
		'api_keys_url': 'https://aistudio.google.com/app/apikey',
		'dashboard_url': 'https://aistudio.google.com',
		'login_indicators': [
			'input[type="email"]',
			'#identifierId',
		],
		'logged_in_indicators': [
			'a[aria-label*="Google Account"]',
			'.gb_d',
		],
		'create_key_selectors': [
			'button:has-text("Create API key")',
			'button:has-text("Get API key")',
		],
		'key_pattern': r'AIza[a-zA-Z0-9\-_]{35}',
		'key_display_selectors': [
			'.api-key-display',
			'[data-testid="api-key"]',
		],
	},
	APIProvider.OPENROUTER: {
		'login_url': 'https://openrouter.ai/auth/login',
		'api_keys_url': 'https://openrouter.ai/keys',
		'dashboard_url': 'https://openrouter.ai',
		'login_indicators': [
			'input[name="email"]',
			'button:has-text("Sign in")',
		],
		'logged_in_indicators': [
			'.user-menu',
			'[data-testid="user-avatar"]',
		],
		'create_key_selectors': [
			'button:has-text("Create Key")',
			'button:has-text("New Key")',
		],
		'key_pattern': r'sk-or-[a-zA-Z0-9]{40,}',
		'key_display_selectors': [
			'.api-key',
			'input[readonly]',
		],
	},
}


class ApiKeyProvisioner:
	"""
	Handles automated API key provisioning via browser automation.

	This class orchestrates the entire provisioning workflow:
	1. Navigate to provider's website
	2. Handle authentication (with human intervention if needed)
	3. Generate new API key
	4. Extract and save the key
	"""

	def __init__(
		self,
		browser_session: Any,
		llm: Any,
		websocket_broadcast: Any = None,
		data_collection_api_url: Optional[str] = None,
	):
		"""
		Initialize the provisioner.

		Args:
			browser_session: BrowserSession instance from browser-use
			llm: LLM instance for AI-guided navigation
			websocket_broadcast: Function to broadcast updates to WebSocket clients
			data_collection_api_url: URL of data-collection-service for saving keys
		"""
		self.browser_session = browser_session
		self.llm = llm
		self.websocket_broadcast = websocket_broadcast
		self.data_collection_api_url = data_collection_api_url or os.environ.get(
			'DATA_COLLECTION_API_URL', 'http://data-collection-service:8081'
		)
		self.context: Optional[ProvisioningContext] = None
		self._http_client: Optional[httpx.AsyncClient] = None

	async def _get_http_client(self) -> httpx.AsyncClient:
		"""Get or create HTTP client."""
		if self._http_client is None:
			self._http_client = httpx.AsyncClient(timeout=30.0)
		return self._http_client

	async def close(self):
		"""Clean up resources."""
		if self._http_client:
			await self._http_client.aclose()
			self._http_client = None

	async def _broadcast(self, message: dict):
		"""Broadcast message to WebSocket clients."""
		if self.websocket_broadcast:
			try:
				await self.websocket_broadcast(message)
			except Exception as e:
				logger.warning(f'Failed to broadcast: {e}')

	async def _update_status(self, status: ProvisioningStatus, step: Optional[ProvisioningStep] = None, message: str = ''):
		"""Update provisioning status and broadcast to clients."""
		if self.context:
			self.context.status = status
			self.context.current_step = step

		await self._broadcast(
			{
				'type': 'provisioning_update',
				'status': status.value,
				'step': step.value if step else None,
				'message': message,
			}
		)
		logger.info(f'Provisioning status: {status.value} - {message}')

	async def _capture_screenshot(self) -> Optional[str]:
		"""Capture current browser screenshot."""
		try:
			if self.browser_session:
				screenshot_bytes = await self.browser_session.take_screenshot()
				return base64.b64encode(screenshot_bytes).decode('utf-8')
		except Exception as e:
			logger.warning(f'Failed to capture screenshot: {e}')
		return None

	async def _get_page(self):
		"""Get the current page from browser session."""
		try:
			context = getattr(self.browser_session, '_context', None)
			if context:
				pages = context.pages
				if pages:
					return pages[0]
		except Exception as e:
			logger.warning(f'Failed to get page: {e}')
		return None

	async def _check_login_status(self, provider: APIProvider) -> bool:
		"""Check if user is logged in to the provider."""
		page = await self._get_page()
		if not page:
			return False

		config = PROVIDER_CONFIGS.get(provider, {})
		logged_in_indicators = config.get('logged_in_indicators', [])

		for selector in logged_in_indicators:
			try:
				element = await page.query_selector(selector)
				if element:
					logger.info(f'User is logged in (found: {selector})')
					return True
			except Exception:
				continue

		return False

	async def _request_login_intervention(self, provider: APIProvider) -> bool:
		"""Request human intervention for login."""
		await self._update_status(
			ProvisioningStatus.WAITING_LOGIN,
			ProvisioningStep.REQUEST_LOGIN,
			f'{provider.value} 로그인이 필요합니다. 브라우저에서 로그인을 진행해주세요.',
		)

		screenshot = await self._capture_screenshot()

		await self._broadcast(
			{
				'type': 'intervention_requested',
				'intervention_type': 'login',
				'provider': provider.value,
				'reason': f'Please log in to {provider.value} to continue API key provisioning.',
				'screenshot': screenshot,
				'instructions': [
					f'1. {provider.value} 계정으로 로그인하세요',
					'2. 2차 인증(2FA)이 필요한 경우 완료해주세요',
					'3. 로그인이 완료되면 "완료" 버튼을 클릭하세요',
				],
			}
		)

		# Wait for human to complete login (this will be handled by WebSocket)
		return True

	async def _request_2fa_intervention(self, provider: APIProvider) -> Optional[str]:
		"""Request human intervention for 2FA code."""
		await self._update_status(ProvisioningStatus.WAITING_2FA, ProvisioningStep.HANDLE_2FA, '2차 인증 코드가 필요합니다.')

		screenshot = await self._capture_screenshot()

		await self._broadcast(
			{
				'type': 'intervention_requested',
				'intervention_type': '2fa',
				'provider': provider.value,
				'reason': 'Two-factor authentication code required.',
				'screenshot': screenshot,
				'instructions': [
					'휴대폰으로 전송된 인증 코드를 입력해주세요.',
					'또는 인증 앱의 코드를 입력해주세요.',
				],
			}
		)

		# This will return the 2FA code from human input
		return None

	async def _navigate_to_api_keys_page(self, provider: APIProvider) -> bool:
		"""Navigate to the API keys management page."""
		page = await self._get_page()
		if not page:
			return False

		api_keys_url = PROVIDER_URLS.get(provider)
		if not api_keys_url:
			config = PROVIDER_CONFIGS.get(provider, {})
			api_keys_url = config.get('api_keys_url')

		if not api_keys_url:
			logger.error(f'No API keys URL configured for {provider.value}')
			return False

		await self._update_status(
			ProvisioningStatus.NAVIGATING, ProvisioningStep.NAVIGATE_TO_API_KEYS, f'API 키 페이지로 이동 중: {api_keys_url}'
		)

		try:
			await page.goto(api_keys_url, wait_until='networkidle')
			await asyncio.sleep(2)  # Wait for page to stabilize
			return True
		except Exception as e:
			logger.error(f'Failed to navigate to API keys page: {e}')
			return False

	async def _create_new_key(self, provider: APIProvider) -> bool:
		"""Click the create new key button."""
		page = await self._get_page()
		if not page:
			return False

		config = PROVIDER_CONFIGS.get(provider, {})
		create_selectors = config.get('create_key_selectors', [])

		await self._update_status(ProvisioningStatus.GENERATING_KEY, ProvisioningStep.CREATE_NEW_KEY, '새 API 키 생성 중...')

		for selector in create_selectors:
			try:
				# Try different approaches for finding the button
				element = await page.query_selector(selector)
				if element:
					await element.click()
					await asyncio.sleep(2)
					logger.info(f'Clicked create key button: {selector}')
					return True
			except Exception as e:
				logger.debug(f'Selector {selector} failed: {e}')
				continue

		# Try using AI to find and click the button
		logger.info('Using AI to find create key button...')
		return False

	async def _extract_api_key(self, provider: APIProvider) -> Optional[str]:
		"""Extract the generated API key from the page."""
		page = await self._get_page()
		if not page:
			return None

		config = PROVIDER_CONFIGS.get(provider, {})
		key_pattern = config.get('key_pattern', r'[a-zA-Z0-9\-_]{20,}')
		key_selectors = config.get('key_display_selectors', [])

		await self._update_status(ProvisioningStatus.EXTRACTING_KEY, ProvisioningStep.EXTRACT_KEY, 'API 키 추출 중...')

		# Method 1: Try specific selectors
		for selector in key_selectors:
			try:
				element = await page.query_selector(selector)
				if element:
					# Try different ways to get the key value
					key = await element.get_attribute('value')
					if not key:
						key = await element.inner_text()

					if key and re.match(key_pattern, key.strip()):
						logger.info(f'Extracted API key from selector: {selector}')
						return key.strip()
			except Exception as e:
				logger.debug(f'Selector {selector} failed: {e}')
				continue

		# Method 2: Search entire page content for key pattern
		try:
			page_content = await page.content()
			matches = re.findall(key_pattern, page_content)
			if matches:
				# Return the longest match (likely the full key)
				key = max(matches, key=len)
				logger.info(f'Extracted API key from page content (pattern match)')
				return key
		except Exception as e:
			logger.warning(f'Failed to extract key from page content: {e}')

		# Method 3: Try to copy from clipboard after clicking copy button
		try:
			copy_button = await page.query_selector('button:has-text("Copy")')
			if copy_button:
				await copy_button.click()
				await asyncio.sleep(0.5)
				# Note: Getting clipboard content requires additional permissions
		except Exception:
			pass

		return None

	async def _save_to_settings(self, provider: APIProvider, api_key: str) -> bool:
		"""Save the API key to LlmProviderSettings."""
		await self._update_status(ProvisioningStatus.SAVING_KEY, ProvisioningStep.SAVE_TO_SETTINGS, '시스템 설정에 저장 중...')

		# Map APIProvider to LlmProviderType
		provider_type_map = {
			APIProvider.OPENAI: 'OPENAI',
			APIProvider.ANTHROPIC: 'ANTHROPIC',
			APIProvider.GOOGLE: 'GOOGLE',
			APIProvider.OPENROUTER: 'OPENROUTER',
			APIProvider.TOGETHER_AI: 'TOGETHER_AI',
			APIProvider.PERPLEXITY: 'PERPLEXITY',
			APIProvider.BRAVE_SEARCH: 'BRAVE_SEARCH',
			APIProvider.TAVILY: 'TAVILY',
		}

		provider_type = provider_type_map.get(provider, provider.value.upper())

		# Default models for each provider
		default_models = {
			'OPENAI': 'gpt-4o',
			'ANTHROPIC': 'claude-3-5-sonnet-20241022',
			'GOOGLE': 'gemini-1.5-pro',
			'OPENROUTER': 'openai/gpt-4o',
			'TOGETHER_AI': 'meta-llama/Llama-3-70b-chat-hf',
			'PERPLEXITY': 'llama-3.1-sonar-large-128k-online',
		}

		payload = {
			'providerType': provider_type,
			'apiKey': api_key,
			'defaultModel': default_models.get(provider_type, ''),
			'enabled': True,
			'priority': 100,
		}

		try:
			client = await self._get_http_client()
			response = await client.put(
				f'{self.data_collection_api_url}/api/v1/admin/llm-providers',
				json=payload,
			)

			if response.status_code in [200, 201]:
				logger.info(f'Successfully saved API key for {provider_type}')
				return True
			else:
				logger.error(f'Failed to save API key: {response.status_code} - {response.text}')
				return False

		except Exception as e:
			logger.error(f'Failed to save API key to settings: {e}')
			return False

	def _mask_api_key(self, api_key: str) -> str:
		"""Mask API key for display (show first 6 and last 4 chars)."""
		if len(api_key) <= 10:
			return '*' * len(api_key)
		return f'{api_key[:6]}...{api_key[-4:]}'

	async def provision(
		self,
		provider: APIProvider,
		key_name: str = 'NewsInsight-AutoGenerated',
		auto_save: bool = True,
		timeout_seconds: int = 300,
	) -> dict:
		"""
		Execute the full API key provisioning workflow.

		Args:
			provider: The API provider to get a key from
			key_name: Name to give the generated key
			auto_save: Whether to automatically save to system settings
			timeout_seconds: Timeout for the entire process

		Returns:
			Dictionary with provisioning result
		"""
		self.context = ProvisioningContext(
			provider=provider,
			provider_url=PROVIDER_URLS.get(provider, ''),
			key_name=key_name,
			started_at=datetime.now(),
		)

		try:
			# Step 1: Navigate to provider
			await self._update_status(
				ProvisioningStatus.NAVIGATING, ProvisioningStep.NAVIGATE_TO_PROVIDER, f'{provider.value} 웹사이트로 이동 중...'
			)

			page = await self._get_page()
			if not page:
				raise Exception('Browser session not available')

			# Navigate to the provider's dashboard first
			config = PROVIDER_CONFIGS.get(provider, {})
			dashboard_url = config.get('dashboard_url', PROVIDER_URLS.get(provider))

			await page.goto(dashboard_url, wait_until='networkidle')
			await asyncio.sleep(2)

			# Step 2: Check login status
			is_logged_in = await self._check_login_status(provider)

			if not is_logged_in:
				# Step 3: Request human intervention for login
				await self._request_login_intervention(provider)

				# Wait for login completion (handled via WebSocket)
				# This is a placeholder - actual implementation requires
				# WebSocket message handling to signal login completion
				return {
					'status': 'waiting_login',
					'provider': provider.value,
					'message': 'Please complete login in the browser window.',
					'requires_intervention': True,
				}

			# Step 4: Navigate to API keys page
			success = await self._navigate_to_api_keys_page(provider)
			if not success:
				raise Exception('Failed to navigate to API keys page')

			# Step 5: Create new key
			success = await self._create_new_key(provider)
			if not success:
				# Request human intervention to create key
				await self._broadcast(
					{
						'type': 'intervention_requested',
						'intervention_type': 'create_key',
						'provider': provider.value,
						'reason': 'Please click the button to create a new API key.',
						'screenshot': await self._capture_screenshot(),
					}
				)

				return {
					'status': 'waiting_create_key',
					'provider': provider.value,
					'message': 'Please click to create a new API key.',
					'requires_intervention': True,
				}

			# Step 6: Extract the generated key
			api_key = await self._extract_api_key(provider)

			if not api_key:
				raise Exception('Failed to extract API key from page')

			self.context.extracted_key = api_key

			# Step 7: Save to settings if requested
			saved = False
			if auto_save:
				saved = await self._save_to_settings(provider, api_key)

			# Success!
			self.context.status = ProvisioningStatus.COMPLETED
			self.context.completed_at = datetime.now()

			await self._update_status(ProvisioningStatus.COMPLETED, None, f'API 키가 성공적으로 발급되었습니다!')

			return {
				'status': 'completed',
				'provider': provider.value,
				'api_key_masked': self._mask_api_key(api_key),
				'saved_to_settings': saved,
				'message': f'{provider.value} API 키가 성공적으로 발급되었습니다.',
			}

		except asyncio.TimeoutError:
			self.context.status = ProvisioningStatus.FAILED
			self.context.error = 'Provisioning timed out'

			await self._update_status(ProvisioningStatus.FAILED, None, '시간 초과로 인해 키 발급에 실패했습니다.')

			return {
				'status': 'failed',
				'provider': provider.value,
				'error': 'Provisioning timed out',
				'message': '시간 초과로 인해 키 발급에 실패했습니다.',
			}

		except Exception as e:
			self.context.status = ProvisioningStatus.FAILED
			self.context.error = str(e)

			await self._update_status(ProvisioningStatus.FAILED, None, f'키 발급 실패: {str(e)}')

			return {
				'status': 'failed',
				'provider': provider.value,
				'error': str(e),
				'message': f'API 키 발급에 실패했습니다: {str(e)}',
			}

		finally:
			await self.close()


async def create_provisioning_task(
	provider_name: str, browser_session: Any, llm: Any, websocket_broadcast: Any = None, **kwargs
) -> dict:
	"""
	Convenience function to create and run a provisioning task.

	Args:
		provider_name: Name of the provider (e.g., 'openai', 'anthropic')
		browser_session: BrowserSession instance
		llm: LLM instance
		websocket_broadcast: Function to broadcast updates
		**kwargs: Additional arguments for provisioning

	Returns:
		Provisioning result dictionary
	"""
	# Parse provider name to APIProvider enum
	try:
		provider = APIProvider(provider_name.lower())
	except ValueError:
		return {
			'status': 'failed',
			'error': f'Unknown provider: {provider_name}',
			'supported_providers': [p.value for p in APIProvider if p != APIProvider.UNKNOWN],
		}

	if provider == APIProvider.UNKNOWN:
		return {
			'status': 'failed',
			'error': 'Provider not specified',
			'supported_providers': [p.value for p in APIProvider if p != APIProvider.UNKNOWN],
		}

	provisioner = ApiKeyProvisioner(
		browser_session=browser_session,
		llm=llm,
		websocket_broadcast=websocket_broadcast,
	)

	return await provisioner.provision(
		provider=provider,
		key_name=kwargs.get('key_name', 'NewsInsight-AutoGenerated'),
		auto_save=kwargs.get('auto_save', True),
		timeout_seconds=kwargs.get('timeout_seconds', 300),
	)
